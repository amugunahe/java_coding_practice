package com.polymorphism; // 이 코드가 속한 폴더(패키지) 이름이다.

/*
  ABTest 클래스: **자바의 '다형성(Polymorphism)'과 '상속(Inheritance)'을 존나게 테스트하는 예제다!**
 
  핵심:
  - **`A` 클래스:** 부모 클래스다! 모든 자식들이 물려받을 기본 틀(x, y 좌표)과 기본적인 메소드(`disp`, `setX`, `setY`)를 가진다.
  `private` 변수는 자기만 쓸 수 있다! (존나 중요!)
  - **`B` 클래스:** `A`를 상속받는 자식 클래스다!
  - **필드 숨김(Field Hiding):** 부모에도 있는 `y`를 `B`가 다시 선언해서 자기만의 `y`를 가지는 거다. (부모 `y`와 자식 `y`는 서로 다른 변수!)
  - **메소드 오버라이딩(Overriding):** 부모 `A`에 있는 `setY()`랑 `disp()`를 `B` 자기식대로 바꿔서 덮어쓴다!
  (`@Override` 어노테이션으로 명시해주면 존나 확실하다!)
  - **다형성 (업캐스팅):** `A a = new B();`처럼 부모 타입 변수(`A a`)가 실제로는 자식 객체(`new B()`)를 가리키는 거다!
  - 변수 타입(`A`)만 보고 메소드를 부를 수 있는지 확인하고,
  - **실제 객체(`B`)에서 오버라이딩된 메소드(`disp()`, `setY()`)는 자식(`B`)께 실행된다!** (이게 다형성의 존나 중요한 특징이다!)
  - 필드 숨김 때문에 `A a`로 `a.y`에 접근하면 `A`의 `y`가 나오고, 실제 `B` 객체의 `y`는 다를 수 있다! (헷갈리면 안 된다, 씨발!)
 */

// --- A 클래스: 부모 (기본 좌표) ---
// 모든 자식들이 물려받을 기본 틀이다.
class A {
	private int x = 100; // x 좌표 (나만 건드릴 수 있음) - private이라 직접 접근 못함
	private int y = 200; // y 좌표 (나만 건드릴 수 있음) - private이라 직접 접근 못함

	public void setX(int x) { // x 좌표 설정 메소드
		this.x = x; // 매개변수 x의 값을 현재 객체(this)의 멤버 변수 x에 저장
	}

	public void setY(int y) { // y 좌표 설정 메소드
		this.y = y; // 매개변수 y의 값을 현재 객체(this)의 멤버 변수 y에 저장
	}

	public void disp() { // 현재 좌표 출력 메소드
		System.out.println("A클래스 (부모): x: " + x + ", y: " + y);
	}
}

// --- B 클래스: 자식 (A 물려받고, 지만의 특징 추가) ---
// 'A'를 상속받아서 'A'의 기능들을 쓰고, 지만의 새로운 속성/기능도 추가한다.
class B extends A { // A의 자식이다!

	// ★★★ 존나 중요! '필드 숨김(Field Hiding)' ★★★
	// 부모 'A'에도 'y'가 있지만, 'B'가 'y'를 새로 만들어서 지 혼자 쓰는 거다.
	// 그래서 'A'의 'y'랑 'B'의 'y'는 서로 다른 별개의 공간이다. (값도 다를 수 있음!)
	private int y = 300; // B가 새로 만든 y 좌표 (이건 A의 y와 다른 별개의 변수다!)
	private int z = 400; // B에만 있는 새로운 z 좌표

	// ★★★ 존나 중요! 오버라이딩! ★★★
	// 부모 'A'의 'setY()'를 'B' 자기식대로 바꾼 거다.
	// 'B' 객체로 'setY()' 부르면, 'A' 거 말고 이 'B' 거가 실행된다.
	@Override // 부모 메소드를 덮어썼음을 명시한다. (실수 방지!)
	public void setY(int y) { // B의 y 좌표 설정 (A의 setY 덮어씀)
		this.y = y; // 'this.y'는 이 'B' 객체 자신의 'y' 멤버 변수를 말한다.
	}

	public void setZ(int z) { // z 좌표 설정 (B에만 있는 고유 기능)
		this.z = z;
	}

	// ★★★ 존나 중요! 오버라이딩! ★★★
	// 부모 'A'의 'disp()'를 'B' 자기식대로 바꾼 거다.
	@Override // 부모 메소드를 덮어썼음을 명시한다.
	public void disp() { // 정보 출력 (A의 disp() 덮어씀)
		super.disp(); // 'super.disp()': 일단 부모 'A'의 'disp()'를 먼저 실행한다! (그래서 A의 x,y가 먼저 나옴)
		System.out.println("B클래스 (자식): y: " + y + ", z: " + z); // 그 다음에 B의 y, z를 출력.
	}
}

// --- ABTest 클래스: 프로그램 실행 시작점 (다형성 테스트장) ---
public class ABTest {

	public static void main(String[] args) {

		// --- ★★★ 존나 중요! 다형성의 활용 (업캐스팅) ★★★ ---
		// 'A' 타입 변수 'a'가 실제로는 'B' 객체를 가리킨다.
		// 'a'로는 'A'에 있는 것만 부를 수 있지만, 오버라이딩된 건 'B'께 실행된다!
		A a = new B(); // 'a'가 'B' 객체를 참조 중이다. ('B'가 'A'의 자식이니 이렇게 업캐스팅이 가능하다!)

		System.out.println("--- 1. 초기 상태 ---");
		// 'a'는 'B' 객체를 가리키고, 'disp()'는 'B'에서 오버라이딩되었으므로, 'B'의 'disp()'가 호출된다.
		// 'B'의 disp() 안에서는 `super.disp()`를 호출하므로, `A`의 x, y가 먼저 출력되고, `B`의 y, z가 이어서 출력된다.
		a.disp(); 
		System.out.println(); // 줄 바꿈

		System.out.println("--- 2. a.setX(1) 호출 후 ---");
		// 'setX()': 이건 'A'에만 있는 메소드다. 'B'는 이걸 오버라이딩 안 했다.
		// 따라서 'a'가 가리키는 'B' 객체 내부의 'A' 부분에 있는 'x' 값을 1로 바꾼다.
		a.setX(1);
		a.disp(); // 다시 'B'의 'disp()'가 호출되어 변경된 x값을 포함하여 출력된다.
		System.out.println(); // 줄 바꿈

		System.out.println("--- 3. a.setY(2) 호출 후 ---");
		// 'setY()': 'A'에도 있고 'B'에도 있다. 근데 'B'에서 오버라이딩했지?
		// 'a'가 'B' 객체를 가리키니까, 다형성 규칙(오버라이딩 규칙)에 따라 **'B' 클래스의 'setY()'가 호출된다.**
		// 그래서 'B'의 'y' (초기값 300)가 2로 바뀐다.
		// ★★★ 존나 중요! 'A'의 'y' (200)는 그대로다! (필드 숨김 때문!) ★★★
		a.setY(2);
		a.disp(); // 다시 'B'의 'disp()'가 호출되어 변경된 'B'의 y값을 포함하여 출력된다.
		System.out.println(); // 줄 바꿈

		// a.setZ(3); // ★★★ 존나 중요! 컴파일 에러 난다! ★★★
		            // 'a'는 'A' 타입이라 'A'에 없는 'setZ()' 메소드는 못 부른다.
		            // 실제 객체가 'B'여도, 변수 타입('A')만 보고 판단하기 때문에 에러가 발생한다!

		// --- 'B' 객체만의 고유 기능 직접 쓰는 방법 ---
		// 만약 'B'만의 고유한 메소드(`setZ()`)를 쓰고 싶다면, 변수도 'B' 타입으로 선언해야 한다.
		// B b = new B(); // 'B' 타입 변수 'b'를 만들고 'B' 객체를 참조하게 한다.
		// b.setZ(3);     // 'b'는 'B' 타입이라 'setZ()' 메소드 호출이 존나게 가능하다!
		// b.disp();      // 'b'의 상태를 출력.
	}
}
