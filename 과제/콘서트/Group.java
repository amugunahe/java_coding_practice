package com.homework; // 이 클래스(Group.java)가 속한 **패키지 이름**이다. 'Concert' 클래스와 같은 패키지에 있어서 서로 쉽게 찾아 사용할 수 있다.

import java.util.Scanner; // **사용자 입력을 키보드로부터 받기 위해 필요한 Scanner 클래스**를 가져온다.

/*
  이 'Group' 클래스는 콘서트 좌석 예약 시스템에서 **특정 좌석 등급(예: S, A, B)의 좌석들을 관리하는 역할**을 담당한다.
 
  **주요 구성 요소:**
  - 이 그룹이 관리하는 **좌석의 등급 (`type`)**
  - 이 그룹에 속한 **개별 좌석들의 배열 (`seats`)**
  - **사용자 입력을 처리하기 위한 `Scanner` 객체** (각 그룹별로 입력을 받기 위해 자체적으로 가짐)
 
  이 클래스는 각 등급별로 **예약, 취소, 현황 조회 기능을 직접 수행**한다.
 */

public class Group { // **'Group'이라는 이름의 공개(public) 클래스**를 선언한다.

    // --- 1. 클래스의 속성 (**멤버 변수**) ---
    // 이 변수들은 'Group' 객체가 가지는 **'상태'를 나타낸다.**
    private char type; // 이 그룹이 관리하는 **좌석의 등급을 저장하는 문자(char) 변수**다. 예를 들어 'S', 'A', 'B' 같은 값이 들어갈 수 있다. **'private'이므로 이 클래스 내에서만 직접 접근 가능**하다.

    private Seat[] seats; // **'Seat' 타입의 배열**이다. 이 배열 안에 이 등급의 모든 **개별 좌석 객체들이 저장**된다. 예를 들어, 'S' 등급 좌석이 10개라면, `seats` 배열은 10개의 'Seat' 객체를 가진다.

    private Scanner sc; // **사용자 입력을 받기 위한 'Scanner' 객체 변수**다. 'Concert' 클래스에도 Scanner가 있지만, 'Group' 클래스에서도 직접 입력을 받을 때 사용한다.

    // --- 2. **생성자(Constructor)** ---
    // 'Group' 객체가 **생성될 때 가장 먼저 실행되는 특별한 메소드**다. 객체가 제대로 작동하기 위한 **초기 설정**을 담당한다.
    public Group(char type, int num) { // 'Group' 생성자다. **좌석 등급 문자('type')와 해당 등급의 좌석 수('num')를 매개변수로 받는다.**
        this.type = type; // 매개변수로 받은 'type'(예: 'S')을 이 객체의 'type' 멤버 변수에 저장한다.
        seats = new Seat[num]; // **'Seat' 배열을 'num' 크기(예: 10)로 초기화**한다. 이제 10개의 'Seat' 객체를 저장할 수 있는 공간이 생겼다. 하지만 이 상태에서는 각 칸이 아직 비어있다(**`null` 상태**).

        for (int i = 0; i < seats.length; i++) { // **`seats` 배열의 모든 칸을 순회**하면서 (0번 인덱스부터 마지막까지)
            seats[i] = new Seat(); // **각 칸마다 새로운 'Seat' 객체를 생성하여 저장**한다. 이렇게 해야 비로소 각 좌석이 개별적으로 관리될 수 있다.
        }
        sc = new Scanner(System.in); // **'Scanner' 객체를 생성하여 'sc' 변수에 할당**한다.
    }

    // --- 3. 메소드 (**그룹별 좌석 관리 기능**) ---

    /*
     * **현재 등급의 좌석을 예약하는 기능**을 수행한다.
     * 사용자로부터 이름과 좌석 번호를 입력받아 예약 처리한다.
     */

    public void reserve() { // 'reserve' 메소드는 외부에서 호출될 수 있다. (`Concert` 클래스에서 호출)
        show(); // **예약하기 전에 현재 이 등급의 좌석 현황을 먼저 화면에 보여준다.** (`show()` 메소드 호출)

        System.out.print("이름: "); // 사용자에게 이름을 입력하라고 안내한다.
        String name = sc.next(); // 사용자가 입력한 이름(단어)을 읽어서 'name' 변수에 저장한다.

        System.out.print("번호: "); // 사용자에게 좌석 번호를 입력하라고 안내한다.
        int no = sc.nextInt(); // 사용자가 입력한 정수(좌석 번호)를 읽어서 'no' 변수에 저장한다.

        // **입력된 좌석 번호가 유효한 범위(1부터 좌석 총 개수까지) 내에 있는지 확인**한다.
        if (no < 1 || no > seats.length) {
            System.out.println("잘못된 좌석번호입니다."); // 잘못된 번호이면 오류 메시지 출력
            return; // **메소드를 여기서 종료하고 호출된 곳으로 돌아간다.**
        }

        // **해당 좌석이 이미 예약되어 있는지 확인**한다. (배열 인덱스는 0부터이므로 `no-1`)
        // `seats[no - 1]`는 사용자가 입력한 번호의 좌석 객체를 의미한다.
        // **`isOccupied()`는 'Seat' 클래스에 정의된, 좌석이 예약되었는지 확인하는 메소드**일 거다.
        if (seats[no - 1].isOccupied()) {
            System.out.println("이미 예약된 좌석입니다."); // 이미 예약되어 있다면 오류 메시지 출력
            return; // **메소드를 여기서 종료한다.**
        }

        // 위 조건들을 통과했다면, **유효하고 비어있는 좌석이므로 예약 처리를 진행**한다.
        seats[no - 1].reserve(name); // 해당 **'Seat' 객체의 `reserve(name)` 메소드를 호출**하여 이름을 저장하고 좌석을 예약 상태로 바꾼다.
        System.out.println(name + "님이 " + type + "석 " + no + "번 좌석을 예약했습니다."); // 예약 성공 메시지를 출력한다.
    }

    /*
      **현재 등급의 좌석 예약을 취소하는 기능**을 수행한다.
      사용자로부터 취소자 이름을 입력받아 해당 예약 좌석을 찾아 취소한다.
     */

    public void cancel() { // 'cancel' 메소드는 외부에서 호출될 수 있다.
        show(); // **취소하기 전에 현재 이 등급의 좌석 현황을 먼저 화면에 보여준다.**

        System.out.print("취소자 이름: "); // 사용자에게 취소할 사람의 이름을 입력하라고 안내한다.
        String name = sc.next(); // 사용자가 입력한 이름을 읽어서 'name' 변수에 저장한다.

        boolean found = false; // **예약자를 찾았는지 여부를 표시하는 논리형(boolean) 변수**다. 초기값은 `false` (아직 못 찾음).
        for (int i = 0; i < seats.length; i++) { // **`seats` 배열의 모든 좌석을 순서대로 확인**한다.
            // **현재 좌석(`seats[i]`)이 예약되어 있는지 확인 (`isOccupied()`)하고,**
            // **예약되어 있다면 그 좌석에 저장된 이름과 사용자가 입력한 이름이 같은지 확인**한다. (`getName().equals(name)`)
            if (seats[i].isOccupied() && seats[i].getName().equals(name)) {
                seats[i].cancel(); // **이름이 일치하는 예약된 좌석을 찾았다면, 해당 'Seat' 객체의 `cancel()` 메소드를 호출**하여 예약을 취소한다.
                System.out.println(name + "님의 " + type + "석 " + (i + 1) + "번 좌석 예약을 취소했습니다."); // 취소 성공 메시지
                found = true; // **예약자를 찾았으니 `found`를 `true`로 바꾼다.**
                break; // **예약자를 찾아서 취소했으므로, 더 이상 찾을 필요 없이 'for' 루프를 종료한다.**
            }
        }
        if (!found) { // **`for` 루프가 끝났는데도 `found`가 여전히 `false`라면** (예약자를 못 찾았다면)
            System.out.println(name + "님으로 예약된 좌석이 없습니다."); // 예약된 좌석이 없다는 메시지를 출력한다.
        }
    }

    /*
      **현재 등급의 좌석 현황을 화면에 표시**한다.
      예약된 좌석은 이름으로, 빈 좌석은 '---'로 표시한다.
     */

    public void show() { // 'show' 메소드는 외부에서 호출될 수 있다.
        System.out.print(type + ">> "); // **이 그룹의 좌석 등급(예: "S>> ")을 먼저 출력**한다.
        for (int i = 0; i < seats.length; i++) { // **`seats` 배열의 모든 좌석을 순서대로 확인**한다.
            // 현재 좌석(`seats[i]`)이 예약되어 있는지 확인한다.
            if (seats[i].isOccupied()) {
                System.out.print(seats[i].getName() + " "); // **예약되어 있다면, 그 좌석에 저장된 이름을 출력**한다.
            } else {
                System.out.print("--- "); // **예약되어 있지 않다면, '---'를 출력하여 빈 좌석임을 나타낸다.**
            }
        }
        System.out.println(); // **한 등급의 좌석 현황 출력이 끝나면, 다음 출력을 위해 줄 바꿈**을 한다.
    }
}
