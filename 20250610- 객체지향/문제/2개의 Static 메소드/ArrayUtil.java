package com.functionex; // 이 코드가 속한 패키지(폴더)를 정의합니다.
                      // 패키지는 관련 있는 클래스들을 묶어 관리하는 데 사용됩니다.
                      // 나중에 이 클래스를 사용할 때 'import com.functionex.ArrayUtil;'처럼 가져올 수 있어요.

public class ArrayUtil { // 'ArrayUtil'이라는 이름의 클래스를 정의합니다.
                         // 'public'은 이 클래스를 어디서든 접근할 수 있다는 의미이고,
                         // 'class'는 객체를 만들기 위한 설계도라고 생각할 수 있습니다.
                         // 여기서는 배열(Array)을 다루는 유틸리티(Util) 기능을 모아놓은 클래스입니다.

    // --- concat 메서드 ---
    // 두 개의 정수 배열을 연결하여 새로운 배열을 반환하는 메서드입니다.
    public static int[] concat(int[] a, int[] b) {
        // 'public': 이 메서드는 다른 모든 클래스에서 호출할 수 있습니다.
        // 'static': 이 메서드는 'ArrayUtil' 클래스의 객체(인스턴스)를 생성하지 않고도
        //           'ArrayUtil.concat()'과 같이 클래스 이름으로 바로 호출할 수 있습니다.
        //           유틸리티 메서드에서 자주 사용됩니다.
        // 'int[]': 이 메서드가 반환(return)할 값의 타입이 '정수형 배열'임을 나타냅니다.
        // 'concat': 메서드의 이름입니다. 'concatenate(연결하다)'에서 따왔습니다.
        // '(int[] a, int[] b)': 이 메서드가 받게 될 입력 값(매개변수)입니다.
        //                      'int[] a'는 첫 번째 정수형 배열, 'int[] b'는 두 번째 정수형 배열을 의미합니다.

        // 배열 a와 b를 연결한 새로운 배열을 반환(리턴)합니다.

        // 1. 새로운 배열 생성:
        //    연결된 두 배열의 모든 요소를 담을 수 있는 새로운 배열 'arr'을 생성합니다.
        //    새로운 배열의 크기는 첫 번째 배열 'a'의 길이와 두 번째 배열 'b'의 길이를 합한 값입니다.
        //    예: a = {1, 2} (길이 2), b = {3, 4, 5} (길이 3) 이라면,
        //        'arr'은 총 2 + 3 = 5개의 요소를 저장할 수 있는 크기로 생성됩니다.
        int[] arr = new int[a.length + b.length];

        // 2. 배열 'a'의 내용을 새로운 배열 'arr'에 복사:
        //    첫 번째 배열 'a'의 모든 요소를 새로 만든 'arr' 배열의 시작 부분에 복사합니다.
        //    'for' 반복문을 사용하여 'a'의 각 요소를 'arr'의 해당 위치에 하나씩 넣어줍니다.
        //    'i'는 'a' 배열의 인덱스(0부터 시작하는 위치)이자 'arr' 배열의 인덱스로 사용됩니다.
	    
        for (int i = 0; i < a.length; i++) {
            arr[i] = a[i]; // 'a'의 i번째 요소를 'arr'의 i번째 위치에 복사합니다.
        }
        // 예: a = {1, 2}
        //    - i=0: arr[0] = a[0] (arr[0] = 1)
        //    - i=1: arr[1] = a[1] (arr[1] = 2)
        //    -> 현재 arr은 {1, 2, ?, ?, ?} (나머지는 기본값인 0으로 채워져 있음)

        // 3. 배열 'b'의 내용을 새로운 배열 'arr'에 이어서 복사:
        //    두 번째 배열 'b'의 모든 요소를 'arr' 배열의 'a' 배열 내용 바로 뒤에 이어서 복사합니다.
        //    여기서 중요한 것은 'arr' 배열에서의 올바른 위치(인덱스)를 계산하는 것입니다.
        //    'b' 배열의 첫 번째 요소는 'arr' 배열에서 'a.length' 위치부터 시작해야 합니다.
	    
        for (int i = 0; i < b.length; i++) {
            // 'k' 변수를 사용하여 'b' 배열의 'i'번째 요소를 'arr' 배열의 어디에 넣을지 계산합니다.
            // 'a.length'는 'a' 배열의 끝 위치를 의미하므로, 그 뒤에 'i'를 더하면
            // 'arr'에서 'b'의 요소가 들어갈 정확한 위치가 됩니다.
            // 예: a.length가 2인 경우
            //    - b의 첫 번째 요소 (i=0): k = 2 + 0 = 2. 즉, arr[2]에 b[0]을 넣습니다.
            //    - b의 두 번째 요소 (i=1): k = 2 + 1 = 3. 즉, arr[3]에 b[1]을 넣습니다.
            //    - ... 이런 식으로 이어집니다.
		
            int k = a.length + i;
            arr[k] = b[i]; // 'b'의 i번째 요소를 계산된 'arr'의 k번째 위치에 복사합니다.
        }
        // 예: a = {1, 2}, b = {3, 4, 5}
        //    - i=0: k=2, arr[2] = b[0] (arr[2] = 3)
        //    - i=1: k=3, arr[3] = b[1] (arr[3] = 4)
        //    - i=2: k=4, arr[4] = b[2] (arr[4] = 5)
        //    -> 최종 arr은 {1, 2, 3, 4, 5}가 됩니다.

        return arr; // 모든 요소 복사가 끝나면, 최종적으로 완성된 새로운 배열 'arr'을 반환합니다.
    }

    // --- print 메서드 ---
    // 주어진 정수 배열의 모든 요소를 화면에 보기 좋은 형태로 출력하는 메서드입니다.
    public static void print(int[] a) {
        // 'public static': 위 'concat' 메서드와 동일한 의미입니다.
        // 'void': 이 메서드는 어떤 값도 반환하지 않습니다. 단순히 화면에 내용을 출력하는 '작업'만 수행합니다.
        // 'print': 메서드의 이름입니다.
        // '(int[] a)': 이 메서드가 출력할 대상인 정수형 배열 'a'를 매개변수로 받습니다.

        // 배열 출력 시작을 알리는 대괄호 '['를 출력합니다.
        // 'System.out.print()'는 출력 후 줄을 바꾸지 않습니다.
        System.out.print("[");

        // 배열 'a'의 모든 요소를 반복하며 출력합니다.
        // 'i'는 배열의 인덱스(0부터 시작)입니다.
        // 'a.length'는 배열 'a'의 총 길이를 의미합니다.
        // 반복문은 'i'가 0부터 시작해서 'a.length - 1'까지 실행됩니다 (배열의 마지막 인덱스).
        for (int i = 0; i < a.length; i++) {
            // 'a'의 현재 i번째 요소를 출력하고, 뒤에 공백 하나를 추가하여 숫자들을 구분합니다.
            System.out.print(a[i] + " ");
        }

        // 배열 출력이 끝났음을 알리는 대괄호 ']'를 출력합니다.
        System.out.print("]");
    }
}
