문제 1) 아래에서 설명하는 테스트 커버리지는 무엇인지 쓰시오.

## ✅ 문제

소프트웨어 테스트의 효율성을 평가하는 지표 중 하나로,  
주로 소프트웨어의 각 **조건식이 모두 참과 거짓인 경우 최소 한 번씩 평가되었는지**  
측정하는 데 사용된다.  
조건문 내의 각각의 **논리 조건이 True와 False로 평가될 때** 해당 코드의 행동을 테스트한다.

---

### ✅ 정답  
**조건 커버리지 (Condition Coverage)**

---

### 📌 해설: 코드 커버리지(Code Coverage) 종류

| 커버리지 종류               | 설명                                                                                       | 갓반인 예시                                                  |
|-----------------------------|--------------------------------------------------------------------------------------------|--------------------------------------------------------------|
| **구문 커버리지 (Statement Coverage)**    | 모든 구문(코드 한 줄, 명령문)이 적어도 한 번 실행되었는지 확인                              | `if(true) { print("Hi"); }` → "Hi" 출력문이 실행되어야 함       |
| **조건 커버리지 (Condition Coverage)**    | 조건문 내 **각 개별 조건**이 True와 False로 한 번 이상 평가되었는지 측정                   | `if (A > 10 && B < 5)`에서 A > 10과 B < 5 각각 True/False 한번씩 실행 필요 |
| **결정 커버리지 (Decision Coverage)**      | 조건식 전체가 True 또는 False가 한 번씩 평가되었는지 확인 (분기문 if, while 중심)           | `if (A > 10 && B < 5)`가 True일 때와 False일 때 모두 실행돼야 함       |
| **조건/결정 커버리지 (Condition/Decision Coverage)** | 조건 커버리지와 결정 커버리지를 모두 만족해야 함                                           | 위 조건과 결정 커버리지 모두 충족하는 테스트 케이스 작성 필요           |
| **변경 조건/결정 커버리지 (Modified Condition/Decision Coverage, MC/DC)** | 각 개별 조건이 결과에 독립적으로 영향을 미치는지 확인                                     | 조건 하나씩 True/False 바꿀 때 전체 결과가 달라지는지 테스트               |
| **다중 조건 커버리지 (Multiple Condition Coverage)** | 조건의 모든 가능한 조합을 테스트하여 100% 커버리지 달성                                  | `if (A && B)`의 모든 조합 (TT, TF, FT, FF)을 테스트해야 함              |

---

### ✅ 갓반인 예시: 조건 커버리지

```java
if (A > 10 && B < 5) {
    // 실행 코드
}


조건 커버리지를 만족하려면:

A > 10이 True, False 각각 한 번 이상 평가

B < 5도 True, False 각각 한 번 이상 평가되어야 함

단, 전체 if문이 실행되었는지만 확인하는 결정 커버리지와는 구별됨.

📌 요약
구문 커버리지는 코드가 실행됐는지 확인
조건 커버리지는 조건식 내 각 부분이 True/False 됐는지 확인
결정 커버리지는 조건 전체 결과(True/False) 확인
더 엄격한 커버리지일수록 테스트 케이스가 더 많아짐
-----------------------------------------------------------------------------------------------------

## ✅ 문제 2

다음 내용에서 설명하는 용어를 쓰시오.

> 소프트웨어가 불법으로 변경되었을 경우,  
> 소프트웨어가 정상 수행되지 않게 하는 기법이다.  
> 특정 기기 데이터 또는 소프트웨어가 무단 변경, 파괴 또는 조작으로부터 보호되도록  
> 설계하는 과정이다.  
> 무단 접근을 시도하는 행위를 탐지하고 방지하는 데 목적이 있다.

---

### ✅ 정답  
**템퍼프루핑 (Tamper Proofing)**

---

### 📌 해설: 템퍼프루핑(Tamper Proofing)이란?

- **템퍼프루핑**은 소프트웨어나 콘텐츠가 **불법적으로 변조(위변조)** 될 때  
  이를 감지하고, **정상 동작을 방해하거나 중단시키는 보안 기술**입니다.  
- **Tamper**: 변조하다, 조작하다  
- **Proofing**: 방지, 저항  
- 주로 소프트웨어 무결성 유지 및 해커의 우회/변조 방지를 위해 사용됨

---

## 🔒 저작권 보호 관련 기술 정리

| 분류                 | 설명                                                                                      | 갓반인 예시                                              |
|----------------------|-------------------------------------------------------------------------------------------|----------------------------------------------------------|
| **암호화 기술**       | 콘텐츠를 암호화하여 **특정 키를 가진 사용자만 접근 가능**하게 만드는 기술                 | Netflix가 스트리밍 콘텐츠를 암호화해 권한 없는 사용 차단       |
| **템퍼프루핑**       | 콘텐츠가 **무단 변경되면 오작동하거나 사용 불가 상태**가 되도록 만드는 기술                | 게임이 변조되면 실행 중 오류를 발생시키거나 종료하는 보호 기능    |
| **워터마킹**          | 콘텐츠에 **저작권 정보(숨겨진 데이터)를 삽입**하여 불법 복제 추적 가능                     | 영화 DVD에 특정 고객 ID 워터마크 삽입, 불법 복제시 출처 추적      |
| **핑거프린팅**        | 콘텐츠 유통 과정에서 **사용자 정보를 삽입하여 유포 경로 추적**                            | 음악 파일에 구매자 이메일 정보 삽입해 유출 시 추적 가능         |
| **DRM (디지털 권리 관리)** | 디지털 콘텐츠를 **승인된 사용자만 사용할 수 있게 제한하는 통합 보호 기술**                 | 전자책에 DRM 적용, 무단 복제 및 공유 제한                     |

---

### ✅ DRM (Digital Rights Management) 주요 구성 요소

| 구성 요소          | 역할 및 설명                                           | 갓반인 예시                                            |
|-------------------|------------------------------------------------------|--------------------------------------------------------|
| **콘텐츠 제공자**    | 콘텐츠를 제작하는 주체                                | 영화사, 출판사                                         |
| **콘텐츠 분배자**    | 콘텐츠를 사용자에게 전달하는 유통자                    | 스트리밍 서비스, 온라인 서점                            |
| **패키저 (Packager)**| 콘텐츠, 메타데이터, DRM 정책을 묶어 하나의 패키지로 생성 | 영상 파일 + 사용권 정책을 하나로 묶어 배포               |
| **보안 컨테이너**    | 콘텐츠 암호화 및 보호 역할                             | 암호화된 동영상 파일 저장                               |
| **DRM 컨트롤러**    | 사용 권한을 관리하고 실행 시 권한 검증                  | 재생 가능 횟수, 기간 제한 관리                          |
| **클리어링 하우스** | 라이선스 발급, 사용자 인증 및 정산 처리                 | 유료 결제 후 라이선스 키 발급                           |

---

### 📌 요약

- **템퍼프루핑**은 콘텐츠나 소프트웨어가 변조될 때 이를 감지하고 문제를 일으켜 변조를 방지하는 기술  
- 저작권 보호를 위해 **암호화, 템퍼프루핑, 워터마킹, 핑거프린팅, DRM** 등 다양한 기술이 함께 사용됨  
- DRM은 여러 구성요소가 협력하여 콘텐츠를 안전하게 보호하고 권한을 관리함  
- 갓반인 예시를 통해 현실 적용 상황도 쉽게 이해 가능  


---


-----------------------------------------------------------------------------------------------------
## ✅ 문제 3

다음은 데이터베이스 설계의 순서에 관한 문제이다.  
아래의 데이터베이스 설계 순서를 올바르게 나열하시오.

---

### ✅ 정답  
**요구조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현**

---

### 📌 해설: 데이터베이스 설계 과정

데이터베이스 설계는 **사용자 요구사항을 분석하고**, 이를 **현실적인 데이터베이스로 구현**하기 위한 단계별 과정입니다.

| 단계            | 설명                                                      | 갓반인 예시                                         |
|-----------------|-----------------------------------------------------------|-----------------------------------------------------|
| **1. 요구조건 분석** | 사용자와 대화하며 어떤 데이터를 저장하고 관리할지 정함           | 쇼핑몰: 고객, 주문, 상품 정보가 필요함을 파악           |
| **2. 개념적 설계**   | ER 다이어그램 등으로 데이터 구조와 관계를 추상적으로 모델링        | 고객 - 주문 - 상품 간 관계를 ER 다이어그램으로 그림     |
| **3. 논리적 설계**   | DBMS에 맞는 테이블과 제약조건으로 변환 (정규화 수행 포함)          | 고객 테이블, 주문 테이블, 상품 테이블 생성, 정규화 적용  |
| **4. 물리적 설계**   | 저장 방식, 인덱스, 접근 경로 등 성능 최적화 설계                     | 주문 검색 속도 향상을 위한 인덱스 설계                  |
| **5. 구현**          | DBMS에 데이터베이스 생성 및 애플리케이션과 연동                      | MySQL에 테이블 생성, 웹 쇼핑몰과 연결                     |

---

### 📌 핵심 요약

- **요구조건 분석**: "무엇이 필요한가?" (사용자의 필요 파악)  
- **개념적 설계**: "무엇을 어떻게 표현할 것인가?" (ER 모델로 데이터 구조 설계)  
- **논리적 설계**: "DBMS에서 어떻게 구현할 것인가?" (테이블, 키, 제약조건 등)  
- **물리적 설계**: "효율적으로 저장하려면 어떻게 할까?" (인덱스, 파티셔닝 등)  
- **구현**: 데이터베이스를 실제로 만들고 앱과 연결  

---

### 💡 갓반인 팁!

- 요구조건 분석이 탄탄해야 설계 단계가 수월하다.  
- 정규화는 데이터 중복을 줄이고 무결성을 지키는 핵심 과정!  
- 물리적 설계는 성능 최적화와 직결되니 꼭 고려할 것!  
- 구현 전에 설계를 충분히 검토하는 습관이 중요하다.  


-----------------------------------------------------------------------------------------------------

## ✅ 문제 4

다음에서 설명하는 디자인 패턴을 보기에서 찾아 쓰시오.

---

### 🔹 (1)

> 특정 클래스의 인스턴스가 하나만 생성되도록 보장하고,  
> 그 인스턴스에 어디에서든 접근할 수 있도록 하는 패턴이다.

✅ **정답: 싱글톤 (Singleton)**

---

### 🔹 (2)

> 객체 구조 내의 요소에 대해 수행할 작업을 캡슐화하는 디자인 패턴이다.  
> 객체 구조의 클래스를 수정하지 않고도 새로운 연산을 추가할 수 있게 해준다.

✅ **정답: 비지터 (Visitor)**

---

## 📌 해설: 디자인 패턴 예시

| 패턴명         | 설명                                                                                       | 갓반인 예시                                       |
|----------------|--------------------------------------------------------------------------------------------|--------------------------------------------------|
| **싱글톤 (Singleton)** | - 클래스 인스턴스를 오직 하나만 만들어서 모든 곳에서 공유하도록 제한하는 생성 패턴<br>- 전역 접근 지점 제공<br>- 리소스 절약과 상태 일관성 유지 | 애플리케이션 설정 정보 객체, DB 커넥션 풀           |
| **비지터 (Visitor)**   | - 객체 구조 변경 없이 새로운 기능 추가할 때 사용<br>- 알고리즘을 객체 구조에서 분리해 관리<br>- 복잡한 구조의 요소를 방문해 처리할 때 효과적 | 컴파일러에서 문법 트리를 순회하며 코드 생성, 최적화  |

---

## 📚 디자인 패턴 분류 예시

| 생성 패턴 (Object Creational) | 구조 패턴 (Structural)   | 행위 패턴 (Behavioral)        |
|-------------------------------|--------------------------|-------------------------------|
| Singleton                     | Adapter                  | Visitor                       |
| Factory Method                | Composite                | Observer                      |
| Builder                      | Decorator                | Strategy                      |
| Abstract Factory             | Proxy                    | Template Method               |

---

### 💡 갓반인 꿀팁!

- **생성 패턴**: 객체 생성 방법을 표준화해서 유연하게 관리  
- **구조 패턴**: 클래스와 객체의 관계를 쉽게 연결하고 관리  
- **행위 패턴**: 객체들 간의 상호작용과 책임 분산에 집중  

이해할 땐, 각 패턴이 “무엇을 쉽게, 어떻게 해결해주는지”에 초점을 맞춰보자!



-----------------------------------------------------------------------------------------------------
## ✅ 문제 5

다음에서 설명하는 답을 보기에서 골라 작성하시오.

---

### 🔹 보기

- **HAMMING**  
- **FEC (Forward Error Correction)**  
- **BEC (Backward Error Correction)**  
- **PARITY**  
- **CRC (Cyclic Redundancy Check)**

---

### 🔸 문제 설명 및 정답

| 번호 | 설명 | 정답 |
|------|------|------|
| (1) | 송수신 과정에서의 단일 비트 오류를 검출하고 정정할 수 있게 한다. | **HAMMING** |
| (2) | 데이터를 전송하기 전에 오류 정정 코드를 추가하고 수신측에서 발생 가능한 오류를 검출하고 정정할 수 있도록 하는 기술이다. | **FEC** |
| (3) | 오류가 감지된 후 데이터를 복구하기 위해 데이터 송신자에게 재전송을 요청하는 오류 수정 방식이다. | **BEC** |
| (4) | 데이터 무결성을 확인하기 위해 사용되는 간단한 오류 검출 방식이다. | **PARITY** |
| (5) | 데이터 전송의 정확성을 보장하기 위해 사용되는 오류 검출 기법이다. 데이터 블록 전체에 대해 특정 다항식을 사용하여 검사값(체크섬)을 계산하고, 이 값을 데이터에 추가한다. | **CRC** |

---

## 📌 전송 오류 제어 방식 정리

### ✅ 전진 오류 수정 (FEC: Forward Error Correction)
- 수신 측에서 **재전송 요청 없이** 오류를 직접 **검출하고 수정**  
- 대표적 기법: **해밍 코드(Hamming Code)**, 상승 코드  
- 주로 **실시간 통신**(예: 위성 방송, 스트리밍)에 사용  
- 갓반인 예시: 위성 TV 신호가 중간에 깨져도 수신기에서 자동으로 오류 보정

---

### ✅ 후진 오류 수정 (BEC: Backward Error Correction)
- 오류 발생 시 **수신 측에서 송신 측에 재전송 요청**  
- 대표적 기법: **패리티 검사**, **CRC (순환 중복 검사)**, 블록 합 방식  
- 갓반인 예시: 이메일 첨부파일 다운로드 시 오류가 있으면 서버에 재요청해서 다시 받음

---

### ✅ 각 오류 제어 기법 요약

| 기법         | 특징                                                   | 갓반인 예시                              |
|--------------|--------------------------------------------------------|-----------------------------------------|
| **Hamming**  | 단일 비트 오류 검출과 정정 가능                         | 네트워크 통신에서 작은 오류 자동 보정    |
| **FEC**      | 재전송 없이 수신 측에서 직접 오류 정정                  | 위성 방송, 실시간 스트리밍               |
| **BEC**      | 오류 감지 후 송신 측에 재전송 요구                      | 파일 다운로드 시 손상된 부분 재요청      |
| **Parity**   | 1비트 패리티 비트 추가로 간단한 오류 검출               | 간단한 메모리 오류 검출                   |
| **CRC**      | 다항식 기반 고급 오류 검출, 강력한 무결성 검사          | 네트워크 패킷 무결성 검사                 |

---

### 💡 핵심 요약  
- **FEC**: 송신자-수신자 재전송 없이 오류 스스로 고침 → 빠르고 실시간에 유리  
- **BEC**: 오류 있으면 재전송 요구 → 신뢰성 높지만 지연 발생 가능  
- 상황에 따라 적절한 오류 제어 방식을 선택하는 게 중요!  

---


-----------------------------------------------------------------------------------------------------

## ✅ 문제 6

다음에서 설명하는 답을 보기에서 골라 작성하시오.

---

### 🔹 보기

- 정보 프레임  
- 감독 프레임  
- 비번호/비순서 프레임  
- 비동기 균형 모드  
- 비동기 응답 모드

---

### 🔸 문제 설명 및 정답

| 번호 | 설명 | 정답 |
|------|------|------|
| (1) | HDLC 프레임 중 **데이터 전송**을 위한 프레임. 사용자 데이터를 포함하며, 데이터 링크 계층에서 종단 간 데이터 전송 담당 | **정보 프레임 (Information Frame, I-Frame)** |
| (2) | HDLC 프레임 중 **오류 검출 및 흐름 제어**에 사용. 데이터를 포함하지 않고 수신 상태 관리 목적 | **감독 프레임 (Supervisory Frame, S-Frame)** |
| (3) | **추가 제어나 특별 상황**에 쓰임. 링크 설정, 해제, 오류 보고 등 제어 명령 수행 | **비번호/비순서 프레임 (Unnumbered Frame, U-Frame)** |
| (4) | HDLC 전송 모드 중 **모든 단말이 대등하게 주국 역할 수행 가능**. 양방향 통신에서 가장 유연한 모드 | **비동기 균형 모드 (Asynchronous Balanced Mode, ABM)** |
| (5) | HDLC 전송 모드 중, **주국이 통신 제어**, 종국도 송신 시작 가능 | **비동기 응답 모드 (Asynchronous Response Mode, ARM)** |

---

## 📌 HDLC(HIGH LEVEL DATA LINK CONTROL) 요약 정리

### ✅ HDLC 프레임 구성

- **Flag**: 프레임의 시작과 끝을 알리는 특별 비트 (`01111110`)  
- **Address**: 수신자 장치 주소 정보  
- **Control**: 프레임의 종류 및 제어 정보 (I, S, U 프레임 식별)  
- **Data**: 실제 전송되는 사용자 데이터  
- **FCS (Frame Check Sequence)**: CRC를 이용한 오류 검출 코드  

갓반인 예시:  
> 데이터 전송 시 I-Frame이 사용자 데이터를 담아 보내고, 수신자는 S-Frame으로 수신 상태 알려줘요.

---

### ✅ HDLC 프레임 유형

| 프레임 종류               | 설명                                        | 갓반인 예시                                  |
|--------------------------|---------------------------------------------|---------------------------------------------|
| **정보 프레임 (I-Frame)** | 실제 사용자 데이터를 전송하는 프레임          | 채팅 메시지 전송 시 실제 텍스트 데이터를 담음  |
| **감독 프레임 (S-Frame)** | 오류 검출과 흐름 제어, 수신 상태 알림         | 패킷을 잘 받았다는 ACK 신호를 보냄             |
| **비순서 프레임 (U-Frame)**| 링크 설정/해제, 오류 보고, 특별 제어 명령용    | 연결 시작할 때 링크 세팅 신호를 주고받음        |

---

### ✅ HDLC 전송 모드

| 모드                           | 설명                                           | 갓반인 예시                                |
|--------------------------------|------------------------------------------------|-------------------------------------------|
| **정규 응답 모드 (NRM)**         | 주국이 모든 통신 제어, 종국은 응답만 가능          | 프린터와 PC 간 연결, PC가 제어함            |
| **비동기 응답 모드 (ARM)**       | 주국이 제어하지만, 종국도 데이터 송신 시작 가능     | 무선 단말기에서 중앙 장비와 통신할 때 사용   |
| **비동기 균형 모드 (ABM)**       | 모든 단말이 동등한 권한으로 주국 역할 수행 가능       | LAN 내에서 컴퓨터들이 자유롭게 통신하는 경우  |

---

### 💡 핵심 요약  
- HDLC는 데이터 링크 계층 표준 프로토콜로 **프레임 단위로 데이터 전송과 제어** 수행  
- **I-Frame**: 실제 데이터 운반, **S-Frame**: 흐름/오류 제어, **U-Frame**: 링크 제어  
- 전송 모드는 제어 권한과 통신 방식에 따라 **NRM, ARM, ABM**으로 나뉨  
- 가장 유연한 모드는 **ABM**, 모든 단말이 동등하게 통신 가능  




-----------------------------------------------------------------------------------------------------
## ✅ 문제 7

다음 보기에서 **대칭키**와 **비대칭키**에 해당하는 내용을 알맞게 쓰시오.

---

### 🔹 보기  
`RSA`, `DES`, `AES`, `ECC`, `ARIA`, `SEED`

---

### ✅ 정답

- **대칭키(Symmetric Key)**  
  👉 `DES`, `AES`, `ARIA`, `SEED`

- **비대칭키(Asymmetric Key)**  
  👉 `RSA`, `ECC`

---

## 📌 해설

### 🔸 대칭키 암호화 (Symmetric Key Encryption)

- **같은 키**로 암호화와 복호화를 수행하는 방식  
- 빠르고 연산 효율이 높지만, **키 분배 문제**가 있음  
- **블록 암호**와 **스트림 암호**로 나뉨

#### ✔️ 블록 암호 알고리즘

| 알고리즘 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **DES** | 64비트 블록, 56비트 키, 페이스텔 구조, 현재는 보안 취약 | 초기 은행 시스템에서 많이 쓰임 |
| **3-DES** | DES를 3번 연속 수행, 보안 강화되었으나 속도 느림 | 은행 송금 보안 강화용 |
| **AES** | 미국 표준, 128/192/256비트 키, Rijndael 알고리즘 | Wi-Fi WPA2 보안에 사용 |
| **SEED** | 대한민국 표준 블록 암호 | 한국 인터넷 뱅킹에 적용 |
| **ARIA** | 한국 개발 128비트 블록 암호 | 정부 보안 시스템에서 사용 |
| **LEA** | 국산 경량 블록 암호 | IoT 기기 보안에 적합 |

#### ✔️ 스트림 암호 알고리즘

| 알고리즘 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **LFSR** | 선형 피드백 시프트 레지스터 기반 | 무전기 통신 암호화 |
| **RC4** | 한때 인터넷 보안에 많이 쓰였으나 취약 | 예전 SSL 통신에 사용 |
| **A5** | GSM 휴대폰 통신 암호화에 사용 | 휴대폰 통화 보호 |

---

### 🔸 비대칭키 암호화 (Asymmetric Key Encryption)

- **서로 다른 키**(공개키와 개인키)를 사용  
- 속도는 느리지만 키 관리가 쉽고, **전자서명 및 보안 통신에 필수**

| 알고리즘 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **RSA** | 소인수분해 기반, 가장 널리 사용 | 인터넷 HTTPS 인증서 |
| **ECC** | 타원곡선 기반, 짧은 키로 높은 보안성 | 모바일 결제 보안 |
| **ElGamal** | 이산대수 기반, 디지털 서명용 | 전자문서 서명 |
| **DSA** | 미국 표준 디지털 서명 알고리즘 | 정부 문서 인증 |
| **Diffie-Hellman** | 안전한 키 교환 알고리즘 | VPN 세션 키 교환 |

---

### 🔸 단방향 암호화 (해시 함수)

- 복호화 불가능한 **일방향 함수**  
- 주로 **무결성 검증**, **전자서명** 등에 활용

| 알고리즘 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **MD5** | 빠른 해시, 현재는 취약점 존재 | 예전 파일 무결성 검사 |
| **SHA-1/2/3** | 다양한 길이 해시 생성, NIST 표준 | 소프트웨어 배포 검증 |
| **HAS-160** | 한국산 해시 알고리즘, KCDSA에 사용 | 국내 전자서명 시스템 |

---

💡 **요약**  
- 대칭키는 빠르지만 키 공유가 문제  
- 비대칭키는 느리지만 키 관리 편리, 보안 통신 필수  
- 해시는 데이터 무결성 보장 및 전자서명 기본  
- 각각의 알고리즘은 상황과 환경에 맞게 선택  



-----------------------------------------------------------------------------------------------------

## ✅ 문제 8

다음 괄호에 알맞은 내용을 쓰시오.

---

### 🔹 문제 설명

보안에서 사용되는 **( )**는 데이터의 무결성과 인증을 보장하는데 중요한 역할을 하는 기술이다.  
**( )**는 임의 길이의 데이터를 입력받아 고정된 크기의 값을 출력한다.  
이 값들은 입력 데이터의 고유한 지문과 같은 역할을 하며,  
원본 데이터에 아주 작은 변화가 생기더라도 출력되는 값은 완전히 달라진다.  
이 특성을 통해 데이터의 무결성을 확인할 수 있다.

---

### ✅ 정답  
**해시 (Hash)**

---

## 📌 해설

### 🔸 해시 함수 (Hash Function)

- 길이 상관없이 입력 데이터를 **고정 길이 해시값**으로 바꿔주는 함수  
- 입력이 조금만 달라져도 완전히 다른 해시값 생성 (민감도 매우 높음)  
- 안전한 해시는 아래 특성 필수

| 특성                 | 설명                              | 갓반인 예시                       |
|----------------------|---------------------------------|----------------------------------|
| **압축성 (Compression)**    | 긴 데이터 → 고정된 길이 해시값               | 긴 문서도 256비트 해시값으로 요약 가능 |
| **효율성 (Efficiency)**     | 빠른 계산                         | 대용량 파일도 빠르게 해시 계산 가능     |
| **충돌 회피 (Collision Resistance)** | 서로 다른 입력이 같은 해시값 갖기 어려움        | 다른 두 파일이 같은 해시값 갖는 경우 극히 드묾 |
| **은닉성 (Hiding)**          | 해시값만으로 원본 데이터 유추 불가             | 해시값만 보고 원본 문서 유추 불가능       |
| **1방향성 (One-way)**        | 해시값으로 원본 데이터 역산 불가               | 암호화된 비밀번호 해시로 원래 비밀번호 복원 불가 |

---

## ✅ 대표 해시 알고리즘

| 알고리즘   | 설명                                   | 갓반인 예시                        |
|------------|--------------------------------------|-----------------------------------|
| **MD5**     | 128비트 해시, 빠르지만 충돌 가능성 존재             | 예전 소프트웨어 배포 체크섬          |
| **SHA-1**   | 160비트 해시, 보안 취약점 발견                        | 옛날 디지털 서명용 해시              |
| **SHA-2 (SHA-256/512)** | 현재 널리 쓰이는 안전한 해시                       | HTTPS 인증서, 블록체인 해시          |
| **SHA-3**   | SHA 계열 최신 버전                                   | 최신 보안 표준 해시                  |
| **HAS-160** | 한국 개발, KCDSA 전자서명에서 사용                     | 국내 전자정부 문서 서명              |

---

## ✅ 해시 함수 활용 예시

| 용도           | 설명                                         | 갓반인 예시                     |
|----------------|--------------------------------------------|--------------------------------|
| 데이터 무결성 검증 | 파일 변조 여부 확인                             | 다운로드 파일 체크섬 비교             |
| 전자서명        | 문서의 변조 방지와 작성자 인증                        | 공인인증서 서명 검증                 |
| 비밀번호 저장    | 비밀번호를 해시해 데이터베이스에 저장, 원본은 저장 안 함          | 웹사이트 로그인 비밀번호 관리          |
| 블록체인        | 각 블록 고유 식별자로 해시 사용                          | 비트코인 거래 블록 식별자 생성         |

---

💡 **요약**  
- 해시는 데이터 요약, 무결성, 보안에서 핵심 역할  
- 안전한 해시는 충돌 없이 빠르고 원본 복원이 불가능해야 함  
- 각종 보안 시스템과 블록체인에서 필수로 쓰임  




-----------------------------------------------------------------------------------------------------
## ✅ 문제 9

다음 SQL 명령어에서, **학생 뷰(View)** 를 참조하는 **다른 모든 뷰(view)** 들까지 함께 삭제할 수 있도록 괄호에 들어갈 알맞은 SQL 키워드를 쓰시오.

---

### 🔹 문제

`DROP VIEW 학생 (    )`

---

### ✅ 정답  
**CASCADE**

---

## 📌 해설

SQL에서 **`DROP VIEW`** 명령은 데이터베이스에 정의된 뷰(View)를 삭제하는 데 사용됩니다.  
하지만 해당 뷰가 **다른 뷰 또는 객체에 의해 참조**되고 있을 경우, 단순한 `DROP VIEW` 명령으로는 삭제되지 않습니다.

이때 사용하는 것이 바로 `**CASCADE**` 옵션입니다.

---

### ✅ DROP VIEW 구문

```sql
DROP VIEW 뷰이름 CASCADE;


---
## 📌 DROP VIEW 옵션과 개념 정리

| 옵션                 | 설명                                     | 갓반인 예시                                      |
|----------------------|------------------------------------------|-------------------------------------------------|
| **CASCADE**           | 뷰를 참조하는 모든 다른 뷰나 객체까지 함께 삭제함    | 학생 뷰가 성적 뷰에서 참조 중일 때, 둘 다 삭제 가능          |
| **RESTRICT (기본값)** | 뷰가 다른 객체에 참조되면 삭제를 거부                  | 학생 뷰가 참조 중이면 삭제 실패                                |

---

### ✅ DROP VIEW 사용 예시

```sql
-- 학생 뷰 삭제, 이 뷰를 참조하는 다른 뷰들도 모두 삭제
DROP VIEW 학생 CASCADE;

## 📌 관련 개념

| 용어         | 설명                                           | 갓반인 예시                                    |
|--------------|------------------------------------------------|-----------------------------------------------|
| **VIEW**      | 하나 이상의 테이블 또는 뷰를 기반으로 만든 가상 테이블         | 학생 테이블에서 이름과 학년만 보여주는 뷰             |
| **뷰 의존성** | 뷰가 다른 뷰 또는 객체를 참조하는 관계                         | 성적 뷰가 학생 뷰를 참조하여 학생 정보 사용                |
| **CASCADE**   | 참조 관계를 모두 고려해 의존된 객체까지 자동으로 삭제함            | 학생 뷰 삭제 시 성적 뷰도 같이 삭제되어 데이터 무결성 유지    |

---

💡 **요약**

- `DROP VIEW`는 뷰 자체만 삭제하려 할 때 참조 중이면 삭제가 실패할 수 있음  
- `CASCADE` 옵션을 붙이면 참조 중인 뷰와 객체들도 함께 삭제됨  
- 뷰 간 의존성을 고려할 때 꼭 알아야 하는 중요한 옵션임  


-----------------------------------------------------------------------------------------------------
## ✅ 문제 10

다음 테이블 구조에 주어진 데이터를 삽입하기 위한 **SQL문을 작성**하시오.

---

### 🔹 테이블 생성문
CREATE TABLE STUDENT (
    NUM INT,
    NAME VARCHAR(20),
    GRADE INT,
    MAJOR VARCHAR(30),
    TEL VARCHAR(20)
);

🔹 삽입할 데이터
num	name	grade	major	tel
123	lee	3	com	010

## 📌 해설

- `INSERT INTO` 문은 테이블에 **새로운 행(row)** 을 추가할 때 사용합니다.
- 각 열(column)의 데이터 타입에 맞게 값을 넣어야 하며, **문자열은 반드시 작은따옴표('')로 감싸야 합니다.**
- 열 이름을 명시하는 것은 코드의 **가독성**과 **유지보수성**을 높이는 좋은 습관입니다.

---

### 갓반인 예시

- 학생 테이블(STUDENT)에 학생 정보를 추가할 때  
  → 학번(num): 123, 이름(name): 'lee', 학년(grade): 3, 전공(major): 'com', 전화번호(tel): '010'  
  이렇게 각 컬럼에 맞게 값을 넣어줍니다.

```sql
INSERT INTO STUDENT (num, name, grade, major, tel) 
VALUES (123, 'lee', 3, 'com', '010');

-----------------------------------------------------------------------------------------------------

## ✅ 문제 11

다음 설명에 대한 알맞은 답을 쓰시오

---

### 🔹 설명

- **(1)**: 아직 개발되지 않았거나 테스트되지 않은 **모듈의 상위 모듈**을 시뮬레이션하는 테스트 코드이다.  
  테스트 대상인 하위 모듈에 필요한 입력을 제공하고, 그 출력을 받아들여 테스트를 가능하게 한다.

- **(2)**: 아직 개발되지 않았거나 테스트되지 않은 **모듈의 하위 모듈**을 시뮬레이션하는 테스트 코드이다.  
  주로 하위 모듈이 아직 준비되지 않았을 때 **상위 모듈을 테스트**하기 위해 사용된다.  
  상위 모듈로부터 호출을 받아 **적절한 응답을 반환**함으로써, 상위 모듈이 독립적으로 테스트 될 수 있도록 돕는다.

---

### ✅ 정답

- (1): **드라이버 (Driver)**  
- (2): **스텁 (Stub)**

---
### 📌 관련 개념 정리

| 구분           | 설명 |
|----------------|------|
| **Stub (스텁)**   | 하위 모듈이 아직 준비되지 않았을 때, 상위 모듈 테스트를 위해 사용하는 **임시 코드**<br>하위 모듈을 대신하여 호출에 대한 **응답을 가짜로 반환**함 |
| **Driver (드라이버)** | 상위 모듈이 아직 구현되지 않았을 때, 하위 모듈 테스트를 위해 사용하는 **임시 코드**<br>하위 모듈에 **입력을 전달하고 출력 결과를 검증**함 |

---

### 📌 통합 테스트 관련

- **하향식 통합 테스트**: 상위 모듈부터 테스트를 수행하며, **스텁(Stub)** 을 사용  
  - 예: 결제 시스템 상위 모듈이 먼저 있고, 아직 하위 모듈(카드 결제 등)이 개발 중일 때, 스텁으로 가짜 결제 응답을 만들어 테스트함

- **상향식 통합 테스트**: 하위 모듈부터 테스트를 수행하며, **드라이버(Driver)** 를 사용  
  - 예: 카드 결제 모듈을 먼저 개발하고, 상위 모듈이 아직 없을 때, 드라이버로 입력을 주고 결과를 확인하며 테스트함

-----------------------------------------------------------------------------------------------------
## ✅ 문제 12

다음 C 언어 코드에서 **출력 결과가 `43215`** 가 되도록 괄호 안에 알맞은 코드를 쓰시오.


### 🔹 코드

#include <stdio.h>                                  // 표준 입출력 함수 (printf 등)를 사용하기 위해 필요한 헤더 파일이다.

int main() {                                  // C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                                       // (여기서는 return 0;이 생략되어 있다.)

    int n[5] = {5, 4, 3, 2, 1};                                  // 'n'이라는 이름의 5칸짜리 정수 배열을 선언하고
                                                              // {5, 4, 3, 2, 1} 값으로 초기화한다.
                                                           // n[0]은 5, n[1]은 4, ..., n[4]는 1이 된다.

                                                             // for 반복문: 'i'는 0부터 시작해서 5보다 작을 때까지 (즉, 0, 1, 2, 3, 4) 1씩 증가한다.
                                                             // 배열 'n'의 모든 요소를 순회하는 것처럼 보인다.
    for (int i = 0; i < 5; i++) {
                                                     // printf("%d", (1)); // 💡 개중요! 여기서 문제가 발생한다.
                                                         // '%d'는 정수를 출력하라는 서식 지정자인데,
                                                         // 그 뒤에 오는 값으로 'n[i]'가 아니라 그냥 숫자 '1'이 직접 들어가 있다.
                                                         // 괄호 (1)은 단순히 정수 리터럴 '1'을 의미한다.
                                                         // 따라서 이 코드는 'n' 배열의 내용과는 전혀 상관없이,
                                                         // 반복문이 돌 때마다 무조건 숫자 '1'만 출력하게 된다.
                                                         // 출력 후 줄 바꿈이 없으므로, '1'들이 옆으로 쭉 붙어서 나온다.
            printf("%d", (1));
    }
                                                                   // for 반복문이 5번 돌고 나면 프로그램이 종료된다.
}

✅ 정답
n[(i + 1) % 5]
-----------------------------------------------------------------------------------------------------
## ✅ 문제 13

다음 Java 코드의 일부이다. 가지고 있는 돈의 합계가 4620원일 경우  
1000원, 500원, 100원, 10원의 지폐와 동전을 이용하여, 조건에 맞게 프로그램을 완성하시오.  
(**단, 최소한의 코드로 작성해야 한다**)

---

### 🔹 조건

- 변수: `m`
- 연산자: `/`, `%`
- 정수: `1000`, `500`, `100`, `10`

---

### ✅ 출력 결과

4
1
1
2


---

### ✅ 정답

```java
m = 4620;
a = m / 1000;
b = (m % 1000) / 500;
c = (m % 500) / 100;
d = (m % 100) / 10;

📌 해설
a = m / 1000 → 4620원 중 1000원이 몇 장? → 4

b = (m % 1000) / 500 → 620원 중 500원이 몇 개? → 1

c = (m % 500) / 100 → 나머지 120원 중 100원이 몇 개? → 1

d = (m % 100) / 10 → 남은 20원 중 10원이 몇 개? → 2
-----------------------------------------------------------------------------------------------------
## ✅ 문제 14

다음은 C언어 코드이다.  
입력값이 `홍길동`, `김철수`, `박영희` 순서일 때, 출력 결과를 쓰시오.

---

### ✅ 코드

#include <stdio.h>                                     // 표준 입출력 함수 (printf 등)를 사용하기 위해 이 헤더 파일을 포함해야 한다.

                                                   // char n[30];: 'n'이라는 char 타입 배열을 선언하는데, 크기가 30칸이다.
                                                   // 💡 중요! 이 배열은 '전역 변수(Global Variable)'다.
                                                   // 전역 변수는 프로그램의 모든 함수에서 접근하고 값을 바꿀 수 있으며,
                                                   // 메모리에 프로그램 시작부터 끝까지 딱 한 번만 생성되고 유지된다.
char n[30];

                                                                     // getname 함수: 사용자로부터 문자열을 입력받아 전역 배열 'n'에 저장하고, 그 'n'의 주소를 반환한다.
                                                                     // char* 는 이 함수가 'char' 타입의 포인터(문자열의 시작 주소)를 반환한다는 뜻이다.
char* getname() {
    printf("입력: ");                                                 // 사용자에게 "입력: " 메시지를 출력한다.
                                                                         // gets(n);: 사용자로부터 한 줄의 문자열을 입력받아 '전역 배열 n'에 저장한다.
                                                                         // 💡 개중요! 'gets()' 함수는 매우 위험한 함수다.
                                                                         // 입력받을 문자열의 길이를 검사하지 않기 때문에, 만약 사용자가 'n' 배열의 크기(30칸)보다
                                                                         // 더 긴 문자열을 입력하면 '버퍼 오버플로우'라는 심각한 보안 문제를 일으킬 수 있다.
                                                                         // 즉, 30글자 넘어가면 메모리 다른 영역을 침범해서 프로그램이 뻗거나 해킹당할 수 있다는 얘기다.
                                                                         // 실제 C 프로그래밍에서는 절대 'gets()' 대신 'fgets()' 같은 안전한 함수를 써야 한다!
    gets(n);
                                                                            // return n;: 'n' 배열의 시작 주소(메모리 주소)를 반환한다.
                                                                            // 💡 중요! 'n'은 전역 변수이므로, 이 함수가 몇 번 호출되든 항상 '동일한' 메모리 주소를 반환한다.
                                                                            // 그리고 그 주소 공간에 새로운 입력 값이 계속 덮어쓰여진다.
    return n;
}

                                                                                          // main 함수: C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                                                                          // int main()은 정수 값을 반환한다는 의미 (보통 0을 반환하여 정상 종료를 알린다).
int main() {
                                                                            // char* n1 = getname();: getname() 함수를 호출하여 반환된 주소를 'n1' 포인터 변수에 저장한다.
                                                                            // 1. getname() 호출 -> 사용자로부터 "홍길동" 입력 가정.
                                                                            //    전역 배열 'n'에는 "홍길동"이 저장된다.
                                                                            //    'n'의 주소가 'n1'에 저장된다. (이제 n1은 'n' 배열의 시작점을 가리킨다.)
    char* n1 = getname();

                                                                               // char* n2 = getname();: getname() 함수를 두 번째로 호출한다.
                                                                               // 2. getname() 호출 -> 사용자로부터 "김철수" 입력 가정.
                                                                               //    💡 중요! 이 시점에서 '전역 배열 n'의 내용은 "김철수"로 '덮어쓰여진다'.
                                                                               //    이전의 "홍길동"은 메모리에서 사라진다.
                                                                               //    'n'의 주소가 다시 반환되고, 이 주소가 'n2'에 저장된다.
                                                                               //    결과적으로 'n1'과 'n2'는 '같은 메모리 주소(전역 배열 n의 주소)'를 가리키게 된다.
                                                                               //    하지만 그 주소에는 이제 "김철수"가 들어있다.
    char* n2 = getname();

                                                                                           // char* n3 = getname();: getname() 함수를 세 번째로 호출한다.
                                                                                           // 3. getname() 호출 -> 사용자로부터 "박영희" 입력 가정.
                                                                                           //    💡 중요! '전역 배열 n'의 내용은 다시 "박영희"로 '덮어쓰여진다'.
                                                                                           //    이전의 "김철수"는 사라진다.
                                                                                           //    'n'의 주소가 또 다시 반환되고, 이 주소가 'n3'에 저장된다.
                                                                                           //    결과적으로 'n1', 'n2', 'n3'는 모두 '같은 메모리 주소(전역 배열 n의 주소)'를 가리키게 된다.
                                                                                           //    그리고 그 주소에는 최종적으로 "박영희"가 들어있다.
    char* n3 = getname();

                                                                                     // printf("%s\n", n1);: 'n1' 포인터가 가리키는 메모리 주소에 있는 문자열을 출력한다.
                                                                                     // n1은 전역 배열 'n'의 주소를 가리키고, 'n'에는 현재 마지막으로 입력된 "박영희"가 들어있다.
                                                                                     // 따라서 "박영희"가 출력된다. '\n'은 줄 바꿈이다.
    printf("%s\n", n1);
                                                                                     // printf("%s\n", n2);: 'n2' 포인터가 가리키는 메모리 주소에 있는 문자열을 출력한다.
                                                                                     // n2도 전역 배열 'n'의 주소를 가리키므로, 역시 "박영희"가 출력된다.
    printf("%s\n", n2);
                                                                                     // printf("%s\n", n3);: 'n3' 포인터가 가리키는 메모리 주소에 있는 문자열을 출력한다.
                                                                                     // n3도 전역 배열 'n'의 주소를 가리키므로, 당연히 "박영희"가 출력된다.
    printf("%s\n", n3);

    return 0;                                                                         // 프로그램이 정상적으로 종료되었음을 운영체제에 알린다.
}


✅ 입력
홍길동
김철수
박영희

✅ 출력 결과
박영희
박영희
박영희


-----------------------------------------------------------------------------------------------------

## ✅ 문제 15

다음 C언어 코드의 결과를 쓰시오

---

### ✅ 코드

#include <stdio.h> // printf 함수를 사용하기 위해 필요한 헤더 파일이다.

int main() {                                           // C 프로그램의 시작점이다.
    int n[3] = {73, 95, 82};                                  // 'n'이라는 3칸짜리 정수형 배열을 선언하고 73, 95, 82로 초기화한다.
    int sum = 0;                               // 'sum'이라는 정수형 변수를 0으로 초기화한다. 여기에 배열 값들을 더할 거다.

                                                             // for 반복문: 배열 'n'의 모든 요소를 순회하며 'sum'에 더한다.
                                                             // i는 0부터 2까지 (총 3번) 반복한다.
    for (int i = 0; i < 3; i++) {
        sum += n[i];                                                       // sum = sum + n[i]; 와 같다.
                                                                                 // 1. sum = 0 + 73 = 73
                                                                              // 2. sum = 73 + 95 = 168
                                                                              // 3. sum = 168 + 82 = 250
    }
    // for 문이 끝나면 sum은 250이 된다.
switch (sum / 30) {                                                 // 💡 개중요! 'sum'(250)을 30으로 나눈 정수 몫을 가지고 switch 문을 실행한다.
                                                                                    // 250 / 30 = 8 (나머지 10은 버려진다, 정수 나눗셈이기 때문)
                                                                                    // 따라서 switch (8)이 된다.

        case 10:                       // 만약 몫이 10이라면...
        case 9:                           // 만약 몫이 9라면... (여기에 해당하지 않으므로 건너뛴다)
            printf("A");                                  // 'A'를 출력한다. (하지만 지금 몫은 8이므로 여기까지 건너뛴다)
        case 8:                                 // 💡 여기부터 실행된다! 몫이 8이므로 이 'case 8'부터 코드가 실행된다.
            printf("B");                         // 'B'를 출력한다.
                                                    // 💡 중요! 'break' 문이 없으므로, 다음 case로 코드가 '이어져서(fall-through)' 실행된다.
        case 7:                                 // 몫이 8이므로 이 'case 7'도 실행된다 (fall-through).
        case 6:                                       // 몫이 8이므로 이 'case 6'도 실행된다 (fall-through).
            printf("C");                                     // 'C'를 출력한다.
                                                    // 💡 중요! 역시 'break' 문이 없으므로, 다음 default로 코드가 '이어져서' 실행된다.
        default:                                         // 위에서 break가 없었기 때문에 'default'까지도 실행된다.
            printf("D");                                        // 'D'를 출력한다.
    }
                                                                // main 함수가 int를 반환하도록 선언되었으므로, 보통 0을 반환하여 정상 종료를 알린다.
                                                                // return 0;
}


✅ 출력 결과
BCD

✅ 계산 과정
- `sum / 30`의 결과는 `250 / 30 = 8` (정수 나눗셈이므로 **소수점 이하는 버림**)
- 따라서 `switch (8)`이 되며, `case 8:`부터 실행됨
- `case 8: printf("B");` → **"B" 출력**
- `break`가 없으므로 아래로 계속 실행됨
- `case 7:`과 `case 6:`은 코드 없이 통과되고  
  `printf("C");` → **"C" 출력**
- 다시 `break`가 없으므로 `default:`도 실행되어  
  `printf("D");` → **"D" 출력**

-----------------------------------------------------------------------------------------------------
## ✅ 문제 16

다음 C언어 코드의 결과를 쓰시오

---

### ✅ 코드

#include <stdio.h>                         // printf 함수를 사용하기 위해 필요한 헤더 파일이다.

int main() {                                           // C 프로그램의 시작점이다.
    int c = 0;                                                 // 'c'라는 정수형 변수를 0으로 초기화한다.
                                                         // 이 변수는 4의 배수가 나올 때마다 1씩 증가하는 '카운터' 역할을 한다.

                                                       // for 반복문: 'i'는 1부터 시작해서 2023까지 1씩 증가하면서 모든 숫자를 순회한다.
    for (int i = 1; i <= 2023; i++) {
                                                                          // if 조건문: 현재 숫자 'i'를 4로 나눈 나머지가 0인지 확인한다.
                                                                          // (즉, 'i'가 4의 배수인지 확인한다.)
        if (i % 4 == 0)
            c++;                                                                    // 만약 'i'가 4의 배수라면, 'c' 값을 1 증가시킨다. (c = c + 1; 과 같다)
    }
                                                                   // for 문이 끝나면 'c'에는 1부터 2023까지의 숫자 중 4의 배수의 총 개수가 저장된다.

printf("%d", c);                                              // 최종적으로 'c'에 저장된 4의 배수 개수를 화면에 출력한다.
                                                               // %d는 정수를 출력하라는 서식 지정자다.
                                                               // 출력 후 줄 바꿈은 없다.
                                                       // return 0; // main 함수가 int를 반환하도록 선언되었으므로, 보통 0을 반환하여 정상 종료를 알린다.
}


✅ 최종 출력 결과
505


-----------------------------------------------------------------------------------------------------

## ✅ 문제 17) 다음 파이썬 코드의 결과를 쓰시오

a = "engineer informationprogramming"                 # 'a'에 긴 문자열 하나 넣어놨다. 이게 원본이야.

b = a[:3]                                                 # 'a'에서 맨 처음부터 3글자만 딱 자르는 거다. 결과는 "eng".
c = a[4:6]                                                         # 'a'에서 5번째 글자(인덱스 4)부터 6번째 글자(인덱스 5)까지 자르는 거야. 결과는 "in".
d = a[29:]                             # 'a'에서 30번째 글자(인덱스 29)부터 문자열 끝까지 자르는 거다. 결과는 "g".

e = b + c + d                         # 잘라낸 "eng", "in", "g" 세 개를 순서대로 합치는 거다.
                                                    # 그러면 "enging"이 되겠지?

print(e)                         # 최종 결과값 "enging"을 화면에 딱 출력해라.


✅ 정답
engneing

-----------------------------------------------------------------------------------------------------
## ✅ 문제 18) 다음 자바 코드의 결과를 쓰시오

```java
class Eraon { // 'Eraon'이라는 클래스를 정의한다.
    public static void main(String[] args){ // 자바 프로그램이 시작될 때 가장 먼저 실행되는 메인 함수다.

        String str1 = "Programming"; // 1. 'str1'은 "Programming"이라는 문자열 리터럴로 초기화된다.
                                     //    💡 중요! 문자열 리터럴은 'String Constant Pool'이라는 특별한 메모리 영역에 저장된다.
                                     //    같은 문자열이 이미 풀에 있으면 기존 객체를 재사용한다.

        String str2 = "Programming"; // 2. 'str2'도 "Programming"이라는 문자열 리터럴로 초기화된다.
                                     //    'String Constant Pool'에 "Programming"이 이미 있으므로,
                                     //    'str2'는 'str1'과 '동일한' 객체를 참조하게 된다.

        String str3 = new String("Programming"); // 3. 'str3'은 'new' 키워드를 사용해서 "Programming" 문자열 객체를 새로 생성한다.
                                                //    💡 중요! 'new'를 쓰면 '힙(Heap)' 메모리 영역에 '항상 새로운' 객체를 만든다.
                                                //    그래서 str3은 str1, str2와 내용이 같더라도 '다른' 메모리 주소의 객체를 가리킨다.
        
        System.out.println(str1 == str2); // 💡 중요! 'str1'과 'str2'가 '동일한 객체(메모리 주소)'를 참조하는지 비교한다.
                                          // str1과 str2는 String Constant Pool의 같은 "Programming"을 가리키므로 true가 나온다.
                                          // 출력: true

        System.out.println(str1 == str3); // 💡 중요! 'str1'과 'str3'이 '동일한 객체(메모리 주소)'를 참조하는지 비교한다.
                                          // str1은 풀의 객체, str3은 힙의 새로운 객체이므로 서로 다른 객체다.
                                          // 출력: false

        System.out.println(str1.equals(str3)); // 💡 중요! 'str1'과 'str3'이 '내용(문자열 값)'이 같은지 비교한다.
                                              // 'equals()' 메서드는 객체가 아니라 '문자열의 내용'을 비교한다.
                                              // str1의 내용("Programming")과 str3의 내용("Programming")이 같으므로 true가 나온다.
                                              // 출력: true

        System.out.println(str2.equals(str3)); // 💡 중요! 'str2'와 'str3'이 '내용(문자열 값)'이 같은지 비교한다.
                                              // str2의 내용("Programming")과 str3의 내용("Programming")이 같으므로 true가 나온다.
                                              // 출력: true
    }
}


✅ 정답
true  
false  
true  
true

💡 **핵심 요약**

- `==` 연산자:  
  👉 **두 변수가 같은 메모리 주소(= 동일한 객체)** 를 가리키는지 비교  
  👉 즉, **객체의 참조(레퍼런스)** 비교임

- **문자열 리터럴 방식** (`"문자열"`):  
  👉 Java의 **String Constant Pool**에서 재사용됨  
  👉 같은 리터럴은 **같은 객체**를 참조 (예: `"abc" == "abc"` → true)

- **`new String()` 방식**:  
  👉 항상 **새로운 객체**를 힙 메모리에 생성함  
  👉 즉, `"abc" != new String("abc")` (주소 다름)

- `equals()` 메서드:  
  👉 **문자열 값 자체(내용)**을 비교  
  👉 문자열 비교할 땐 항상 `==` 말고 **`equals()`**를 써야 함

---

🎯 **갓반인 예시**

```java
String a = "hello";
String b = "hello";
String c = new String("hello");

System.out.println(a == b);       // true (같은 리터럴 → 같은 객체)
System.out.println(a == c);       // false (new로 만든 객체 → 주소 다름)
System.out.println(a.equals(c));  // true (내용은 같음)


-----------------------------------------------------------------------------------------------------

## ✅ 문제 19) 다음 C언어 코드의 실행 결과를 쓰시오

```c
#include <stdio.h>                                        // printf 함수를 사용하기 위해 이 헤더 파일을 포함해야 한다.

                                                            // #define MAX_SIZE 10: 전처리기 지시문으로 'MAX_SIZE'라는 상수를 10으로 정의한다.
                                                            // 이 코드를 컴파일할 때 MAX_SIZE라는 단어는 모두 10으로 바뀐다. 스택의 최대 크기를 나타낸다.
#define MAX_SIZE 10
                                                            // int stack[MAX_SIZE];: 'stack'이라는 이름의 정수형 배열을 선언한다. 크기는 MAX_SIZE, 즉 10칸이다.
                                                            // 이 배열이 실제 스택의 데이터를 저장하는 공간이 된다.
int stack[MAX_SIZE];
                                                            // int top = -1;: 'top'이라는 정수형 변수를 -1로 초기화한다.
                                                            // 'top'은 스택에서 가장 위에 있는 요소의 '인덱스(위치)'를 가리킨다.
                                                            // -1은 스택이 '비어있는' 상태를 나타내는 약속된 값이다.
int top = -1;

                                                            // isEmpty 함수: 스택이 비어있는지 확인한다.
                                                            // 반환 타입이 int인 이유는 C에서는 true/false를 1/0으로 표현하기 때문이다.
int isEmpty(){
                                                                // top이 -1이면 (스택이 비어있으면) 1을 반환한다.
    if(top == -1) return 1;
                                                             // top이 -1이 아니면 (스택이 비어있지 않으면) 0을 반환한다.
    return 0;
}

                                                                                 // isFull 함수: 스택이 가득 찼는지 확인한다.
int isFull(){
                                                          // 💡 중요! 이 부분은 논리적으로 약간의 오류가 있다.
                                                          // MAX_SIZE가 10이면 배열 인덱스는 0부터 9까지다. 따라서 스택이 꽉 차면 'top'은 9가 되어야 한다.
                                                          // 'top == 10'은 배열의 범위를 벗어난 인덱스를 나타내므로, 이 조건은 실제로는 '항상 거짓'이다.
                                                          // 즉, 이 코드 내에서 'printf("Full")'은 절대로 실행되지 않는다.
                                                          // 올바른 'isFull' 조건은 'top == MAX_SIZE - 1' (즉, top == 9)이어야 한다.
    if(top == 10) return 1;
    return 0;
}

                                                                     // push 함수: 스택에 새로운 요소를 추가한다.
                                                                     // void는 반환 값이 없다는 의미다.
void push(int num){
                                                          // 스택이 가득 찼는지 먼저 확인한다. (현재 isFull 함수 구현상 이 조건은 항상 false다.)
    if (isFull())
        printf("Full");                                     // 만약 가득 찼으면 "Full"을 출력 (이 코드에서는 출력될 일이 없다.)
                                                                   // 💡 핵심! '++top'은 'top'을 먼저 1 증가시킨 후에 그 값을 사용한다.
                                                                   // 예를 들어, top이 -1이었다면 0으로 증가하고 stack[0]에 'num'이 저장된다.
                                                                   // 스택의 '맨 위'에 요소를 넣고 top을 그 위치로 옮기는 과정이다.
    stack[++top] = num;
}

                                                                           // pop 함수: 스택의 가장 위에 있는 요소를 제거하고 그 값을 반환한다.
                                                                           // 반환 타입이 int이므로 제거한 요소를 정수 값으로 돌려준다.
int pop(){
                                                                         // 스택이 비어있는지 먼저 확인한다.
    if (isEmpty())
        printf("Empty");                                              // 만약 비어있으면 "Empty"를 출력한다. (이 경우, 유효하지 않은 값을 반환할 수 있으니 주의해야 한다.)
                                                                         // 💡 핵심! 'top--'는 현재 'top'이 가리키는 위치의 '값'을 먼저 반환한 후에 'top'을 1 감소시킨다.
                                                                         // 예를 들어, top이 1이었다면 stack[1]의 값을 반환하고 top은 0으로 감소한다.
                                                                         // 스택의 '맨 위' 요소를 꺼내고 top을 한 칸 아래로 옮기는 과정이다.
    return stack[top--];
}

                                                            // main 함수: C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                                            // int args, char const * argv[]는 프로그램 실행 시 전달되는 인자를 받기 위한 것이지만, 이 코드에서는 사용되지 않는다.
int main(int args, char const * argv[]){
                                                                // 아래부터 스택 연산들이 순서대로 실행된다. 각 단계별로 top과 스택의 상태를 추적해보자.
                                                                // 시작: top = -1, stack = []

    push(5);                                                             // 1. push(5) 실행: top이 0으로 증가하고 stack[0]에 5가 저장된다.
                                                                               //    상태: top = 0, stack = [5]

    push(2);                                                             // 2. push(2) 실행: top이 1로 증가하고 stack[1]에 2가 저장된다.
                                                                      //    상태: top = 1, stack = [5, 2]

                                                                      // while(!isEmpty()): 스택이 비어있지 않은 동안 계속 반복한다.
                                                                      // 현재 top은 1이므로 isEmpty()는 0(거짓)이다. !isEmpty()는 true(참)이므로 루프 진입.
    while(!isEmpty()){
                                                                             // printf("%d", pop());: pop() 함수를 호출하여 반환된 값을 출력한다.
                                                                             // 3. pop() 실행: stack[1]의 값(2)을 반환하고 top이 0으로 감소한다.
                                                                             //    출력: 2
                                                                             //    상태: top = 0, stack = [5]
        printf("%d", pop());

        push(4);                                                             // 4. push(4) 실행: top이 1로 증가하고 stack[1]에 4가 저장된다.
                                                                       //    상태: top = 1, stack = [5, 4]

        push(1);                                                             // 5. push(1) 실행: top이 2로 증가하고 stack[2]에 1이 저장된다.
                                                                          //    상태: top = 2, stack = [5, 4, 1]

        printf("%d", pop());                                           // 6. pop() 실행: stack[2]의 값(1)을 반환하고 top이 1로 감소한다.
                                                                             //    출력: 1
                                                                             //    상태: top = 1, stack = [5, 4]

        push(3);                                                    // 7. push(3) 실행: top이 2로 증가하고 stack[2]에 3이 저장된다.
                                                                 //    상태: top = 2, stack = [5, 4, 3]

        printf("%d", pop());                                     // 8. pop() 실행: stack[2]의 값(3)을 반환하고 top이 1로 감소한다.
                                                                                //    출력: 3
                                                                                //    상태: top = 1, stack = [5, 4]

        printf("%d", pop());                                           // 9. pop() 실행: stack[1]의 값(4)을 반환하고 top이 0으로 감소한다.
                                                                                   //    출력: 4
                                                                                   //    상태: top = 0, stack = [5]

        push(6);                                                                // 10. push(6) 실행: top이 1로 증가하고 stack[1]에 6이 저장된다.
                                                                                      //     상태: top = 1, stack = [5, 6]

        printf("%d", pop());                                              // 11. pop() 실행: stack[1]의 값(6)을 반환하고 top이 0으로 감소한다.
                                                                                               //     출력: 6
                                                                                               //     상태: top = 0, stack = [5]

        printf("%d", pop());                                  // 12. pop() 실행: stack[0]의 값(5)을 반환하고 top이 -1로 감소한다.
                                                                                   //     출력: 5
                                                                                   //     상태: top = -1, stack = []
    }                                                             // while 루프 종료: top이 -1이므로 isEmpty()는 true, !isEmpty()는 false. 루프 조건이 만족되지 않아 종료.

    return 0;                                                             // main 함수가 정상적으로 실행되었음을 알린다. (운영체제에 0을 반환)
}

✅ 정답
213465


-----------------------------------------------------------------------------------------------------
## ✅ 문제 20) 다음 C언어 코드이다.  
`11 12 22 25 64`로 출력되도록 괄호 안에 알맞은 코드를 쓰시오.

---

### 🔹 코드

#include <stdio.h> // 표준 입출력 함수 (printf 등)를 사용하기 위해 필요한 헤더 파일이다.

int main() {                         // C 프로그램의 시작점이다.
    int E[] = {64, 25, 12, 22, 11};                   // 'E'라는 정수형 배열을 선언하고 초기값을 할당한다.
                                                      // 배열의 크기는 초기화 값의 개수에 따라 자동으로 5가 된다.
    int n = sizeof(E) / sizeof(E[0]);                // 'n'은 배열 'E'의 길이를 계산한다.
                                                   // sizeof(E)는 배열 전체의 바이트 크기 (5 * 4 = 20바이트)
                                                   // sizeof(E[0])는 배열 요소 하나의 바이트 크기 (int는 4바이트)
                                                   // 따라서 20 / 4 = 5가 되어, 'n'은 배열의 요소 개수(5)가 된다.
    int i = 0;                                        // 바깥쪽 루프의 제어 변수 'i'를 0으로 초기화한다.
                        // 바깥쪽 do-while 루프: 배열의 첫 번째 요소부터 'n-2'번째 요소까지 (정렬 기준 위치) 순회한다.
                            // 'n-1'까지 도는 이유는 마지막 요소는 더 이상 비교할 대상이 없기 때문이다.
    do {
        int j = i + 1;                         // 안쪽 루프의 제어 변수 'j'를 'i + 1'로 초기화한다.
                                                  // 'j'는 'i' 다음 위치부터 배열의 끝까지 순회하며 'E[i]'와 비교할 대상을 가리킨다.
                                                   
                                                           // 안쪽 do-while 루프: 'j'가 배열의 끝(n)에 도달하기 전까지 반복한다.
                                                           // E[i]와 E[j]를 비교하여 정렬한다.
        do {
            if (E[i] > E[j]) {                      // 💡 중요! 현재 'E[i]' 값이 'E[j]' 값보다 크다면 (오름차순이 아니면)
                                                                // 즉, E[i]가 E[j]보다 크면, 두 값의 위치를 서로 바꾼다.
                int tmp = E[i];                         // 'E[i]' 값을 임시 변수 'tmp'에 저장한다.
                E[i] = E[j];                               // 'E[j]' 값을 'E[i]' 위치로 옮긴다.
                E[j] = tmp;                                // 'tmp'에 저장했던 원래 'E[i]' 값을 'E[j]' 위치로 옮긴다.
                                                                    // 이렇게 하면 더 작은 값이 E[i] 위치로 오게 된다.
            }
            j++;                                        // 안쪽 루프의 'j' 값을 1 증가시킨다. (다음 요소와 비교하기 위해)
        } while (j < n);                                  // 'j'가 배열의 끝(n)에 도달하기 전까지 반복한다.
                                                                // 즉, E[i]를 E[i+1]부터 E[n-1]까지 모두 비교한다.

        i++;                                  // 바깥쪽 루프의 'i' 값을 1 증가시킨다. (다음 기준 위치로 이동하기 위해)
    } while (i < n - 1);                            // 'i'가 'n - 1'에 도달하기 전까지 반복한다.
                                                 // (예: n=5이면 i는 0, 1, 2, 3까지 돈다. i=4일 때는 루프를 돈다.)
                                                 // 즉, 배열의 마지막 요소 바로 앞까지 모든 기준 위치에 대해 비교를 수행한다.
                                                // for 반복문: 정렬이 완료된 'E' 배열의 모든 요소를 순서대로 출력한다.
                                                    // 'i'는 0부터 'n-1'까지 (총 n번) 반복한다.
    for (int i = 0; i < n; i++)                            // 💡 중요! 'i < n'까지 돌아서 배열의 모든 요소를 출력한다.
        printf("%d ", E[i]);                          // 'E[i]'에 저장된 정수 값을 출력하고, 뒤에 공백을 하나 붙인다.

                                                    // return 0; // main 함수가 int를 반환하도록 선언되었으므로, 보통 0을 반환하여 정상 종료를 알린다.
}

✅ 정답
괄호 안 코드: E[i] > E[j]

📌 요점 정리
이 코드는 즉시 교환 방식으로 정렬한다.

do-while 반복문을 통해 선택 정렬과 유사한 오름차순 정렬을 수행한다.

최종적으로 작은 값부터 큰 값 순으로 배열이 정렬되어 출력된다.
-----------------------------------------------------------------------------------------------------



