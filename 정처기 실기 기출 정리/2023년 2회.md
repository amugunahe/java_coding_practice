문제 1) 아래에서 설명하는 테스트 커버리지는 무엇인지 쓰시오.

## ✅ 문제

소프트웨어 테스트의 효율성을 평가하는 지표 중 하나로,  
주로 소프트웨어의 각 **조건식이 모두 참과 거짓인 경우 최소 한 번씩 평가되었는지**  
측정하는 데 사용된다.  
조건문 내의 각각의 **논리 조건이 True와 False로 평가될 때** 해당 코드의 행동을 테스트한다.

---

### ✅ 정답  
**조건 커버리지 (Condition Coverage)**

---

### 📌 해설: 코드 커버리지(Code Coverage) 종류

| 커버리지 종류             | 설명 |
|---------------------------|------|
| **구문 커버리지**         | 각 구문(statement)이 한 번 이상 수행되었는지 확인 |
| **조건 커버리지**         | 조건식의 각 **개별 조건**이 True/False로 **한 번 이상 평가**되었는지 측정 |
| **결정 커버리지**         | 조건식 전체 결과가 True/False로 평가되었는지 확인 (if, while 등 분기점 중심) |
| **조건/결정 커버리지**    | 조건 커버리지 + 결정 커버리지를 모두 만족해야 함 |
| **변경 조건/결정 커버리지**| 개별 조건이 결과에 독립적으로 영향을 미치는지를 확인 |
| **다중 조건 커버리지**     | 모든 가능한 조건 조합을 테스트하여 100% 커버리지를 달성 |

---

### ✅ 예시: 조건 커버리지

if (A > 10 && B < 5) {
   // ...
}

조건 커버리지를 만족하려면:

A > 10이 True, False 각각 한 번 이상 평가

B < 5도 True, False 각각 한 번 이상 평가되어야 함

단, 전체 if문이 실행되었는지만 확인하는 결정 커버리지와는 구별됨.
-----------------------------------------------------------------------------------------------------

## ✅ 문제 2

다음 내용에서 설명하는 용어를 쓰시오.

> 소프트웨어가 불법으로 변경되었을 경우,  
> 소프트웨어가 정상 수행되지 않게 하는 기법이다.  
> 특정 기기 데이터 또는 소프트웨어가 무단 변경, 파괴 또는 조작으로부터 보호되도록  
> 설계하는 과정이다.  
> 무단 접근을 시도하는 행위를 탐지하고 방지하는 데 목적이 있다.

---

### ✅ 정답  
**템퍼프루핑 (Tamper Proofing)**

---

### 📌 해설

**템퍼프루핑 (Tamper Proofing)** 은 소프트웨어나 콘텐츠가 **불법적인 변경(위변조)** 될 경우  
이를 감지하고, **정상 동작을 방해하거나 중단시키는 보안 기술**입니다.

- **Tamper**: 변조하다, 조작하다  
- **Proofing**: 방지, 저항

템퍼프루핑은 소프트웨어 무결성을 유지하고,  
해커가 시스템을 우회하거나 변조하는 것을 막기 위해 사용됩니다.

---

## 🔒 저작권 보호 관련 기술 정리

| 분류             | 설명 |
|------------------|------|
| **암호화 기술**   | 콘텐츠를 암호화하여 **특정 키를 가진 사용자만 사용 가능**하게 함 |
| **템퍼프루핑**   | 콘텐츠가 **무단 변경되면 오작동 유도 또는 사용 불가** 처리 |
| **워터마킹**     | 콘텐츠에 **저작권 정보 삽입** (불법복제 추적 가능) |
| **핑거프린팅**   | 콘텐츠 유통 경로 추적을 위해 **사용자 정보 삽입** |
| **DRM** (디지털 권리 관리) | 디지털 콘텐츠를 **승인된 사용자만 사용 가능**하게 제한하는 통합 보호 기술 |

---

### ✅ DRM (Digital Rights Management) 구성 요소

- **콘텐츠 제공자**: 콘텐츠 생성자
- **콘텐츠 분배자**: 콘텐츠 유통자
- **패키저 (Packager)**: 콘텐츠 + 메타데이터 + DRM 정책을 묶는 역할
- **보안 컨테이너**: 콘텐츠 암호화 및 보호
- **DRM 컨트롤러**: 사용 권한 제어
- **클리어링 하우스**: 라이선스 발급 및 정산 처리

---


-----------------------------------------------------------------------------------------------------
## ✅ 문제 3

다음은 데이터베이스 설계의 순서에 관한 문제이다.  
아래의 데이터베이스 설계 순서를 올바르게 나열하시오.

---

### ✅ 정답  
**요구조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현**

---

### 📌 해설

데이터베이스 설계 과정은 **사용자 요구사항을 분석하고**, 이를 **현실적인 데이터베이스로 구현**하기 위한 일련의 단계입니다.

| 단계 | 설명 |
|------|------|
| **1. 요구조건 분석** | 사용자의 요구를 파악하여 어떤 데이터를 저장하고 관리할지 결정 |
| **2. 개념적 설계** | 개념적 데이터 모델링 수행 (예: ER 모델 작성) |
| **3. 논리적 설계** | 특정 DBMS에 맞는 논리적 모델로 변환 (예: 정규화, 관계 스키마 설계) |
| **4. 물리적 설계** | 저장 구조, 인덱스, 접근 경로 등의 실제 저장 방식을 설계 |
| **5. 구현** | 설계된 내용을 기반으로 DBMS 상에 실제로 데이터베이스를 구축 |

---

### 📌 핵심 요약

- **요구조건 분석**: "무엇이 필요한가?"
- **개념적 설계**: "무엇을 어떻게 표현할 것인가?" → ER 모델
- **논리적 설계**: "DBMS에서 어떻게 구현할 것인가?" → 테이블, 제약조건 등
- **물리적 설계**: "효율적으로 저장하려면 어떻게 할까?" → 인덱스, 파티셔닝 등
- **구현**: DB 생성 및 애플리케이션 연동

---

-----------------------------------------------------------------------------------------------------

## ✅ 문제 4

다음에서 설명하는 디자인 패턴을 보기에서 찾아 쓰시오.

---

### 🔹 (1)

> 특정 클래스의 인스턴스가 하나만 생성되도록 보장하고,  
> 그 인스턴스에 어디에서든 접근할 수 있도록 하는 패턴이다.

✅ **정답: 싱글톤 (Singleton)**

---

### 🔹 (2)

> 객체 구조 내의 요소에 대해 수행할 작업을 캡슐화하는 디자인 패턴이다.  
> 객체 구조의 클래스를 수정하지 않고도 새로운 연산을 추가할 수 있게 해준다.

✅ **정답: 비지터 (Visitor)**

---

## 📌 해설

| 패턴명 | 설명 |
|--------|------|
| **싱글톤 (Singleton)** | - 클래스의 인스턴스를 하나만 생성하고 공유할 수 있도록 제한하는 생성 패턴<br>- 전역 접근 지점을 제공함<br>- 예: 설정 객체, 데이터베이스 연결 객체 |
| **비지터 (Visitor)** | - 객체 구조는 변경하지 않고 새로운 기능을 추가하고 싶을 때 사용<br>- 알고리즘을 객체 구조에서 분리하여 정의함<br>- 예: 컴파일러의 문법 트리 분석 |

---

## 📚 디자인 패턴 분류 예시

| 생성 패턴 | 구조 패턴 | 행위 패턴 |
|------------|------------|--------------|
| Singleton | Adapter | Visitor |
| Factory Method | Composite | Observer |
| Builder | Decorator | Strategy |
| Abstract Factory | Proxy | Template Method |

---


-----------------------------------------------------------------------------------------------------
## ✅ 문제 5

다음에서 설명하는 답을 보기에서 골라 작성하시오.

---

### 🔹 보기

- **HAMMING**  
- **FEC (Forward Error Correction)**  
- **BEC (Backward Error Correction)**  
- **PARITY**  
- **CRC (Cyclic Redundancy Check)**

---

### 🔸 문제 설명 및 정답

| 번호 | 설명 | 정답 |
|------|------|------|
| (1) | 송수신 과정에서의 단일 비트 오류를 검출하고 정정할 수 있게 한다. | **HAMMING** |
| (2) | 데이터를 전송하기 전에 오류 정정 코드를 추가하고 수신측에서 발생 가능한 오류를 검출하고 정정할 수 있도록 하는 기술이다. | **FEC** |
| (3) | 오류가 감지된 후 데이터를 복구하기 위해 데이터 송신자에게 재전송을 요청하는 오류 수정 방식이다. | **BEC** |
| (4) | 데이터 무결성을 확인하기 위해 사용되는 간단한 오류 검출 방식이다. | **PARITY** |
| (5) | 데이터 전송의 정확성을 보장하기 위해 사용되는 오류 검출 기법이다. 데이터 블록 전체에 대해 특정 다항식을 사용하여 검사값(체크섬)을 계산하고, 이 값을 데이터에 추가한다. | **CRC** |

---

## 📌 전송 오류 제어 방식 정리

### ✅ 전진 오류 수정 (FEC: Forward Error Correction)

- 수신 측에서 **재전송 요구 없이** 스스로 오류를 검출하고 수정
- **해밍 코드**, 상승 코드 등이 해당
- 실시간 통신(예: 위성, 방송)에 사용

### ✅ 후진 오류 수정 (BEC: Backward Error Correction)

- 오류가 발생하면 **송신 측에 재전송을 요청**함
- **패리티 검사**, **CRC**, 블록합 방식 등

---

### ✅ 각 오류 제어 기법 요약

| 기법 | 특징 |
|------|------|
| **Hamming** | 단일 비트 오류 검출 및 정정 가능 |
| **FEC** | 수신 측에서 오류를 정정 (재전송 없음) |
| **BEC** | 수신 측에서 오류를 감지 후 송신 측에 재전송 요청 |
| **Parity** | 가장 간단한 오류 검출 기법, 1비트의 패리티 비트를 추가 |
| **CRC** | 다항식을 이용한 고급 오류 검출 방식, 체크섬 사용 |

---


-----------------------------------------------------------------------------------------------------

## ✅ 문제 6

다음에서 설명하는 답을 보기에서 골라 작성하시오.

---

### 🔹 보기

- 정보 프레임  
- 감독 프레임  
- 비번호/비순서 프레임  
- 비동기 균형 모드  
- 비동기 응답 모드

---

### 🔸 문제 설명 및 정답

| 번호 | 설명 | 정답 |
|------|------|------|
| (1) | HDLC 프레임 중 **데이터 전송**을 위한 프레임. 사용자 데이터를 포함하며, 데이터 링크 계층에서 종단 간 데이터 전송을 담당 | **정보 프레임 (Information Frame, I-Frame)** |
| (2) | HDLC 프레임 중 **오류 검출, 흐름 제어**를 위해 사용. 데이터를 포함하지 않으며 수신 상태 관리 목적 | **감독 프레임 (Supervisory Frame, S-Frame)** |
| (3) | **추가적인 제어 목적이나 특별 상황**에 사용. 설정, 해제, 오류 보고 등 제어 명령 | **비번호/비순서 프레임 (Unnumbered Frame, U-Frame)** |
| (4) | HDLC 전송 모드 중 **모든 단말이 주국 기능 수행** 가능, 유연한 양방향 통신 제공 | **비동기 균형 모드 (Asynchronous Balanced Mode, ABM)** |
| (5) | HDLC 전송 모드 중, **주국이 통신을 제어**하지만, 종국도 데이터 전송을 시작할 수 있는 모드 | **비동기 응답 모드 (Asynchronous Response Mode, ARM)** |

---

## 📌 HDLC(HIGH LEVEL DATA LINK CONTROL) 요약 정리

### ✅ HDLC 프레임 구성

- **Flag**: 프레임 시작/끝 표시 (`01111110`)
- **Address**: 수신자 주소
- **Control**: 프레임 종류 식별 (정보/감독/비순서)
- **Data**: 전송할 사용자 데이터
- **FCS (Frame Check Sequence)**: 오류 검출용 CRC

---

### ✅ HDLC 프레임 유형

| 프레임 종류 | 설명 |
|-------------|------|
| **정보 프레임 (I-Frame)** | 실제 사용자 데이터를 전송 |
| **감독 프레임 (S-Frame)** | 흐름 제어 및 오류 제어 담당, 수신 상태 통보 |
| **비순서 프레임 (U-Frame)** | 링크 설정/해제, 명령 제어, 오류 보고 등 제어 목적 |

---

### ✅ HDLC 전송 모드

| 모드 | 설명 |
|------|------|
| **정규 응답 모드 (NRM)** | 주국이 통신을 제어, 종국은 응답만 |
| **비동기 응답 모드 (ARM)** | 주국이 제어하되 종국도 송신 시작 가능 |
| **비동기 균형 모드 (ABM)** | 모든 단말이 대등하게 주국 기능 수행 가능, **가장 유연**한 모드 |

---


-----------------------------------------------------------------------------------------------------
## ✅ 문제 7

다음 보기에서 **대칭키**와 **비대칭키**에 해당하는 내용을 알맞게 쓰시오.

---

### 🔹 보기  
`RSA`, `DES`, `AES`, `ECC`, `ARIA`, `SEED`

---

### ✅ 정답

- **대칭키(Symmetric Key)**  
  👉 `DES`, `AES`, `ARIA`, `SEED`

- **비대칭키(Asymmetric Key)**  
  👉 `RSA`, `ECC`

---

## 📌 해설

### 🔸 대칭키 암호화(Symmetric Key Encryption)

- 암호화와 복호화에 **같은 키**를 사용하는 방식
- 빠르고 연산 효율이 높지만, **키 분배 문제**가 발생
- **블록 암호 / 스트림 암호**로 구분

#### ✔️ 블록 암호 알고리즘
| 알고리즘 | 설명 |
|----------|------|
| **DES** | 64비트 블록, 56비트 키, 페이스텔 구조, 현재는 보안 취약 |
| **3-DES** | DES를 3번 반복, 보안은 강화되었으나 느림 |
| **AES** | 미국 표준, 128/192/256비트 키, Rijndael 알고리즘 |
| **SEED** | 대한민국 표준 블록 암호 |
| **ARIA** | 한국에서 개발한 128비트 블록 암호 |
| **LEA** | 국산 경량 블록 암호 알고리즘 |

#### ✔️ 스트림 암호 알고리즘
| 알고리즘 | 설명 |
|----------|------|
| **LFSR** | 선형 피드백 시프트 레지스터 |
| **RC4** | 인터넷 보안 프로토콜에서 사용되었으나, 현재는 취약 |
| **A5** | GSM 통신에 사용 |

---

### 🔸 비대칭키 암호화(Asymmetric Key Encryption)

- 암호화와 복호화에 **서로 다른 키**(공개키, 개인키)를 사용하는 방식
- **속도는 느리지만**, 키 관리가 쉬움
- 전자서명 및 보안 통신에 필수

| 알고리즘 | 설명 |
|----------|------|
| **RSA** | 소인수분해 기반, 가장 널리 사용되는 공개키 알고리즘 |
| **ECC** | 타원곡선 기반, RSA보다 짧은 키로도 높은 보안성 제공 |
| **ElGamal** | 이산대수 기반, 디지털 서명에 사용 |
| **DSA** | 미국의 디지털 서명 알고리즘 |
| **Diffie-Hellman** | 키 교환 알고리즘 |

---

### 🔸 단방향 암호화 (해시 함수)

- 복호화가 불가능한 **일방향 함수**
- 주로 **무결성 검증**, **전자서명** 등에 사용

| 알고리즘 | 설명 |
|----------|------|
| **MD5** | 빠른 계산 속도, 현재는 취약점 존재 |
| **SHA-1/2/3** | NIST 개발, 다양한 길이의 해시 생성 가능 |
| **HAS-160** | KCDSA에서 사용되는 국산 해시 알고리즘 |

---

-----------------------------------------------------------------------------------------------------

## ✅ 문제 8

다음 괄호에 알맞은 내용을 쓰시오.

---

### 🔹 문제 설명

보안에서 사용되는 **( )**는 데이터의 무결성과 인증을 보장하는데 중요한 역할을 하는 기술이다.  
**( )**는 임의 길이의 데이터를 입력받아 고정된 크기의 값을 출력한다.  
이 값들은 입력 데이터의 고유한 지문과 같은 역할을 하며,  
원본 데이터에 아주 작은 변화가 생기더라도 출력되는 값은 완전히 달라진다.  
이 특성을 통해 데이터의 무결성을 확인할 수 있다.

---

### ✅ 정답  
**해시 (Hash)**

---

## 📌 해설

### 🔸 해시 함수(Hash Function)

- 임의의 길이를 가진 입력 데이터를 **고정된 길이의 해시값**으로 변환하는 함수  
- 입력값이 조금만 달라도 **전혀 다른 해시값**이 생성됨 (민감도 ↑)
- 암호학적으로 안전한 해시 함수는 다음의 특성을 가져야 함:

| 특성 | 설명 |
|------|------|
| **압축성(Compression)** | 임의의 길이 입력 → 고정된 길이 출력 |
| **효율성(Efficiency)** | 계산이 빠름 |
| **충돌 회피(Collision Resistance)** | 서로 다른 입력이 같은 해시값을 갖기 어려움 |
| **은닉성(Hiding)** | 해시값만으로는 원래 입력값을 알 수 없음 |
| **1방향성(One-way)** | 해시값으로 입력값을 역산할 수 없음 |

---

## ✅ 대표적인 해시 알고리즘

| 알고리즘 | 설명 |
|----------|------|
| **MD5** | 128비트 해시, 속도는 빠르나 충돌 발생 가능성 존재 |
| **SHA-1** | 160비트 해시, 보안 취약점 발견됨 |
| **SHA-2 (SHA-256/512)** | 현재 널리 사용되는 안전한 해시 알고리즘 |
| **SHA-3** | SHA 시리즈의 최신 알고리즘 |
| **HAS-160** | 한국에서 개발된 해시 함수, KCDSA에서 사용됨 |

---

## ✅ 해시 사용 예시

- 데이터 무결성 검증 (파일 체크섬 등)
- 전자서명 (디지털 서명)
- 비밀번호 저장 (해시 후 저장)
- 블록체인 (블록의 고유 식별자 생성)


-----------------------------------------------------------------------------------------------------
## ✅ 문제 9

다음 SQL 명령어에서, **학생 뷰(View)** 를 참조하는 **다른 모든 뷰(view)** 들까지 함께 삭제할 수 있도록 괄호에 들어갈 알맞은 SQL 키워드를 쓰시오.

---

### 🔹 문제

`DROP VIEW 학생 (    )`

---

### ✅ 정답  
**CASCADE**

---

## 📌 해설

SQL에서 **`DROP VIEW`** 명령은 데이터베이스에 정의된 뷰(View)를 삭제하는 데 사용됩니다.  
하지만 해당 뷰가 **다른 뷰 또는 객체에 의해 참조**되고 있을 경우, 단순한 `DROP VIEW` 명령으로는 삭제되지 않습니다.

이때 사용하는 것이 바로 `**CASCADE**` 옵션입니다.

---

### ✅ DROP VIEW 구문

```sql
DROP VIEW 뷰이름 CASCADE;
CASCADE:
뷰를 참조하고 있는 모든 다른 뷰(또는 객체) 까지 함께 삭제함

RESTRICT (기본값):
뷰가 다른 객체에 참조되고 있다면 삭제를 거부

✅ 예시
-- 학생 뷰 삭제, 이 뷰를 참조하는 모든 다른 뷰들도 함께 삭제
DROP VIEW 학생 CASCADE;

✅ 관련 개념
VIEW: 하나 이상의 테이블(또는 다른 뷰)을 기반으로 정의된 가상 테이블

뷰 의존성: 뷰가 또 다른 뷰를 참조하거나, 다른 뷰가 해당 뷰를 참조할 수 있음

DROP VIEW CASCADE: 이러한 의존성 관계를 고려해 모두 제거
-----------------------------------------------------------------------------------------------------
## ✅ 문제 10

다음 테이블 구조에 주어진 데이터를 삽입하기 위한 **SQL문을 작성**하시오.

---

### 🔹 테이블 생성문
CREATE TABLE STUDENT (
    NUM INT,
    NAME VARCHAR(20),
    GRADE INT,
    MAJOR VARCHAR(30),
    TEL VARCHAR(20)
);

🔹 삽입할 데이터
num	name	grade	major	tel
123	lee	3	com	010

✅ 정답

INSERT INTO STUDENT (num, name, grade, major, tel) 
VALUES (123, 'lee', 3, 'com', '010');

📌 해설
INSERT INTO 문은 테이블에 새로운 행(row)을 추가할 때 사용합니다.

각 열(column)의 데이터 타입에 맞춰 '문자열'은 반드시 작은따옴표로 묶어줘야 합니다.

열 이름을 명시하는 것이 가독성 및 유지보수에 유리합니
-----------------------------------------------------------------------------------------------------

## ✅ 문제 11

다음 설명에 대한 알맞은 답을 쓰시오

---

### 🔹 설명

- **(1)**: 아직 개발되지 않았거나 테스트되지 않은 **모듈의 상위 모듈**을 시뮬레이션하는 테스트 코드이다.  
  테스트 대상인 하위 모듈에 필요한 입력을 제공하고, 그 출력을 받아들여 테스트를 가능하게 한다.

- **(2)**: 아직 개발되지 않았거나 테스트되지 않은 **모듈의 하위 모듈**을 시뮬레이션하는 테스트 코드이다.  
  주로 하위 모듈이 아직 준비되지 않았을 때 **상위 모듈을 테스트**하기 위해 사용된다.  
  상위 모듈로부터 호출을 받아 **적절한 응답을 반환**함으로써, 상위 모듈이 독립적으로 테스트 될 수 있도록 돕는다.

---

### ✅ 정답

- (1): **드라이버 (Driver)**  
- (2): **스텁 (Stub)**

---

### 📌 관련 개념 정리

| 구분     | 설명 |
|----------|------|
| **Stub (스텁)**   | 하위 모듈이 아직 준비되지 않았을 때, 상위 모듈 테스트를 위해 사용하는 **임시 코드**<br>하위 모듈을 대신하여 호출에 대한 **응답을 가짜로 반환**함 |
| **Driver (드라이버)** | 상위 모듈이 아직 구현되지 않았을 때, 하위 모듈 테스트를 위해 사용하는 **임시 코드**<br>하위 모듈에 **입력을 전달하고 출력 결과를 검증**함 |

---

### 📌 통합 테스트 관련

- **하향식 통합 테스트**: 상위 모듈부터 테스트를 수행하며, **스텁(Stub)** 을 사용  
- **상향식 통합 테스트**: 하위 모듈부터 테스트를 수행하며, **드라이버(Driver)** 를 사용

-----------------------------------------------------------------------------------------------------
## ✅ 문제 12

다음 C 언어 코드에서 **출력 결과가 `43215`** 가 되도록 괄호 안에 알맞은 코드를 쓰시오.


### 🔹 코드

```c
#include <stdio.h>

int main() {
    int n[5] = {5, 4, 3, 2, 1};
    for (int i = 0; i < 5; i++) {
        printf("%d", (1));
    }
}

✅ 정답
n[(i + 1) % 5]
-----------------------------------------------------------------------------------------------------
## ✅ 문제 13

다음 Java 코드의 일부이다. 가지고 있는 돈의 합계가 4620원일 경우  
1000원, 500원, 100원, 10원의 지폐와 동전을 이용하여, 조건에 맞게 프로그램을 완성하시오.  
(**단, 최소한의 코드로 작성해야 한다**)

---

### 🔹 조건

- 변수: `m`
- 연산자: `/`, `%`
- 정수: `1000`, `500`, `100`, `10`

---

### ✅ 출력 결과

4
1
1
2


---

### ✅ 정답

```java
m = 4620;
a = m / 1000;
b = (m % 1000) / 500;
c = (m % 500) / 100;
d = (m % 100) / 10;

📌 해설
a = m / 1000 → 4620원 중 1000원이 몇 장? → 4

b = (m % 1000) / 500 → 620원 중 500원이 몇 개? → 1

c = (m % 500) / 100 → 나머지 120원 중 100원이 몇 개? → 1

d = (m % 100) / 10 → 남은 20원 중 10원이 몇 개? → 2
-----------------------------------------------------------------------------------------------------
## ✅ 문제 14

다음은 C언어 코드이다.  
입력값이 `홍길동`, `김철수`, `박영희` 순서일 때, 출력 결과를 쓰시오.

---

### ✅ 코드

```c
char n[30];

char* getname() {
    printf("입력: ");
    gets(n);       // 동일한 전역 배열 n에 입력을 저장
    return n;      // n의 주소를 리턴
}

int main() {
    char* n1 = getname();  // 첫 번째 입력 (홍길동)
    char* n2 = getname();  // 두 번째 입력 (김철수) → n이 덮어씀
    char* n3 = getname();  // 세 번째 입력 (박영희) → n이 다시 덮어씀

    printf("%s\n", n1);
    printf("%s\n", n2);
    printf("%s\n", n3);

    return 0;
}

✅ 입력
홍길동
김철수
박영희

✅ 출력 결과
박영희
박영희
박영희

📌 해설
char n[30]; → 전역 변수로 선언된 배열로, 하나뿐이다.

gets(n); → 매번 같은 배열 n에 새로운 문자열이 입력됨.

따라서 n1, n2, n3는 모두 같은 주소 n을 가리킨다.

결국 마지막 입력인 "박영희"가 덮어쓰여져, 모든 포인터가 동일한 값을 출력하게 된다.
-----------------------------------------------------------------------------------------------------

## ✅ 문제 15

다음 C언어 코드의 결과를 쓰시오

---

### ✅ 코드

```c
int n[3] = {73, 95, 82};
int sum = 0;
for (int i = 0; i < 3; i++) {
    sum += n[i];
}
switch (sum / 30) {
    case 10:
    case 9: printf("A");
    case 8: printf("B");
    case 7:
    case 6: printf("C");
    default: printf("D");
}

✅ 계산 과정
n[3] = {73, 95, 82}

sum = 73 + 95 + 82 = 250

sum / 30 = 250 / 30 = 8 (정수 나눗셈 결과)

✅ switch 문 분석
switch (8) {
    case 10:
    case 9: printf("A");   // 실행 안 됨
    case 8: printf("B");   // 실행됨 → "B" 출력
    case 7:
    case 6: printf("C");   // fall-through → 실행 → "C" 출력
    default: printf("D");  // fall-through → 실행 → "D" 출력
}

✅ C언어에서 switch-case는 break가 없으면 fall-through됨 → 아래로 계속 실행됨.


✅ 출력 결과
BCD

📌 해설 요약
sum / 30 == 8 → case 8:부터 실행

break문이 없으므로 이후 case 6, default도 연달아 실행됨

따라서 **"B", "C", "D"**가 차례로 출력됨

-----------------------------------------------------------------------------------------------------
## ✅ 문제 16

다음 C언어 코드의 결과를 쓰시오

---

### ✅ 코드

```c
int c = 0;
for (int i = 1; i <= 2023; i++) {
    if (i % 4 == 0)
        c++;
}
printf("%d", c);


✅ 계산 과정
i % 4 == 0 조건은 4의 배수일 때 참

1부터 2023까지 숫자 중에서 4의 배수 개수를 세는 것

➤ 1 ~ 2023 중 4의 배수 개수:
2023 ÷ 4 = 505.75 → 정수 부분만 취하면 505개

✅ 정답
505

📌 해설 요약
반복문에서 i는 1부터 2023까지 1씩 증가

i % 4 == 0일 때마다 카운트 증가

4의 배수는 4, 8, 12, ..., 2020 → 총 505개 존재

✅ 최종 출력 결과
505

-----------------------------------------------------------------------------------------------------

## ✅ 문제 17) 다음 파이썬 코드의 결과를 쓰시오

```python
a = " engineer information programming"
b = a[:3]
c = a[4:6]
d = a[29:]
e = b + c + d
print(e)

✅ 정답
engneing

📌 해설
🔹 문자열 슬라이싱 개념 복습
파이썬 문자열 인덱스는 0부터 시작하며, a[start:end] 는 start 이상, end 미만 범위를 의미합니다.

🔹 문자열 a 분석
a = " engineer information programming"
문자열 길이: 34글자 (앞에 공백 포함)
인덱스 기준:

인덱스	문자
0	(공백)
1	e
2	n
3	g
4	i
5	n
6	e
...	...
29	i
30	n
31	g


🔹 코드 실행 분석
b = a[:3]       # a[0], a[1], a[2] => ' en'
c = a[4:6]      # a[4], a[5] => 'in'
d = a[29:]      # a[29:] => 'ing'
e = b + c + d
print(e)

🔸 문제의 전제
결과가 engneing 이 되려면 a 문자열 앞의 공백이 없는 것으로 간주해야 합니다.

즉, 다음과 같이 가정:

a = "engineer information programming"
이 경우:

a[:3]     → 'eng'  
a[4:6]    → 'ne'  
a[29:]    → 'ing'
→ e = 'eng' + 'ne' + 'ing' = 'engneing'

✅ 최종 출력 결과
engneing
-----------------------------------------------------------------------------------------------------
## ✅ 문제 18) 다음 자바 코드의 결과를 쓰시오

```java
class Eraon {
    public static void main(String[] args){
        String str1 = "Programming";
        String str2 = "Programming";
        String str3 = new String("Programming");
        
        System.out.println(str1 == str2);
        System.out.println(str1 == str3);
        System.out.println(str1.equals(str3));
        System.out.println(str2.equals(str3));
    }
}

✅ 정답
true  
false  
true  
true

📌 해설
🔹 == 연산자와 .equals() 차이
비교 방식	설명
==	객체의 주소값(참조) 를 비교함
.equals()	문자열의 실제 내용 을 비교함

🔹 각 출력 분석
str1 == str2

"Programming" 은 문자열 리터럴이라서 JVM의 상수 풀(string pool) 에 저장됨.

str1, str2 모두 동일한 객체(주소)를 참조 → true

str1 == str3

str3 은 new String("Programming") 으로 heap 메모리에 새로운 객체를 생성함.

str1 과 str3 은 다른 객체 → false

str1.equals(str3)

.equals() 는 문자열의 내용을 비교함 → 내용은 같음 → true

str2.equals(str3)

내용은 같음 → true

✅ 핵심 요약
== → 참조 비교 (주소)

.equals() → 내용 비교

리터럴은 같은 객체로 공유되지만, new 키워드는 새 객체 생성

-----------------------------------------------------------------------------------------------------

## ✅ 문제 19) 다음 C언어 코드의 실행 결과를 쓰시오

```c
#define MAX_SIZE 10
int stack[MAX_SIZE];
int top = -1;

int isEmpty(){
    if(top == -1) return 1;
    return 0;
}

int isFull(){
    if(top == 10) return 1;
    return 0;
}

void push(int num){
    if (isFull())
        printf("Full");
    stack[++top] = num;
}

int pop(){
    if (isEmpty())
        printf("Empty");
    return stack[top--];
}

int main(int args, char const * argv[]){
    push(5);
    push(2);
    while(!isEmpty()){
        printf("%d", pop());
        push(4); push(1);
        printf("%d", pop());
        push(3);
        printf("%d", pop());
        printf("%d", pop());
        push(6);
        printf("%d", pop());
        printf("%d", pop());
    }
}


✅ 정답
213465

📌 해설
🔹 초기 상태
push(5);  // stack: [5]
push(2);  // stack: [5, 2]   → top = 1


🔹 반복 루프 진입
while (!isEmpty()) {
    printf("%d", pop());  // 2 출력 → stack: [5]
    push(4);              // stack: [5, 4]
    push(1);              // stack: [5, 4, 1]
    printf("%d", pop());  // 1 출력 → stack: [5, 4]
    push(3);              // stack: [5, 4, 3]
    printf("%d", pop());  // 3 출력 → stack: [5, 4]
    printf("%d", pop());  // 4 출력 → stack: [5]
    push(6);              // stack: [5, 6]
    printf("%d", pop());  // 6 출력 → stack: [5]
    printf("%d", pop());  // 5 출력 → stack: []
}

🔹 출력 순서
2 → pop()

1 → pop()

3 → pop()

4 → pop()

6 → pop()

5 → pop()

✅ 최종 출력 결과
복사
편집
213465

-----------------------------------------------------------------------------------------------------
## ✅ 문제 20) 다음 C언어 코드이다.  
`11 12 22 25 64`로 출력되도록 괄호 안에 알맞은 코드를 쓰시오.

---

### 🔹 코드

```c
int E[] = {64, 25, 12, 22, 11};
int n = sizeof(E) / sizeof(E[0]);
int i = 0;
do {
    int j = i + 1;
    do {
        if (E[i] > E[j]) {     // ✅ [정답] E[i] > E[j]
            int tmp = E[i];
            E[i] = E[j];
            E[j] = tmp;
        }
        j++;
    } while (j < n);
    i++;
} while (i < n - 1);

for (int i = 0; i < n; i++)    // ✅ 출력 루프에서 i < n
    printf("%d ", E[i]);


✅ 정답
괄호 안 코드: E[i] > E[j]

📌 해설
이 코드는 선택 정렬(Selection Sort) 알고리즘을 기반으로 구현된 정렬 방식이다.

i 인덱스 이후의 최소값을 찾아 현재 위치 i와 교환하는 방식

따라서 E[i] > E[j] 조건이 작동하면 더 작은 값을 앞으로 정렬하게 된다.

🔹 출력문 주의
printf("%d", E[j]);라고 쓰면 정렬된 값을 정확히 출력할 수 없음.

출력 루프에서는 반드시 정렬된 배열을 순서대로 출력해야 하므로 → printf("%d ", E[i]);가 되어야 함.

✅ 최종 출력 결과
11 12 22 25 64

// 올바른 출력 루프
for (int i = 0; i < n; i++)
    printf("%d ", E[i]);
-----------------------------------------------------------------------------------------------------



