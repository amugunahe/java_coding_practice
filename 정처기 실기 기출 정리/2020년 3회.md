### 문제 1) 형상 통제에 대해 간략히 설명하시오

**답:**  
소프트웨어 형상 변경 요청을 검토하고 승인하며, 현재의 베이스라인에 반영될 수 있도록 통제하는 활동이다.

📌 **관련 개념 설명**
- **형상 통제(Configuration Control)**는 형상 관리의 핵심 활동 중 하나로, 소프트웨어 개발 중 발생하는 변경 요청을 체계적으로 처리하는 절차이다.
- 구체적인 활동에는 다음이 포함된다:
  - 변경 요청 접수
  - 변경 영향 분석
  - 변경 승인 여부 결정
  - 승인된 변경 사항을 베이스라인에 반영
- 형상 통제를 통해 개발 산출물의 일관성과 무결성을 유지할 수 있으며, 무분별한 변경으로 인한 품질 저하를 방지할 수 있다.

----------------------------------------------------------------------------------------
### 문제 2) 다음 통합 방식의 유형을 각각 쓰시오.

**유형 설명:**

(1)  
- 중간에 미들웨어를 두지 않고 각 애플리케이션 간 직접 연결  
- 솔루션 구매 없이 통합, 상대적으로 저렴하게 통합 가능  
- 변경 및 재사용이 어려움  

(2)  
- 단일 접점이 허브 시스템을 통해 데이터를 전송하는 중앙 집중적 방식  
- 모든 데이터 전송이 보장되고, 확장 및 유지보수가 용이  
- 허브 장애 시 전체 시스템에 영향  

**답:**  
(1) **Point to Point (포인트 투 포인트)**  
(2) **Hub & Spoke (허브 앤 스포크)**

📌 **관련 개념 설명**
- **Point to Point 방식**
  - 애플리케이션들 간에 직접 연결을 통해 데이터를 주고받는 방식.
  - 초기 비용은 낮지만, 시스템이 복잡해질수록 관리가 어려워지고 유지보수 비용이 증가.
  - 변경 시 연결된 모든 시스템에 영향을 미치므로 확장성이 낮음.

- **Hub & Spoke 방식**
  - 중앙에 허브(Hub)를 두고, 각 시스템(Spoke)은 허브와만 연결됨.
  - 새로운 시스템 추가 및 변경이 쉬워 확장성과 유지보수성이 뛰어남.
  - 단, 허브에 장애가 생기면 전체 통합 시스템에 영향을 줄 수 있는 단점이 있음.

----------------------------------------------------------------------------------------
### 문제 3) UI(User Interface) 설계 원칙 중 **직관성**에 대해 간략히 서술하시오

**답:**  
누구나 쉽게 이용하고 사용할 수 있어야 한다.  
사용자가 기능을 쉽게 파악할 수 있도록 해야 한다.

📌 **관련 개념 설명**
- **직관성(Intuitiveness)**:  
  UI 설계에서 직관성이란 사용자가 별도의 설명이나 학습 없이도 UI를 쉽게 이해하고 사용할 수 있어야 한다는 원칙이다.  
  예를 들어, 버튼의 위치나 모양만 보고도 기능을 유추할 수 있어야 하며, 사용자가 자연스럽게 동작할 수 있는 흐름을 제공해야 한다.

---

### ✅ UI 설계 4대 원칙 정리

| 설계 원칙 | 설명 |
|-----------|------|
| **직관성** | 누구나 쉽게 이해하고 설명할 수 있어야 한다. |
| **유효성** | 사용자의 목적을 정확하게 달성할 수 있어야 한다. |
| **학습성** | 누구나 쉽게 배우고 익힐 수 있어야 한다. |
| **유연성** | 사용자의 다양한 요구사항을 수용하며 오류를 최소화해야 한다. |
 
----------------------------------------------------------------------------------------
### 문제 4) 다음 제어 흐름 그래프에 대한 분기 커버리지를 수행하는 경우의  
테스트 케이스 경로를 7단계와 6단계로 나눠서 순서대로 나열하시오

**제어 흐름 설명:**

(1) pointer = false
↓
(2) x > y ? ── yes → (3) pointer = true
↓ no
(4) x = x + 1
↓
(5) Call sub
↓
(6) x > y ? ── yes/no → (7) Print Result

markdown
복사
편집

**답:**  
- **경로 1:** 1 → 2(yes) → 3 → 4 → 5 → 6 → 7  
- **경로 2:** 1 → 2(no) → 4 → 5 → 6 → 7  

📌 **관련 개념 설명**

### ✅ 코드 커버리지 유형 정리

| 커버리지 종류 | 설명 |
|---------------|------|
| **구문 커버리지 (Statement Coverage)** | 프로그램의 모든 구문이 최소한 한 번 이상 실행되었는지를 확인하는 테스트 커버리지. |
| **조건 커버리지 (Condition Coverage)** | 각 결정 조건 내의 개별 조건식이 true/false를 모두 가지는지 확인. |
| **결정 커버리지 (Decision Coverage)** | 모든 분기문(if, while 등)의 true/false 경로가 한 번 이상 수행되었는지 확인. |
| **조건/결정 커버리지** | 결정 커버리지 + 조건 커버리지를 모두 만족해야 함. |
| **변경 조건/결정 커버리지 (MC/DC)** | 각 조건식이 결정 결과에 독립적으로 영향을 주는지 확인. |
| **다중 조건 커버리지 (Multiple Condition Coverage)** | 조건식의 가능한 모든 조합을 테스트하여 100% 커버리지를 보장해야 함. |

✅ **분기 커버리지(Branch Coverage)**는 **결정 커버리지**에 해당하며,  
각 분기(True/False)를 최소 한 번씩 실행해야 하므로 위 두 경로는 이를 만족한다.
 
----------------------------------------------------------------------------------------
### 문제 5) 소프트웨어 테스트 기법 중, 소프트웨어 기능이 완전히 작동하는 것을 입증하는 테스트로,  
**동치분할 / 경계값 분석**을 이용하여 테스트하는 기법을 쓰시오.

**답:**  
**블랙박스 테스트**

📌 **관련 개념 설명**

### ✅ 블랙박스 테스트(Black-box Testing)
- 소프트웨어의 **내부 구조나 동작 방식**을 모른 채, **기능 중심**으로 테스트하는 기법.
- 사용자의 입장에서 **입력값과 출력값**만으로 테스트 수행.
- 주로 **요구사항 명세서 기반**으로 설계된 테스트 케이스를 사용.

---

### ✅ 블랙박스 테스트 주요 기법

| 기법 | 설명 |
|------|------|
| **동치분할(Equivalence Partitioning)** | 입력 자료를 유효한 값과 무효한 값으로 나누어 각 대표값만 테스트하는 기법. |
| **경계값 분석(Boundary Value Analysis)** | 입력 조건의 **최소값, 최대값**과 그 경계 근처 값들을 중심으로 테스트 케이스를 구성하는 기법. |
| **원인-효과 그래프 검사(Cause-Effect Graphing)** | 입력 조건들 간의 관계를 논리적으로 분석하여 테스트 케이스를 도출하는 기법. |
| **오류 예측 검사(Error Guessing)** | 과거 경험이나 직관을 바탕으로 **오류가 발생할 가능성이 높은 영역**을 중점적으로 테스트. |
| **비교 검사(Comparison Testing)** | 동일한 기능을 수행하는 여러 버전의 프로그램에 **같은 입력**을 주고 **출력 비교**를 통해 오류를 검출하는 기법. |

----------------------------------------------------------------------------------------
### 문제 6) \<학생\> 테이블에 '주소' 컬럼을 추가하는 SQL문을 완성하는 빈칸 (1)~(2)에 알맞은 예약어를 쓰시오.

**문제 문장:**  
(1) TABLE 학생 (2) 주소 VARCHAR(20);

**답:**  
(1) **ALTER**  
(2) **ADD**

---

📌 **완성된 SQL문:**  
```sql
ALTER TABLE 학생 ADD 주소 VARCHAR(20);
📌 관련 개념 설명

✅ ALTER 명령어
기능	문법
속성 추가	ALTER TABLE 테이블명 ADD 속성명 데이터타입;
속성 변경	ALTER TABLE 테이블명 MODIFY 속성명 데이터타입;
속성 삭제	ALTER TABLE 테이블명 DROP 속성명;
속성 이름 변경	ALTER TABLE 테이블명 RENAME COLUMN 기존속성명 TO 새속성명;
테이블 이름 변경	ALTER TABLE 기존테이블명 RENAME TO 새테이블명;
인덱스 추가	ALTER TABLE 테이블명 ADD INDEX 인덱스명(컬럼명);
인덱스 삭제	ALTER TABLE 테이블명 DROP INDEX 인덱스명;


----------------------------------------------------------------------------------------

### 문제 7) \<성적\> 테이블을 대상으로 아래 \<요구사항\>을 적용하여 결과를 출력하는 SQL문을 작성하시오.

---

#### 📋 요구사항 요약
1. \<성적\> 테이블에서 **과목별 평균 점수가 90점 이상**인 경우
2. **과목이름**, **최소점수**, **최대점수**를 출력
3. **WHERE 절 사용 금지**
4. **GROUP BY**, **HAVING** 사용
5. **AS**를 이용해 컬럼에 별칭 부여
6. 세미콜론(;)은 생략 가능

---

### ✅ 정답 SQL문:
```sql
SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수
FROM 성적
GROUP BY 과목이름
HAVING AVG(점수) >= 90

----------------------------------------------------------------------------------------

### 문제 8) \<학생\> 테이블에서 이름이 '민수'인 학생 튜플을 삭제하는 SQL문을 작성하시오  
(단, 다음의 요구사항을 참고하여 작성하시오.)

---

### ✅ 요구사항
1. 이름 속성 데이터는 **문자형**이다.  
   → 문자형 데이터는 **작은 따옴표('')**로 표시해야 한다.  
2. SQL 명령문은 **대/소문자를 구분하지 않는다.**  
3. SQL 명령문은 **세미콜론(;)을 생략해도 무방**하다.  

---

### ✅ 정답
DELETE FROM 학생 WHERE 이름 = '민수'

📌 관련 개념 설명

데이터 삽입
INSERT INTO 학생(학번, 이름, 나이) VALUES ('A101', '민수', 20)

데이터 수정
UPDATE 학생 SET 나이 = 21 WHERE 이름 = '민수'


데이터 삭제
DELETE FROM 학생 WHERE 이름 = '민수'

----------------------------------------------------------------------------------------
### 문제 9) 데이터베이스 스키마에 대해 간략히 서술하시오

**답:**  
데이터베이스의 전체적인 구조와 제약조건에 대한 명세를 기술하고 정의한 것이다.

📌 **관련 개념 설명**  
- **데이터베이스 스키마(Database Schema)**란 데이터베이스 내에 저장되는 데이터의 구조와 제약 조건을 체계적으로 정의한 설계도이다.  
- 스키마는 테이블, 열(속성), 데이터 타입, 관계, 인덱스, 무결성 제약조건 등을 포함한다.  
- 스키마는 데이터베이스의 논리적 구조를 나타내며, 실제 데이터가 저장되는 물리적 구조와 구분된다.  
- 스키마 설계는 데이터베이스 설계의 핵심 단계로, 효율적이고 일관된 데이터 관리를 가능하게 한다.  

----------------------------------------------------------------------------------------
### 문제 10) 다음 설명하는 관계대수 연산 기호를 쓰시오.

**설명:**  
릴레이션 A에서 릴레이션 B의 모든 조건을 만족하는 튜플을 제외한 후 프로젝션하는 연산자이다.

---

### 답:  
**DIVISION (%)**

---

📌 **관련 개념 설명**

| 연산자 종류 | 설명 |
|-------------|------|
| **SELECT (σ)** | 릴레이션에서 조건을 만족하는 튜플(행)을 선택하는 연산자 (수평적 부분집합) |
| **PROJECT (π)** | 릴레이션에서 원하는 속성(열)만 추출하는 연산자 (수직적 부분집합) |
| **JOIN (⨝)** | 두 릴레이션에서 조건에 맞는 튜플들을 결합하여 하나의 릴레이션으로 만드는 연산자 |
| **DIVISION (÷ 또는 %)** | 릴레이션 A에서 릴레이션 B의 모든 튜플 조건을 만족하는 튜플을 추출하는 연산자. 주로 "A ÷ B" 형태로 사용하며, B의 모든 값을 만족하는 A의 튜플을 반환함. |

---

### 추가 설명

- **DIVISION 연산**은  
  "A DIVISION B"는 릴레이션 A의 튜플 중 B의 모든 튜플과 대응되는 것을 찾는 연산으로,  
  예를 들어 "A의 속성 중 B의 속성을 제외한 나머지 속성에 대해 B의 모든 튜플과 대응되는 A의 튜플"을 반환한다.

- 집합 연산과는 달리, 조건 만족 튜플을 추출하는 특수한 연산이다.

----------------------------------------------------------------------------------------

### 문제 11) 다음 설명에 해당하는 라우팅 프로토콜을 쓰시오

- 최단 경로 탐색에 다익스트라 알고리즘 기반 방식 사용  
- 최적 경로 선택을 위해 홉수, 대역폭, 지연시간 등을 고려  
- 링크 상태 변화 시에만 라우팅 정보 전송  

---

### 답:  
**OSPF (Open Shortest Path First)**

---

📌 **관련 개념 설명**

- **라우팅 프로토콜 분류**  
  - **IGP (Interior Gateway Protocol)**: AS 내부 라우터 간 라우팅  
    - 대표 프로토콜: RIP, OSPF, IGRP  
  - **EGP (Exterior Gateway Protocol)**: AS 간 라우팅  
    - 대표 프로토콜: EGP, BGP  

- **OSPF 특징**  
  - 링크 상태 라우팅 프로토콜  
  - 다익스트라 알고리즘을 이용한 최단 경로 계산  
  - 라우터는 링크 상태 데이터베이스를 유지하며, 링크 상태 변화 시에만 정보를 전송하여 효율적  
  - 홉수, 대역폭, 지연시간 등의 메트릭을 고려하여 최적 경로 결정  
  - 빠른 수렴과 확장성을 갖춤  


----------------------------------------------------------------------------------------
### 문제 12) 인터넷 프로토콜의 비신뢰적인 특성을 보완하기 위한 프로토콜로,  
IP 패킷 전송 중 에러 발생 시 에러 발생 원인을 알려주거나 네트워크 상태를 진단해주는 기능을 제공하는 프로토콜의 영문 약어를 쓰시오.

---

### 답:  
**ICMP** (Internet Control Message Protocol)

---

📌 **관련 개념 설명**

- **ICMP**는 IP 프로토콜 위에서 동작하는 네트워크 관리용 프로토콜로,  
  - 패킷 전송 중 발생하는 오류 메시지를 전달하고  
  - 네트워크 상태를 진단하는 데 사용됨  
- IP 프로토콜은 비신뢰적인 프로토콜로, ICMP가 이를 보완하여 에러 보고와 진단 기능을 수행함.

---

### 참고: OSI 7계층 모델

| 계층 번호 | 계층 이름       |
|-----------|----------------|
| 7         | 응용 계층       |
| 6         | 표현 계층       |
| 5         | 세션 계층       |
| 4         | 전송 계층       |
| 3         | 네트워크 계층   |
| 2         | 데이터 링크 계층 |
| 1         | 물리 계층       |

  --------------------------------------------------------------------------------------
### 문제 13) 헝가리안 표기법에 대해 간략히 설명하시오

**답:**  
프로그래밍 언어에서 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 코딩 규칙이다.

---

📌 **관련 개념 설명**

- **헝가리안 표기법 (Hungarian Notation)**  
  변수명이나 함수 인자명 앞에 해당 변수의 데이터 타입이나 목적을 나타내는 접두사를 붙이는 규칙으로,  
  예를 들어 `strName` (문자열), `iCount` (정수), `pNode` (포인터) 등으로 표기한다.  
- 주로 코드의 가독성과 유지보수를 돕기 위해 사용됨.

---

### ✅ 변수명 표기법 종류

| 표기법       | 설명                                         | 예시                      |
|--------------|----------------------------------------------|---------------------------|
| **카멜 표기법** (camelCase) | 여러 단어를 결합할 때 첫 단어는 소문자, 이후 단어의 첫 글자를 대문자로 표기 | `userName`, `totalCount`  |
| **파스칼 표기법** (PascalCase) | 모든 단어의 첫 글자를 대문자로 표기                      | `UserName`, `TotalCount`  |
| **스네이크 표기법** (snake_case) | 모든 단어를 소문자로 표기하고 단어 사이에 언더바(_) 사용      | `user_name`, `total_count`|
| **케밥 표기법** (kebab-case) | 모든 단어를 소문자로 표기하고 단어 사이에 하이픈(-) 사용       | `user-name`, `total-count`|

  --------------------------------------------------------------------------------------

### 문제 14) 리팩토링의 목적에 대해 간략히 설명하시오

**답:**  
결과의 변경 없이 코드의 구조를 재조정하는 것이다.

---

📌 **관련 개념 설명**

- **리팩토링(Refactoring)**  
  기존 코드의 동작(기능)은 그대로 유지하면서,  
  코드의 가독성, 유지보수성, 효율성을 높이기 위해 내부 구조를 개선하는 작업이다.  
- 주로 중복 제거, 코드 간결화, 명확한 네이밍, 모듈화 등을 포함한다.  
- 버그 수정이나 기능 추가와는 구분되며, 코드 품질 향상이 목적이다.

 
  -------------------------------------------------------------------------------------

### 문제 15) 빈칸 안에 공통으로 들어갈 가장 적합한 용어를 쓰시오

심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며,  
도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 가리켜  
'기술적 은어'라는 뜻으로 **()**라고 불렀다.

---

### 답:  
**프로토콜 (Protocol)**

---

📌 **관련 개념 설명**

- **프로토콜(Protocol)**  
  컴퓨터 간 통신을 위해 정해진 통신 규칙과 절차를 의미한다.  
- 데이터 전송, 오류 검출, 재전송, 연결 설정 및 해제 등 다양한 통신 과정을 정의한다.  
- 네트워크 통신에서 서로 다른 시스템 간 원활한 정보 교환을 가능하게 한다.

  -------------------------------------------------------------------------------------
### 문제 16) 다음 C언어로 작성된 프로그램을 실행한 출력 결과를 쓰시오

```c
void main()
{ 
    int i = 0, c = 0;
    while (i < 10) {
        i++;
        c *= i;
    }
    printf("%d", c);
}

답:
0

📌 출력 결과 설명

변수 c는 초기값이 0으로 설정되어 있음.

while문에서 i가 1부터 10까지 증가하면서 매 반복마다 c *= i; 수행.

하지만 c가 0이므로, 어떤 수를 곱해도 c는 계속 0으로 유지됨.

따라서 출력값은 0이 됨.

복사
편집

  ---------------------------------------------------------------------------------
### 문제 17) 다음은 C언어로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```c
int r1() {
    return 4;
}
int r10() {
    return (30 + r1());
}
int r100() {
    return (200 + r10());
}
void main() {
    printf("%d", r100());
}

답:
234

📌 출력 결과 설명

r1() 함수는 4를 반환

r10() 함수는 30 + r1() = 30 + 4 = 34 반환

r100() 함수는 200 + r10() = 200 + 34 = 234 반환

main() 함수에서 r100() 결과를 출력하므로 출력값은 234가 됨.

  --------------------------------------------------------------------------------------
### 문제 18) 다음 Java로 작성된 프로그램을 실행한 출력 결과를 쓰시오

```java
public static void main(String[] args) {
    int i = 0;
    int sum = 0;

    while (i < 10) {
        i++;
        if (i % 2 == 1)  // 홀수면 continue
            continue;
        sum += i;
    }
    System.out.print(sum);
}
답:
30

📌 출력 결과 설명

변수 i는 1부터 10까지 증가

if (i % 2 == 1) : i가 홀수면 continue하여 합산을 건너뜀

짝수만 sum에 더해짐: 2 + 4 + 6 + 8 + 10 = 30

따라서 출력 결과는 30임.


  --------------------------------------------------------------------------------------

### 문제 19) 다음은 Java로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```java
abstract class vehicle {
    String name;
    public vehicle(String val) {
        this.name = val;
    }
    public String getName() {
        return "Vehicle name: " + name;
    }
}

class Car extends vehicle {
    private String name;
    public Car(String val) {
        super.name = val;
        name = val;
    }
    public String getName(String val) {
        return "Car name: " + val;
    }
    public String getNmae(byte val[]) {
        return "Car name: " + val;
    }
}

public class Main {
    public static void main(String[] args) {
        vehicle obj = new Car("Spark");
        System.out.println(obj.getName());
    }
}

답:
Vehicle name: Spark

📌 출력 결과 설명

vehicle 클래스의 name 필드에 "Spark"가 저장됨.

Car 클래스는 vehicle을 상속받고 있지만, getName() 메서드를 오버라이드 하지 않음.

obj.getName() 호출 시 vehicle 클래스의 getName()이 호출되어 "Vehicle name: Spark" 출력.

Car 클래스에 getName(String val)와 getNmae(byte val[]) 메서드가 있으나, 이들은 오버라이딩이 아니고 매개변수도 다름. 따라서 호출 대상이 아님.

문법 오류(괄호, 따옴표, 변수 초기화 등)는 수정된 것으로 가정함.

  --------------------------------------------------------------------------------------

### 문제 20) C++에서 생성자에 대해 간략히 설명하시오

**답:**  
생성자는 객체 생성 시 자동으로 호출되는 메서드로, 주로 멤버 변수를 초기화하는 목적으로 사용된다.

---

📌 **관련 개념 설명**

- **생성자(Constructor)**  
  - 클래스 이름과 동일한 이름을 가지며 반환형이 없는 특별한 멤버 함수  
  - 객체가 생성될 때 자동으로 실행되어 객체 초기화를 담당  
  - 매개변수를 받을 수 있어 다양한 초기화 방식 제공 가능  
  - 기본 생성자, 매개변수 생성자, 복사 생성자 등이 있음  
- 생성자를 정의하지 않으면 컴파일러가 기본 생성자를 자동 생성함.
