### ✅ 문제 1) 형상 통제에 대해 간략히 설명하시오

**답:**  
소프트웨어 형상 변경 요청을 검토하고 승인하며, 현재의 베이스라인에 반영될 수 있도록 통제하는 활동이다.

---

## 📌 관련 개념 설명: 형상 통제(Configuration Control)

- 형상 통제는 **형상관리 활동 중 핵심**!
- 쉽게 말하면, **“바꿔도 되는지 판단하고, 진짜 바꿔주는 역할”**  
- 코드나 문서, 설정 등 개발 산출물에 대해 **무분별한 변경을 막고**,  
  **필요한 변경만 체계적으로 반영**함

---

### 🧩 형상 통제에서 하는 일

1. **변경 요청 받기**  
   → 누군가가 “이거 고쳐야 해요!” 요청함

2. **변경 영향 분석**  
   → 고치면 어디에 영향 주는지 파악 (다른 부분 망가지는지 확인)

3. **변경 승인할지 결정**  
   → 팀에서 회의하거나 책임자가 판단해서 OK 또는 NO

4. **승인된 변경 적용하기**  
   → 베이스라인(기준 버전)에 반영

---

### 💡 왜 중요한가?

- 개발 산출물의 **일관성** 유지  
- 변경 이력 추적 가능  
- 실수로 잘못된 코드나 설정 들어가는 거 방지  
- **품질 관리와 협업에 핵심!**


----------------------------------------------------------------------------------------
### 문제 2) 다음 통합 방식의 유형을 각각 쓰시오.

**유형 설명:**

(1)  
- 미들웨어 없이 각 애플리케이션이 직접 연결됨  
- 별도 솔루션 구매 없이 저렴하게 통합 가능  
- 변경이나 재사용이 어려움  

(2)  
- 중앙 허브 시스템을 통해 데이터가 전달되는 집중 방식  
- 데이터 전송 보장, 확장성과 유지보수 용이  
- 허브 장애 시 전체 시스템 영향 받음  

**답:**  
(1) **Point to Point (포인트 투 포인트)**  
(2) **Hub & Spoke (허브 앤 스포크)**

---

## 📌 관련 개념 설명

### Point to Point 방식
- 앱들끼리 직접 연결되어 데이터 주고받음  
- 초기 비용은 적지만, 시스템 커지면 관리 어렵고 유지보수 비용 증가  
- 변경하면 연결된 모든 시스템에 영향 줘서 확장성 낮음

### Hub & Spoke 방식
- 중앙 허브(Hub)에 각 시스템(Spoke)이 연결됨  
- 새 시스템 추가/변경이 쉽고 유지보수 편함  
- 허브가 고장 나면 전체 시스템에 문제 발생 가능

----------------------------------------------------------------------------------------
### 문제 3) UI(User Interface) 설계 원칙 중 **직관성**에 대해 간략히 서술하시오

**답:**  
누구나 쉽게 이용하고 사용할 수 있어야 한다.  
사용자가 기능을 쉽게 파악할 수 있도록 해야 한다.

📌 **관련 개념 설명**

- **직관성(Intuitiveness)**  
  UI는 따로 배우지 않아도 누구나 바로 이해하고 쓸 수 있어야 한다.  
  예를 들어, 버튼 위치나 모양만 봐도 무슨 기능인지 알 수 있어야 하고, 자연스럽게 사용할 수 있게 만들어야 한다.

---

### ✅ UI 설계 4대 원칙 정리

| 설계 원칙 | 설명                            |
|-----------|---------------------------------|
| **직관성** | 누구나 쉽고 빠르게 이해할 수 있어야 함  |
| **유효성** | 사용자가 원하는 목적을 제대로 이뤄야 함 |
| **학습성** | 처음 써도 금방 배워서 익숙해져야 함     |
| **유연성** | 다양한 사용자 요구를 받아들이고, 실수해도 쉽게 고칠 수 있어야 함 |

 
----------------------------------------------------------------------------------------
### 문제 4) 다음 제어 흐름 그래프에 대한 분기 커버리지를 수행하는 경우의  
테스트 케이스 경로를 7단계와 6단계로 나눠서 순서대로 나열하시오

**제어 흐름 설명:**

(1) pointer = false
↓
(2) x > y ? ── yes → (3) pointer = true
↓ no
(4) x = x + 1
↓
(5) Call sub
↓
(6) x > y ? ── yes/no → (7) Print Result


**답:**  
- **경로 1:** 1 → 2(yes) → 3 → 4 → 5 → 6 → 7  
- **경로 2:** 1 → 2(no) → 4 → 5 → 6 → 7  

📌 **관련 개념 설명**

### ✅ 코드 커버리지 유형 정리

| 커버리지 종류 | 설명 |
|---------------|------|
| **구문 커버리지 (Statement Coverage)** | 프로그램의 모든 구문이 최소한 한 번 이상 실행되었는지를 확인하는 테스트 커버리지. |
| **조건 커버리지 (Condition Coverage)** | 각 결정 조건 내의 개별 조건식이 true/false를 모두 가지는지 확인. |
| **결정 커버리지 (Decision Coverage)** | 모든 분기문(if, while 등)의 true/false 경로가 한 번 이상 수행되었는지 확인. |
| **조건/결정 커버리지** | 결정 커버리지 + 조건 커버리지를 모두 만족해야 함. |
| **변경 조건/결정 커버리지 (MC/DC)** | 각 조건식이 결정 결과에 독립적으로 영향을 주는지 확인. |
| **다중 조건 커버리지 (Multiple Condition Coverage)** | 조건식의 가능한 모든 조합을 테스트하여 100% 커버리지를 보장해야 함. |

✅ **분기 커버리지(Branch Coverage)**는 **결정 커버리지**에 해당하며,  
각 분기(True/False)를 최소 한 번씩 실행해야 하므로 위 두 경로는 이를 만족한다.
 
----------------------------------------------------------------------------------------
### 문제 5) 소프트웨어 테스트 기법 중, 소프트웨어 기능이 완전히 작동하는 것을 입증하는 테스트로,  
**동치분할 / 경계값 분석**을 이용하여 테스트하는 기법을 쓰시오.

**답:**  
**블랙박스 테스트**

📌 **관련 개념 설명**

### ✅ 블랙박스 테스트 (Black-box Testing)
- 소프트웨어 내부 구조는 모르고, 기능만 보고 테스트하는 방법  
- 사용자가 입력한 값과 그에 따른 결과만 확인  
- 주로 요구사항 문서에 맞춰 테스트 케이스를 만듦

---

### ✅ 주요 블랙박스 테스트 기법

| 기법                   | 설명                                                         |
|------------------------|--------------------------------------------------------------|
| **동치분할(Equivalence Partitioning)**   | 입력을 좋은 값과 나쁜 값으로 나누고, 대표 값들만 테스트함                |
| **경계값 분석(Boundary Value Analysis)** | 입력 조건의 최소, 최대, 경계 주변 값 위주로 테스트함                      |
| **원인-효과 그래프 검사(Cause-Effect Graphing)** | 입력 조건 간 논리 관계를 분석해 테스트 케이스를 만드는 방법             |
| **오류 예측 검사(Error Guessing)**       | 경험이나 직감으로 오류 가능성이 높은 부분을 집중 테스트함                |
| **비교 검사(Comparison Testing)**        | 여러 버전 프로그램에 같은 입력을 주고 결과를 비교해 문제를 찾는 방법       |


----------------------------------------------------------------------------------------
### 문제 6) \<학생\> 테이블에 '주소' 컬럼을 추가하는 SQL문을 완성하는 빈칸 (1)~(2)에 알맞은 예약어를 쓰시오.

**문제 문장:**  
(1) TABLE 학생 (2) 주소 VARCHAR(20);

**답:**  
(1) **ALTER**  
(2) **ADD**

---

📌 **완성된 SQL문:**  

ALTER TABLE 학생 ADD 주소 VARCHAR(20);

📌 관련 개념 설명

✅ ALTER 명령어 주요 기능 및 문법
기능	문법
속성 추가	ALTER TABLE 테이블명 ADD 속성명 데이터타입;
속성 변경	ALTER TABLE 테이블명 MODIFY 속성명 데이터타입;
속성 삭제	ALTER TABLE 테이블명 DROP 속성명;
속성 이름 변경	ALTER TABLE 테이블명 RENAME COLUMN 기존속성명 TO 새속성명;
테이블 이름 변경	ALTER TABLE 기존테이블명 RENAME TO 새테이블명;
인덱스 추가	ALTER TABLE 테이블명 ADD INDEX 인덱스명(컬럼명);
인덱스 삭제	ALTER TABLE 테이블명 DROP INDEX 인덱스명;


----------------------------------------------------------------------------------------

### 문제 7) \<성적\> 테이블을 대상으로 아래 \<요구사항\>을 적용하여 결과를 출력하는 SQL문을 작성하시오.

---

#### 📋 요구사항 요약
1. \<성적\> 테이블에서 **과목별 평균 점수가 90점 이상**인 경우
2. **과목이름**, **최소점수**, **최대점수**를 출력
3. **WHERE 절 사용 금지**
4. **GROUP BY**, **HAVING** 사용
5. **AS**를 이용해 컬럼에 별칭 부여
6. 세미콜론(;)은 생략 가능

---

### ✅ 정답 SQL문:
```sql
SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수
FROM 성적
GROUP BY 과목이름
HAVING AVG(점수) >= 90

----------------------------------------------------------------------------------------

### 문제 8) \<학생\> 테이블에서 이름이 '민수'인 학생 튜플을 삭제하는 SQL문을 작성하시오  
(단, 다음의 요구사항을 참고하여 작성하시오.)

---

### ✅ 요구사항
1. 이름 속성 데이터는 **문자형**이다.  
   → 문자형 데이터는 **작은 따옴표('')**로 표시해야 한다.  
2. SQL 명령문은 **대/소문자를 구분하지 않는다.**  
3. SQL 명령문은 **세미콜론(;)을 생략해도 무방**하다.  

---

### ✅ 정답
DELETE FROM 학생 WHERE 이름 = '민수'

📌 관련 개념 설명

데이터 삽입
INSERT INTO 학생(학번, 이름, 나이) VALUES ('A101', '민수', 20)

데이터 수정
UPDATE 학생 SET 나이 = 21 WHERE 이름 = '민수'


데이터 삭제
DELETE FROM 학생 WHERE 이름 = '민수'

----------------------------------------------------------------------------------------
### 문제 9) 데이터베이스 스키마에 대해 간략히 서술하시오

**답:**  
데이터베이스의 전체적인 구조와 제약조건에 대한 명세를 기술하고 정의한 것이다.

📌 **관련 개념 설명**

- **데이터베이스 스키마(Database Schema)**  
  데이터베이스에 저장되는 데이터의 구조와 규칙을 체계적으로 정리한 설계도임.

- 스키마에는 테이블, 컬럼(속성), 데이터 타입, 테이블 간 관계, 인덱스, 무결성 제약 조건 등이 포함됨.

- 스키마는 데이터베이스의 논리적 구조를 나타내며, 실제 데이터가 저장되는 물리적 구조와는 다름.

- 좋은 스키마 설계는 효율적이고 일관된 데이터 관리를 가능하게 함.


----------------------------------------------------------------------------------------
### 문제 10) 다음 설명하는 관계대수 연산 기호를 쓰시오.

**설명:**  
릴레이션 A에서 릴레이션 B의 모든 조건을 만족하는 튜플을 제외한 후 프로젝션하는 연산자이다.

---

### 답:  
**DIVISION (%)**

---
📌 **관련 개념 설명**

| 연산자 종류      | 설명                                                                                  |
|-----------------|-------------------------------------------------------------------------------------|
| **SELECT (σ)**  | 테이블에서 조건에 맞는 행(튜플)만 골라내는 연산 (가로 방향 일부 선택)                  |
| **PROJECT (π)** | 테이블에서 특정 열(속성)만 골라내는 연산 (세로 방향 일부 선택)                        |
| **JOIN (⨝)**   | 두 테이블에서 조건에 맞는 행들을 합쳐 하나의 테이블로 만드는 연산                      |
| **DIVISION (÷)**| 한 테이블 A에서, 다른 테이블 B의 모든 값과 관련된 행만 뽑아내는 특수 연산 (A ÷ B 형태) |

---

### 추가 설명

- **DIVISION 연산**은  
  A 테이블의 행 중에서 B 테이블의 모든 행과 관련된 행만 골라내는 연산임.  
- 예를 들어, "모든 과목을 수강한 학생"을 찾을 때 쓰임.  
- 집합 연산과 다르게, 특정 조건을 모두 만족하는 튜플을 찾는 데 특화되어 있음.

----------------------------------------------------------------------------------------

### 문제 11) 다음 설명에 해당하는 라우팅 프로토콜을 쓰시오

- 최단 경로 탐색에 다익스트라 알고리즘 기반 방식 사용  
- 최적 경로 선택을 위해 홉수, 대역폭, 지연시간 등을 고려  
- 링크 상태 변화 시에만 라우팅 정보 전송  

---

### 답:  
**OSPF (Open Shortest Path First)**

---

📌 **관련 개념 설명**

- **라우팅 프로토콜 분류**  
  - **IGP (Interior Gateway Protocol)**:  
    - 같은 자율 시스템(AS) 내부의 라우터들끼리 경로 정보를 주고받음  
    - 대표 프로토콜: RIP, OSPF, IGRP  
  - **EGP (Exterior Gateway Protocol)**:  
    - 서로 다른 자율 시스템(AS) 간의 라우팅을 담당  
    - 대표 프로토콜: EGP, BGP  

- **OSPF (Open Shortest Path First) 특징**  
  - 링크 상태 방식 라우팅 프로토콜  
  - 다익스트라 알고리즘을 사용해 최단 경로 계산  
  - 라우터들이 링크 상태 정보를 데이터베이스로 관리하며, 변경 시에만 업데이트 전송 → 효율적  
  - 홉수, 대역폭, 지연 시간 같은 다양한 메트릭을 고려해 최적 경로 선택  
  - 빠른 네트워크 수렴과 좋은 확장성 제공



----------------------------------------------------------------------------------------
### 문제 12) 인터넷 프로토콜의 비신뢰적인 특성을 보완하기 위한 프로토콜로,  
IP 패킷 전송 중 에러 발생 시 에러 발생 원인을 알려주거나 네트워크 상태를 진단해주는 기능을 제공하는 프로토콜의 영문 약어를 쓰시오.

---

### 답:  
**ICMP** (Internet Control Message Protocol)

---
📌 **관련 개념 설명**

- **ICMP (Internet Control Message Protocol)**  
  - IP 프로토콜 위에서 작동하는 네트워크 관리용 프로토콜  
  - 데이터 전송 중 발생하는 오류 메시지를 전달  
  - 네트워크 상태 진단(예: 핑 테스트)에 사용됨  
- IP 프로토콜은 신뢰성 없는 프로토콜이라, ICMP가 에러 보고와 진단 역할을 보완함

---

### 참고: OSI 7계층 모델

| 계층 번호 | 계층 이름       |
|-----------|----------------|
| 7         | 응용 계층       |
| 6         | 표현 계층       |
| 5         | 세션 계층       |
| 4         | 전송 계층       |
| 3         | 네트워크 계층   |
| 2         | 데이터 링크 계층 |
| 1         | 물리 계층       |


  --------------------------------------------------------------------------------------
### 문제 13) 헝가리안 표기법에 대해 간략히 설명하시오

**답:**  
프로그래밍 언어에서 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 코딩 규칙이다.

---
📌 **관련 개념 설명**

- **헝가리안 표기법 (Hungarian Notation)**  
  변수명이나 함수 이름 앞에 데이터 타입이나 목적을 나타내는 접두사를 붙이는 방식  
  예) `strName` (문자열), `iCount` (정수), `pNode` (포인터)  
- 주로 코드 가독성과 유지보수를 쉽게 하기 위해 사용함

---

### ✅ 변수명 표기법 종류

| 표기법               | 설명                                                  | 예시                      |
|----------------------|-------------------------------------------------------|---------------------------|
| **카멜 표기법** (camelCase)   | 여러 단어 결합 시 첫 단어는 소문자, 다음 단어 첫 글자 대문자  | `userName`, `totalCount`  |
| **파스칼 표기법** (PascalCase) | 모든 단어의 첫 글자를 대문자로 표기                         | `UserName`, `TotalCount`  |
| **스네이크 표기법** (snake_case) | 모든 단어 소문자, 단어 사이에 언더바(_) 사용                 | `user_name`, `total_count`|
| **케밥 표기법** (kebab-case)     | 모든 단어 소문자, 단어 사이에 하이픈(-) 사용                  | `user-name`, `total-count`|

  --------------------------------------------------------------------------------------

### 문제 14) 리팩토링의 목적에 대해 간략히 설명하시오

**답:**  
결과의 변경 없이 코드의 구조를 재조정하는 것이다.

---

📌 **관련 개념 설명**

- **리팩토링(Refactoring)**  
  기존 기능은 그대로 유지하면서,  
  코드를 더 읽기 쉽고, 고치기 쉽고, 효율적으로 바꾸는 작업  
- 보통 중복된 코드 없애기, 코드 간단하게 만들기, 이름 명확하게 짓기, 기능별로 나누기 등을 포함  
- 버그 고치거나 기능 추가하는 것과는 다르고, 코드 품질을 높이는 게 목적임  


 
  -------------------------------------------------------------------------------------

### 문제 15) 빈칸 안에 공통으로 들어갈 가장 적합한 용어를 쓰시오

심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며,  
도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 가리켜  
'기술적 은어'라는 뜻으로 **()**라고 불렀다.

---

### 답:  
**프로토콜 (Protocol)**

---

📌 **관련 개념 설명**

- **프로토콜(Protocol)**  
  컴퓨터끼리 대화할 때 꼭 지켜야 하는 약속이나 규칙 같은 것  
- 데이터 보내고 받는 방법, 문제 생기면 다시 보내는 방법, 연결 시작하고 끝내는 방법 등을 정해놓음  
- 이 규칙 덕분에 서로 다른 컴퓨터나 시스템이 문제없이 서로 이야기할 수 있음  

### 예시  
- 우리가 전화할 때 "안녕하세요"라고 인사하고, 끊을 때 "안녕히 계세요" 하는 것도 일종의 프로토콜  
- 인터넷에서 이메일 보내는 SMTP, 웹페이지 요청하는 HTTP도 프로토콜임  


  -------------------------------------------------------------------------------------
### 문제 16) 다음 C언어로 작성된 프로그램을 실행한 출력 결과를 쓰시오

```c
void main()
{ 
    int i = 0, c = 0;
    while (i < 10) {
        i++;
        c *= i;
    }
    printf("%d", c);
}

답:
0

📌 출력 결과 설명

📌 설명 (변수 c에 주목해라!)
야, 이거 딱 보면 감 와야 한다.

int i = 0, c = 0;: i도 0, c도 0으로 시작한다.

while (i < 10): i가 10보다 작을 때까지 계속 반복한다. (그러니까 i는 1부터 10까지 커진다.)

i++;: i를 1 증가시킨다.

c *= i;: 이게 핵심이다! c에 i 값을 곱해서 다시 c에 저장하는 거지.

생각해봐라. c가 처음부터 0이었지?

i가 1이 되면, c = 0 * 1 이니까 c는 여전히 0.

i가 2가 되면, c = 0 * 2 이니까 c는 여전히 0.

계속 반복해도 c가 한 번도 0이 아닌 적이 없으니, 뭘 곱해도 계속 0이다!

그러니까 마지막에 printf("%d", c);를 해도 결과는 0이다 


  ---------------------------------------------------------------------------------
### 문제 17) 다음은 C언어로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```c
int r1() {
    return 4;
}
int r10() {
    return (30 + r1());
}
int r100() {
    return (200 + r10());
}
void main() {
    printf("%d", r100());
}

답:
234

알겠다 게이야. "이기"는 이제 안 쓴다. 존나게 신경 거슬렸으면 미안하다.

네가 알잘딱깔센, 존나 쉽고 직관적으로 알려달라고 했으니, 이번에도 딱딱한 설명 다 치우고, 진짜 핵심만 쏙쏙 뽑아줄게. 요네즈 켄시가 제이팝 1황인 것처럼, 내가 설명 1황으로 만들어줄게. 간다!

🔢 문제 17) C언어 함수 호출? 차곡차곡 계산!
문제: 다음은 C언어로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

C

int r1() {
    return 4;
}
int r10() {
    return (30 + r1());
}
int r100() {
    return (200 + r10());
}
void main() {
    printf("%d", r100());
}
답: 234

📌 설명 (안에서부터 차례대로 계산!)
야, 이건 그냥 함수 호출이 중첩된 것뿐이야. 복잡하게 생각할 거 없고, 제일 안쪽에 있는 함수부터 차례대로 계산해서 밖으로 나오면 된다.

main() 함수가 printf("%d", r100()); 이걸 실행하지? 그럼 제일 먼저 r100() 함수를 호출하는 거야.

r100() 함수 안을 봐봐. return (200 + r10()); 이 있지? 200에다가 r10()이 반환하는 값을 더하라는 거야. 그럼 이제 r10() 함수를 호출한다.

r10() 함수 안을 봐봐. return (30 + r1()); 이 있지? 30에다가 r1()이 반환하는 값을 더하라는 거야. 그럼 이제 r1() 함수를 호출한다.

r1() 함수 안을 봐봐. return 4; 이렇게 돼있지? 얘는 그냥 4를 반환하고 끝난다.

자, 이제 거꾸로 계산해서 돌아오면 된다.

r1()이 **4**를 반환했지?

그럼 r10()은 30 + (r1()이 반환한 4) 해서 30 + 4 = 34를 반환한다.

그럼 r100()은 200 + (r10()이 반환한 34) 해서 200 + 34 = 234를 반환한다.

결국 main() 함수에서 r100()이 반환한 234를 출력하는 거야. 존나 쉽지?

  --------------------------------------------------------------------------------------
### 문제 18) 다음 Java로 작성된 프로그램을 실행한 출력 결과를 쓰시오

```java
public static void main(String[] args) {
    int i = 0;
    int sum = 0;

    while (i < 10) {
        i++;
        if (i % 2 == 1)  // 홀수면 continue
            continue;
        sum += i;
    }
    System.out.print(sum);
}
답:
30

📌 설명 (continue가 핵심!)
야, 이거 continue가 뭔지 알면 존나 쉬워.

int i = 0; int sum = 0;: i랑 sum 둘 다 0으로 시작해.

while (i < 10): i가 10보다 작을 때까지 계속 반복하는 거야. (그러니까 i는 1부터 10까지 1씩 커진다.)

i++;: i를 1 증가시켜.

if (i % 2 == 1): i를 2로 나눴을 때 나머지가 1이면, 즉 i가 홀수면...

continue;: 이게 존나 중요해! continue를 만나면 그 즉시 현재 반복을 멈추고 다음 반복으로 넘어가 버려.
바로 아래에 있는 sum += i; 이 줄은 실행 안 되고 건너뛰는 거지.

sum += i;: i가 홀수가 아니라 짝수일 때만 이 줄이 실행된다. sum에 i 값을 더하는 거야.

결국 sum에는 1부터 10까지의 숫자 중에서 짝수만 골라서 더해지는 거야.
2 + 4 + 6 + 8 + 10 = 30

그래서 마지막에 System.out.print(sum);을 하면 30이 출력되는 거다. 존나 쉽지?


  --------------------------------------------------------------------------------------

### 문제 19) 다음은 Java로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```java
abstract class vehicle {
    String name;
    public vehicle(String val) {
        this.name = val;
    }
    public String getName() {
        return "Vehicle name: " + name;
    }
}

class Car extends vehicle {
    private String name;
    public Car(String val) {
        super.name = val;
        name = val;
    }
    public String getName(String val) {
        return "Car name: " + val;
    }
    public String getNmae(byte val[]) {
        return "Car name: " + val;
    }
}

public class Main {
    public static void main(String[] args) {
        vehicle obj = new Car("Spark");
        System.out.println(obj.getName());
    }
}

답:
Vehicle name: Spark

📌 설명 (부모님 말씀이 우선이다!)
야, 이거 존나 헷갈리게 해놨는데, 핵심만 알면 쉬워. 부모 클래스 메서드가 호출된다는 거!

vehicle obj = new Car("Spark");:

new Car("Spark")를 호출해서 Car 객체를 만드는 거야. "Spark"라는 이름으로 차를 만드는 거지.

Car 클래스의 생성자(public Car(String val)) 안을 봐봐.

super.name = val; : 이건 부모인 vehicle 클래스의 name 변수에 "Spark"를 저장하는 거야. (생각해봐, 자동차도 차량의 한 종류니까 "Spark"라는 이름을 차량 이름에도 넣는 거지.)

name = val; : 이건 Car 클래스 자기 자신의 name 변수에도 "Spark"를 저장하는 거야. (Car 클래스에 private String name;이 따로 있거든.)

근데 존나 중요한 건, 이 obj 변수는 vehicle 타입으로 선언됐다는 거야! (vehicle obj = ...) 이걸 다형성이라고 부르는데, 자식 객체를 부모 타입으로 받아서 쓰는 거지.

System.out.println(obj.getName());:

obj는 vehicle 타입으로 선언됐지? 그럼 obj.getName()을 호출하면 vehicle 클래스에 있는 getName() 메서드가 호출된다!

Car 클래스에도 getName 비슷한 메서드들이 있긴 해.

public String getName(String val): 얘는 매개변수(String val)가 있잖아? vehicle의 getName()은 매개변수가 없지? 매개변수가 다르면 이건 '오버라이딩'이 아니라 그냥 '다른 메서드'(오버로딩)로 취급한다.

public String getNmae(byte val[]): 얘는 심지어 메서드 이름도 getNmae로 오타가 났고, 매개변수도 다르지? 이건 아예 다른 놈이야.

결국 Car 클래스에 있는 저 두 메서드는 vehicle의 getName()을 덮어쓴(오버라이딩한) 게 아니라는 말이야.

그래서 obj.getName()을 했을 때 vehicle 클래스의 getName()이 실행되면서, 아까 super.name = val;로 저장했던 vehicle의 name 변수값인 "Spark"를 가지고 "Vehicle name: Spark"를 출력하는 거야.

쉽게 말해서, 부모(vehicle)가 가진 기능을 자식(Car)이 딱히 바꾸지 않았으면, 부모가 가진 기능을 그대로 쓴다는 거지.

  --------------------------------------------------------------------------------------

### 문제 20) C++에서 생성자에 대해 간략히 설명하시오

**답:**  
생성자는 객체 생성 시 자동으로 호출되는 메서드로, 주로 멤버 변수를 초기화하는 목적으로 사용된다.

---

📌 **관련 개념 설명**

- **생성자(Constructor)**  
  - 클래스 이름과 똑같고, 반환값이 없는 특별한 함수  
  - 객체가 만들어질 때 자동으로 실행되어 초기 설정을 해줌  
  - 매개변수를 받아 다양한 방식으로 초기화할 수 있음  
  - 기본 생성자(매개변수 없는 것), 매개변수 생성자, 복사 생성자 등이 있음  
- 만약 생성자를 직접 만들지 않으면, 컴파일러가 자동으로 기본 생성자를 만들어줌.

