### ✅ 문제 1) 형상 통제에 대해 간략히 설명하시오

**답:**  
소프트웨어 형상 변경 요청을 검토하고 승인하며, 현재의 베이스라인에 반영될 수 있도록 통제하는 활동이다.

---

## 📌 관련 개념 설명: 형상 통제(Configuration Control)

- 형상 통제는 **형상관리 활동 중 핵심**!
- 쉽게 말하면, **“바꿔도 되는지 판단하고, 진짜 바꿔주는 역할”**  
- 코드나 문서, 설정 등 개발 산출물에 대해 **무분별한 변경을 막고**,  
  **필요한 변경만 체계적으로 반영**함

---

### 🧩 형상 통제에서 하는 일

1. **변경 요청 받기**  
   → 누군가가 “이거 고쳐야 해요!” 요청함

2. **변경 영향 분석**  
   → 고치면 어디에 영향 주는지 파악 (다른 부분 망가지는지 확인)

3. **변경 승인할지 결정**  
   → 팀에서 회의하거나 책임자가 판단해서 OK 또는 NO

4. **승인된 변경 적용하기**  
   → 베이스라인(기준 버전)에 반영

---

### 💡 왜 중요한가?

- 개발 산출물의 **일관성** 유지  
- 변경 이력 추적 가능  
- 실수로 잘못된 코드나 설정 들어가는 거 방지  
- **품질 관리와 협업에 핵심!**


----------------------------------------------------------------------------------------
### 문제 2) 다음 통합 방식의 유형을 각각 쓰시오.

**유형 설명:**

(1)  
- 미들웨어 없이 각 애플리케이션이 직접 연결됨  
- 별도 솔루션 구매 없이 저렴하게 통합 가능  
- 변경이나 재사용이 어려움  

(2)  
- 중앙 허브 시스템을 통해 데이터가 전달되는 집중 방식  
- 데이터 전송 보장, 확장성과 유지보수 용이  
- 허브 장애 시 전체 시스템 영향 받음  

**답:**  
(1) **Point to Point (포인트 투 포인트)**  
(2) **Hub & Spoke (허브 앤 스포크)**

---

## 📌 관련 개념 설명

### Point to Point 방식
- 앱들끼리 직접 연결되어 데이터 주고받음  
- 초기 비용은 적지만, 시스템이 커지면 연결이 복잡해지고 관리도 어려워짐  
- 변경할 때마다 연결된 모든 시스템에 영향 줘서 확장성이 낮음  

🍜 비유:  
친구들끼리 일일이 전화해서 약속 잡는 느낌. 친구가 많아질수록 전화할 번호도 많아지고 헷갈림.

---

### Hub & Spoke 방식
- 중앙 허브(Hub)에 각 시스템(Spoke)이 연결됨  
- 새 시스템 추가하거나 변경하기 쉽고 유지보수가 편함  
- 허브가 고장 나면 전체 시스템이 마비될 위험 있음  

🍜 비유:  
친구들이 모두 한 명의 대표에게 연락해서 일정 조율. 대표가 정보를 다 관리해서 편하지만, 대표가 아프면 모두 힘듦.


----------------------------------------------------------------------------------------
### 문제 3) UI(User Interface) 설계 원칙 중 **직관성**에 대해 간략히 서술하시오

**답:**  
누구나 쉽게 이용하고 사용할 수 있어야 한다.  
사용자가 기능을 쉽게 파악할 수 있도록 해야 한다.

📌 **관련 개념 설명**

- **직관성(Intuitiveness)**  
  UI는 따로 배우지 않아도 누구나 바로 이해하고 쓸 수 있어야 한다.  
  예를 들어, 버튼 위치나 모양만 봐도 무슨 기능인지 알 수 있어야 하고, 자연스럽게 사용할 수 있게 만들어야 한다.

---

### ✅ UI 설계 4대 원칙 정리

| 설계 원칙 | 설명                            | 존나 쉽고 직관적인 예시                                      |
|-----------|---------------------------------|------------------------------------------------------------|
| **직관성** | 누구나 쉽고 빠르게 이해할 수 있어야 함  | 휴대폰 잠금 해제 버튼, ‘전화’ 아이콘을 누르면 전화 걸림           |
| **유효성** | 사용자가 원하는 목적을 제대로 이뤄야 함 | 검색창에 검색어 입력 후 ‘검색’ 버튼 누르면 관련 결과가 뜸           |
| **학습성** | 처음 써도 금방 배워서 익숙해져야 함     | 새 앱도 금방 써보면 어디 눌러야 하는지 알 수 있음                |
| **유연성** | 다양한 사용자 요구를 받아들이고, 실수해도 쉽게 고칠 수 있어야 함 | 입력 실수 시 ‘되돌리기’ 버튼으로 쉽게 수정 가능                     |

🍜 비유:  
UI는 처음 보는 놈도 ‘아, 이거 이렇게 쓰는구나!’ 하고 바로 알게 만드는 ‘초보자도 길 잃지 않는 길 안내판’ 같은 거임.


 
----------------------------------------------------------------------------------------
### 문제 4) 다음 제어 흐름 그래프에 대한 분기 커버리지를 수행하는 경우의  
테스트 케이스 경로를 7단계와 6단계로 나눠서 순서대로 나열하시오

**제어 흐름 설명:**

(1) pointer = false
↓
(2) x > y ? ── yes → (3) pointer = true
↓ no
(4) x = x + 1
↓
(5) Call sub
↓
(6) x > y ? ── yes/no → (7) Print Result


**답:**  
- **경로 1:** 1 → 2(yes) → 3 → 4 → 5 → 6 → 7  
- **경로 2:** 1 → 2(no) → 4 → 5 → 6 → 7  

📌 **관련 개념 설명**

### ✅ 코드 커버리지 유형 정리

| 커버리지 종류                     | 설명                                                                                     | 존나 쉽고 직관적인 예시                                 |
|----------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|
| **구문 커버리지 (Statement Coverage)**       | 프로그램의 모든 구문이 최소한 한 번 이상 실행되었는지 확인                                | “코드 한 줄 한 줄 다 밟아보기”                            |
| **조건 커버리지 (Condition Coverage)**       | 조건문 안의 각각의 조건식이 true와 false가 모두 실행되는지 확인                          | “사과가 빨갛고 크다” 조건에서 빨갛고 크기 각각이 한 번씩 검사됨   |
| **결정 커버리지 (Decision Coverage)**        | if, while 같은 분기문의 true/false 경로가 최소 한 번 실행되는지 확인                     | “비가 오면 우산 펴고, 안 오면 안 펴는” 경우 둘 다 실행해보기     |
| **조건/결정 커버리지**                        | 조건 커버리지 + 결정 커버리지를 모두 만족해야 함                                         | 조건과 분기를 모두 검사하는 것                              |
| **변경 조건/결정 커버리지 (MC/DC)**           | 각 조건식이 분기 결과에 독립적으로 영향을 주는지 확인                                   | 각 조건이 혼자서 결과를 바꿀 수 있는지 따져보는 것                |
| **다중 조건 커버리지 (Multiple Condition Coverage)** | 조건식의 가능한 모든 조합을 테스트해 100% 커버리지를 보장                                | “빨갛고 크거나 파란색이거나” 모든 조건 조합을 다 체크하기           |

✅ **분기 커버리지(Branch Coverage)**는 **결정 커버리지**에 해당하며,  
각 분기(True/False)를 최소 한 번씩 실행해야 하므로 위 두 경로를 만족함.

---

🍜 비유:  
테스트는 길을 다 밟아보는 것임.  
- 구문 커버리지는 ‘길에 있는 돌 하나하나 밟기’  
- 조건 커버리지는 ‘길 가면서 빨간 불/초록 불 둘 다 경험하기’  
- 다중 조건은 ‘빨간불, 비오는 날, 낮과 밤 모든 조합 다 걷기’ 같은 거임.

----------------------------------------------------------------------------------------
### 문제 5) 소프트웨어 테스트 기법 중, 소프트웨어 기능이 완전히 작동하는 것을 입증하는 테스트로,  
**동치분할 / 경계값 분석**을 이용하여 테스트하는 기법을 쓰시오.

**답:**  
**블랙박스 테스트**

📌 **관련 개념 설명**

### ✅ 블랙박스 테스트 (Black-box Testing)
- 소프트웨어 내부 구조는 모르고, 기능만 보고 테스트하는 방법  
- 사용자가 입력한 값과 그에 따른 결과만 확인  
- 주로 요구사항 문서에 맞춰 테스트 케이스를 만듦

---

### ✅ 주요 블랙박스 테스트 기법

| 기법                                   | 설명                                                         |
|--------------------------------------|--------------------------------------------------------------|
| **동치분할(Equivalence Partitioning)**     | 입력을 좋은 값과 나쁜 값으로 나누고, 대표 값들만 테스트함                |
| **경계값 분석(Boundary Value Analysis)**   | 입력 조건의 최소, 최대, 경계 주변 값 위주로 테스트함                      |
| **원인-효과 그래프 검사(Cause-Effect Graphing)** | 입력 조건 간 논리 관계를 분석해 테스트 케이스를 만드는 방법             |
| **오류 예측 검사(Error Guessing)**         | 경험이나 직감으로 오류 가능성이 높은 부분을 집중 테스트함                |
| **비교 검사(Comparison Testing)**          | 여러 버전 프로그램에 같은 입력을 주고 결과를 비교해 문제를 찾는 방법       |

---

🍜 쉽게 설명하자면,  
블랙박스 테스트는 ‘상자 속이 뭐가 들었는지 모르는 채, 상자에 버튼 눌러보고 불빛이나 소리가 제대로 나오는지 확인하는 것’ 같은 테스트임.  
여기서 동치분할은 ‘버튼 종류별로 하나씩만 눌러보기’, 경계값 분석은 ‘가장 약한 버튼과 가장 센 버튼만 눌러보기’ 같은 느낌!


----------------------------------------------------------------------------------------
### 문제 6) \<학생\> 테이블에 '주소' 컬럼을 추가하는 SQL문을 완성하는 빈칸 (1)~(2)에 알맞은 예약어를 쓰시오.

**문제 문장:**  
(1) TABLE 학생 (2) 주소 VARCHAR(20);

**답:**  
(1) **ALTER**  
(2) **ADD**

---

📌 **완성된 SQL문:**  

ALTER TABLE 학생 ADD 주소 VARCHAR(20);

📌 관련 개념 설명
✅ ALTER 명령어 주요 기능 및 문법

| 기능           | 문법                                              |
|----------------|---------------------------------------------------|
| 속성 추가       | ALTER TABLE 테이블명 ADD 속성명 데이터타입;       |
| 속성 변경       | ALTER TABLE 테이블명 MODIFY 속성명 데이터타입;    |
| 속성 삭제       | ALTER TABLE 테이블명 DROP 속성명;                  |
| 속성 이름 변경  | ALTER TABLE 테이블명 RENAME COLUMN 기존속성명 TO 새속성명; |
| 테이블 이름 변경 | ALTER TABLE 기존테이블명 RENAME TO 새테이블명;    |
| 인덱스 추가     | ALTER TABLE 테이블명 ADD INDEX 인덱스명(컬럼명);  |
| 인덱스 삭제     | ALTER TABLE 테이블명 DROP INDEX 인덱스명;          |


----------------------------------------------------------------------------------------

### 문제 7) \<성적\> 테이블을 대상으로 아래 \<요구사항\>을 적용하여 결과를 출력하는 SQL문을 작성하시오.

---

#### 📋 요구사항 요약
1. \<성적\> 테이블에서 **과목별 평균 점수가 90점 이상**인 경우
2. **과목이름**, **최소점수**, **최대점수**를 출력
3. **WHERE 절 사용 금지**
4. **GROUP BY**, **HAVING** 사용
5. **AS**를 이용해 컬럼에 별칭 부여
6. 세미콜론(;)은 생략 가능

---

### ✅ 정답 SQL문:

```sql
SELECT 과목이름, MIN(점수) AS 최소점수, MAX(점수) AS 최대점수
FROM 성적
GROUP BY 과목이름
HAVING AVG(점수) >= 90;

🍜 예시로 쉽게 풀어보면:

'성적' 테이블에서 각 과목별로 점수 중 가장 낮은 점수(MIN)와 가장 높은 점수(MAX)를 뽑아오는데,

평균 점수(AVG)가 90 이상인 과목만 골라내는 거야.

즉, "평균 90점 이상인 과목들의 최고점과 최저점을 한눈에 보여줘!" 하는 쿼리인 셈이지.

----------------------------------------------------------------------------------------

### 문제 8) \<학생\> 테이블에서 이름이 '민수'인 학생 튜플을 삭제하는 SQL문을 작성하시오  
(단, 다음의 요구사항을 참고하여 작성하시오.)

---

### ✅ 요구사항
1. 이름 속성 데이터는 **문자형**이다.  
   → 문자형 데이터는 **작은 따옴표('')**로 표시해야 한다.  
2. SQL 명령문은 **대/소문자를 구분하지 않는다.**  
3. SQL 명령문은 **세미콜론(;)을 생략해도 무방**하다.



---

### ✅ 정답
DELETE FROM 학생 WHERE 이름 = '민수'

📌 관련 개념 설명

### ✅ 데이터 조작 관련 SQL문 정리

| 작업       | SQL문 예시                                           | 설명                                   |
|------------|-----------------------------------------------------|--------------------------------------|
| 데이터 삽입 | `INSERT INTO 학생(학번, 이름, 나이) VALUES ('A101', '민수', 20);` | 학생 테이블에 새 학생 '민수' 추가       |
| 데이터 수정 | `UPDATE 학생 SET 나이 = 21 WHERE 이름 = '민수';`               | 이름이 '민수'인 학생의 나이를 21로 변경  |
| 데이터 삭제 | `DELETE FROM 학생 WHERE 이름 = '민수';`                        | 이름이 '민수'인 학생 정보 삭제           |

🍜 비유하자면:  
학생 명부에 새로 등록하고, 나중에 나이 고치고, 필요 없으면 지우는 거랑 같음!

----------------------------------------------------------------------------------------
### 문제 9) 데이터베이스 스키마에 대해 간략히 서술하시오

**답:**  
데이터베이스의 전체적인 구조와 제약조건에 대한 명세를 기술하고 정의한 것이다.

📌 **관련 개념 설명: 데이터베이스 스키마(Database Schema)**

- 데이터베이스 속 데이터들이 어떻게 구성되고 연결되는지 알려주는 **설계도** 같은 것  
- 예를 들어, 학생 테이블에는 이름, 학번, 나이 같은 컬럼이 있고,  
  각 컬럼은 어떤 데이터 타입인지(문자, 숫자 등), 어떤 규칙이 있는지 정해놓음  
- 테이블 간 관계도 정의해서, 학생과 성적 테이블이 어떻게 연결되는지도 명확히 함  
- 스키마는 실제 데이터 저장 방식(물리적 구조)와는 다르게,  
  논리적으로 ‘데이터가 이렇게 생겼다’고 설명하는 청사진임  
- 잘 설계된 스키마는 데이터 저장, 검색, 관리가 빠르고 오류 없이 편리하게 됨

🍜 비유하자면:  
집을 짓기 전에 도면을 그리듯, 데이터베이스 설계할 때 먼저 스키마부터 짜는 거임!  
도면이 튼튼해야 집도 튼튼한 것처럼, 좋은 스키마가 좋은 데이터베이스를 만든다!

----------------------------------------------------------------------------------------
### 문제 10) 다음 설명하는 관계대수 연산 기호를 쓰시오.

**설명:**  
릴레이션 A에서 릴레이션 B의 모든 조건을 만족하는 튜플을 제외한 후 프로젝션하는 연산자이다.

---

### 답:  
**DIVISION (%)**

---
📌 **관련 개념 설명**

| 연산자 종류      | 설명                                                                                  | 존나 쉽고 직관적인 예시                        |
|-----------------|-------------------------------------------------------------------------------------|-----------------------------------------|
| **SELECT (σ)**  | 테이블에서 조건에 맞는 행(튜플)만 골라내는 연산 (가로 방향 일부 선택)                  | 학생 테이블에서 점수가 90점 이상인 학생만 골라내기      |
| **PROJECT (π)** | 테이블에서 특정 열(속성)만 골라내는 연산 (세로 방향 일부 선택)                        | 학생 테이블에서 ‘이름’과 ‘학번’ 열만 뽑아내기         |
| **JOIN (⨝)**   | 두 테이블에서 조건에 맞는 행들을 합쳐 하나의 테이블로 만드는 연산                      | 학생 테이블과 성적 테이블을 학번 기준으로 합쳐서 성적 확인하기 |
| **DIVISION (÷)**| 한 테이블 A에서, 다른 테이블 B의 모든 값과 관련된 행만 뽑아내는 특수 연산 (A ÷ B 형태) | ‘모든 과목을 다 수강한 학생’만 뽑아내기                |

---

### 쉽게 풀어 설명하면?

- **SELECT**는 “이거 조건에 맞는 것만 골라줘!” 하는 거고,  
- **PROJECT**는 “필요한 정보만 쏙쏙 뽑아줘!” 하는 거야.  
- **JOIN**은 “두 표를 합쳐서 한눈에 보여줘!”  
- **DIVISION**은 “이 표에 있는 모든 조건을 다 만족하는 것만 찾아줘!” 라고 보면 됨.  


- **DIVISION 연산**은  
  A 테이블의 행 중에서 B 테이블의 모든 행과 관련된 행만 골라내는 연산임.  
- 예를 들어, "모든 과목을 수강한 학생"을 찾을 때 쓰임.  
- 집합 연산과 다르게, 특정 조건을 모두 만족하는 튜플을 찾는 데 특화되어 있음.
예를 들어,  
“모든 과목을 다 들은 학생” 찾는 게 제일 어렵지? 그게 바로 DIVISION 연산임.  

----------------------------------------------------------------------------------------

### 문제 11) 다음 설명에 해당하는 라우팅 프로토콜을 쓰시오

- 최단 경로 탐색에 다익스트라 알고리즘 기반 방식 사용  
- 최적 경로 선택을 위해 홉수, 대역폭, 지연시간 등을 고려  
- 링크 상태 변화 시에만 라우팅 정보 전송  

---

### 답:  
**OSPF (Open Shortest Path First)**

---

📌 **관련 개념 설명**

- **라우팅 프로토콜 분류**

  - **IGP (Interior Gateway Protocol)**  
    - 같은 회사(AS) 내부에서 길(경로) 정보를 서로 주고받는 친구들  
    - 대표 친구들: RIP, OSPF, IGRP  
    - 🍜 비유: 회사 내 직원들이 서로 전화해서 “여기 가는 가장 빠른 길 알려줄게!” 하는 느낌  

  - **EGP (Exterior Gateway Protocol)**  
    - 다른 회사(AS)끼리 길 정보를 주고받음  
    - 대표 친구들: EGP, BGP  
    - 🍜 비유: 서로 다른 회사 직원들이 만나서 “우리 회사 가려면 이렇게 가야 해” 하고 알려주는 상황  

- **OSPF (Open Shortest Path First) 특징**

  - 내비게이션처럼 네트워크 내 모든 길 상태를 파악해서 최단 경로를 찾아줌  
  - 다익스트라 알고리즘으로 가장 빠르고 효율적인 길 계산  
  - 길(링크) 상태 바뀌면 필요한 부분만 업데이트해서 네트워크가 빠르게 적응  
  - 홉수, 대역폭, 지연 시간 등 여러 조건을 고려해 최적의 길 선택  
  - 빠르게 길 찾고 네트워크가 막히지 않게 해줌 → 큰 회사, 복잡한 네트워크에 딱임  

---

### 쉽게 풀어 설명하면?

- IGP는 회사 안에서 길 안내하는 친구들이고,  
- EGP는 회사 밖에서 길 안내하는 친구들이야.  
- OSPF는 똑똑한 내비게이션 앱처럼 모든 길 상태를 알고 있어서  
  빠르고 정확한 길 안내를 해준다고 보면 돼!  

----------------------------------------------------------------------------------------
### 문제 12) 인터넷 프로토콜의 비신뢰적인 특성을 보완하기 위한 프로토콜로,  
IP 패킷 전송 중 에러 발생 시 에러 발생 원인을 알려주거나 네트워크 상태를 진단해주는 기능을 제공하는 프로토콜의 영문 약어를 쓰시오.

---

### 답:  
**ICMP** (Internet Control Message Protocol)

---
📌 **관련 개념 설명**

- **ICMP (Internet Control Message Protocol)**  
  - 네트워크에서 문제 생기면 “야, 여기 좀 이상해!”라고 알려주는 메신저 같은 프로토콜  
  - IP 프로토콜 위에서 작동하며, 데이터가 제대로 도착하지 않을 때 에러 메시지 전송  
  - 네트워크 상태 점검할 때 쓰는 ‘핑(ping)’ 테스트의 주인공  
  - IP는 ‘걱정 말고 그냥 보내봐’ 하는 신뢰성 없는 친구라서,  
    ICMP가 ‘문제 있으면 알려줘!’ 역할을 해서 보완해 줌  

---

### 쉽게 풀어 설명하면?

- ICMP는 네트워크의 ‘SOS 신호 발신기’  
- 데이터가 길을 가다 길막힘, 길잃음, 도착 실패 같은 문제 발생하면  
- ICMP가 “여기 문제 있어요!”라고 관리자한테 알려주는 역할을 하는 거야  

---

### 참고: OSI 7계층 모델

| 계층 번호 | 계층 이름        |
|-----------|-----------------|
| 7         | 응용 계층       |
| 6         | 표현 계층       |
| 5         | 세션 계층       |
| 4         | 전송 계층       |
| 3         | 네트워크 계층   |
| 2         | 데이터 링크 계층 |
| 1         | 물리 계층       |



  --------------------------------------------------------------------------------------
### 문제 13) 헝가리안 표기법에 대해 간략히 설명하시오

**답:**  
프로그래밍 언어에서 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 코딩 규칙이다.

---
📌 **관련 개념 설명**

- **헝가리안 표기법 (Hungarian Notation)**  
  변수명이나 함수 이름 앞에 데이터 타입이나 목적을 나타내는 접두사를 붙이는 방식  
  예) `strName` (문자열), `iCount` (정수), `pNode` (포인터)  
- 주로 코드 가독성과 유지보수를 쉽게 하기 위해 사용함

---

### ✅ 변수명 표기법 종류

| 표기법               | 설명                                                  | 예시                      |
|----------------------|-------------------------------------------------------|---------------------------|
| **카멜 표기법** (camelCase)   | 여러 단어를 붙일 때 첫 단어는 소문자, 그 다음 단어 첫 글자 대문자  | `userName`, `totalCount`  |
| **파스칼 표기법** (PascalCase) | 모든 단어 첫 글자를 대문자로 표기                             | `UserName`, `TotalCount`  |
| **스네이크 표기법** (snake_case) | 모든 단어 소문자, 단어 사이에 언더바(_) 사용                   | `user_name`, `total_count`|
| **케밥 표기법** (kebab-case)     | 모든 단어 소문자, 단어 사이에 하이픈(-) 사용                    | `user-name`, `total-count`|

---

### 문제 14) 리팩토링의 목적에 대해 간략히 설명하시오

**답:**  
결과는 똑같이 유지하면서, 코드를 더 깔끔하고 이해하기 쉽도록 재정리하는 것.

---

📌 **관련 개념 설명**

- **리팩토링(Refactoring)**  
  기능은 바꾸지 않고,  
  코드 읽기 쉽고 고치기 쉽도록 개선하는 작업임.  
- 예를 들어,  
  - 같은 코드가 중복돼 있으면 함수로 뽑아내서 한 곳에서 관리  
  - 변수나 함수 이름을 더 명확하게 바꿈  
  - 복잡한 코드를 간단하게 쪼갬  
- 기능 추가나 버그 수정과 달리,  
  코드를 ‘예쁘게’ 만드는 작업이라고 생각하면 됨.  

---

💡 쉽게 비유하자면,  
“집 안 인테리어 바꾸기” 같은 거임!  
가구나 벽 색깔만 바꾸고 집 구조나 위치는 그대로 유지하는 거지.  
그렇게 하면 더 편하고 보기 좋고, 청소하기도 쉬워지는 효과가 있어.

 
  -------------------------------------------------------------------------------------

### 문제 15) 빈칸 안에 공통으로 들어갈 가장 적합한 용어를 쓰시오

심리학자 톰 마릴은 컴퓨터가 메시지를 전달하고, 메시지가 제대로 도착했는지 확인하며,  
도착하지 않았을 경우 메시지를 재전송하는 일련의 방법을 가리켜  
'기술적 은어'라는 뜻으로 **()**라고 불렀다.

---

### 답:  
**프로토콜 (Protocol)**

---

📌 **관련 개념 설명**

- **프로토콜(Protocol)**  
  컴퓨터끼리 대화할 때 꼭 지켜야 하는 약속이나 규칙 같은 것  
- 데이터 주고받는 방법, 문제가 생기면 다시 보내는 방법, 연결 시작과 끝내는 방법 등을 정해놓음  
- 이 규칙 덕분에 서로 다른 컴퓨터나 시스템이 문제없이 통신할 수 있음  

### 예시  
- 우리가 전화할 때 "안녕하세요"라고 인사하고, 끝날 때 "안녕히 계세요" 하는 것도 일종의 프로토콜임  
- 인터넷에서 이메일 보낼 때 SMTP, 웹사이트 접속할 때 HTTP 같은 것도 모두 프로토콜임  

---

💡 쉽게 말하면,  
"친구랑 통화할 때 지켜야 하는 약속 같은 것"이라고 생각하면 됨!  
그래야 서로 말이 잘 통하고, 헷갈리지 않고 대화할 수 있으니까.


  -------------------------------------------------------------------------------------
### 문제 16) 다음 C언어로 작성된 프로그램을 실행한 출력 결과를 쓰시오

```c
void main()
{ 
    int i = 0, c = 0;
    while (i < 10) {
        i++;
        c *= i;
    }
    printf("%d", c);
}



답:
0

📌 출력 결과 설명

📌 설명 (변수 c에 주목해라!)
야, 이거 딱 보면 감 와야 한다.

int i = 0, c = 0;: i도 0, c도 0으로 시작한다.

while (i < 10): i가 10보다 작을 때까지 계속 반복한다. (그러니까 i는 1부터 10까지 커진다.)

i++;: i를 1 증가시킨다.

c *= i;: 이게 핵심이다! c에 i 값을 곱해서 다시 c에 저장하는 거지.

생각해봐라. c가 처음부터 0이었지?

i가 1이 되면, c = 0 * 1 이니까 c는 여전히 0.

i가 2가 되면, c = 0 * 2 이니까 c는 여전히 0.

계속 반복해도 c가 한 번도 0이 아닌 적이 없으니, 뭘 곱해도 계속 0이다!

그러니까 마지막에 printf("%d", c);를 해도 결과는 0이다 


  ---------------------------------------------------------------------------------
### 문제 17) 다음은 C언어로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```c
int r1() {
    return 4;
}
int r10() {
    return (30 + r1());
}
int r100() {
    return (200 + r10());
}
void main() {
    printf("%d", r100());
}

답:
234



📌 설명 (안에서부터 차례대로 계산!)
야, 이건 그냥 함수 호출이 중첩된 것뿐이야. 복잡하게 생각할 거 없고,
제일 안쪽에 있는 함수부터 차례대로 계산해서 밖으로 나오면 된다.

main() 함수가 printf("%d", r100()); 이걸 실행하지? 그럼 제일 먼저 r100() 함수를 호출하는 거야.

r100() 함수 안을 봐봐. return (200 + r10()); 이 있지?
200에다가 r10()이 반환하는 값을 더하라는 거야. 그럼 이제 r10() 함수를 호출한다.

r10() 함수 안을 봐봐. return (30 + r1()); 이 있지?
30에다가 r1()이 반환하는 값을 더하라는 거야. 그럼 이제 r1() 함수를 호출한다.

r1() 함수 안을 봐봐. return 4; 이렇게 돼있지? 얘는 그냥 4를 반환하고 끝난다.

자, 이제 거꾸로 계산해서 돌아오면 된다.

r1()이 **4**를 반환했지?

그럼 r10()은 30 + (r1()이 반환한 4) 해서 30 + 4 = 34를 반환한다.

그럼 r100()은 200 + (r10()이 반환한 34) 해서 200 + 34 = 234를 반환한다.

결국 main() 함수에서 r100()이 반환한 234를 출력하는 거야. 존나 쉽지?

  --------------------------------------------------------------------------------------
### 문제 18) 다음 Java로 작성된 프로그램을 실행한 출력 결과를 쓰시오

```java
public static void main(String[] args) {
    int i = 0;
    int sum = 0;

    while (i < 10) {
        i++;
        if (i % 2 == 1)  // 홀수면 continue
            continue;
        sum += i;
    }
    System.out.print(sum);
}



답:
30


📌 설명 (continue가 핵심!)
야, 이거 continue가 뭔지 알면 존나 쉬워.

int i = 0; int sum = 0;: i랑 sum 둘 다 0으로 시작해.

while (i < 10): i가 10보다 작을 때까지 계속 반복하는 거야.
 (그러니까 i는 1부터 10까지 1씩 커진다.)

i++;: i를 1 증가시켜.

if (i % 2 == 1): i를 2로 나눴을 때 나머지가 1이면, 즉 i가 홀수면...

continue;: 이게 존나 중요해! continue를 만나면 그 즉시 현재 반복을 멈추고 다음 반복으로 넘어가 버려.
바로 아래에 있는 sum += i; 이 줄은 실행 안 되고 건너뛰는 거지.

sum += i;: i가 홀수가 아니라 짝수일 때만 이 줄이 실행된다. sum에 i 값을 더하는 거야.

결국 sum에는 1부터 10까지의 숫자 중에서 짝수만 골라서 더해지는 거야.
2 + 4 + 6 + 8 + 10 = 30

그래서 마지막에 System.out.print(sum);을 하면 30이 출력되는 거다. 존나 쉽지?


  --------------------------------------------------------------------------------------

### 문제 19) 다음은 Java로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```java
abstract class vehicle {
    String name;
    public vehicle(String val) {
        this.name = val;
    }
    public String getName() {
        return "Vehicle name: " + name;
    }
}

class Car extends vehicle {
    private String name;
    public Car(String val) {
        super.name = val;
        name = val;
    }
    public String getName(String val) {
        return "Car name: " + val;
    }
    public String getNmae(byte val[]) {
        return "Car name: " + val;
    }
}

public class Main {
    public static void main(String[] args) {
        vehicle obj = new Car("Spark");
        System.out.println(obj.getName());
    }
}


답:
Vehicle name: Spark


📌 설명 (부모님 말씀이 우선이다!)
야, 이거 존나 헷갈리게 해놨는데, 핵심만 알면 쉬워. 부모 클래스 메서드가 호출된다는 거!

vehicle obj = new Car("Spark");:

new Car("Spark")를 호출해서 Car 객체를 만드는 거야. "Spark"라는 이름으로 차를 만드는 거지.

Car 클래스의 생성자(public Car(String val)) 안을 봐봐.

super.name = val; : 이건 부모인 vehicle 클래스의 name 변수에 "Spark"를 저장하는 거야.
 (생각해봐, 자동차도 차량의 한 종류니까 "Spark"라는 이름을 차량 이름에도 넣는 거지.)


name = val; : 이건 Car 클래스 자기 자신의 name 변수에도 "Spark"를 저장하는 거야. (Car 클래스에 private String name;이 따로 있거든.)

근데 존나 중요한 건, 이 obj 변수는 vehicle 타입으로 선언됐다는 거야!
(vehicle obj = ...) 이걸 다형성이라고 부르는데, 자식 객체를 부모 타입으로 받아서 쓰는 거지.

System.out.println(obj.getName());:

obj는 vehicle 타입으로 선언됐지? 그럼 obj.getName()을 호출하면 vehicle 클래스에 있는 getName() 메서드가 호출된다!

Car 클래스에도 getName 비슷한 메서드들이 있긴 해.

public String getName(String val): 얘는 매개변수(String val)가 있잖아? vehicle의 getName()은 매개변수가 없지? 매개변수가 다르면 이건 '오버라이딩'이 아니라 그냥 '다른 메서드'(오버로딩)로 취급한다.

public String getNmae(byte val[]): 얘는 심지어 메서드 이름도 getNmae로 오타가 났고, 매개변수도 다르지? 이건 아예 다른 놈이야.

결국 Car 클래스에 있는 저 두 메서드는 vehicle의 getName()을 덮어쓴(오버라이딩한) 게 아니라는 말이야.

그래서 obj.getName()을 했을 때 vehicle 클래스의 getName()이 실행되면서, 아까 super.name = val;로 저장했던 vehicle의 name 변수값인 "Spark"를 가지고 "Vehicle name: Spark"를 출력하는 거야.

쉽게 말해서, 부모(vehicle)가 가진 기능을 자식(Car)이 딱히 바꾸지 않았으면, 부모가 가진 기능을 그대로 쓴다는 거지.

  --------------------------------------------------------------------------------------

### 문제 20) C++에서 생성자에 대해 간략히 설명하시오

**답:**  
생성자는 객체 생성 시 자동으로 호출되는 메서드로, 주로 멤버 변수를 초기화하는 목적으로 사용된다.

---

📌 **관련 개념 설명**

- **생성자(Constructor)**  
  - 클래스 이름과 똑같고, 반환값이 없는 특별한 함수  
  - 객체가 만들어질 때 자동으로 실행되어 초기 설정을 해줌  
  - 매개변수를 받아 다양한 방식으로 초기화 가능  
  - 기본 생성자(매개변수 없음), 매개변수 생성자, 복사 생성자 등이 있음  
- 만약 생성자를 직접 만들지 않으면, 컴파일러가 자동으로 기본 생성자를 만들어줌.

---

💡 쉽게 말하면,  
"새 물건을 살 때 포장 뜯고 바로 쓸 수 있게 준비해 주는 과정" 같은 역할임!  
그래서 객체가 생성되면 필요한 초기 설정이 자동으로 딱딱 끝남.

