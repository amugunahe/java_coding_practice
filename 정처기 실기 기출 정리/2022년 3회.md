## 문제 1) 다음 중 형상 관리 도구에 해당하는 것을 모두 고르시오  
Ant, CVS, OLAP, MAVEN, SVN, JENKINS, OLTP, GIT, GRADDLE  

**답:** CVS, SVN, GIT  

---

### 📌 해설:

**형상 관리(Configuration Management)**는 소프트웨어 개발 과정에서 변경 사항을 체계적으로 추적·관리하는 활동을 말하며, 이를 위해 **형상 관리 도구**를 사용합니다.

#### ✅ 형상 관리 도구:
- **CVS (Concurrent Versions System)**: 버전 관리 도구로 소스코드의 이력을 관리  
- **SVN (Subversion)**: CVS의 단점을 보완한 중앙집중형 버전 관리 도구  
- **GIT**: 분산형 버전 관리 도구로, 현재 가장 널리 사용됨

---

### ❌ 형상 관리 도구가 아닌 것:
- **Ant**: 자바 기반의 빌드 도구  
- **MAVEN**: 자바 프로젝트의 의존성 관리와 빌드를 자동화하는 도구  
- **GRADLE**: Groovy를 기반으로 한 빌드 자동화 도구  
- **JENKINS**: CI/CD(지속적 통합/지속적 배포)를 위한 자동화 도구  
- **OLAP (Online Analytical Processing)**: 다차원 데이터 분석 도구  
- **OLTP (Online Transaction Processing)**: 실시간 트랜잭션 처리 시스템

---

### 📌 관련 개념 설명

#### 🔹 형상 관리 절차
1. **형상 식별**: 관리할 소프트웨어 구성요소(코드, 문서 등)를 식별  
2. **형상 통제**: 변경 요청을 승인하고 베이스라인에 반영  
3. **형상 감사**: 변경 내역이 정확히 반영되었는지 점검  
4. **형상 기록**: 형상 항목에 대한 이력 및 상태를 기록·관리  

---------------------------------------------------------------------------------------------------------------
## 문제 2) 다음 디자인패턴에 대한 설명이다. 괄호 안에 알맞는 답을 작성하시오

(1) 은/는 구현부에서 추상층을 분리하여 각자 독립적으로 변형이 가능하고 확장이 가능하도록 한다.  
즉 기능과 구현에 대해서 두 개를 별도로 클래스를 구현을 한다.

(2) 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고, 자동으로 내용이 갱신되는 방식의 패턴이다.

**답:**  
(1) **Bridge**  
(2) **Observer**

---

### 📌 해설

#### (1) **Bridge 패턴**
- 목적: **추상화(Abstraction)**와 **구현부(Implementation)**를 분리하여 독립적으로 확장할 수 있도록 함
- 주요 특징:
  - 기능 계층과 구현 계층을 분리하여 다형성과 유연성을 제공
  - 추상화 클래스는 구현 클래스에 대한 참조(bridge)를 가지고, 위임을 통해 기능을 구현
- 사용 예:
  - GUI 라이브러리에서 다양한 운영체제에 따른 다른 렌더링 방식을 추상화와 구현으로 분리할 때

#### (2) **Observer 패턴**
- 목적: **상태 변화에 따라 자동으로 알림**을 받아 관련 객체들이 자동으로 갱신되도록 함
- 주요 특징:
  - **Publisher(Subject)**와 **Subscriber(Observer)** 구조
  - Subject의 상태 변화 → 모든 Observer에게 자동 통지
  - 느슨한 결합 구조로 시스템 유연성과 확장성 증가
- 사용 예:
  - 이벤트 시스템, GUI의 이벤트 리스너, MVC 패턴에서 Model → View 갱신

---

---------------------------------------------------------------------------------------------------------------
## 문제 3) 다음 UML에 관한 설명이다. 괄호 안에 알맞는 답을 작성하시오.

UML은 컴퓨터 애플리케이션을 모델링할 수 있는 통합 언어이다.  
구성요소로는 사물, (1), 다이어그램으로 이루어져 있고, 구조 다이어그램 중 (2) 다이어그램은  
객체들의 타입을 정의하고, 객체들 간의 관계를 도식화하여 시스템의 특정 모듈이나 일부 및 전체를 구조화한다.  
UML 모델링에서 (3)는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야 하는  
오퍼레이션 세트를 정의하는 모델 요소이다.  

**답:**  
1) 관계  
2) 클래스  
3) 인터페이스  

---

### 📌 해설

#### (1) 관계 (Relationship)
- UML의 구성 요소는 다음과 같다:
  - **사물(Thing)**: 모델의 기본 단위. 예: 클래스, 인터페이스, 컴포넌트 등
  - **관계(Relationship)**: 사물들 간의 연결을 나타냄
  - **다이어그램(Diagram)**: 사물과 관계를 시각적으로 표현
- 관계의 예시:
  - **일반화 관계**: 상속 관계 (`A → B` : A가 B를 상속)
  - **연관 관계**: 두 클래스가 서로 기능을 사용할 때
  - **의존 관계**: 메서드 실행 시 일시적으로 다른 클래스를 사용할 때
  - **실체화 관계**: 클래스가 인터페이스를 구현할 때 (`implements`)
  - **집약/합성 관계**: 포함 관계 (생명 주기 독립/의존 여부에 따라 구분)

#### (2) 클래스 다이어그램 (Class Diagram)
- 구조 다이어그램의 대표적인 형태
- 시스템을 구성하는 **클래스**, **속성**, **메서드**, **클래스 간 관계** 등을 표현
- 객체지향 시스템의 정적인 구조를 모델링함

#### (3) 인터페이스 (Interface)
- 인터페이스는 클래스 또는 컴포넌트가 **구현해야 하는 동작의 집합**을 정의
- 일반적으로 메서드의 선언만 포함하며, 실제 구현은 해당 클래스를 통해 이뤄짐
- UML에서는 인터페이스를 `<<interface>>` 라고 표기

---

### 📌 추가 정리: UML 다이어그램 종류 예시
- **구조적 다이어그램**:
  - 클래스 다이어그램, 객체 다이어그램, 컴포넌트 다이어그램, 배치 다이어그램 등
- **행위적 다이어그램**:
  - 유스케이스 다이어그램, 순서 다이어그램, 상태 다이어그램, 활동 다이어그램 등

### 📌 유스케이스 다이어그램 관계
- **연관 관계**: 액터와 유스케이스 사이의 상호작용
- **포함 관계 (include)**: 반드시 수행해야 하는 하위 유스케이스 포함
- **확장 관계 (extend)**: 조건이 만족될 때 확장적으로 수행되는 유스케이스

---

---------------------------------------------------------------------------------------------------------------

## 문제 4) 아래 점수에 따라 점수를 출력하는 테스트를 진행하려고 한다.  
다음과 같은 테스트 입력 값을 넣을 때의 테스트 방식을 쓰시오

| 점수 구간   | 금액    | 테스트 입력값 |
|-------------|--------|----------------|
| 90~100      | 700만원 | (2)            |
| 80~89       | 500만원 | (3)            |
| 70~79       | 300만원 | (4)            |
| 0~69        | 0만원   | (5)            |

**테스트 입력값:**  
`-1, 0, 1, 68, 69, 70, 99, 100, 101`

**답:** **경계값 분석 (Boundary Value Analysis)**

---

### 📌 해설

#### ✅ 경계값 분석 (Boundary Value Analysis)
- **블랙박스 테스트 기법** 중 하나  
- **입력의 경계값(최댓값, 최솟값, 임계값 등)** 주변에서 오류가 자주 발생하는 점에 착안한 테스트 방식
- 각 등급 구간의 **시작점, 끝점, 바로 앞/뒤 값**을 테스트하는 방식

#### 📌 예시 설명 (입력값과 경계)
| 경계 조건     | 테스트 입력값         | 설명                             |
|---------------|------------------------|----------------------------------|
| 0의 바로 앞/뒤 | -1, 0, 1               | 0을 포함하는 구간의 하한 경계 테스트 |
| 69의 바로 앞/뒤| 68, 69, 70             | 70점 구간 진입 전후 경계 테스트     |
| 99, 100, 101   |                        | 최상위 점수 구간의 경계 확인       |

- 이처럼 경계값에서의 반응을 확인해 **정확한 분기 처리가 되어 있는지** 확인 가능

---

### ✅ 블랙박스 테스트 기법 요약 비교

| 기법                  | 설명 |
|-----------------------|------|
| **동등 분할 기법**       | 입력값을 유사한 영역(등분)으로 나누고, 각 구간에서 대표값을 선택해 테스트 |
| **경계값 분석 기법**     | 등분 구간의 경계점에서의 입력값으로 테스트 |
| **원인-효과 그래프 검사** | 입력 조건과 출력 간의 논리적 관계를 그래프로 모델링하여 테스트 케이스 도출 |
| **오류 예측 기법**       | 오류가 발생할 만한 값을 경험적으로 예측하여 테스트 |
| **비교 검사**           | 두 시스템의 출력 결과를 비교하여 오류 검출 |

---

### 📌 정리

- 본 문제는 점수 구간의 **경계(예: 69, 70 / 100, 101)**에 주목하여 테스트 케이스가 설계되어 있음  
- 그러므로 정답은 **경계값 분석 (Boundary Value Analysis)**



---------------------------------------------------------------------------------------------------------------

## 문제 5) 아래에 설명하는 용어를 작성하시오

여러 개의 사이트에서 한 번의 로그인으로 여러 가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법을 말한다.  
하나의 시스템에서 인증을 할 경우 타 시스템에서는 인증 정보가 있는지 확인하고,  
있으면 로그인 처리를 하도록 하고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것을 의미한다.

**답:** SSO (Single Sign-On)

---

### 📌 해설

#### ✅ SSO (Single Sign-On, 통합 인증)
- **한 번의 로그인으로** 여러 시스템 또는 서비스에 **자동으로 인증**되어 접근할 수 있게 해주는 인증 방식
- 사용자는 **여러 시스템에 반복적으로 로그인할 필요 없음**
- 보안성과 사용자 편의성 동시에 향상

#### 🔑 주요 특징
- 최초 로그인 시 인증 정보를 발급받고, 이후에는 각 시스템이 그 정보를 확인하여 인증
- 인증 정보는 일반적으로 **쿠키, 토큰(JWT 등), 세션 등**으로 관리됨
- 로그아웃 시 전체 시스템에서 **동시 로그아웃 처리**도 가능

#### ✅ SSO 활용 예
- Google, Naver, Facebook 등의 **외부 계정 로그인 연동**
- 기업 내부 시스템 간 SSO 연동 (메일, 인사시스템, 그룹웨어 등)

---

### 📌 관련 용어 비교

| 용어 | 설명 |
|------|------|
| **SSO** | 한 번의 인증으로 여러 시스템 자동 로그인 가능 |
| **OAuth** | 자원을 소유한 사용자 대신에 제3의 애플리케이션이 권한을 위임받아 접근할 수 있도록 해주는 인증 프로토콜 |
| **OpenID** | 사용자 인증을 위한 표준화된 식별 방식 |
| **MFA (Multi-Factor Authentication)** | 여러 인증 수단을 조합하여 인증 (예: 비밀번호 + OTP) |



---------------------------------------------------------------------------------------------------------------

## 문제 6) ER 다이어그램 기호 문제

| 기호         | 기호 이름     | 설명                         |
|--------------|---------------|------------------------------|
| ◻️ 사각형     | **개체(Entity)**     | 데이터베이스에서 독립적으로 존재할 수 있는 객체를 표현 |
| ◆ 마름모     | **관계(Relationship)** | 개체 간의 관계를 표현                     |
| ◯ 타원       | **속성(Attribute)**     | 개체 또는 관계가 가지는 성질이나 특징을 표현 |
| ◯ (밑줄)     | **기본키 속성**         | 개체를 식별할 수 있는 고유한 속성 (Primary Key) |
| ◎ 이중 타원  | **복합 속성(Composite Attribute)** | 여러 하위 속성으로 구성된 속성 |
| ─ 선         | **개체와 속성 연결**     | 개체와 그 속성을 연결하는 선             |
| ⋯⋯ 점선      | **관계 속성 연결**       | 관계와 속성을 연결할 때 사용하는 선      |

---

### 📌 ER 다이어그램 예시 구성 요소 요약

| 요소       | 예시      |
|------------|-----------|
| 개체       | 학생(Student), 강의(Course) 등 |
| 속성       | 학번(ID), 이름(Name), 학점(Grade) 등 |
| 기본키 속성 | 학번(ID) |
| 복합 속성   | 이름(Name → 성, 이름으로 구성) |
| 관계       | 수강(Takes), 신청(Enroll) 등 |

---

### 📌 시각적 요약 (간략 그림 표현)

- `□` : 개체  
- `◇` : 관계  
- `○` : 속성  
- `○ (밑줄)` : 기본키  
- `◎` : 복합 속성  
- `─` : 일반 연결선  
- `⋯⋯` : 관계-속성 연결 점선  

------------------------------------------------------------------------------------------------------------
## 문제 7) 다음은 프로세스 스케줄링에 관련된 내용이다. 괄호에 알맞은 답을 작성하시오.

(1) 선점형 스케줄링 기법으로 CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식  
(2) 시간 단위를 정해서 프로세스를 순서대로 CPU를 할당하는 방식  
(3) 비선점형 스케줄링 기법으로 실행 기간이 가장 짧은 프로세스에게 CPU를 할당하는 방식  

**답:**  
1) **SRT** (Shortest Remaining Time First)  
2) **RR** (Round Robin)  
3) **SJF** (Shortest Job First)  

---

### 📌 해설

#### (1) SRT (Shortest Remaining Time First)
- **선점형 스케줄링**  
- 프로세스들의 **남은 실행 시간(Remain Time)**이 가장 짧은 프로세스에게 CPU를 할당  
- 새로 도착한 프로세스의 남은 시간이 현재 실행 중인 프로세스보다 짧을 경우, **선점 발생**
- SJF의 **선점형 버전**

#### (2) RR (Round Robin)
- **선점형 스케줄링**  
- 각 프로세스에 정해진 시간(Time Quantum)만큼 CPU를 순차적으로 할당  
- 시간이 초과되면 다음 프로세스로 넘어가며 **공정성 보장**
- 시분할 시스템에서 많이 사용

#### (3) SJF (Shortest Job First)
- **비선점형 스케줄링**  
- 대기 중인 프로세스 중에서 **실행 시간이 가장 짧은** 프로세스를 먼저 실행  
- 평균 대기 시간 최소화 가능  
- 단점: 긴 프로세스가 무한히 기다리는 **기아 현상** 발생 가능

---

### 📌 스케줄링 기법 요약

| 구분        | 기법                         | 설명 |
|-------------|------------------------------|------|
| **선점형**   | **Round Robin (RR)**         | 시간 할당량 기준 순환 실행 |
|             | **SRT**                      | 남은 실행 시간이 가장 짧은 프로세스 우선 |
|             | **MLQ (다단계 큐)**           | 우선순위 큐에 따라 분리, 선점 가능 |
|             | **MLFQ (다단계 피드백 큐)**    | 동적으로 큐 이동, 우선순위 조정 가능 |
| **비선점형** | **FCFS (First Come First Serve)** | 먼저 도착한 순서대로 실행 |
|             | **SJF**                      | 실행 시간이 가장 짧은 프로세스 우선 |
|             | **HRN**                      | 응답률이 높은 프로세스부터 실행 |
|             | **우선순위 스케줄링**         | 우선순위 기준 실행 |
|             | **기한부 스케줄링**           | 마감 시간이 임박한 순서로 실행 |

---

---------------------------------------------------------------------------------------------------------------
## 문제 8)  
192.168.1.0/24 네트워크를 FLSM 방식으로 3개의 서브넷으로 나눴을 때,  
**두 번째 네트워크의 브로드캐스트 IP를 쓰시오.**  

**답:** 192.168.1.127  

---

### 📌 해설

#### ✅ FLSM (Fixed Length Subnet Mask)
- **모든 서브넷이 동일한 크기**로 나뉘는 방식
- 동일한 서브넷 마스크 사용

#### ✅ 문제 분석

- 원래 네트워크: `192.168.1.0/24` (256개 주소)
- 3개의 동일한 크기의 서브넷으로 분할해야 함
  - 가장 가까운 2ⁿ 중 3개 이상을 만족하는 값 = **2³ = 8** (즉, 8개의 서브넷이 생성됨)
  - 따라서 **서브넷당 32개 주소** 필요 (256 ÷ 8 = 32)
  - 하나의 서브넷 크기: **2⁵ = 32 → 서브넷 마스크는 /27**
    - 즉, 각 서브넷은 32개 주소 (30개 사용 가능 주소, 1개 네트워크, 1개 브로드캐스트)

#### ✅ 각 서브넷 범위 (/27 기준)

| 서브넷 번호 | 네트워크 주소     | 브로드캐스트 주소    | 사용 가능 IP 범위            |
|-------------|-------------------|-----------------------|------------------------------|
| 1           | 192.168.1.0/27    | 192.168.1.31          | 192.168.1.1 ~ 192.168.1.30   |
| 2           | 192.168.1.32/27   | **192.168.1.63**      | 192.168.1.33 ~ 192.168.1.62  |
| 3           | 192.168.1.64/27   | **192.168.1.95**      | 192.168.1.65 ~ 192.168.1.94  |
| 4           | 192.168.1.96/27   | 192.168.1.127         | 192.168.1.97 ~ 192.168.1.126 |
| ...         | ...               | ...                   | ...                          |

> ❗ 하지만 문제에서 말한 "두 번째 네트워크"는 **3개로 나눈 것 중 2번째**를 의미  
> 전체를 3개의 동일 크기 서브넷으로 나누면:

- 256 ÷ 3 = 약 85개씩 필요 (가장 가까운 2⁷ = 128)
- **FLSM은 2ⁿ 크기만 가능하므로 128씩 할당 (총 2개의 /25, 1개의 /26 사용) 불가**
- 따라서 **FLSM으로는 4개의 /26 서브넷 (64개씩)** 만들어야 함

#### ✅ 정답 다시 정리 (FLSM으로 3개 만들 때는 /26 사용)

| 서브넷 번호 | 네트워크 주소     | 브로드캐스트 주소    | 사용 가능 IP 범위           |
|-------------|-------------------|-----------------------|-----------------------------|
| 1           | 192.168.1.0/26    | 192.168.1.63          | 192.168.1.1 ~ 192.168.1.62  |
| 2           | 192.168.1.64/26   | **192.168.1.127**     | 192.168.1.65 ~ 192.168.1.126 |
| 3           | 192.168.1.128/26  | 192.168.1.191         | 192.168.1.129 ~ 192.168.1.190 |

✔️ **정답: `192.168.1.127` (두 번째 /26 서브넷의 브로드캐스트 주소)**

---

---------------------------------------------------------------------------------------------------------------
## 문제 9) 아래 설명에 대한 알맞은 답을 작성하시오

(1) 기술적인 방법이 아닌 사람들 간의 기본적인 신뢰를 기반으로 사람을 속여 비밀 정보를 획득하는 기법  
(2) 기업이 정보를 수집한 후, 저장만 하고 분석에 활용하고 있지 않은 다량의 데이터

**답:**  
1) 사회 공학  
2) 다크 데이터

---

📌 **관련 개념 설명**

- **사회 공학(Social Engineering)**:  
  보안 시스템의 기술적인 약점이 아닌 **사람의 심리적 취약점**을 이용하여 비밀 정보를 얻는 해킹 기법이다.  
  예시로는 피싱(Phishing), 스미싱(Smishing), 전화 사기 등이 있다.

- **다크 데이터(Dark Data)**:  
  조직이 수집하거나 저장했지만, **분석하거나 활용하지 않는 데이터**를 의미한다.  
  저장만 되어 있고 가치는 창출하지 못하며, 보안 위협 및 저장 비용을 증가시킬 수 있다.

---------------------------------------------------------------------------------------------------------------
## 문제 10) 아래 설명에 대한 알맞은 답을 작성하시오

- 네트워크 하드웨어 및 응용 프로그램에 의해 생성된 보안경고의 실시간 분석을 제공한다.  
- 빅데이터 수준의 데이터를 장시간 심층 분석한 인덱싱 기반이다.  
- 주요 기능은 데이터 통합, 상관관계, 알림, 대시보드

**답:** SIEM

---

### 보안 솔루션 정리

- **방화벽(Firewall)**  
  네트워크 간에 전송되는 정보를 선별하는 기능을 가진 침입 차단 시스템

- **웹방화벽(Web Application Firewall, WAF)**  
  웹 기반 공격을 방어할 목적으로 만들어진 웹서버 특화 방화벽

- **침입탐지 시스템(IDS, Intrusion Detection System)**  
  컴퓨터 시스템의 비정상적인 사용, 오용 등을 실시간으로 탐지하는 시스템  
  - 이상 탐지  
  - 오용 탐지

- **침입방지 시스템(IPS, Intrusion Prevention System)**  
  방화벽과 침입탐지 시스템을 결합한 시스템

- **데이터 유출 방지(DLP, Data Loss Prevention)**  
  내부 정보의 유출을 방지하기 위한 보안 솔루션

- **NAC(Network Access Control)**  
  네트워크에 접속하는 내부 PC의 MAC 주소(고유 랜카드 주소)를 IP 관리 시스템에 등록 후 일관된 보안관리 기능 제공

- **ESM(Event Security Management)**  
  다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합 관리하는 보안 솔루션

- **SIEM(Security Information and Event Management)**  
  빅데이터 수준의 데이터를 장시간 심층 분석한 인덱싱 기반으로, 실시간 보안경고 분석 및 데이터 통합, 상관관계, 알림, 대시보드 기능 제공

- **SOAR(Security Orchestration, Automation and Response)**  
  보안 오케스트레이션, 자동화 및 대응을 통해 IT 시스템 보호하는 솔루션

- **샌드박스(Sandbox)**  
  응용 프로그램이 가상 환경에서 독립적으로 실행되는 형태

- **FDS(Fraud Detection System)**  
  전자금융거래의 이상 거래를 탐지하고 차단하는 시스템

- **프록시 서버(Proxy Server)**  
  클라이언트를 대신하여 인터넷상의 다른 서버에 접속하며, 방화벽 및 캐시 기능 수행

---------------------------------------------------------------------------------------------------------------
## 문제 11) 아래 설명에 대한 알맞은 답을 작성하시오.

(1) 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 하드웨어 기반의 보안 기술  
(2) 사용자가 사이트의 URL 주소를 입력할 때 철자를 잘못 입력하거나 빠뜨리는 실수를 이용하여, 해커가 만들어놓은 유사한 URL로 접속하도록 유도하는 공격  

**답:**  
1) TrustZone  
2) 타이포스쿼팅 (Typosquatting)

---

📌 **관련 개념 설명**

- **TrustZone**  
  ARM 프로세서 기반의 하드웨어 보안 기술로, 일반 영역과 분리된 독립적인 보안 영역을 제공하여 민감한 데이터와 코드가 안전하게 처리되도록 한다.

- **타이포스쿼팅 (Typosquatting)**  
  사용자가 URL 입력 시 철자 오류나 오타를 내는 점을 악용해, 유사한 도메인 이름을 등록하여 사용자를 가짜 사이트로 유도하는 사이버 공격 기법이다.

---------------------------------------------------------------------------------------------------------------
## 문제 12) 다음 항목에 맞는 관계대수 기호를 작성하시오

| 항목           | 기호          |
|----------------|---------------|
| 합집합         | A ∪ B         |
| 차집합         | A − B         |
| 카티션 프로덕트 | A × B         |
| 프로젝트       | π (A) B       |
| 조인           | A ⨝ B         |

---

### 관계대수 연산자

- **순수 관계 연산자**  
  - SELECT (σ)  
  - PROJECT (π)  
  - JOIN (⨝)  
  - DIVISION (÷)

- **일반 집합 연산자**  
  - 합집합 (∪)  
  - 교집합 (∩)  
  - 차집합 (−)  
  - 카티션 프로덕트 (×)

---------------------------------------------------------------------------------------------------------------
## 문제 13) 아래의 테이블에서 SQL 명령을 수행할 경우 알맞은 값을 작성하시오

### 테이블 및 데이터

```sql
create table 부서 (
  부서코드 int primary key,
  부서명 varchar(20)
);

create table 직원(
  직원코드 int primary key,
  부서코드 int,
  직원명 varchar(20),
  foreign key(부서코드) references 부서(부서코드)
    on delete cascade
);

insert into 부서(부서코드, 부서명) values (10, '영업팀');
insert into 부서(부서코드, 부서명) values (20, '개발팀');
insert into 부서(부서코드, 부서명) values (30, '기획팀');

insert into 직원(직원코드, 부서코드) values (1000, 10);
insert into 직원(직원코드, 부서코드) values (2000, 10);
insert into 직원(직원코드, 부서코드) values (3000, 10);
insert into 직원(직원코드, 부서코드) values (4000, 20);
insert into 직원(직원코드, 부서코드) values (5000, 20);
insert into 직원(직원코드, 부서코드) values (6000, 30);
insert into 직원(직원코드, 부서코드) values (7000, 30);
문제 쿼리 및 결과
SELECT DISTINCT COUNT(직원코드) FROM 직원 WHERE 부서코드 = '10';

부서코드 10에 해당하는 직원 수를 세는 쿼리

부서코드 10에 직원코드 1000, 2000, 3000이 있으므로 3

DELETE FROM 부서 WHERE 부서코드 = '10';

부서코드가 10인 부서를 삭제하면

외래키 제약조건 ON DELETE CASCADE에 의해 부서코드 10에 해당하는 직원들도 모두 삭제됨

SELECT DISTINCT COUNT(직원코드) FROM 직원;

삭제 후 직원 테이블의 직원 수를 세는 쿼리

부서코드 10에 속한 직원 3명이 삭제되어 남은 직원은 4명 (4000, 5000, 6000, 7000)

답
항목	값
(1) 부서코드 10 직원 수 조회	3
(2) 부서코드 10 삭제 후 직원 수	4


---------------------------------------------------------------------------------------------------------------

## 문제 14) STUDENT 테이블에 컴퓨터학과 학생 50명, 기계과 학생 100명, 건축과 학생 50명의 데이터가 있다.  
다음 SQL 실행 결과 튜플의 수를 작성하시오.

---

### 주어진 데이터

| 학과      | 학생 수 |
|-----------|---------|
| 컴퓨터학과 | 50      |
| 기계과    | 100     |
| 건축과    | 50      |
| **총합**   | 200     |

---

### SQL문과 결과

1. `SELECT DEPT FROM STUDENT;`  
   - 모든 학생의 학과(DEPT) 컬럼을 조회  
   - 학생 수 만큼 튜플이 반환됨  
   - **결과: 200**

2. `SELECT DISTINCT DEPT FROM STUDENT;`  
   - 중복을 제거한 학과 목록 조회  
   - 학과는 3개(컴퓨터학과, 기계과, 건축과)  
   - **결과: 3**

3. `SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT='건축과';`  
   - 조건에 맞는 학과 중복 제거 후 개수 카운트  
   - 조건 `DEPT='건축과'`에 해당하는 학과는 건축과 1개뿐  
   - **결과: 1**

---

### 답안

| 문항 | 결과 |
|------|-------|
| (1)  | 200   |
| (2)  | 3     |
| (3)  | 1     |


---------------------------------------------------------------------------------------------------------------

## 문제 15) 다음 프로그램의 출력결과를 2차원 배열 형태로 작성하시오

```c
#include <stdio.h>
static int field[4][4] = {
    {0,1,0,1},
    {0,0,0,1},
    {1,1,1,0},
    {0,1,1,1}
};
static int mines[4][4] = {
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0}
};

void calculate(int w, int h, int j, int i){
    if(i >= 0 && i < w && j >= 0 && j < h) 
        mines[i][j]++;
}

void main(){
    int x, y, j, i, w=4, h=4;
    for(y = 0; y < h; y++){
        for(x = 0; x < w; x++){
            if(field[x][y] == 0) continue;
            for(j = y-1; j <= y+1; j++){
                for(i = x-1; i <= x+1; i++){
                    calculate(w, h, j, i);
                }
            }
        }
    }

    // 출력
    for(y = 0; y < h; y++){
        for(x = 0; x < w; x++){
            printf("%d ", mines[x][y]);
        }
        printf("\n");
    }
}
문제 해설
field 배열에서 1인 칸 주변 3x3 영역에 대해 mines 배열에 +1을 한다.

field[x][y]에서 x는 열(03), y는 행(03)이며, mines[i][j]도 같은 인덱스 체계임.

각 1에 대해 주변 8칸과 자기 자신을 포함해 mines 값을 증가시킨다.

계산 과정
field의 1 위치:

(x,y) 좌표 (열,행)
(1,0), (3,0)
(3,1)
(0,2), (1,2), (2,2)
(1,3), (2,3), (3,3)

이 위치들의 주변 3x3 범위에 mines 값을 +1 한다.

최종 mines 배열 (4x4)
3	4	3	3
2	5	5	4
3	6	6	4
1	3	4	2

정리된 출력 결과 (mines 배열)
복사
편집
3 4 3 3
2 5 5 4
3 6 6 4
1 3 4 2
---------------------------------------------------------------------------------------------------------------

## 문제 16) 다음 C언어 프로그램의 출력 결과를 쓰시오

```c
int main(){
    int result[5];
    int ary[] = {77, 32, 10, 99, 50};
    for (int i = 0; i < 5; i++){
        result[i] = 1;
        for(int j = 0; j < 5; j++)
            if(ary[i] > ary[j]) 
                result[i]++;
    }
    for(int i = 0; i < 5; i++)
        printf("%d", result[i]);
}
해설
result[i]는 ary[i] 값이 배열 내에서 몇 번째로 큰지(등수)를 저장한다.

초기값 1에서 자신보다 작은 값들을 셀 때마다 1씩 증가시키는 방식이다.

i	ary[i]	비교 대상(ary[j])	ary[i] > ary[j] 개수	result[i] (= 1 + 개수)
0	77	32, 10, 99, 50	3 (32, 10, 50)	4
1	32	10	1	2
2	10	없음	0	1
3	99	77, 32, 10, 50	4	5
4	50	32, 10	2	3

출력 결과
복사
편집
24513

---------------------------------------------------------------------------------------------------------------

## 문제 17) 다음 C언어 프로그램의 출력 결과를 쓰시오

```c
int x, y;
int cnt = 0;
for(int i = 6; i <= 30; i++){
    x = 0;
    y = i / 2;
    for(int j = 1; j <= y; j++){
        if(i % j == 0)
            x = x + j;
    }
    if(x == i){
        cnt++;
    }
}
printf("%d", cnt);
해설
변수 i가 6부터 30까지 반복한다.

내부 반복문은 j가 1부터 i/2까지 돌면서, j가 i의 약수면 x에 더한다.

x는 i의 모든 약수(자기 자신 제외)의 합이 된다.

x == i이면 i는 완전수(perfect number)이다.

완전수는 자기 자신을 제외한 약수의 합이 자기 자신과 같은 수이다.

6~30 사이 완전수
6: 약수 1,2,3 합 = 6 → 완전수

28: 약수 1,2,4,7,14 합 = 28 → 완전수

따라서 cnt는 2가 된다.

출력 결과
복사
편집
2
---------------------------------------------------------------------------------------------------------------

## 문제 18) 다음 Java 프로그램의 출력 결과를 쓰시오

```java
static int[] makeAry(){
    int[] tmp = new int[4];
    for(int i = 0; i < tmp.length; i++){
        tmp[i] = i;
    }
    return tmp;
}

public static void main(String[] args){
    int[] inData = makeAry();
    for(int i = 0; i < inData.length; i++)
        System.out.print(inData[i]);
}
해설
makeAry() 메서드는 길이 4인 배열 tmp를 생성하고,
인덱스 값(i)을 그대로 배열의 각 요소에 저장함.

따라서 tmp 배열은 {0, 1, 2, 3}이 됨.

main에서 반환된 배열을 inData에 받고, 순서대로 출력함.

출력 결과는 0123이 됨.

출력 결과
yaml
복사
편집
0123
---------------------------------------------------------------------------------------------------------------
## 문제 19) 다음 Java 프로그램의 출력 결과를 쓰시오

```java
int max = 0;
for(int i = 1; i < 99; i++){
    if(i % 3 == 0 && i % 2 != 0)
        max = i;
}
System.out.print(max);
해설
i는 1부터 98까지 반복한다.

조건: i가 3의 배수이면서 짝수가 아닌(즉, 홀수인) 수를 찾는다.

조건에 맞는 수가 나오면 max에 저장한다.

반복이 끝나면 가장 큰 값이 max에 남게 된다.

3의 배수이면서 홀수인 수 (1~98 범위 내)
3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99(초과)

99는 99보다 작지 않으므로 포함 안 됨 (범위는 i < 99)

마지막 값은 93

출력 결과
복사
편집
93

---------------------------------------------------------------------------------------------------------------

## 문제 20) 다음 파이썬 코드에 대한 출력값을 작성하시오.

```python
tData = [1, 2, 3, 4, 5]
tData = list(map(lambda num: num + 100, tData))
print(tData)
해설
map() 함수는 리스트 tData의 각 요소에 람다 함수 num + 100을 적용한다.

각 요소에 100을 더한 새 리스트가 만들어진다.

출력 결과
csharp
복사
편집
[101, 102, 103, 104, 105]
---------------------------------------------------------------------------------------------------------------
  
