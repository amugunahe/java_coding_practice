## 문제 1) 다음 중 형상 관리 도구에 해당하는 것을 모두 고르시오  
Ant, CVS, OLAP, MAVEN, SVN, JENKINS, OLTP, GIT, GRADDLE  

**답:** CVS, SVN, GIT  

---

### 📌 해설:

**형상 관리(Configuration Management)**는 소프트웨어 개발 중 발생하는 **변경 사항을 체계적으로 추적하고 관리**하는 활동이야.  
이를 위해 **형상 관리 도구**를 사용해서 코드, 문서, 설정 파일 등 다양한 산출물의 버전을 관리하지.

---

#### ✅ 형상 관리 도구(Version Control Tools):

- **CVS (Concurrent Versions System)**  
  - 소스코드의 변경 이력을 기록하고 관리하는 최초의 널리 쓰인 버전 관리 도구  
  - 여러 사람이 동시에 작업해도 충돌을 관리 가능  
  - 예) 여러 개발자가 같은 파일을 편집해도 변경 이력 저장과 동기화 가능

- **SVN (Subversion)**  
  - CVS의 단점을 보완한 중앙집중형 버전 관리 시스템  
  - 트리 기반으로 저장, 충돌 해결 기능 향상  
  - 예) 한 서버에서 코드 버전을 관리하며, 각 개발자는 서버에서 최신 버전 받아 작업

- **GIT**  
  - 분산형 버전 관리 도구로 로컬에서도 완전한 이력 관리 가능  
  - 브랜치 생성과 병합이 편리해서 현재 가장 많이 쓰임  
  - 예) 로컬에서 브랜치 만들어 기능 개발 후, 원격 저장소에 병합하여 배포

---

#### ❌ 형상 관리 도구가 아닌 것들:

- **Ant**  
  - 자바 기반 빌드 자동화 도구  
  - 예) 소스 코드 컴파일, 테스트, 패키징 등을 자동으로 수행

- **MAVEN**  
  - 자바 프로젝트 의존성 관리 및 빌드 도구  
  - 예) 필요한 라이브러리를 자동 다운로드 및 프로젝트 빌드

- **GRADLE**  
  - Groovy 기반 빌드 자동화 도구  
  - 예) Android 프로젝트 빌드 시 주로 사용

- **JENKINS**  
  - 지속적 통합(CI)/지속적 배포(CD) 자동화 도구  
  - 예) 코드 푸시 시 자동으로 빌드, 테스트, 배포 수행

- **OLAP (Online Analytical Processing)**  
  - 다차원 데이터 분석용 시스템  
  - 예) 데이터 웨어하우스에서 복잡한 분석 쿼리 실행

- **OLTP (Online Transaction Processing)**  
  - 실시간 트랜잭션 처리 시스템  
  - 예) 은행의 계좌 이체, 예약 시스템 등

---

### 📌 관련 개념 설명: 형상 관리 절차

1. **형상 식별(Configuration Identification)**  
   - 관리 대상 소프트웨어 구성 요소(코드, 문서, 라이브러리 등)를 명확히 구분하고 이름을 부여  
   - 예) `v1.0`, `v1.1`, `release_candidate_2025` 같은 버전 태그 지정

2. **형상 통제(Configuration Control)**  
   - 변경 요청을 접수하고 승인 절차를 거쳐 변경 사항을 반영  
   - 예) 버그 수정, 기능 추가 요청을 검토 후 승인하여 코드에 적용

3. **형상 감사(Configuration Audit)**  
   - 변경 내역이 올바르게 반영되었는지 점검하고 문서화  
   - 예) 릴리즈 전에 변경된 코드와 문서가 일치하는지 확인

4. **형상 기록(Configuration Status Accounting)**  
   - 각 형상 항목의 이력과 상태를 기록, 관리하는 활동  
   - 예) 누가 언제 어떤 파일을 수정했는지 로그 관리

---

✅ **정리**  
- 형상 관리는 소프트웨어 개발의 변경 관리를 위한 필수 활동이며,  
- CVS, SVN, GIT 같은 도구로 버전을 관리해 개발 협업을 원활히 한다는 점!  
- 빌드 도구나 자동화 도구(예: Ant, Maven, Jenkins)는 형상 관리 도구가 아니니까 헷갈리지 말자!  

---------------------------------------------------------------------------------------------------------------
## 문제 2) 다음 디자인패턴에 대한 설명이다. 괄호 안에 알맞는 답을 작성하시오

(1) 은/는 구현부에서 추상층을 분리하여 각자 독립적으로 변형이 가능하고 확장이 가능하도록 한다.  
즉 기능과 구현에 대해서 두 개를 별도로 클래스를 구현을 한다.

(2) 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고, 자동으로 내용이 갱신되는 방식의 패턴이다.

**답:**  
(1) **Bridge**  
(2) **Observer**

---

### 📌 해설


#### (1) **Bridge 패턴**
- 목적: **추상화(Abstraction)**와 **구현부(Implementation)**를 분리해서 각각 독립적으로 확장 가능하게 함  
- 주요 특징:  
  - 기능과 구현을 완전히 분리하여 유연성 증가  
  - 추상화 객체가 구현 객체에 대해 참조를 가지고 기능을 위임  
- 사용 예 (갓반인):  
  - GUI 라이브러리에서 Windows, Mac, Linux 각각 다른 그래픽 API를 사용하는 경우  
    - 추상화: “그리기” 명령을 내리는 부분  
    - 구현부: 각 운영체제별 실제 그리기 코드  
  - 덕분에 새 운영체제가 추가되어도 추상화 계층만 유지하며 쉽게 확장 가능

---

#### (2) **Observer 패턴**
- 목적: 한 객체 상태 변화에 따라 여러 객체들이 **자동으로 알림 받고 갱신**되도록 함  
- 주요 특징:  
  - Subject(발행자)와 Observer(구독자) 관계  
  - Subject 상태 변경 시 등록된 모든 Observer에게 알림 자동 전송  
  - 느슨한 결합으로 변경 영향 최소화  
- 사용 예 (갓반인):  
  - SNS 알림: 사용자가 게시물을 올리면 팔로워들에게 자동으로 알림 전달  
  - GUI 버튼 클릭 이벤트 처리: 버튼 누르면 등록된 여러 리스너에 자동 통지  
  - MVC 패턴에서 Model이 바뀌면 View들이 자동으로 화면 갱신

---


---------------------------------------------------------------------------------------------------------------
## 문제 3) 다음 UML에 관한 설명이다. 괄호 안에 알맞는 답을 작성하시오.

UML은 컴퓨터 애플리케이션을 모델링할 수 있는 통합 언어이다.  
구성요소로는 사물, (1), 다이어그램으로 이루어져 있고, 구조 다이어그램 중 (2) 다이어그램은  
객체들의 타입을 정의하고, 객체들 간의 관계를 도식화하여 시스템의 특정 모듈이나 일부 및 전체를 구조화한다.  
UML 모델링에서 (3)는 클래스와 같은 기타 모델 요소 또는 컴포넌트가 구현해야 하는  
오퍼레이션 세트를 정의하는 모델 요소이다.  

**답:**  
1) 관계  
2) 클래스  
3) 인터페이스  

---

### 📌 해설

#### (1) 관계 (Relationship)
- UML의 기본 요소는 크게 3가지로 나뉘어  
  - **사물(Thing)**: 모델링 대상의 기본 단위 (예: 클래스, 인터페이스, 컴포넌트)  
  - **관계(Relationship)**: 사물들 간의 연결이나 의존성 표현  
  - **다이어그램(Diagram)**: 사물과 관계를 시각적으로 표현한 그림  
- 주요 관계 유형 (갓반인 예시 포함):  
  - **일반화 관계 (Generalization)**: 상속 관계, 예) 클래스 A가 클래스 B를 상속함 (`A → B`)  
  - **연관 관계 (Association)**: 두 클래스가 서로 기능을 사용할 때, 예) 고객(Customer)과 주문(Order)이 서로 연결됨  
  - **의존 관계 (Dependency)**: 메서드 실행 시 임시로 다른 클래스를 사용하는 경우, 예) 메서드 안에서 다른 클래스 객체를 잠깐 사용  
  - **실체화 관계 (Realization)**: 클래스가 인터페이스를 구현할 때, 예) 클래스가 `Runnable` 인터페이스 구현  
  - **집약/합성 관계 (Aggregation/Composition)**: 포함 관계  
    - 집약: 부품이 독립적으로 존재 가능, 예) 자동차와 타이어 (타이어는 자동차 없이도 존재 가능)  
    - 합성: 부품 생명주기가 포함하는 객체에 의존, 예) 집과 방 (방은 집 없이는 의미 없음)

---

#### (2) 클래스 다이어그램 (Class Diagram)
- 시스템 구조를 클래스 중심으로 표현  
- 각 클래스의 **속성**, **메서드**, 그리고 **클래스 간 관계**를 명확히 나타냄  
- 예) 은행 시스템에서 `계좌(Account)`, `고객(Customer)`, `거래(Transaction)` 클래스를 그리고 이들 간 관계를 연결  
- 정적인 시스템 구조를 한눈에 볼 수 있음

---

#### (3) 인터페이스 (Interface)
- 클래스나 컴포넌트가 구현해야 하는 **메서드 선언 집합**  
- 직접 구현은 없고, **구현체가 해당 메서드를 작성함**  
- UML 표기법: `<<interface>>` 라벨로 표시  
- 예) `Comparable` 인터페이스는 `compareTo()` 메서드 선언만 포함, 이를 구현한 클래스들이 실제 비교 로직을 구현함

---

### 📌 추가 정리: UML 다이어그램 종류 예시

| 유형       | 다이어그램 종류                                   | 설명 및 예시                                   |
|------------|-------------------------------------------------|----------------------------------------------|
| 구조적 다이어그램  | 클래스 다이어그램, 객체 다이어그램, 컴포넌트 다이어그램, 배치 다이어그램 | 시스템의 정적인 구조와 관계 표현              |
| 행위적 다이어그램  | 유스케이스 다이어그램, 순서 다이어그램, 상태 다이어그램, 활동 다이어그램 | 시스템 동작, 이벤트, 상태 변화 등을 모델링    |

---

### 📌 유스케이스 다이어그램 관계

| 관계 종류 | 설명                                  | 갓반인 예시                             |
|-----------|-------------------------------------|--------------------------------------|
| 연관 관계 | 액터(actor)와 유스케이스 간 상호작용 | 사용자 → 로그인 기능                   |
| 포함 관계 (include) | 반드시 수행되어야 하는 하위 유스케이스 포함 | 로그인 시 “비밀번호 확인” 기능 포함     |
| 확장 관계 (extend) | 조건 만족 시 확장적으로 실행되는 유스케이스 | 로그인 실패 시 “비밀번호 재설정” 기능 확장 |

---


---------------------------------------------------------------------------------------------------------------

## 문제 4) 아래 점수에 따라 점수를 출력하는 테스트를 진행하려고 한다.  
다음과 같은 테스트 입력 값을 넣을 때의 테스트 방식을 쓰시오

| 점수 구간   | 금액    | 테스트 입력값 |
|-------------|--------|----------------|
| 90~100      | 700만원 | (2)            |
| 80~89       | 500만원 | (3)            |
| 70~79       | 300만원 | (4)            |
| 0~69        | 0만원   | (5)            |

**테스트 입력값:**  
`-1, 0, 1, 68, 69, 70, 99, 100, 101`

**답:** **경계값 분석 (Boundary Value Analysis)**

---

### 📌 해설

#### ✅ 경계값 분석 (Boundary Value Analysis)
- **무엇?**  
  블랙박스 테스트 기법 중 하나로, 입력값의 **경계(최솟값, 최댓값, 임계값 등)** 근처에서 발생하는 오류를 집중적으로 찾는 방법  
- **왜?**  
  경계 부근에서 버그가 자주 생기기 때문에 여기 집중해서 테스트함  
- **어떻게?**  
  각 구간의 **시작점, 끝점, 바로 전후 값**을 꼼꼼히 테스트함  
- **예시 (갓반인)**  
  만약 점수 구간이 0~69, 70~100 이라면,  
  - 0 바로 앞(-1), 0, 1  
  - 69, 70, 71  
  - 100, 101 같은 값들을 테스트해서 오류가 있는지 본다  

---

#### ✅ 동등 분할 기법 (Equivalence Partitioning)
- **무엇?**  
  입력값을 비슷한 특징끼리 묶어 구간(분할)으로 나누고, 각 구간에서 대표값 한두 개만 테스트하는 방법  
- **왜?**  
  비슷한 값은 같은 동작을 하므로 대표값만 테스트해도 충분하다는 아이디어  
- **어떻게?**  
  예를 들어 점수가 0~69, 70~100 두 구간이면, 각각 구간 내 아무 숫자 하나씩만 테스트  
- **예시 (갓반인)**  
  50 (0~69 구간 대표값), 85 (70~100 구간 대표값) 이렇게 테스트  

---

#### ✅ 원인-효과 그래프 검사 (Cause-Effect Graphing)
- **무엇?**  
  입력 조건(원인)과 결과(효과)를 논리적으로 그래프로 모델링해서 테스트 케이스를 도출하는 기법  
- **왜?**  
  복잡한 조건들을 명확하게 파악하고, 빠뜨림 없이 테스트를 설계하기 위해  
- **어떻게?**  
  논리 관계(AND, OR 등)를 도식화해서 가능한 입력 조합을 확인  
- **예시 (갓반인)**  
  “회원이고, 결제 완료 상태면 배송 시작” 같은 조건을 그래프로 그려서 테스트 케이스 만듦  

---

#### ✅ 오류 예측 기법 (Error Guessing)
- **무엇?**  
  경험과 직관을 바탕으로 오류가 잘 발생할 만한 값을 예상해 테스트하는 방법  
- **왜?**  
  개발자나 테스터가 과거 경험으로 문제될 만한 부분을 찾아내기 위함  
- **어떻게?**  
  평소에 문제 많았던 입력값, 경계값, 비정상 입력 등을 직접 넣어봄  
- **예시 (갓반인)**  
  빈 문자열, 아주 큰 수, 특수문자, NULL 값 넣어보기  

---

#### ✅ 비교 검사 (Comparison Testing)
- **무엇?**  
  두 시스템 혹은 두 버전의 결과를 비교해 차이점을 찾아내는 테스트 기법  
- **왜?**  
  변경 후 기능이 제대로 동작하는지 빠르게 검증하기 위해  
- **어떻게?**  
  이전 버전 결과와 새 버전 결과를 자동 혹은 수동으로 비교  
- **예시 (갓반인)**  
  A버전과 B버전 계산 결과가 같은지, 웹 페이지 출력이 동일한지 비교  

---

### 📌 정리

| 기법                | 핵심 포인트                          | 갓반인 예시                      |
|---------------------|-----------------------------------|---------------------------------|
| 경계값 분석          | 경계값 전후 입력 집중 테스트       | 점수 69, 70, 71                |
| 동등 분할 기법       | 입력값 구간 나누고 대표값만 테스트 | 50점, 85점                      |
| 원인-효과 그래프 검사 | 입력과 출력 논리 그래프화           | “회원이고 결제완료면 배송시작”  |
| 오류 예측 기법       | 경험으로 오류 예상 값 테스트        | 빈 문자열, 특수문자, NULL 입력  |
| 비교 검사           | 두 결과를 비교하여 차이점 찾기       | 이전버전과 새버전 출력 비교      |


---------------------------------------------------------------------------------------------------------------

## 문제 5) 아래에 설명하는 용어를 작성하시오

여러 개의 사이트에서 한 번의 로그인으로 여러 가지 다른 사이트들을 자동적으로 접속하여 이용하는 방법을 말한다.  
하나의 시스템에서 인증을 할 경우 타 시스템에서는 인증 정보가 있는지 확인하고,  
있으면 로그인 처리를 하도록 하고, 없는 경우 다시 통합 인증을 할 수 있도록 만드는 것을 의미한다.

**답:** SSO (Single Sign-On)

---

### 📌 해설

#### ✅ SSO (Single Sign-On, 통합 인증)
- **무엇?**  
  한 번 로그인하면 여러 시스템이나 서비스에 **자동으로 로그인**할 수 있게 해주는 인증 방식  
- **왜?**  
  매번 다른 시스템에 반복 로그인하는 번거로움을 없애고, 보안도 챙기기 위해  
- **어떻게?**  
  최초 로그인 시 인증 토큰(쿠키, JWT, 세션 등)을 받아서, 다른 시스템들은 이 토큰을 확인해 인증 처리함  
- **예시 (갓반인)**  
  회사 이메일에 로그인하면, 같은 회사의 그룹웨어, 사내 인사 시스템도 별도 로그인 없이 바로 접근 가능  

---

#### 🔑 주요 특징
- 최초 로그인 후 인증 정보를 발급받음  
- 인증 정보는 **쿠키, 토큰, 세션** 등으로 관리  
- 로그아웃 시 모든 연동 시스템에서 동시 로그아웃 처리 가능  
- 사용자 편의성과 보안성 동시에 향상  

---

#### ✅ SSO 활용 예 (갓반인)
- Google 계정으로 Gmail, YouTube, Google Drive 한 번에 로그인  
- Naver 계정으로 네이버 쇼핑, 블로그, 카페 등 여러 서비스 자동 로그인  
- 기업 내부 메일, 인사시스템, 그룹웨어가 SSO로 연결되어 하나의 로그인으로 모든 시스템 이용  

---

### 📌 관련 용어 비교

| 용어               | 설명                                               | 갓반인 예시                              |
|--------------------|--------------------------------------------------|---------------------------------------|
| **SSO**            | 한 번 인증하면 여러 시스템 자동 로그인 가능         | 회사 시스템 여러 개, 구글 서비스 여러 개 한 번에 로그인 |
| **OAuth**          | 사용자를 대신해 제3자 애플리케이션에 권한 위임       | "내 페이스북 사진 앱이 내 사진을 볼 수 있도록 허용"  |
| **OpenID**         | 사용자 인증을 위한 표준 식별 방식                    | 여러 사이트에서 “Google 계정으로 로그인” 버튼 눌러 인증  |
| **MFA (다중 인증)** | 여러 인증 수단(비밀번호+OTP 등)을 조합해 인증 강화  | 은행 로그인 시 비밀번호 + 휴대폰 문자번호 입력 |



---------------------------------------------------------------------------------------------------------------

## 문제 6) ER 다이어그램 기호 문제

| 기호         | 기호 이름     | 설명                         |
|--------------|---------------|------------------------------|
| ◻️ 사각형     | **개체(Entity)**     | 데이터베이스에서 독립적으로 존재할 수 있는 객체를 표현 |
| ◆ 마름모     | **관계(Relationship)** | 개체 간의 관계를 표현                     |
| ◯ 타원       | **속성(Attribute)**     | 개체 또는 관계가 가지는 성질이나 특징을 표현 |
| ◯ (밑줄)     | **기본키 속성**         | 개체를 식별할 수 있는 고유한 속성 (Primary Key) |
| ◎ 이중 타원  | **복합 속성(Composite Attribute)** | 여러 하위 속성으로 구성된 속성 |
| ─ 선         | **개체와 속성 연결**     | 개체와 그 속성을 연결하는 선             |
| ⋯⋯ 점선      | **관계 속성 연결**       | 관계와 속성을 연결할 때 사용하는 선      |

---

### 📌 ER 다이어그램 예시 구성 요소 요약

| 요소       | 예시      |
|------------|-----------|
| 개체       | 학생(Student), 강의(Course) 등 |
| 속성       | 학번(ID), 이름(Name), 학점(Grade) 등 |
| 기본키 속성 | 학번(ID) |
| 복합 속성   | 이름(Name → 성, 이름으로 구성) |
| 관계       | 수강(Takes), 신청(Enroll) 등 |

---

### 📌 시각적 요약 (간략 그림 표현)

- `□` : 개체  
- `◇` : 관계  
- `○` : 속성  
- `○ (밑줄)` : 기본키  
- `◎` : 복합 속성  
- `─` : 일반 연결선  
- `⋯⋯` : 관계-속성 연결 점선  

------------------------------------------------------------------------------------------------------------
## 문제 7) 다음은 프로세스 스케줄링에 관련된 내용이다. 괄호에 알맞은 답을 작성하시오.

(1) 선점형 스케줄링 기법으로 CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식  
(2) 시간 단위를 정해서 프로세스를 순서대로 CPU를 할당하는 방식  
(3) 비선점형 스케줄링 기법으로 실행 기간이 가장 짧은 프로세스에게 CPU를 할당하는 방식  

**답:**  
1) **SRT** (Shortest Remaining Time First)  
2) **RR** (Round Robin)  
3) **SJF** (Shortest Job First)  

---

### 📌 해설

#### (1) SRT (Shortest Remaining Time First)
- **무엇?**  
  남은 실행 시간이 가장 짧은 프로세스에게 CPU를 주는 **선점형 스케줄링**  
- **특징**  
  새 프로세스가 도착했을 때, 현재 실행 중인 프로세스보다 남은 시간이 짧으면 바로 선점함  
- **갓반인 예시**  
  실행 중인 프로세스가 10초 남았는데, 새로 들어온 프로세스가 3초면 바로 3초짜리 프로세스 실행 시작

---

#### (2) RR (Round Robin)
- **무엇?**  
  프로세스마다 정해진 시간(타임 퀀텀)을 돌아가며 주는 **선점형 스케줄링**  
- **특징**  
  순서대로 일정 시간씩 CPU 할당 → 시간이 다 되면 다음 프로세스에 넘김 → 공정성 보장  
- **갓반인 예시**  
  4개의 프로세스가 있는데 각자 2초씩 CPU 쓰고 돌아가며 실행하는 모습

---

#### (3) SJF (Shortest Job First)
- **무엇?**  
  실행 시간이 가장 짧은 프로세스를 먼저 실행하는 **비선점형 스케줄링**  
- **특징**  
  평균 대기시간이 최소화되지만, 긴 작업이 계속 대기하는 기아 현상 발생 가능  
- **갓반인 예시**  
  대기 중인 작업 중 2초짜리가 10초짜리보다 먼저 실행되는 상황

---

### 📌 스케줄링 기법 요약

| 구분       | 기법                       | 설명                                    | 갓반인 예시                             |
|------------|----------------------------|---------------------------------------|---------------------------------------|
| **선점형** | **Round Robin (RR)**       | 각 프로세스에 시간 할당량을 정해 순환 실행 | 4개 프로세스가 2초씩 돌아가면서 CPU 사용 |
|            | **SRT**                    | 남은 실행 시간이 가장 짧은 프로세스 우선  | 10초 남은 작업 중 새로 3초짜리가 들어오면 즉시 교체 |
|            | **MLQ (다단계 큐)**         | 우선순위별 여러 큐로 나눠 실행, 선점 가능  | 긴급 작업은 높은 우선순위 큐에서 먼저 실행 |
|            | **MLFQ (다단계 피드백 큐)** | 작업 특성에 따라 우선순위 동적 조정       | CPU 많이 쓴 작업은 낮은 우선순위 큐로 이동 |
| **비선점형**| **FCFS (선입선출)**          | 먼저 도착한 작업부터 실행                  | 먼저 들어온 순서대로 작업 처리               |
|            | **SJF**                    | 실행 시간이 가장 짧은 작업 먼저 실행       | 2초 작업이 10초 작업보다 먼저 실행             |
|            | **HRN (응답률 우선)**       | 대기 시간 대비 실행 시간 비율 높은 작업 우선  | 오래 기다린 짧은 작업이 우선 처리             |
|            | **우선순위 스케줄링**        | 우선순위 높은 작업 우선 처리               | 긴급한 작업을 먼저 실행                       |
|            | **기한부 스케줄링**          | 마감 임박 작업 먼저 처리                   | 마감 10분 전 작업이 1시간 작업보다 우선        |


---------------------------------------------------------------------------------------------------------------
## 문제 8)  
192.168.1.0/24 네트워크를 FLSM 방식으로 3개의 서브넷으로 나눴을 때,  
**두 번째 네트워크의 브로드캐스트 IP를 쓰시오.**  

**답:** 192.168.1.127  

---

### 📌 해설

#### ✅ FLSM (Fixed Length Subnet Mask)
- **모든 서브넷이 동일한 크기**로 나뉘는 방식  
- 동일한 서브넷 마스크를 사용하여 균등하게 분할  
- **갓반인 예시:**  
  회사 네트워크 192.168.1.0/24를 4개로 쪼갤 때, 모두 /26(64개 IP씩) 크기로 나눠서 균등하게 사용함

---

#### ✅ 문제 분석

- 원래 네트워크: `192.168.1.0/24` → 총 256개 IP 주소  
- 3개의 동일한 크기 서브넷으로 분할해야 함  
- FLSM은 2의 제곱수 크기 단위로 나누기 때문에  
- 3개를 만족하는 가장 가까운 2ⁿ은 8 (2³ = 8), 즉 8개의 서브넷으로 나누게 됨  
- 따라서 실제로는 8개의 서브넷으로 나누며, 각 서브넷 크기는 256 ÷ 8 = 32개 주소 (서브넷 마스크 /27)  
- 하지만 문제에서 “3개의 서브넷 중 2번째 네트워크”를 물었으므로, 보통 3개로 나눴을 때 두 번째 범위 찾기 → FLSM 적용 시 /26 단위로 생각하는 게 더 일반적임

---

#### ✅ 각 서브넷 범위 (/27 기준 - 8개 서브넷 예시)

| 서브넷 번호 | 네트워크 주소   | 브로드캐스트 주소 | 사용 가능 IP 범위           |
|-------------|-----------------|-------------------|----------------------------|
| 1           | 192.168.1.0/27  | 192.168.1.31      | 192.168.1.1 ~ 192.168.1.30 |
| 2           | 192.168.1.32/27 | 192.168.1.63      | 192.168.1.33 ~ 192.168.1.62|
| 3           | 192.168.1.64/27 | 192.168.1.95      | 192.168.1.65 ~ 192.168.1.94|
| ...         | ...             | ...               | ...                        |

- **갓반인 예시:**  
  IP 192.168.1.45는 2번째 서브넷에 속함 (32~63 구간)

---

#### ✅ 각 서브넷 범위 (/26 기준 - 4개 서브넷 예시)

| 서브넷 번호 | 네트워크 주소   | 브로드캐스트 주소 | 사용 가능 IP 범위            |
|-------------|-----------------|-------------------|-----------------------------|
| 1           | 192.168.1.0/26  | 192.168.1.63      | 192.168.1.1 ~ 192.168.1.62  |
| 2           | 192.168.1.64/26 | **192.168.1.127** | 192.168.1.65 ~ 192.168.1.126|
| 3           | 192.168.1.128/26| 192.168.1.191     | 192.168.1.129 ~ 192.168.1.190|

- **갓반인 예시:**  
  IP 192.168.1.100은 2번째 서브넷에 속함 (64~127 구간)

---

### ✅ 최종 정답 및 요약

- 문제에서 묻는 “두 번째 네트워크의 브로드캐스트 주소”는  
- 3개로 나눌 때 **/26 기준 두 번째 서브넷의 브로드캐스트 주소인 `192.168.1.127`** 이 맞음

---

### 📌 정리 표

| 항목          | 값                | 갓반인 예시 설명                         |
|---------------|-------------------|----------------------------------------|
| 네트워크 주소  | 192.168.1.64/26   | 두 번째 서브넷 시작 주소 (64)           |
| 브로드캐스트 주소 | 192.168.1.127     | 두 번째 서브넷 끝 주소                   |
| 사용 가능 IP 범위 | 192.168.1.65 ~ 192.168.1.126 | IP 192.168.1.100은 여기 속함           |


---------------------------------------------------------------------------------------------------------------
## 문제 9) 아래 설명에 대한 알맞은 답을 작성하시오

(1) 기술적인 방법이 아닌 사람들 간의 기본적인 신뢰를 기반으로 사람을 속여 비밀 정보를 획득하는 기법  
(2) 기업이 정보를 수집한 후, 저장만 하고 분석에 활용하고 있지 않은 다량의 데이터

**답:**  
1) 사회 공학  
2) 다크 데이터

---

### 📌 관련 개념 설명

#### ✅ 사회 공학 (Social Engineering)
- **정의:**  
  보안 시스템의 기술적 취약점이 아닌, **사람의 심리적 약점**을 이용해 정보를 빼내는 해킹 방법  
- **갓반인 예시:**  
  - **피싱 (Phishing):** 가짜 은행 사이트로 유도해 로그인 정보 훔치기  
  - **스미싱 (Smishing):** 문자 메시지로 악성 링크 보내 개인정보 탈취  
  - **전화 사기:** 상담원 흉내 내서 비밀번호나 계좌번호 알아내기

---

#### ✅ 다크 데이터 (Dark Data)
- **정의:**  
  기업이나 조직이 수집·저장은 했지만 **분석하거나 활용하지 않는 데이터**  
- **갓반인 예시:**  
  - 오래된 로그 파일, 사용하지 않는 센서 데이터  
  - 보안 취약점이 될 수 있고 저장 비용만 발생시키는 쓸모없는 데이터  
  - 예를 들어, 지난 해의 고객 상담 기록 중 분석하지 않고 그냥 쌓여있는 자료

---

---------------------------------------------------------------------------------------------------------------
## 문제 10) 아래 설명에 대한 알맞은 답을 작성하시오

- 네트워크 하드웨어 및 응용 프로그램에 의해 생성된 보안경고의 실시간 분석을 제공한다.  
- 빅데이터 수준의 데이터를 장시간 심층 분석한 인덱싱 기반이다.  
- 주요 기능은 데이터 통합, 상관관계, 알림, 대시보드

**답:** SIEM

---

### 📌 보안 솔루션 정리

#### ✅ 방화벽 (Firewall)
- **정의:**  
  네트워크 간에 오가는 데이터를 **선별하여 차단 또는 허용**하는 보안 장치  
- **갓반인 예시:**  
  집 문지기처럼, 외부에서 들어오는 나쁜 사람(해커) 출입 막기

---

#### ✅ 웹방화벽 (Web Application Firewall, WAF)
- **정의:**  
  웹 서버에 특화된 방화벽으로 **웹 기반 공격(예: SQL 인젝션, 크로스 사이트 스크립팅 등)** 차단  
- **갓반인 예시:**  
  웹사이트에 들어오는 악성 요청만 골라내서 차단하는 보안 요원

---

#### ✅ 침입탐지 시스템 (IDS, Intrusion Detection System)
- **정의:**  
  시스템에서 이상 징후를 **실시간 탐지**하는 시스템  
- **탐지 방법:**  
  - **이상 탐지:** 정상 패턴과 다른 행동 감지  
  - **오용 탐지:** 알려진 공격 시그니처 기반 탐지  
- **갓반인 예시:**  
  CCTV가 이상 행동 발견하면 경고음 울려서 알려주는 역할

---

#### ✅ 침입방지 시스템 (IPS, Intrusion Prevention System)
- **정의:**  
  IDS 기능에 **자동 차단 기능**이 추가된 시스템  
- **갓반인 예시:**  
  이상 행동 발견하면 바로 문 잠그고 출입 차단하는 보안 시스템

---

#### ✅ 데이터 유출 방지 (DLP, Data Loss Prevention)
- **정의:**  
  내부에서 외부로 **중요 데이터가 빠져나가지 않도록 막는 솔루션**  
- **갓반인 예시:**  
  회사 비밀 문서가 이메일이나 USB로 무단 유출되는 것 막는 보안 요원

---

#### ✅ NAC (Network Access Control)
- **정의:**  
  네트워크 접속 시 **접속하는 장비의 MAC 주소를 등록/관리**하여 보안 통제  
- **갓반인 예시:**  
  출입증 확인하고 승인된 사람만 사무실 들어가게 하는 출입 관리 시스템

---

#### ✅ ESM (Event Security Management)
- **정의:**  
  여러 보안 장비에서 발생하는 **로그와 이벤트를 통합 관리**하는 시스템  
- **갓반인 예시:**  
  여러 CCTV 화면을 한 화면에서 모니터링하며 사건을 추적하는 보안 관제실

---

#### ✅ SIEM (Security Information and Event Management)
- **정의:**  
  빅데이터 분석 기반으로 **실시간 보안 경고, 로그 통합, 이상 징후 탐지**를 수행하는 솔루션  
- **갓반인 예시:**  
  모든 CCTV 녹화본과 센서 정보를 분석해 이상 징후를 조기에 알려주는 인공지능 보안관

---

#### ✅ SOAR (Security Orchestration, Automation and Response)
- **정의:**  
  여러 보안 시스템을 **자동으로 연결하고 대응 절차를 실행하는 솔루션**  
- **갓반인 예시:**  
  알람 울리면 자동으로 출동 명령 내리고 현장 상황 보고까지 처리하는 스마트 보안 시스템

---

#### ✅ 샌드박스 (Sandbox)
- **정의:**  
  프로그램을 **가상 독립 환경에서 실행해 안전성 검사**를 하는 기술  
- **갓반인 예시:**  
  의심스러운 손님을 별도의 대기실에 넣어 행동 관찰하는 보안 요원

---

#### ✅ FDS (Fraud Detection System)
- **정의:**  
  전자금융 거래에서 **이상 거래를 탐지하고 차단**하는 시스템  
- **갓반인 예시:**  
  카드 이상 사용 감지해서 바로 차단하는 은행 보안 시스템

---

#### ✅ 프록시 서버 (Proxy Server)
- **정의:**  
  클라이언트를 대신해 인터넷 서버와 통신하며, **방화벽 및 캐시 기능** 수행  
- **갓반인 예시:**  
  회사 직원 대신 인터넷에 접속해 검열하고, 자주 쓰는 페이지는 미리 저장해 빠르게 보여주는 대리인

---

---------------------------------------------------------------------------------------------------------------
## 문제 11) 아래 설명에 대한 알맞은 답을 작성하시오.

(1) 독립적인 보안 구역을 따로 두어 중요한 정보를 보호하는 하드웨어 기반의 보안 기술  
(2) 사용자가 사이트의 URL 주소를 입력할 때 철자를 잘못 입력하거나 빠뜨리는 실수를 이용하여, 해커가 만들어놓은 유사한 URL로 접속하도록 유도하는 공격  

**답:**  
1) TrustZone  
2) 타이포스쿼팅 (Typosquatting)

---

📌 **관련 개념 설명**

#### ✅ TrustZone  
- **정의:**  
  ARM 프로세서에서 제공하는 **하드웨어 기반 보안 기술**  
- **주요 특징:**  
  - 일반 실행 환경(Non-secure world)과 보안 실행 환경(Secure world)을 분리  
  - 민감한 데이터, 키, 암호화 코드 등을 안전하게 보호  
- **갓반인 예시:**  
  스마트폰 안에 ‘비밀 금고’가 따로 있어서 중요한 정보만 그 안에서 안전하게 처리하는 시스템

---

#### ✅ 타이포스쿼팅 (Typosquatting)  
- **정의:**  
  사용자가 URL을 입력할 때 자주 하는 오타나 철자 실수를 노려서  
  비슷한 도메인 이름을 미리 등록해 놓고 사용자들을 **가짜 사이트로 유도하는 공격**  
- **갓반인 예시:**  
  ‘naver.com’을 ‘navar.com’처럼 오타 낸 걸 보고 가짜 네이버 사이트로 낚는 사기꾼

---


---------------------------------------------------------------------------------------------------------------
## 문제 12) 다음 항목에 맞는 관계대수 기호를 작성하시오

| 항목           | 기호          |
|----------------|---------------|
| 합집합         | A ∪ B         |
| 차집합         | A − B         |
| 카티션 프로덕트 | A × B         |
| 프로젝트       | π (A) B       |
| 조인           | A ⨝ B         |

---

### 관계대수 연산자- **순수 관계 연산자 (Relational Algebra Operators)**  
  - **SELECT (σ)**: 조건에 맞는 튜플(행) 선택  
  - **PROJECT (π)**: 특정 속성(열)만 선택  
  - **JOIN (⨝)**: 두 릴레이션을 조건에 맞게 결합  
  - **DIVISION (÷)**: 특정 조건을 만족하는 부분 릴레이션 추출

- **일반 집합 연산자 (Set Operators)**  
  - **합집합 (∪)**: 두 릴레이션의 모든 튜플 합침 (중복 제거)  
  - **교집합 (∩)**: 두 릴레이션에 공통으로 존재하는 튜플  
  - **차집합 (−)**: 첫 번째 릴레이션에는 있지만 두 번째에는 없는 튜플  
  - **카티션 프로덕트 (×)**: 두 릴레이션의 모든 튜플 조합 생성  


---------------------------------------------------------------------------------------------------------------
## 문제 13) 아래의 테이블에서 SQL 명령을 수행할 경우 알맞은 값을 작성하시오

### 테이블 및 데이터

```sql
create table 부서 (
  부서코드 int primary key,
  부서명 varchar(20)
);

create table 직원(
  직원코드 int primary key,
  부서코드 int,
  직원명 varchar(20),
  foreign key(부서코드) references 부서(부서코드)
    on delete cascade
);

insert into 부서(부서코드, 부서명) values (10, '영업팀');
insert into 부서(부서코드, 부서명) values (20, '개발팀');
insert into 부서(부서코드, 부서명) values (30, '기획팀');

insert into 직원(직원코드, 부서코드) values (1000, 10);
insert into 직원(직원코드, 부서코드) values (2000, 10);
insert into 직원(직원코드, 부서코드) values (3000, 10);
insert into 직원(직원코드, 부서코드) values (4000, 20);
insert into 직원(직원코드, 부서코드) values (5000, 20);
insert into 직원(직원코드, 부서코드) values (6000, 30);
insert into 직원(직원코드, 부서코드) values (7000, 30);


문제 쿼리 및 결과
SELECT DISTINCT COUNT(직원코드) FROM 직원 WHERE 부서코드 = '10';

부서코드 10에 해당하는 직원 수를 세는 쿼리

부서코드 10에 직원코드 1000, 2000, 3000이 있으므로 3

DELETE FROM 부서 WHERE 부서코드 = '10';

부서코드가 10인 부서를 삭제하면

외래키 제약조건 ON DELETE CASCADE에 의해 부서코드 10에 해당하는 직원들도 모두 삭제됨

SELECT DISTINCT COUNT(직원코드) FROM 직원;

삭제 후 직원 테이블의 직원 수를 세는 쿼리

부서코드 10에 속한 직원 3명이 삭제되어 남은 직원은 4명 (4000, 5000, 6000, 7000)

답
항목	값
(1) 부서코드 10 직원 수 조회	3
(2) 부서코드 10 삭제 후 직원 수	4


---------------------------------------------------------------------------------------------------------------

## 문제 14) STUDENT 테이블에 컴퓨터학과 학생 50명, 기계과 학생 100명, 건축과 학생 50명의 데이터가 있다.  
다음 SQL 실행 결과 튜플의 수를 작성하시오.

---

### 주어진 데이터

| 학과      | 학생 수 |
|-----------|---------|
| 컴퓨터학과 | 50      |
| 기계과    | 100     |
| 건축과    | 50      |
| **총합**   | 200     |

---

### SQL문과 결과

1. `SELECT DEPT FROM STUDENT;`  
   - 모든 학생의 학과(DEPT) 컬럼을 조회  
   - 학생 수 만큼 튜플이 반환됨  
   - **결과: 200**

2. `SELECT DISTINCT DEPT FROM STUDENT;`  
   - 중복을 제거한 학과 목록 조회  
   - 학과는 3개(컴퓨터학과, 기계과, 건축과)  
   - **결과: 3**

3. `SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT='건축과';`  
   - 조건에 맞는 학과 중복 제거 후 개수 카운트  
   - 조건 `DEPT='건축과'`에 해당하는 학과는 건축과 1개뿐  
   - **결과: 1**

---

### 답안

| 문항 | 결과 |
|------|-------|
| (1)  | 200   |
| (2)  | 3     |
| (3)  | 1     |


---------------------------------------------------------------------------------------------------------------

## 문제 15) 다음 프로그램의 출력결과를 2차원 배열 형태로 작성하시오

```c
#include <stdio.h>       // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일이다.

                                        // field 배열은 지뢰의 위치를 나타낸다. 1은 지뢰가 있는 곳, 0은 지뢰가 없는 곳이다.
                                        // static 키워드는 이 배열이 현재 파일 내에서만 접근 가능하게 만든다.
                                        // 4x4 크기의 정수형 2차원 배열이다.
static int field[4][4] = {
    {0,1,0,1},               // 첫 번째 행 (y=0): (0,1)과 (0,3)에 지뢰가 있다.
    {0,0,0,1},               // 두 번째 행 (y=1): (1,3)에 지뢰가 있다.
    {1,1,1,0},             // 세 번째 행 (y=2): (2,0), (2,1), (2,2)에 지뢰가 있다.
    {0,1,1,1}            // 네 번째 행 (y=3): (3,1), (3,2), (3,3)에 지뢰가 있다.
};

                                              // mines 배열은 각 칸 주변에 지뢰가 몇 개 있는지 숫자를 기록할 배열이다.
                                              // field 배열과 마찬가지로 4x4 크기의 정수형 2차원 배열이며, 초기에는 모든 값이 0으로 설정된다.
                                              // 여기에 나중에 지뢰 개수가 계산되어 채워진다.
static int mines[4][4] = {
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0},
    {0,0,0,0}
};

                                                                  // calculate 함수는 특정 칸 (i, j)의 mines 값을 1 증가시키는 역할을 한다.
                                                                  // 하지만 그냥 증가시키지 않고, 배열의 유효한 범위 안에 있는지 먼저 확인한다.
                                                                  // w: 배열의 가로(열) 크기 (여기선 4)
                                                                  // h: 배열의 세로(행) 크기 (여기선 4)
                                                                  // j: 증가시킬 칸의 행(세로) 인덱스
                                                                  // i: 증가시킬 칸의 열(가로) 인덱스
void calculate(int w, int h, int j, int i){
                                            // 이 if문이 존나 중요하다. (i, j) 좌표가 배열의 유효한 범위(0부터 w-1, 0부터 h-1) 안에 있는지 확인한다.
                                            // 배열 범위를 벗어나는 접근은 프로그램 오류(크래시)를 일으킬 수 있기 때문에 이를 방지하는 역할을 한다.
    if(i >= 0 && i < w && j >= 0 && j < h)
                                                  // 만약 (i, j)가 유효한 범위 안에 있다면, mines[i][j] 값을 1 증가시킨다.
                                                  // 이는 해당 칸 주변에 지뢰가 하나 더 있다는 것을 카운트하는 것이다.
        mines[i][j]++;
}

                                                    // main 함수는 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                                    // 여기에서 지뢰 필드를 계산하고 출력하는 모든 로직이 진행된다.
void main(){
                                                      // 변수들을 선언하고 초기화한다.
                                                      // x, y: field 배열을 순회할 때 사용할 현재 칸의 열(x)과 행(y) 인덱스
                                                      // j, i: 지뢰가 있는 칸 주변 8방향 + 자기 자신을 순회할 때 사용할 행(j)과 열(i) 인덱스
                                                      // w, h: 배열의 가로(w)와 세로(h) 크기. 둘 다 4로 초기화한다.
    int x, y, j, i, w=4, h=4;

                                                  // 첫 번째 중첩 for 문: field 배열의 모든 칸을 순회한다 (행 -> 열 순서).
                                                  // y는 0부터 h-1 (0, 1, 2, 3)까지 증가하며 각 행을 대표한다.
    for(y = 0; y < h; y++){
                                                  // x는 0부터 w-1 (0, 1, 2, 3)까지 증가하며 각 열을 대표한다.
        for(x = 0; x < w; x++){
                                                        // 만약 현재 field[x][y] 칸의 값이 0이면 (즉, 지뢰가 없으면),
                                                        // 이 칸은 주변 지뢰 수를 세는 데 영향을 주지 않으므로 다음 칸으로 바로 넘어간다.
            if(field[x][y] == 0) continue;

                                                                  // 여기까지 왔다는 건 field[x][y]가 1이라는 뜻 (현재 칸에 지뢰가 있다!).
                                                                  // 이제 이 지뢰 주변 8칸 (그리고 지뢰 칸 자신)의 mines 값을 1씩 증가시켜야 한다.
                                                                  // 두 번째 중첩 for 문: 현재 지뢰 (x,y)를 중심으로 3x3 영역(9칸)을 순회한다.
                                                                  // j는 현재 지뢰의 행(y)을 기준으로 y-1(위), y(중앙), y+1(아래)을 순회한다.
            for(j = y-1; j <= y+1; j++){
                                                // i는 현재 지뢰의 열(x)을 기준으로 x-1(왼쪽), x(중앙), x+1(오른쪽)을 순회한다.
                for(i = x-1; i <= x+1; i++){
                                                                  // 계산된 주변 칸의 (i, j) 좌표를 calculate 함수에 넘겨준다.
                                                                  // calculate 함수는 이 (i,j) 칸이 유효한 범위라면 mines[i][j] 값을 1 증가시킨다.
                    calculate(w, h, j, i);
                }
            }
        }
    }

                                                            // // 최종 mines 배열 결과 출력 부분이다.
                                                            // 다시 한번 중첩 for 문을 사용해서 mines 배열의 모든 칸을 순회한다.
                                                            // y는 0부터 h-1 (0, 1, 2, 3)까지 증가하며 각 행을 순서대로 방문한다.
    for(y = 0; y < h; y++){
                                    // x는 0부터 w-1 (0, 1, 2, 3)까지 증가하며 각 열을 순서대로 방문한다.
        for(x = 0; x < w; x++){
                                              // mines[x][y]에 저장된 정수 값을 화면에 출력하고, 그 뒤에 공백을 하나 추가한다.
            printf("%d ", mines[x][y]);
        }
                                      // 한 행의 모든 값을 출력하고 나면 줄 바꿈 문자를 출력하여 다음 행의 숫자가 새 줄에 나오도록 한다.
        printf("\n");
    }
}


답: 3 4 3 3
2 5 5 4
3 6 6 4
1 3 4 2

문제 해설
field 배열에서 1인 칸 주변 3x3 영역에 대해 mines 배열에 +1을 한다.

field[x][y]에서 x는 열(03), y는 행(03)이며, mines[i][j]도 같은 인덱스 체계임.

각 1에 대해 주변 8칸과 자기 자신을 포함해 mines 값을 증가시킨다.

계산 과정
field의 1 위치:

(x,y) 좌표 (열,행)
(1,0), (3,0)
(3,1)
(0,2), (1,2), (2,2)
(1,3), (2,3), (3,3)

이 위치들의 주변 3x3 범위에 mines 값을 +1 한다.

최종 mines 배열 (4x4)
3	4	3	3
2	5	5	4
3	6	6	4
1	3	4	2

정리된 출력 결과 (mines 배열)

3 4 3 3
2 5 5 4
3 6 6 4
1 3 4 2
---------------------------------------------------------------------------------------------------------------

## 문제 16) 다음 C언어 프로그램의 출력 결과를 쓰시오

#include <stdio.h>                             // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일이다.

                                        // int main() 함수는 C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                        // int는 함수가 정수형 값을 반환한다는 의미인데, 여기서는 보통 0을 반환하여 프로그램이 정상 종료되었음을 알린다.
int main(){
                                                    // result 배열은 각 숫자의 '상대적인 순위'를 저장할 5칸짜리 정수 배열이다.
                                                    // 여기에 나중에 각 ary[i] 값이 자기보다 큰 숫자를 제외하고 몇 번째로 큰지(작은 숫자 개수+1)가 저장된다.
    int result[5];
                                                              // ary 배열은 원본 숫자들을 담고 있는 5칸짜리 정수 배열이다.
                                                              // {77, 32, 10, 99, 50}이라는 초기값으로 설정된다.
    int ary[] = {77, 32, 10, 99, 50};

                                                                      // 이 이중 for 문이 이 코드의 핵심 계산 로직이다.
                                                                      // 각 ary[i] 값에 대해 ary 배열의 다른 모든 값들을 비교하면서
                                                                      // ary[i]보다 작은 숫자가 몇 개 있는지 세는 역할을 한다.

                                                                      // 바깥쪽 for 문: ary 배열의 모든 요소(77, 32, 10, 99, 50)를 하나씩 순서대로 짚어본다.
                                                                      // i는 현재 비교 대상 숫자의 인덱스 (0부터 4까지).
    for (int i = 0; i < 5; i++){
                                                          // 💡 중요: result[i] 값을 1로 초기화한다.
                                                          // 이는 '자기 자신'을 포함하여 '최소한 1등(또는 1개)'이라는 의미로 시작하는 거다.
                                                          // 이후 자신보다 작은 숫자가 발견될 때마다 1씩 증가시킬 것이다.
        result[i] = 1;

                                                                          // 안쪽 for 문: 바깥쪽 for 문에서 선택된 ary[i]와 비교하기 위해,
                                                                          // ary 배열의 모든 요소(ary[0]부터 ary[4]까지)를 다시 한번 순회한다.
                                                                          // j는 ary[i]와 비교할 다른 숫자의 인덱스 (0부터 4까지).
        for(int j = 0; j < 5; j++)
                                                      // 만약 현재 비교 대상 숫자(ary[i])가 비교할 다른 숫자(ary[j])보다 크다면,
                                                      // (예: ary[0]=77일 때 ary[1]=32와 비교하면 77 > 32는 참이다)
            if(ary[i] > ary[j])
                                                        // result[i] 값을 1 증가시킨다.
                                                        // 이는 ary[i]보다 작은 숫자가 하나 더 있다는 것을 의미한다.
                                                        // 이 과정을 모든 j에 대해 반복하면 result[i]에는 ary[i]보다 작은 숫자의 총 개수 + 1 (자기 자신)이 저장된다.
                result[i]++;
    }
                                                              // 이중 for 문이 모두 끝나면, result 배열에는 다음과 같은 값들이 저장된다:
                                                              // ary[0]=77 -> result[0]=4 (32, 10, 50 보다 크다)
                                                              // ary[1]=32 -> result[1]=2 (10 보다 크다)
                                                              // ary[2]=10 -> result[2]=1 (자기보다 작은 숫자가 없다)
                                                              // ary[3]=99 -> result[3]=5 (77, 32, 10, 50 보다 크다)
                                                              // ary[4]=50 -> result[4]=3 (32, 10 보다 크다)
                                                              // 따라서 result 배열의 최종 상태는 [4, 2, 1, 5, 3]이 된다.

                                                    // 마지막 for 문: 계산이 완료된 result 배열의 모든 값을 순서대로 화면에 출력한다.
                                                    // i는 0부터 4까지 순서대로 result 배열의 인덱스를 나타낸다.
    for(int i = 0; i < 5; i++)
                                                      // printf 함수를 사용하여 result[i]에 저장된 정수 값을 출력한다.
                                                      // %d는 정수를 출력하라는 서식 지정자다.
                                                      // 중요한 점: 숫자 뒤에 공백이나 줄 바꿈 문자가 없어서, 숫자들은 모두 붙어서 출력된다.
        printf("%d", result[i]);

                                              // main 함수는 보통 0을 반환하여 운영체제에게 프로그램이 성공적으로 종료되었음을 알린다.
    return 0;
}

출력 결과

24513

---------------------------------------------------------------------------------------------------------------

## 문제 17) 다음 C언어 프로그램의 출력 결과를 쓰시오

#include <stdio.h>                         // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일이다.

                                      // int main() 함수는 C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                      // int는 함수가 정수형 값을 반환한다는 의미인데, 여기서는 보통 0을 반환하여 프로그램이 정상 종료되었음을 알린다.
int main(){
                                // x와 y라는 정수형 변수를 선언한다.
                                // x: 각 숫자 i의 '진약수'(자기 자신을 제외한 약수)들의 합을 저장할 변수다.
                                // y: i를 2로 나눈 몫을 저장할 변수다. 약수를 찾을 때 이 값까지만 확인하면 된다 (자기 자신의 절반보다 큰 약수는 있을 수 없으니까).
    int x, y;
                                    // cnt라는 정수형 변수를 0으로 초기화한다. 이 변수는 6부터 30까지의 숫자 중에서 '완전수'가 몇 개인지 세는 카운터 역할을 한다.
    int cnt = 0;

                                                                // 첫 번째 (바깥쪽) for 반복문: i는 6부터 30까지의 모든 정수를 하나씩 순회한다.
                                                                // 완전수는 보통 6부터 시작하기 때문에 6부터 검사한다.
    for(int i = 6; i <= 30; i++){
                                                    // 💡 중요: 새로운 i 값(새로운 숫자)을 검사할 때마다 x(약수의 합)를 0으로 초기화한다.
                                                    // 이전 숫자의 약수 합이 남아있으면 안 되니까 깔끔하게 시작하는 거다.
        x = 0;
                                                      // y에 현재 숫자 i를 2로 나눈 몫을 저장한다.
                                                      // 예를 들어 i가 6이면 y는 3, i가 7이면 y는 3이 된다.
                                                      // j는 1부터 이 y값까지만 확인하면 되기 때문에 계산 범위를 줄여 효율성을 높인다.
        y = i / 2;

                                                      // 두 번째 (안쪽) for 반복문: j는 1부터 y(i의 절반)까지 순회하며 i의 약수인지 확인한다.
                                                      // j는 i의 가능한 약수 후보들을 나타낸다.
        for(int j = 1; j <= y; j++){
                                                            // 만약 i를 j로 나눈 나머지가 0이면, j는 i의 약수다.
                                                            // (예: 6 % 1 == 0, 6 % 2 == 0, 6 % 3 == 0)
            if(i % j == 0)
                                          // j가 i의 약수이므로, x(약수의 합)에 j를 더한다.
                                          // 이 과정을 안쪽 for 문이 끝날 때까지 반복하면 x에는 i의 모든 '진약수'(자기 자신을 제외한 약수)들의 합이 저장된다.
                x = x + j;
        }
                                                            // 안쪽 for 문이 모두 끝나면, x에는 현재 숫자 i의 모든 진약수들의 합이 들어있다.
                                                            // 이제 이 x가 원래 숫자 i와 같은지 비교한다.
                                                            // '완전수'의 정의는 자기 자신을 제외한 약수들의 합이 자기 자신과 같은 숫자다.
        if(x == i){
                                                          // 만약 x와 i가 같으면, i는 완전수다.
                                                          // 완전수를 찾았으므로 cnt(완전수의 개수) 값을 1 증가시킨다.
            cnt++;
        }
    }
                                                                  // 바깥쪽 for 문(i = 6부터 30까지의 모든 숫자 검사)이 모두 끝나면,
                                                                  // cnt에는 6부터 30 사이에 존재하는 완전수의 총 개수가 저장된다.
                                                                  // 6부터 30 사이의 완전수는 6과 28, 단 두 개 뿐이다.
                                                                  // (6의 약수: 1, 2, 3 -> 합 = 6)
                                                                  // (28의 약수: 1, 2, 4, 7, 14 -> 합 = 28)
                                                              
                                                                  // 최종적으로 cnt에 저장된 완전수의 개수를 화면에 출력한다.
                                                                  // %d는 정수를 출력하라는 서식 지정자다.
                                                                  // 출력되는 숫자 뒤에는 공백이나 줄 바꿈이 없으므로, 그냥 숫자가 그대로 찍힌다.
    printf("%d", cnt);

                                                        // main 함수는 보통 0을 반환하여 운영체제에게 프로그램이 성공적으로 종료되었음을 알린다.
    return 0;
}

출력 결과
2

---------------------------------------------------------------------------------------------------------------

## 문제 18) 다음 Java 프로그램의 출력 결과를 쓰시오

                                                    // makeAry 함수는 정수형 배열을 만들어서 반환하는 역할을 한다.
                                                    // static: 이 함수가 객체를 생성하지 않고도 직접 호출될 수 있음을 의미한다. (main 함수에서 바로 쓸 수 있다는 뜻)
                                                    // int[]: 이 함수가 '정수형 배열'을 결과값으로 돌려준다는 뜻이다.
                                                    // makeAry(): 함수의 이름이고, 괄호 안은 매개변수가 없다는 뜻이다.
static int[] makeAry(){
                                                        // int[] tmp = new int[4];: 'tmp'라는 이름의 정수형 배열을 새로 만든다.
                                                        // 'new int[4]'는 칸이 4개(인덱스는 0, 1, 2, 3)인 배열을 메모리에 할당하라는 명령이다.
    int[] tmp = new int[4];
                                                    // for(int i = 0; i < tmp.length; i++): 반복문을 사용해서 'tmp' 배열의 모든 칸을 순서대로 방문한다.
                                                    // i는 0부터 시작해서 'tmp.length'(배열의 길이, 여기선 4)보다 작을 때까지 1씩 증가한다.
    for(int i = 0; i < tmp.length; i++){
                                                        // tmp[i] = i;: 현재 방문 중인 칸(tmp[i])에 자신의 인덱스 번호(i)를 값으로 집어넣는다.
                                                        // 이 for 문이 끝나면 'tmp' 배열은 [0, 1, 2, 3] 이렇게 채워진다.
                                                        // 예를 들면, tmp[0]에는 0, tmp[1]에는 1, tmp[2]에는 2, tmp[3]에는 3이 들어간다.
        tmp[i] = i;
    }
                                                      // return tmp;: 다 채워진 'tmp' 배열을 이 함수를 호출한 곳(main 함수)으로 돌려준다.
    return tmp;
}

                                                // public static void main(String[] args): 자바 프로그램이 시작될 때 가장 먼저 실행되는 메인 함수다.
                                                // public: 어디서든 이 함수를 호출할 수 있다는 뜻이다.
                                                // static: 위 makeAry 함수처럼 객체 생성 없이 바로 호출 가능하다는 뜻이다.
                                                // void: 이 함수는 어떤 값도 되돌려주지 않는다는 뜻이다.
                                                // main: 함수 이름이다. 자바의 진입점.
                                                // String[] args: 프로그램 실행 시 외부에서 전달받을 수 있는 인자들을 담는 배열이다. (여기선 사용 안 함)
public static void main(String[] args){
                                                      // int[] inData = makeAry();: 'makeAry()' 함수를 호출하고, 그 함수가 반환한 배열을
                                                      // 'inData'라는 이름의 정수형 배열 변수에 저장한다.
                                                      // 위 makeAry() 함수가 [0, 1, 2, 3]을 반환했으므로, 'inData'도 [0, 1, 2, 3]이 된다.
    int[] inData = makeAry();
                                                    // for(int i = 0; i < inData.length; i++): 'inData' 배열의 모든 칸을 순서대로 방문한다.
                                                    // i는 0부터 'inData.length'(배열의 길이, 여기선 4)보다 작을 때까지 1씩 증가한다.
    for(int i = 0; i < inData.length; i++)
                                                          // System.out.print(inData[i]);: 현재 칸(inData[i])에 있는 값을 화면에 출력한다.
                                                          // 'System.out.print()'는 출력 후 줄을 바꾸지 않는다.
                                                          // 그래서 0, 1, 2, 3이 다닥다닥 붙어서 출력된다.
        System.out.print(inData[i]);
}


출력 결과
0123
---------------------------------------------------------------------------------------------------------------
## 문제 19) 다음 Java 프로그램의 출력 결과를 쓰시오
                                                                          // 표준 입출력 기능을 사용하기 위한 자바의 기본 라이브러리. (이 코드에서는 System.out.print를 위해 필요하다.)
                                                                          // 이 예제에는 이 import 문이 직접 포함되어 있지 않지만, 실제 자바 파일을 컴파일하고 실행하려면 필요할 거다.
                                                                          // import java.lang.System; // 사실 java.lang 패키지는 기본적으로 import 되므로 명시할 필요는 없다.
                                                                          
                                                                          // public class Main { // 보통 자바 코드는 클래스 안에 있어야 한다. (이 예제에는 클래스 선언이 생략되어 있다.)
                                                                          //     public static void main(String[] args) { // 자바 프로그램이 시작될 때 가장 먼저 실행되는 'main' 함수다.
                                                                                                                      // public: 어디서든 접근 가능. static: 객체 생성 없이 바로 실행 가능.
                                                                                                                      // void: 아무 값도 반환하지 않음. String[] args: 외부 입력 인자.
        int max = 0;                                                         // 'max'라는 정수형 변수를 0으로 초기화한다.
                                                                               // 이 변수에는 나중에 우리가 찾는 조건(3의 배수이면서 홀수)을 만족하는 가장 큰 숫자가 저장될 거다.
                                                        
                                                                                // for 반복문: 'i'는 1부터 시작해서 99보다 작을 때까지 (즉, 98까지) 1씩 증가하면서 모든 숫자를 순회한다.
        for(int i = 1; i < 99; i++){
                                                                    // if 조건문: 현재 숫자 'i'가 두 가지 조건을 모두 만족하는지 확인한다.
                                                                    // 1. i % 3 == 0: 'i'를 3으로 나눈 나머지가 0인지 (즉, 'i'가 3의 배수인지) 확인한다.
                                                                    // 2. i % 2 != 0: 'i'를 2로 나눈 나머지가 0이 아닌지 (즉, 'i'가 홀수인지, 짝수가 아닌지) 확인한다.
                                                                    // '&&'는 논리 AND 연산자다. 두 조건이 모두 참이어야만 if문 안의 코드가 실행된다.
            if(i % 3 == 0 && i % 2 != 0)
                                                                        // 만약 'i'가 두 가지 조건을 모두 만족하면, 'max' 변수의 값을 현재 'i'의 값으로 업데이트한다.
                                                                        // 이 for 반복문은 'i'가 1부터 98까지 '증가'하는 순서로 돌기 때문에,
                                                                        // 조건에 맞는 숫자가 발견될 때마다 'max'가 그 숫자로 갱신된다.
                                                                        // 최종적으로 반복문이 끝났을 때 'max'에 남아있는 값이 바로 조건에 맞는 숫자 중 가장 '큰' 숫자가 된다.
                                                                        // 예시 추적:
                                                                        // i=3: (3%3==0 && 3%2!=0) 참 -> max = 3
                                                                        // i=9: (9%3==0 && 9%2!=0) 참 -> max = 9
                                                                        // i=15: (15%3==0 && 15%2!=0) 참 -> max = 15
                                                                        // ...
                                                                        // i=93: (93%3==0 && 93%2!=0) 참 -> max = 93
                                                                        // (이후 94, 95, 96, 97, 98은 조건을 만족하지 않으므로 max는 93으로 유지된다.)
                max = i;
        }
                                                                                      // for 반복문이 모두 끝나면, 최종적으로 'max'에 저장된 값을 화면에 출력한다.
                                                                                      // System.out.print() 함수는 괄호 안의 내용을 출력하고 줄을 바꾸지 않는다.
                                                                                      // 따라서 숫자만 딱 찍히게 된다.
        System.out.print(max);
        }
     } 

출력 결과
93

---------------------------------------------------------------------------------------------------------------

## 문제 20) 다음 파이썬 코드에 대한 출력값을 작성하시오.

                                                                                        # tData라는 리스트(파이썬의 배열)를 만들고, 1부터 5까지의 정수 값으로 초기화한다.
                                                                                        # 이게 우리가 작업을 할 원본 데이터다.
tData = [1, 2, 3, 4, 5]

                                                                                          # 이 한 줄이 이 코드의 핵심이다.
                                                                                          # tData 리스트의 모든 숫자에 100을 더해서 새로운 리스트를 만드는 과정이다.
                                                                                          # tData = list(map(lambda num: num + 100, tData))
                                                                                          # 1. lambda num: num + 100: 이게 바로 '람다(lambda) 함수'라는 거다.
                                                                                          #    - 'num'이라는 값을 받아서, 그 값에 '100'을 더한 결과를 반환하는 아주 간단한 '익명 함수'다.
                                                                                          #    - 말 그대로 이름이 없는 함수라서 한 번 쓰고 버릴 때 많이 쓴다.
                                                                                          # 2. map(lambda num: num + 100, tData): 'map()' 함수는 두 가지를 인자로 받는다.
                                                                                          #    - 첫 번째 인자: 앞에서 만든 '람다 함수'다.
                                                                                          #    - 두 번째 인자: 'tData' 리스트다.
                                                                                          #    - 'map' 함수는 'tData' 리스트의 각 요소(숫자)에 람다 함수를 '매핑(적용)' 시킨다.
                                                                                          #    - 즉, tData의 모든 숫자(1, 2, 3, 4, 5)에 각각 100을 더하는 작업을 수행한다.
                                                                                          #    - 결과는 바로 리스트가 아니라 'map 객체'라는 형태로 나온다.
                                                                                          # 3. list(...): 'map' 함수가 반환한 'map 객체'를 우리가 눈으로 볼 수 있는 실제 '리스트' 형태로 변환해준다.
                                                                                          #    - 변환된 리스트는 [101, 102, 103, 104, 105]가 된다.
                                                                                          # 4. tData = ...: 이렇게 새로 만들어진 리스트를 다시 'tData' 변수에 덮어씌운다.
                                                                                          #    - 이제 tData는 원래의 [1, 2, 3, 4, 5]가 아니라 [101, 102, 103, 104, 105]가 된다.
tData = list(map(lambda num: num + 100, tData))

                                                                                  # print(tData): 최종적으로 현재 'tData' 리스트에 저장된 내용을 화면에 출력한다.
                                                                                  # 파이썬의 print() 함수는 리스트를 통째로 넘겨주면, 리스트의 형태로 괄호([ ])와 함께 내용을 깔끔하게 출력해준다.
print(tData)


출력 결과
[101, 102, 103, 104, 105]
---------------------------------------------------------------------------------------------------------------
  
