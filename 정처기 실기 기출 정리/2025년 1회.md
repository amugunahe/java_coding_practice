## 문제 1) 다음 네트워크 보안과 관련된 공격 기법에 대한 설명이다.  
다음 설명을 읽고 물음에 답하시오.

네트워크상에서 클라이언트와 서버 간에 인증된 통신이 이루어지고 있을 때, 공격자가 중간에서 인증이 필요한  
특정한 정보를 가로채어 사용자의 권한을 탈취하는 공격을 (        )라고 한다.  
이 공격에 성공하면 공격자는 정상 사용자의 권한을 얻어 불법적으로 서버에 접근하거나 정보를 유출할 수 있다.  
대표적인 공격 기법으로는 네트워크 패킷을 스니핑하여 인증 정보를 탈취하거나, 웹 브라우저에 저장된  
인증용 쿠키를 탈취하여 이용하는 방식이 있다.

**답:** 세션 하이재킹(Session Hijacking)

---

📌 **관련 개념 설명**

### ✅ 세션 하이재킹 (Session Hijacking)
- 사용자가 로그인한 후 발급받은 **세션 ID(쿠키, 토큰 등)**를 **공격자가 탈취해서 그 사용자처럼 가장**하는 공격.
- 세션 ID만 탈취되면, **비밀번호 없이도 사용자 권한으로 시스템에 접근** 가능.

---

### 🔓 공격 방법 예시
| 공격 방식 | 설명 |
|-----------|------|
| **스니핑(Sniffing)** | 네트워크를 몰래 감청해서 **세션 ID나 민감한 정보**를 가로챔 |
| **쿠키 탈취(Cookie Theft)** | XSS 등으로 클라이언트에 저장된 **쿠키를 훔쳐감** |
| **세션 고정(Session Fixation)** | **공격자가 미리 정한 세션 ID**를 사용자에게 쓰게 하고 나중에 **그 세션에 접근** |

---

### 🛡️ 방어 방법
- **HTTPS 사용**: 세션 ID 전송 시 **암호화**
- **세션 타임아웃 설정**: 일정 시간 지나면 세션 자동 종료
- **User-Agent / IP 확인**: 세션이 **다른 환경에서 재사용되지 않도록** 함
- **HttpOnly 설정**: 자바스크립트로 **쿠키 접근 못하게 차단**

---------------------------------------------------------------------------------------------------------
## 문제 2) 다음은 관계형 데이터베이스의 무결성 제약 조건에 관한 설명이다.  
각 설명에 알맞은 무결성 제약 조건을 쓰시오.

(1) 기본키를 구성하는 모든 속성은 절대로 **null 값이나 중복된 값을 가질 수 없다는 규칙**이다.  
(2) 외래키의 값은 반드시 **참조하고 있는 테이블의 기본키 값으로 존재하거나 null이어야 한다는 규칙**이다.  
(3) 특정 속성(컬럼)에 대해 **미리 정의된 형식과 범위 내에서만 데이터가 입력되도록 제한하는 규칙**이다.

**답:**  
1) 개체 무결성  
2) 참조 무결성  
3) 도메인 무결성  

---

📌 **관련 개념 설명**

### ✅ 개체 무결성 (Entity Integrity)
- 테이블의 **기본키(PK)**는 각 행을 고유하게 식별하기 위한 필수 조건
- **NULL이 될 수 없고**, **중복된 값도 허용되지 않음**
- 즉, **기본키는 반드시 값이 존재하고 유일해야 함**
- ✅ 위반 시: 행의 고유성이 깨지므로 **개체 무결성 손상**
- 
-- ❌ 오류 발생: 동일한 학번 존재 (중복)
INSERT INTO 학생 VALUES ('A101', '민수');
INSERT INTO 학생 VALUES ('A101', '지훈');

---

### ✅ 참조 무결성 (Referential Integrity)
- **외래키(FK)**는 다른 테이블의 기본키를 참조함
- 외래키는 반드시 **해당 기본키 값이 존재해야 하며**, 존재하지 않으면 **NULL이어야 함**
- 🔗 테이블 간의 관계를 안전하게 유지하기 위한 필수 조건
- ✅ 위반 시: 연결된 데이터 관계가 무너짐


CREATE TABLE 학과 (
  학과코드 CHAR(3) PRIMARY KEY,
  학과명 VARCHAR(20)
);

CREATE TABLE 학생 (
  학번 CHAR(5) PRIMARY KEY,
  이름 VARCHAR(20),
  학과코드 CHAR(3),
  FOREIGN KEY (학과코드) REFERENCES 학과(학과코드)
);


-- ❌ 오류 발생: 학과코드 'XYZ'는 학과 테이블에 존재하지 않음
INSERT INTO 학생 VALUES ('A101', '민수', 'XYZ');

---

### ✅ 도메인 무결성 (Domain Integrity)
- 컬럼에 저장될 수 있는 **데이터의 형식, 값의 범위** 등을 제한함
- 예시:
  - 나이 컬럼: 0 이상
  - 성별 컬럼: '남', '여' 중 하나만 입력
  - 숫자형 필드에 문자 입력 ❌
- ✅ 목적: **데이터 정확성 + 일관성 유지**

- CREATE TABLE 회원 (
  회원ID CHAR(5),
  나이 INT CHECK (나이 >= 0 AND 나이 <= 120),  -- 나이는 0~120 사이만 허용
  성별 CHAR(1) CHECK (성별 IN ('M', 'F'))       -- 성별은 'M', 'F'만 허용
);

-- ❌ 오류 발생: 나이가 음수
INSERT INTO 회원 VALUES ('U001', -5, 'M');

-- ❌ 오류 발생: 성별 값이 허용되지 않음
INSERT INTO 회원 VALUES ('U002', 25, '남자');


---------------------------------------------------------------------------------------------------------
## 문제 3) 다음 설명을 읽고 이에 해당하는 오류 검출 방식을 쓰시오.

네트워크 환경에서 데이터를 전송할 때 송신 측은 전송하려는 데이터에 특정 **다항식**을 적용하여 얻은  
**나머지 값을 데이터와 함께 전송**하고, 수신 측에서는 동일한 다항식으로 나누어 나머지를 비교하여  
**데이터의 손상 여부를 판단**한다. 이러한 방식으로 데이터 전송 중 발생할 수 있는 오류를  
효과적으로 검출하는 방법을 (        )라고 한다.  
이 방식은 **이더넷**과 같은 네트워크 통신 프로토콜에서 널리 사용된다.

**답:** CRC (Cyclic Redundancy Check, 순환 중복 검사)

---

# 📌 관련 개념 설명

---

## ✅ CRC (Cyclic Redundancy Check, 순환 중복 검사)

- **오류 검출용** 대표적 기법  
- **이진 다항식(제너레이터 다항식)**을 사용한 나눗셈 기반 방식
- 송신 측:
  - 전송할 데이터에 대해 **다항식 나눗셈 연산** 수행
  - 나온 **나머지(remainder)**를 데이터 뒤에 붙여 전송
- 수신 측:
  - 수신 데이터에 대해 같은 다항식으로 나눗셈
  - **나머지가 0이면 무결, 0이 아니면 오류 감지**

✅ **특징**
- **오류 검출 가능**, **오류 수정 불가능**
- **패리티 비트보다 강력한 검출 능력**
- **이더넷, HDLC, USB, 디지털 통신 등에서 널리 사용**

---

## ✅ 전송 오류 제어 방식 요약

| 구분                 | 설명                                                 | 예시                        |
|----------------------|------------------------------------------------------|-----------------------------|
| **전진 오류 수정 (FEC)** | 수신 측이 자체적으로 오류를 **검출 + 수정**               | 해밍 코드, 리드-솔로몬 코드 |
| **후진 오류 수정 (BEC)** | 수신 측이 오류 감지 후 송신 측에 **재전송 요청**            | 패리티 검사, 블록합, CRC    |
| **오류 검출 전용 방식**  | **오류는 검출**하되, 수정은 못함                          | 패리티 비트, 블록합, CRC    |

---

## ✅ 예시: CRC 작동 원리 (간단 요약)

1. 전송 데이터: `101110`
2. 생성 다항식(G): `1001`
3. 송신 측:
   - `101110` 뒤에 3개의 0을 붙여 `101110000` 만들고 G로 나눔
   - 나머지를 뒤에 붙여 전송 → `101110 + 나머지`
4. 수신 측:
   - 전체 데이터로 G로 나눔 → **나머지가 0이면 정상, 0 아니면 오류**

---

✅ CRC는 **효율적이고 강력한 오류 검출** 방식이지만,  
**오류 수정 기능이 없기 때문에**, 보통 **재전송(ARQ)** 방식과 함께 사용됨.


---------------------------------------------------------------------------------------------------------
## 문제 4) 다음 설명을 읽고, 괄호 안에 들어갈 가장 적합한 용어를 쓰시오.

컴퓨터 사용자에게 **악성코드에 감염되었다거나, 보안 위협이 존재한다는 허위 경고**를 띄워 사용자의 불안을 유발하고,  
이를 해결하기 위한 **가짜 보안 소프트웨어를 결제하도록 유도하여 금전적 이득**을 취하는 악성 소프트웨어를 (         )라고 한다.  
사용자는 실제로는 감염되지 않은 상태임에도 불구하고 이러한 허위 경고에 속아 결제 및  
**개인 정보를 탈취**당할 수 있어 주의가 필요하다.

**답:** 스캐어웨어 (Scareware)

---

# 📌 관련 개념 설명: 스캐어웨어 (Scareware)

---

## ✅ 스캐어웨어(Scareware)란?

- "Scare(겁주다)" + "Software(소프트웨어)"의 합성어
- 사용자에게 **허위 경고 메시지**를 띄워 **공포감을 유발**하고,  
  **가짜 보안 프로그램 설치나 구매를 유도**하는 악성코드

---

## ✅ 주요 특징

- “⚠️ 당신의 PC가 바이러스에 감염되었습니다” 같은 팝업창을 띄움  
- 가짜 백신, 최적화 프로그램 설치를 유도  
- 설치 후 결제를 요구하거나 개인정보 입력을 유도하여  
  → **금전 탈취** 또는 **정보 유출**

---

## ✅ 예시 상황

1. 웹사이트 접속 중 갑자기 팝업창 발생  
   → “PC 성능이 저하되었습니다! 지금 스캔하세요!”
2. 사용자 클릭  
   → 가짜 백신 다운로드
3. 설치 후 결제 유도  
   → 카드정보 탈취

---

## ✅ 예방 방법

- **정품 백신 소프트웨어**만 사용하고 실시간 감시 활성화  
- **출처 불명 소프트웨어 설치 금지**  
- **수상한 팝업 클릭 금지**, 닫을 수 없을 경우 작업 관리자 강제 종료  
- **OS 및 백신 프로그램 최신 업데이트 유지**

---

> 💡 요약: 겁주고 돈 뺏는 수법. 놀라지 말고 침착하게 닫고, 백신으로 점검하자!


---------------------------------------------------------------------------------------------------------
## 문제 5) 다음은 JAVA 코드이다. 출력 결과를 쓰시오.

```java
class ExceptionTest {
    public static void main(String[] args) {
        int a = 5, b = 0;
        try {
            System.out.println(a / b);
        } catch (arithmeticException e) {
            System.out.printf("출력1");
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.printf("출력2");
        } catch (NumberFormatException e) {
            System.out.printf("출력3");
        } catch (Exception e) {
            System.out.printf("출력3");
        } finally {
            System.out.printf("출력5");
        }
    }
}


답: 출력3출력5

📌 설명 (예외 잡는 과정이 핵심!)
야, 이 코드는 자바에서 예외(Exception)를 어떻게 처리하는지 보여주는 거야. 잘 봐봐.

int a = 5, b = 0;: 변수 a는 5, b는 0으로 시작해.

try { System.out.println(a / b); }: try 블록 안에서 a / b 즉, 5 / 0을 계산하려고 해. 야, 알지? 숫자를 0으로 나누면 에러난다! 자바에서는 이걸 **ArithmeticException**이라는 예외로 처리해.

catch (arithmeticException e): ArithmeticException이 발생했으니 이 catch 블록을 먼저 찾아봐. 근데 여기서 존나 중요한 부분이 있어.
자바는 대소문자를 구분하는데, ArithmeticException의 A가 여기서는 소문자 a로 되어 있지? 이건 올바른 예외 클래스 이름이 아니야!
 그래서 이 catch 블록은 사실상 컴파일 오류를 일으켜. 하지만 문제에서는 컴파일 오류 없이 실행된다고 가정했으니까, 이 부분은 건너뛴다고 봐야 해.

catch (ArrayIndexOutOfBoundsException e): 다음 catch 블록은 ArrayIndexOutOfBoundsException 예외를 잡으려고 해. 이건 배열 인덱스 에러인데, 지금 5 / 0 에러랑은 다르니까 이 블록도 건너뛴다.

catch (NumberFormatException e): 다음 catch 블록은 NumberFormatException 예외를 잡으려고 해. 이건 문자열을 숫자로 바꿀 때 나는 에러인데, 이것도 5 / 0 에러랑 다르니까 건너뛴다.

catch (Exception e): 자, 여기까지 오면 남은 건 이 catch 블록밖에 없어. Exception은 자바의 모든 예외 클래스들의 '가장 큰 부모' 클래스야.
그러니까 어떤 예외가 발생하든, 위에 있는 특정 catch 블록에서 못 잡으면 이 Exception 블록이 무조건 잡아버려.
5 / 0으로 인한 ArithmeticException도 결국 Exception의 자식 클래스거든. 그래서 여기서 **System.out.printf("출력3");**이 실행된다.

finally { System.out.printf("출력5"); }: 마지막으로 finally 블록이야. 이 블록은 예외가 발생하든 안 하든, try-catch 블록이 끝나면 무조건 실행되는 부분이야.
그래서 System.out.printf("출력5");가 실행된다.

그래서 최종 출력은 **출력3**이 먼저 나오고 바로 뒤에 **출력5**가 붙어서 나오는 거야.

---------------------------------------------------------------------------------------------------------
## 문제 6) 다음 네트워크 프로토콜에 대한 설명을 읽고, 빈칸 (1), (2)에 들어갈 올바른 프로토콜의 이름을 각각 쓰시오.

(1) 이란 IP 주소를 가지고 있는 호스트가 네트워크상에서 데이터를 전송할 때,  
수신 호스트의 IP 주소는 알고 있지만, 해당 IP 주소에 대응하는 물리적인 **MAC 주소를 모르는 경우**  
이를 얻기 위해 사용하는 프로토콜이다.

(2) 이란 네트워크에 연결된 호스트가 자신의 **MAC 주소는 알고 있지만, IP 주소를 모르는 경우**  
서버에 질의하여 자신의 IP 주소를 얻기 위해 사용하는 프로토콜이다.  
이 프로토콜은 주로 **디스크가 없는 클라이언트가 부팅 시** 자신의 IP 주소를 얻기 위해 사용되었다.

**답:**  
1) ARP  
2) RARP

---# 📌 ARP vs RARP + OSI 7계층 정리

---

## ✅ 1) ARP (Address Resolution Protocol)

- **역할:** IP 주소를 MAC 주소로 변환 (IP ➝ MAC)
- **위치:** OSI 7계층 중 **2계층 (데이터 링크 계층)**
- **사용 예:** 로컬 네트워크에서 데이터를 전송하기 위해 상대방의 MAC 주소가 필요할 때

🧾 **예시**
- 내가 `192.168.0.20`에게 데이터를 보내고 싶다.  
- 하지만 상대의 MAC 주소를 모르므로 ARP 요청을 브로드캐스트 함  
- `192.168.0.20`이 응답하면서 자신의 MAC 주소를 알려줌  
- 그 MAC 주소로 데이터 프레임 전송 가능

---

## ✅ 2) RARP (Reverse Address Resolution Protocol)

- **역할:** MAC 주소를 IP 주소로 변환 (MAC ➝ IP)
- **위치:** OSI 7계층 중 **2계층 (데이터 링크 계층)**
- **사용 예:** 디스크가 없는 장치가 네트워크 부팅 시 자신의 IP를 서버로부터 요청  
- **현재는 거의 사용되지 않으며**, **BOOTP** 또는 **DHCP**로 대체됨

🧾 **예시**
- 디스크 없는 워크스테이션이 부팅되었지만 자신의 IP 주소를 모름  
- 자신이 가진 MAC 주소를 브로드캐스트로 보내면  
- 네트워크 내의 RARP 서버가 해당 MAC에 대응하는 IP 주소를 응답해줌

---

## ✅ OSI 7계층 요약

| 계층 번호 | 계층 이름         | 주요 기능 설명 |
|-----------|------------------|----------------|
| 7         | 응용 계층         | 사용자 인터페이스 제공 (예: HTTP, FTP, SMTP) |
| 6         | 표현 계층         | 데이터 암호화, 압축, 변환 (예: JPEG, ASCII 변환) |
| 5         | 세션 계층         | 연결 설정/유지/종료, 세션 관리 |
| 4         | 전송 계층         | 오류 복구, 흐름 제어 (예: TCP/UDP) |
| 3         | 네트워크 계층     | IP 주소 기반 라우팅, 경로 선택 (예: IP, ICMP) |
| 2         | 데이터 링크 계층   | MAC 주소 기반 전송, 프레임 처리 (예: Ethernet, ARP) |
| 1         | 물리 계층         | 전기적 신호로 비트 전송 (예: 케이블, 허브, 전압) |

---

## 🔍 요점 정리

- ARP: IP ➝ MAC (로컬 네트워크에서 MAC 주소 찾기)
- RARP: MAC ➝ IP (부팅 시 자신의 IP를 서버로부터 얻기)
- 둘 다 **데이터 링크 계층(2계층)**에서 동작하지만,
  - ARP는 **현재도 널리 사용**
  - RARP는 **DHCP 등으로 대체되어 거의 안 씀**

---------------------------------------------------------------------------------------------------------

## 문제 7) 다음 SQL 문제를 분석하고 실행 결과를 정확히 작성하시오.

### [emp] 테이블

| id   | name   |
|------|--------|
| 1001 | 김철수 |
| 1002 | 홍길동 |
| 1004 | 강감찬 |
| 1008 | 이순신 |

---

### [sal] 테이블

| id   | incentives |
|------|------------|
| 1002 | 300        |
| 1004 | 300        |
| 1008 | 1000       |
| 1009 | 500        |

---

📌 설명 (테이블 합치고 조건 거는 게 핵심!)
야, 이 SQL 쿼리는 두 개의 테이블(emp, sal)을 합쳐서(조인) 특정 조건을 만족하는 데이터만 뽑아내는 거야. 존나 쉬워.

1. FROM emp, sal (카티션 곱)
FROM emp, sal 이건 emp 테이블의 모든 행이랑 sal 테이블의 모든 행을 그냥 다 붙여버린다는 뜻이야. 이걸 카티션 곱이라고 하는데, 일단 모든 경우의 수를 다 만들어 놓는 거지.

예를 들어, emp에 4줄, sal에 4줄 있으면 4 * 4 = 16줄이 만들어지는 거야.

2. WHERE emp.id = sal.id (조인 조건)
WHERE emp.id = sal.id 이건 위에서 존나게 많이 만들어진 줄 중에서, emp 테이블의 id랑 sal 테이블의 id가 똑같은 것만 골라내라는 조건이야.

이걸 하면 두 테이블이 id를 기준으로 연결돼.

emp.id = 1001 (김철수) -> sal 테이블에 id 1001 없어. 탈락.

emp.id = 1002 (홍길동) -> sal.id = 1002 (incentives 300) => 연결!

emp.id = 1004 (강감찬) -> sal.id = 1004 (incentives 300) => 연결!

emp.id = 1008 (이순신) -> sal.id = 1008 (incentives 1000) => 연결!

sal.id = 1009 (incentives 500) -> emp 테이블에 id 1009 없어. 탈락.

여기까지 하면 대충 이런 결과가 나와. (아직 조건 다 안 건 상태)

| emp.id | emp.name | sal.id | sal.incentives |
|--------|----------|--------|----------------|
| 1002   | 홍길동   | 1002   | 300            |
| 1004   | 강감찬   | 1004   | 300            |
| 1008   | 이순신   | 1008   | 1000           |


3. AND sal.incentives >= 500 (추가 조건 필터링)
AND sal.incentives >= 500 이건 위에서 연결된 결과 중에서 incentives 값이 500 이상인 것만 다시 골라내라는 조건이야.

홍길동 (incentives 300): 300 >= 500은 거짓. 탈락.

강감찬 (incentives 300): 300 >= 500은 거짓. 탈락.

이순신 (incentives 1000): 1000 >= 500은 참! 통과.

그래서 최종적으로 이순신 데이터만 남는다.

4. SELECT emp.name, sal.incentives (결과 선택)
마지막으로 SELECT emp.name, sal.incentives 이건 최종으로 걸러진 데이터 중에서 emp.name이랑 sal.incentives만 보여달라는 거지.

최종 결과:

| name   | incentives |
|--------|------------|
| 이순신 | 1000       |


---------------------------------------------------------------------------------------------------------

## 문제 8) 다음은 관계형 데이터베이스 관련 용어에 대한 설명이다.  
각 설명과 올바르게 매칭되는 용어를 보기에서 찾아 기호를 쓰시오.

---

### 설명:

1. 하나의 테이블에 존재하는 속성(Attribute)의 개수  
2. 하나의 테이블에 존재하는 튜플(Tuple)의 개수  
3. 다른 테이블의 기본키를 참조하는 키  
4. 하나의 속성이 가질 수 있는 값의 범위

---

### 보기:

ㄱ. degree  
ㄴ. cardinality  
ㄷ. primary  
ㄹ. foreign key  
ㅁ. attribute  
ㅂ. domain  
ㅅ. candidate key  
ㅇ. tuple

---

### **답:**

1) ㄱ (degree)  
2) ㄴ (cardinality)  
3) ㄹ (foreign key)  
4) ㅂ (domain)

---

### 📌 관련 개념 설명: 릴레이션(테이블) 구성 요소

| 용어              | 의미 설명 | 예시 |
|-------------------|-----------|------|
| **degree (차수)**     | 하나의 테이블에 **열(Column)**이 몇 개인지를 나타냄 | `학생` 테이블에 이름, 학번, 나이 → **차수는 3** |
| **cardinality (기수)** | 하나의 테이블에 **행(Row)**이 몇 개인지를 나타냄 | `학생` 테이블에 학생이 10명 등록됨 → **기수는 10** |
| **foreign key (외래 키)** | 다른 테이블의 **기본키를 참조**하는 속성으로, 테이블 간 **관계(연결)**를 나타냄 | `수강` 테이블의 `학번`이 `학생` 테이블의 `학번`을 참조 |
| **domain (도메인)**     | **속성이 가질 수 있는 값의 범위**를 정의 | 성별 속성은 '남', '여'만 허용됨 → 도메인은 `'남', '여'` |

---

### ✅ 한눈에 이해하는 핵심 포인트

- **차수**는 “세로 방향(열)” 개수  
- **기수**는 “가로 방향(행)” 개수  
- **외래키**는 “다른 테이블의 기본키 참조하는 연결선”  
- **도메인**은 “값의 범위 제한(규칙)”  

📌 예를 들어:
```sql
학생(학번, 이름, 성별)  ← 차수는 3
학생 테이블에 5명이 등록됨 → 기수는 5
수강(수강번호, 학번)에서 학번은 학생 테이블의 학번을 참조 → 외래키
성별은 '남' 또는 '여'만 가능 → 도메인


---------------------------------------------------------------------------------------------------------

## 문제 9) 다음 네트워크와 서브넷 마스크가 주어졌을 때  
브로드캐스트로 데이터를 전송할 경우 수신 가능한 IP 주소를 보기에서 모두 고르시오.

- **네트워크 주소:** 192.168.35.10  
- **서브넷 마스크:** 255.255.252.0 → **CIDR: /22**



### ✅ 정답  
**ㄱ, ㄴ, ㄷ, ㄹ, ㅁ**
---

📌 설명 (네트워크 범위를 정확히 찾는 게 핵심!)
야, 이 문제는 IP 주소랑 서브넷 마스크를 가지고, '네트워크 범위'를 정확히 찾아내는 게 핵심이야. 브로드캐스트는 특정 네트워크 안에 있는 모든 컴퓨터한테 보내는 거니까, 그 네트워크 범위 안에 있는 IP만 받을 수 있거든.

1. 서브넷 마스크 255.255.252.0 해석하기
255.255.252.0 이걸 CIDR 표기법으로 바꾸면 **/22**가 돼.

255는 2진수로 1이 8개 (11111111)
255는 2진수로 1이 8개 (11111111)
252는 2진수로 11111100 (1이 6개, 0이 2개)
0은 2진수로 0이 8개 (00000000)

1의 개수를 다 더하면 8 + 8 + 6 = 22개지? 그래서 /22가 되는 거야.

/22의 의미: IP 주소 32비트 중에서 **앞의 22비트는 '네트워크 주소'고, 뒤의 32 - 22 = 10비트는 '호스트 주소'**라는 뜻이야.

호스트 주소 비트 수 = 10비트

이 10비트로 나타낼 수 있는 IP 개수는 2^10 = 1024개야.

이 1024개 IP가 하나의 서브넷(네트워크 덩어리)에 들어간다는 거지.


세 번째 옥텟(252)의 0의 의미:
255.255.252.0에서 세 번째 옥텟이 252잖아? 이걸 256 - 252 = 4 이렇게 계산하면, 네트워크 주소의 세 번째 숫자가 4 단위로 바뀐다는 뜻이야.
예를 들면 xxx.xxx.0.0, xxx.xxx.4.0, xxx.xxx.8.0, xxx.xxx.12.0 ... 이런 식으로 네트워크가 나뉜다는 거지.

2. 192.168.35.10이 속한 네트워크 범위 찾기
우리한테 주어진 IP는 192.168.35.10이야.

세 번째 옥텟이 35지? 아까 4 단위로 네트워크가 바뀐다고 했잖아?
35에서 4의 배수를 찾아보면, 32가 가장 가까운 작은 4의 배수지?
그러니까 이 IP가 속한 네트워크 주소는 192.168.32.0이 되는 거야.
네트워크 주소: 192.168.32.0

이 네트워크의 마지막 IP, 즉 브로드캐스트 주소는 어떻게 찾을까?

시작이 32.0이고, 하나의 네트워크에 IP가 1024개(0부터 1023까지) 들어간다고 했지?
192.168.32.0부터 시작해서 1024개니까,

192.168.32.0 ~ 192.168.32.255 (256개)
192.168.33.0 ~ 192.168.33.255 (256개)
192.168.34.0 ~ 192.168.34.255 (256개)
192.168.35.0 ~ 192.168.35.255 (256개)

이걸 다 합치면 정확히 1024개가 되고, 마지막 주소는 192.168.35.255가 되는 거야.

결론: 192.168.35.10이 속한 네트워크 범위는 192.168.32.0부터 192.168.35.255까지다.

유효한 호스트 IP 주소는 192.168.32.1부터 192.168.35.254까지야.

3. 보기에서 수신 가능한 IP 주소 고르기
이제 위에 찾은 네트워크 범위(192.168.32.0 ~ 192.168.35.255) 안에 들어오는 IP를 고르면 된다.

ㄱ. 192.168.32.100: 포함. (32.0 ~ 35.255 범위 안)
ㄴ. 192.168.34.50: 포함. (32.0 ~ 35.255 범위 안)
ㄷ. 192.168.35.99: 포함. (32.0 ~ 35.255 범위 안)
ㄹ. 192.168.33.25: 포함. (32.0 ~ 35.255 범위 안)
ㅁ. 192.168.35.99: 포함. (범위 안에 있고, ㄷ과 중복)
ㅂ. 192.168.36.10: 미포함. (36.0부터는 다음 네트워크 범위야.)
ㅅ. 192.168.31.150: 미포함. (31.0 이하부터는 이전 네트워크 범위야.)
ㅇ. 192.168.38.200: 미포함. (범위 벗어남.)
ㅈ. 192.168.39.10: 미포함. (범위 벗어남.)

---

---------------------------------------------------------------------------------------------------------

## 문제 10) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

#include <stdio.h>                                                       // printf 같은 입출력 함수를 위해 필요

int main(){
    char arr[5] = {'B', 'A', 'D', 'E'};                               // 문자 배열 선언. 크기 5인데 4개만 초기화 -> arr[4]는 널문자('\0')
    char c = 'C';                                                       // 문자 변수 'c'에 'C' 저장
    int i;                                                               // 반복문 등에 사용될 정수형 변수

                                                                            // 1. 첫 번째 printf: 문자 빼기 (아스키 코드 값으로 계산)
    printf("%d\n", arr[3] - arr[1]);

                                                                                // 2. 첫 번째 for 루프: 특정 위치 찾기
    for(i = 0; i < 4; i++){
        if(arr[i] > c)                                                           // arr[i] 문자가 'C'보다 크면
            break;                                                                 // 루프를 멈춘다
    }

                                                                                      // 3. 찾은 위치에 'C'를 삽입하고 뒤의 문자들을 민다.
    char temp = arr[i];                                                                 // arr[i]의 원래 값을 temp에 임시 저장
    arr[i] = c;                                                                         // arr[i] 위치에 'C'를 넣는다
    i++;                                                                                 // i를 1 증가시켜서 다음 루프 시작점을 맞춘다

                                                                                          // 4. 두 번째 for 루프: 남은 문자들을 한 칸씩 뒤로 밀기
    for(; i < 5; i++){                                                                     // i는 위에서 증가된 값부터 시작한다. arr의 끝까지 반복
        char temp2 = arr[i];                                                                     // arr[i]의 현재 값을 temp2에 임시 저장
        arr[i] = temp;                                                                             // arr[i] 위치에 이전 루프에서 밀려난 temp 값을 넣는다
        temp = temp2;                                                                             // 다음 루프를 위해 temp 값을 업데이트한다
    }

                                                                                                            // 5. 최종 배열 출력
    for(i = 0; i < 5; i++){
        printf("%c", arr[i]);                                                                               // 문자 하나씩 출력
    }
    return 0;
}



답:
4
BACDE


📌 설명 (문자 삽입 과정이 핵심!)
야, 이 코드는 문자 배열을 다루면서 아스키 코드 연산, 그리고 배열 중간에 문자를 끼워 넣는(삽입) 과정을 보여주는 문제야. 한 단계씩 잘 따라와 봐.

1. 초기 상태 확인
arr 배열은 {'B', 'A', 'D', 'E'}로 초기화돼 있어. 크기가 5인데 4개만 채웠으니까, arr[4]는 C언어에서 자동으로 \0 (널문자)으로 채워진다.

arr[0] = 'B'

arr[1] = 'A'

arr[2] = 'D'

arr[3] = 'E'

arr[4] = '\0'

c 변수에는 'C' 문자가 들어있다.

2. 첫 번째 printf 출력 (arr[3] - arr[1])
printf("%d\n", arr[3] - arr[1]); 이 부분은 문자끼리 빼기를 하고 결과를 정수로 출력하라고 돼 있지?
C언어에서 문자는 사실 아스키(ASCII) 코드 값이라는 숫자로 저장돼.

arr[3]은 'E'야. 'E'의 아스키 코드 값은 **69**다.

arr[1]은 'A'야. 'A'의 아스키 코드 값은 **65**다.

그래서 69 - 65 = 4가 돼. 첫 번째 출력은 **4**다. 그리고 \n 때문에 줄바꿈이 일어난다.

3. 첫 번째 for 루프 (삽입될 위치 찾기)
for 루프는 i가 0부터 시작해서 arr[i] > c (즉, arr[i]가 'C'보다 크면) break로 멈추는 거야.

i = 0: arr[0]은 'B' (66). 'B' > 'C' (66 > 67)? 거짓. 계속.

i = 1: arr[1]은 'A' (65). 'A' > 'C' (65 > 67)? 거짓. 계속.

i = 2: arr[2]는 'D' (68). 'D' > 'C' (68 > 67)? 참! break로 루프가 멈춘다.

이 시점에서 i는 2가 된다.

4. 중간에 문자 삽입 및 뒤로 밀기
루프가 멈춘 i=2 위치에 c ('C')를 넣고, 원래 있던 문자들을 한 칸씩 뒤로 미는 과정이야.

char temp = arr[i];: temp에 arr[2]의 값인 **'D'**를 저장한다.

arr[i] = c;: arr[2]에 c의 값인 **'C'**를 넣는다.

현재 arr 상태: {'B', 'A', 'C', 'E', '\0'}

i++;: i는 2에서 **3**으로 증가한다. (이 다음 for 루프의 시작점이 됨)

5. 두 번째 for 루프 (나머지 문자들 밀어 넣기)
이제 i는 3부터 시작해서 arr의 끝까지 (i < 5) 돌면서, 아까 temp에 저장했던 문자들을 차례대로 뒤로 밀어 넣는다.

i = 3일 때:

char temp2 = arr[i]; (temp2에 arr[3]의 값인 **'E'**를 저장)

arr[i] = temp; (arr[3]에 temp의 값인 **'D'**를 넣는다)

현재 arr 상태: {'B', 'A', 'C', 'D', '\0'}

temp = temp2; (temp는 temp2의 값인 **'E'**가 된다)

i = 4일 때:

char temp2 = arr[i]; (temp2에 arr[4]의 값인 **'\0'**을 저장)

arr[i] = temp; (arr[4]에 temp의 값인 **'E'**를 넣는다)

현재 arr 상태: {'B', 'A', 'C', 'D', 'E'}

temp = temp2; (temp는 temp2의 값인 **'\0'**이 된다)

루프 종료.

6. 최종 for 루프 (최종 배열 출력)
마지막 for 루프는 arr 배열의 모든 문자를 순서대로 출력한다.

arr[0] = 'B'

arr[1] = 'A'

arr[2] = 'C'

arr[3] = 'D'

arr[4] = 'E'

그래서 최종적으로 **BACDE**가 출력된다.

---------------------------------------------------------------------------------------------------------

## 문제 11) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

#include <stdio.h>
#include <stdlib.h>

int A[9] = {8, 9, 3, 7, 2, 8, 3, 1, 4};                                     // 1차원 배열 A

void func(int **res, int cols, int rows) {                         // 2차원 배열 res를 채우는 함수
    for(int i = 0; i < (cols * rows); i++) {
        int r = (i + 1) % (rows * cols);                         // 핵심: 인덱스를 한 칸 밀어서 계산!
        res[r / cols][r % cols] = A[i];                         // A[i] 값을 res의 특정 위치에 넣는다.
    }
}

int main() {
    int **res;                                                                 // 2차원 배열 포인터
    int cols = 3;                                                                 // 열의 개수
    int rows = 3;                                                                   // 행의 개수
    int sum = 0;                                                                   // 최종 합계를 저장할 변수

                                                                              // 2차원 배열 res를 동적으로 할당한다 (3x3 크기)
    res = (int **)malloc(sizeof(int *) * rows);
    for(int i = 0; i < rows; i++) {
        res[i] = (int *)malloc(sizeof(int) * cols);
    }

    func(res, cols, rows);                                                                       // res 배열에 값을 채운다.

                                                                                // res 배열의 값들을 순서대로 더하거나 빼는 계산
    for(int i = 0; i < rows * cols; i++) {
                                                                                // i가 짝수면 +1을 곱하고 (그대로 더하고), i가 홀수면 -1을 곱한다 (빼기).
        sum += res[i / cols][i % cols] * ((i % 2 == 0) ? 1 : -1);
    }

    printf("%d", sum);                                                                                       // 최종 합계 출력

                                                                                  // 동적으로 할당한 메모리를 해제한다.
    for(int i = 0; i < rows; i++) {
        free(res[i]);
    }
    free(res);

    return 0;
}



📌 설명 (두 단계로 나눠서 계산!)
야, 이 문제는 두 단계로 나눠서 계산해야 돼.

func 함수가 2차원 배열 res를 어떻게 채우는지 알아내기.

main 함수의 마지막 for 루프에서 sum을 어떻게 계산하는지 알아내기.

1. func 함수로 res 배열 채우기
func 함수는 A 배열에 있는 값들을 res라는 3x3 크기의 2차원 배열에 옮겨 넣는 역할이야. 근데 그냥 순서대로 넣는 게 아니고, r = (i + 1) % (rows * cols); 이 부분 때문에 인덱스가 한 칸씩 뒤로 밀려서 들어가.

rows * cols는 3 * 3 = 9다. 그러니까 r = (i + 1) % 9가 되는 거지.

자, i가 0부터 8까지 돌면서 어떻게 res에 값이 들어가는지 표로 보자.

## 📌 res 배열에 값이 들어가는 과정

| i | r = (i+1)%9 | 행 (r / cols) | 열 (r % cols) | A[i] 값 | res 배열 위치        | 값 할당         |
|---|-------------|---------------|---------------|---------|----------------------|------------------|
| 8 | 0           | 0             | 0             | 4       | res[0][0]            | 4                |
| 0 | 1           | 0             | 1             | 8       | res[0][1]            | 8                |
| 1 | 2           | 0             | 2             | 9       | res[0][2]            | 9                |
| 2 | 3           | 1             | 0             | 3       | res[1][0]            | 3                |
| 3 | 4           | 1             | 1             | 7       | res[1][1]            | 7                |
| 4 | 5           | 1             | 2             | 2       | res[1][2]            | 2                |
| 5 | 6           | 2             | 0             | 8       | res[2][0]            | 8                |
| 6 | 7           | 2             | 1             | 3       | res[2][1]            | 3                |
| 7 | 8           | 2             | 2             | 1       | res[2][2]            | 1                |





이 과정을 거치면, res 배열은 최종적으로 이렇게 채워진다.

res = [
    [4, 8, 9],  // res[0][0], res[0][1], res[0][2]
    [3, 7, 2],  // res[1][0], res[1][1], res[1][2]
    [8, 3, 1]   // res[2][0], res[2][1], res[2][2]
]



2. main 함수에서 sum 계산하기
이제 main 함수의 마지막 for 루프에서 sum을 계산한다.
sum += res[i / cols][i % cols] * ((i % 2 == 0) ? 1 : -1); 이 부분이 핵심이야.

res[i / cols][i % cols]는 res 배열의 값들을 **정상적인 순서(0,0 -> 0,1 -> 0,2 -> 1,0 ...)**로 접근한다는 뜻이야.

((i % 2 == 0) ? 1 : -1) 이거는 i가 짝수면 +1을 곱하고, i가 홀수면 -1을 곱한다는 말이야. 즉, 짝수 번째 값은 더하고, 홀수 번째 값은 뺀다는 거지.

자, 이제 i가 0부터 8까지 돌면서 sum이 어떻게 변하는지 보자.

i = 0 (짝수): sum += res[0][0] * 1 = 4 * 1 = 4 (sum = 4)
i = 1 (홀수): sum += res[0][1] * -1 = 8 * -1 = -8 (sum = 4 - 8 = -4)
i = 2 (짝수): sum += res[0][2] * 1 = 9 * 1 = 9 (sum = -4 + 9 = 5)
i = 3 (홀수): sum += res[1][0] * -1 = 3 * -1 = -3 (sum = 5 - 3 = 2)
i = 4 (짝수): sum += res[1][1] * 1 = 7 * 1 = 7 (sum = 2 + 7 = 9)
i = 5 (홀수): sum += res[1][2] * -1 = 2 * -1 = -2 (sum = 9 - 2 = 7)
i = 6 (짝수): sum += res[2][0] * 1 = 8 * 1 = 8 (sum = 7 + 8 = 15)
i = 7 (홀수): sum += res[2][1] * -1 = 3 * -1 = -3 (sum = 15 - 3 = 12)
i = 8 (짝수): sum += res[2][2] * 1 = 1 * 1 = 1 (sum = 12 + 1 = 13)

모든 계산이 끝나면 최종 sum 값은 **13**이 된다.

그래서 최종적으로 printf("%d", sum);를 하면 **13**이 출력되는 거야.


---------------------------------------------------------------------------------------------------------

## 문제 12) 아래 설명을 읽고 빈칸에 들어갈 결합도를 쓰시오.

---

### 문제 설명

1. 하나의 모듈이 다른 모듈 내부에 있는 변수나 기능을 **직접 접근하거나 사용하는 경우**를 의미하며,  
   가장 강한 결합도로 모듈 간 독립성을 크게 해친다.

2. 모듈 간의 인터페이스로 단순 자료형이 아니라 **배열(Array), 객체(Object), 구조체**와 같은  
   복합적인 자료 구조가 전달되는 경우를 의미한다.  
   호출하는 모듈이 필요하지 않은 정보까지 함께 전달받아 모듈의 독립성을 저하시킬 수 있다.

3. 두 개 이상의 모듈이 **파라미터로 데이터를 전달하지 않고**, 외부에 선언된 전역변수를 참조하거나 수정하면서  
   서로 상호작용하는 경우이다. 모듈 간 결합도가 강하고 모듈 독립성이 저하된다.

---
### ✅ 문제

아래 설명에 해당하는 **결합도(Coupling)** 유형을 쓰시오.

1) 한 모듈이 다른 모듈의 내부 동작이나 데이터를 **직접 접근하거나 수정**한다.  
2) 배열이나 구조체 등 **복합 자료형을 통째로 전달**하여, **불필요한 정보까지 전달**된다.  
3) 여러 모듈이 **공유되는 전역 변수**를 사용한다.

---

### ✅ 정답

1) **내용 결합도**  
2) **스탬프 결합도**  
3) **공통 결합도**

---

### 📌 관련 개념 설명: 결합도 유형

| 결합도 종류       | 설명 | 예시 |
|------------------|------|------|
| **내용 결합도**   | 한 모듈이 다른 모듈의 **내부 로직/데이터**에 직접 접근하거나 수정함. <br>가장 강한 결합 → 유지보수성 최악 | `Module A`가 `Module B`의 지역 변수에 직접 접근하거나, 내부 함수를 직접 호출 |
| **스탬프 결합도** | 배열, 구조체 등 **복합 자료형 전체**를 전달함으로써 <br>필요하지 않은 정보까지 함께 전달됨 | 고객 정보를 담은 구조체 `CustomerInfo` 전체를 전달했지만, 실제로는 이름과 전화번호만 사용 |
| **공통 결합도**   | 여러 모듈이 **공통의 전역 변수**를 공유하여 사용함 | `global int sharedData`를 `Module A`, `Module B`가 동시에 접근/수정 |
| **제어 결합도**   | 한 모듈이 **논리적인 제어 변수**를 전달하여 다른 모듈의 수행 흐름을 제어 | `Module A`가 `flag = 1`을 넘겨서 `Module B`가 `if(flag)` 형태로 동작 변경 |
| **자료 결합도**   | 모듈 간에 **필요한 데이터만** 전달하며, 가장 이상적인 결합 형태 | `Module A`가 `Module B(num)`처럼 정확히 필요한 값만 전달 |
| **외부 결합도**   | 모듈 간에 외부 장치나 파일, 환경 변수 등을 통해 데이터를 주고받음 | 파일 시스템을 통해 데이터를 공유하거나, 환경 변수로 설정 전달 |
| **내용 없음**     | 결합도가 낮을수록 모듈 간 **독립성이 높고, 유지보수가 용이**함 |

---

> 💡 **결합도는 낮을수록 좋다!**  
> → 높은 결합도는 수정 시 다른 모듈까지 영향을 미쳐 유지보수성 저하



---------------------------------------------------------------------------------------------------------

## 문제 13) 다음은 Java 코드이다. 출력 결과를 쓰시오.

class Parent {
    static int total = 0;                                                   // 1. static: 클래스 전체가 공유하는 'total' 변수

    int v = 1;                                                                 // 2. 인스턴스 변수 'v' (객체마다 따로 가짐)

    public Parent() {                                                             // 3. 부모 클래스 생성자
        total += (++v);                                                            // 'v'를 먼저 1 증가시키고 (v=2), 'total'에 더한다.
        showValue();                                                             // 'showValue' 메서드를 호출한다. (핵심: 어떤 showValue가 불릴까?)
    }

    public void showValue() {                                                           // 4. 부모 클래스의 'showValue' 메서드
        total += total;                                                                   // 'total' 값을 두 배로 만든다.
    }
}

class Child extends Parent {                                                                                 // 5. 자식 클래스 (부모를 상속받음)
    int v = 10;                                                                                 // 6. 자식 클래스만의 'v' 변수 (부모의 'v'와는 다른 놈!)

    public Child() {                                                                                               // 7. 자식 클래스 생성자
                                                                                            // (참고: 자바는 자식 생성자가 불리면 무조건 부모 생성자부터 자동으로 먼저 호출한다!)
        v += 2;                                                                                                    // 자식의 'v'에 2를 더한다.
        total += (v++);                                                                                        // 'total'에 자식의 'v'를 먼저 더하고, 'v'를 나중에 1 증가시킨다.
        showValue();                                                                                       // 'showValue' 메서드를 호출한다. (핵심: 어떤 showValue가 불릴까?)
    }

    @Override                                                                                 // 8. 부모의 'showValue'를 덮어쓰는(오버라이딩) 자식의 'showValue' 메서드
    public void showValue() {
        total += total * 2;                                                                           // 'total' 값을 3배로 만든다. (total + total*2 = total*3)
    }
}

class Main {
    public static void main(String[] args) {
        new Child();                                                                                             // Child 객체를 하나 만든다.
        System.out.println(Parent.total);                                                                         // Parent 클래스의 'total' 값을 출력한다.
    }
}


답: 54

📌 설명 (총 total 값의 변화를 추적하는 게 핵심!)
야, 이 코드는 클래스 상속, 객체 생성 과정, 그리고 메서드 오버라이딩이 얽혀서 total이라는 변수 값이 어떻게 바뀌는지 따라가는 문제야. static 변수는 클래스 전체가 공유하고, new Child() 할 때 부모 생성자가 먼저 호출된다는 게 존나 중요해.

total 변수 값을 잘 추적해야 해!

1. new Child() 객체 생성 과정 (제일 중요!)
new Child()를 하면, 자바는 무조건 부모인 Parent의 생성자부터 먼저 호출한다.

Parent() 생성자 실행 시작:

Parent.total은 현재 0이다.

Parent 클래스의 v (인스턴스 변수)가 1로 초기화된다.

total += (++v);

v는 1에서 **2**로 먼저 증가한다.

total은 0 + 2 = 2가 된다. (현재 total = 2)

showValue(); 호출:

여기서 존나 중요한 동적 바인딩이 일어난다. 비록 Parent 생성자 안에서 호출됐지만, 실제로 만들어지는 객체는 Child 객체잖아? 그래서 Child 클래스에 있는 오버라이딩된 showValue() 메서드가 호출된다!

Child의 showValue() 실행 시작:

total += total * 2;

total은 2였다. 2 + (2 * 2) = 2 + 4 = 6이 된다. (현재 total = 6)

Child의 showValue() 실행 끝.

Parent() 생성자 실행 끝.

이제 Child() 생성자 실행 시작:

Child 클래스의 v (인스턴스 변수)가 10으로 초기화된다. (이 v는 Parent의 v와는 다른 별개의 v다!)

v += 2;

Child의 v는 10 + 2 = 12가 된다. (Child의 v = 12)

total += (v++);

total은 6이었다.

total에 Child의 v 값인 12를 먼저 더한다. total = 6 + 12 = 18. (현재 total = 18)

그 다음에 Child의 v를 1 증가시킨다. v는 12에서 **13**이 된다.

showValue(); 호출:

이번에도 Child 객체니까, Child의 오버라이딩된 showValue() 메서드가 호출된다.

Child의 showValue() 실행 시작:

total += total * 2;

total은 18이었다. 18 + (18 * 2) = 18 + 36 = 54가 된다. (최종 total = 54)

Child의 showValue() 실행 끝.

Child() 생성자 실행 끝.

2. System.out.println(Parent.total);
모든 객체 생성이 끝나고, 마지막으로 Parent.total 값을 출력한다.
위에서 계산한 최종 total 값은 **54**였다.

그래서 최종 출력 결과는 **54**가 된다.
---------------------------------------------------------------------------------------------------------

## 문제 14) 다음 설명을 읽고 어떤 디자인 패턴인지 보기에서 골라 쓰시오

### 문제 설명

- 이 패턴은 **Wrapper(래퍼)**라고도 불린다.  
- 서로 호환되지 않는 두 개의 클래스 사이에서 한 클래스의 인터페이스를 다른 클래스가 기대하는 형태로 변환하여  
  기존에 호환되지 않았던 클래스들이 함께 작동할 수 있도록 해주는 **구조적 디자인 패턴**이다.  
- 이 패턴을 활용하면 이미 존재하는 클래스를 수정하지 않고도 기존 코드와 새로운 코드의 통합을 용이하게 만들 수 있다.

---

### 답

**ㄹ. Adapter**

---

### 📌 디자인 패턴 보기 및 설명 정리

---

#### ✅ 보기 및 각 패턴 설명

| 기호 | 디자인 패턴명         | 설명 |
|------|----------------------|------|
| ㄱ   | **Singleton**        | 클래스의 인스턴스를 **하나만 생성**하고, 어디서든 **접근 가능**하도록 하는 생성 패턴 |
| ㄴ   | **Factory Method**   | 객체 생성 코드를 **서브클래스에 위임**하여, 생성 과정을 **캡슐화**하는 생성 패턴 |
| ㄷ   | **Abstract Factory** | 관련성 있는 객체들의 집합을 **추상적인 인터페이스**를 통해 생성하는 생성 패턴 |
| ㄹ   | **Adapter**          | **호환되지 않는 인터페이스**를 연결하여 기존 코드를 **수정 없이 재사용**할 수 있게 하는 구조 패턴 |
| ㅁ   | **Decorator**        | 객체에 **동적으로 새로운 책임(기능)**을 부여하는 구조 패턴 |
| ㅂ   | **Observer**         | 객체의 상태 변화 시 **연관된 객체에 자동 통보**하는 행동 패턴 |
| ㅅ   | **Visitor**          | 객체 구조는 그대로 두고, **새로운 기능을 분리해서 추가**하는 행동 패턴 |

---

#### ✅ 보충 설명

### 🔹 Adapter (어댑터) 패턴

- **용도**: 기존 클래스나 라이브러리를 **수정하지 않고**, 다른 시스템과 호환되게 만들기 위함
- **사용 예시**:
  - 오래된 시스템의 API와 최신 시스템의 API를 연결
  - 서로 다른 포맷이나 인터페이스를 맞춰줄 때

```java
// 예시: USB-C → HDMI 어댑터처럼 인터페이스 호환을 맞춰주는 중간자
Client ----> Adapter ----> 기존 클래스


---------------------------------------------------------------------------------------------------------

## 문제 15) 구문(문장) 커버리지를 수행하려고 한다.  
아래 제어 흐름도의 빈칸에 맞는 소스코드를 쓰고, 구문 커버리지의 경로를 쓰시오.

---

### [소스코드]

```c
int fnc(int a){
    int total = 0;
    while (a >= 0){
        if (a % 2 == 0)
            total = total + a;
        a = a - 2;
    }
    return total;
}

[제어 흐름도]
    1 ←
    ↓ ↑ 
6 ← 2 ↑
    ↓ ↑
    3 ↑
    ↓ ↑
    4 ↑
    ↓ ↑
    5 →

[제어 흐름도의 빈칸에 들어갈 코드]
total = 0;
a >= 0
a % 2 == 0
total = total + a;
a = a - 2;

return total;

구문 커버리지 경로
1 → 2 → 3 → 4 → 5 → 2 → 6


📌 설명 (모든 코드 줄을 한 번씩 실행!)
야, 구문 커버리지는 그냥 딱 이거야.
"프로그램에 있는 모든 코드 줄을 최소 한 번씩은 실행시켜 봐야 한다!"
말 그대로 **'모든 문장을 커버한다'**는 뜻이지. 네가 길을 가는데, 어떤 골목이든, 어떤 건물 입구든, 지나갈 수 있는 곳은 다 한 번씩 밟아봐야 한다는 거야.

위에 있는 C 코드랑 제어 흐름도를 봐봐.

int total = 0; 이게 첫 번째 초기화 부분이고, 흐름도에서 1번이야.
while (a >= 0) 이게 반복문 조건이고, 흐름도에서 2번이야.
if (a % 2 == 0) 이게 조건문이고, 흐름도에서 3번이야.
total = total + a; 이게 if 조건이 맞을 때 실행되는 부분이고, 흐름도에서 4번이야.
a = a - 2; 이게 while 문 안에서 a 값을 줄이는 부분이고, 흐름도에서 5번이야.
return total; 이게 함수가 끝날 때 값을 돌려주는 부분이고, 흐름도에서 6번이야.

구문 커버리지를 100% 만들려면, 위에 나열된 모든 코드 줄(1번부터 6번까지)이 최소 한 번씩은 실행돼야 해.

그래서 제시된 경로 1 → 2 → 3 → 4 → 5 → 2 → 6를 보면,

1번(초기화) 실행.

2번(while 조건) 실행.

3번(if 조건) 실행.

4번(if 안) 실행. (이걸 실행하려면 a % 2 == 0이 참이어야겠지?)

5번(a = a - 2;) 실행.

다시 2번(while 조건)으로 돌아가서 실행.

그리고 while 루프가 끝나고 6번(return total;)이 실행되는 거야.

이렇게 한 번의 테스트 경로로 모든 코드 줄을 다 밟아볼 수 있다면, 그게 바로 구문 커버리지를 만족하는 경로가 되는 거지.
---------------------------------------------------------------------------------------------------------

## 문제 16) 다음은 Java 코드이다. 출력 결과를 쓰시오.

class Main {
    static int func(int[] a, int st, int end) {
        if (st >= end) return 0;                                                               // 1. 재귀 탈출 조건
        int mid = (st + end) / 2;                                                                 // 2. 중간 인덱스 계산
        return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));             // 3. 중간값 + 양쪽 재귀 호출 결과 중 큰 값
    }

    public static void main(String[] args) {
        int[] a = new int[] {3, 5, 8, 12, 17};                                                       // 배열 초기화
        int result = func(a, 0, a.length - 1);                                                       // 함수 호출 (a, 0, 4)
        System.out.println(result);                                                                     // 결과 출력
    }
}

답: 20 


📌 설명 (쪼개고, 쪼개서 계산!)
야, 이 코드는 func라는 함수가 자기 자신을 계속 부르는 재귀 함수야.
존나 복잡해 보이지만, "배열을 계속 반으로 쪼개서, 중간값에다가 쪼갠 두 덩어리 중 더 큰 값을 계속 더해가는" 거라고 생각하면 된다.

배열 a는 [3, 5, 8, 12, 17]이야. (인덱스는 0부터 4까지)

제일 처음 main 함수에서 func(a, 0, 4)를 호출했지? 이제부터 이 함수가 어떻게 돌아가는지 따라가 보자.

1. func(a, 0, 4) 호출 (제일 처음)
mid 계산: (0 + 4) / 2 = 2.

a[mid] 값: a[2]는 **8**이야. 이 8은 일단 챙겨 놔.

이제 Math.max 안의 두 부분을 계산해야 해.

왼쪽 덩어리: func(a, 0, 2) 호출
오른쪽 덩어리: func(a, 3, 4) 호출


2. func(a, 0, 2) 호출 (왼쪽 덩어리)
mid 계산: (0 + 2) / 2 = 1.

a[mid] 값: a[1]은 **5**야. 이 5도 일단 챙겨 놔.

또 Math.max 안의 두 부분을 계산해야 해.

왼쪽 쪼개기: func(a, 0, 1) 호출
오른쪽 쪼개기: func(a, 2, 2) 호출


2-1. func(a, 0, 1) 호출 (왼쪽 쪼개기)
mid 계산: (0 + 1) / 2 = 0.

a[mid] 값: a[0]은 **3**이야. 이 3도 일단 챙겨 놔.

또 Math.max 안의 두 부분을 계산.

func(a, 0, 0) 호출: st >= end (0 >= 0) 조건 맞지? 그럼 바로 0을 반환하고 끝난다.
func(a, 1, 1) 호출: st >= end (1 >= 1) 조건 맞지? 그럼 바로 0을 반환하고 끝난다.
결국, func(a, 0, 1)은 a[0] (값: 3) + Math.max(0, 0) = 3 + 0 = 3을 반환한다.

2-2. func(a, 2, 2) 호출 (오른쪽 쪼개기)
st >= end (2 >= 2) 조건 맞지? 그럼 바로 0을 반환하고 끝난다.

이제 func(a, 0, 2)로 돌아가서 계산.
a[1] (값: 5) + Math.max(func(a, 0, 1)의 결과인 3, func(a, 2, 2)의 결과인 0)
= 5 + Math.max(3, 0) = 5 + 3 = 8을 반환한다.


3. func(a, 3, 4) 호출 (오른쪽 덩어리)
mid 계산: (3 + 4) / 2 = 3.

a[mid] 값: a[3]은 **12**야. 이 12도 일단 챙겨 놔.

또 Math.max 안의 두 부분을 계산해야 해.

왼쪽 쪼개기: func(a, 3, 3) 호출

st >= end (3 >= 3) 조건 맞지? 그럼 바로 0을 반환하고 끝난다.

오른쪽 쪼개기: func(a, 4, 4) 호출

st >= end (4 >= 4) 조건 맞지? 그럼 바로 0을 반환하고 끝난다.
결국, func(a, 3, 4)는 a[3] (값: 12) + Math.max(0, 0) = 12 + 0 = 12를 반환한다.

4. 다시 func(a, 0, 4)로 돌아가 최종 계산!
a[2] (값: 8) + Math.max(func(a, 0, 2)의 결과인 8, func(a, 3, 4)의 결과인 12)

= 8 + Math.max(8, 12)
= 8 + 12
= 20

그래서 최종적으로 20이 출력되는 거야.
---------------------------------------------------------------------------------------------------------

class Node:
    def __init__(self, value):
        self.value = value
        self.children = []                                                       # 자식 노드들을 저장할 리스트

def tree(li):
    nodes = [Node(i) for i in li]                                                   # 리스트의 각 값으로 노드를 만든다.
    for i in range(1, len(li)):
                                                                                    # 부모 노드에 자식 노드를 추가한다. (이진 트리처럼)
                                                                                    # (i-1) // 2 는 현재 노드(i)의 부모 노드 인덱스를 계산하는 식이다.
        nodes[(i - 1) // 2].children.append(nodes[i])
    return nodes[0]                                                                   # 리스트의 첫 번째 노드를 트리의 '뿌리'로 반환한다.

def s(node, level=0):                                                                     # 's' 함수는 트리를 순회하면서 특정 값을 더한다.
    if not node:                                                                             # 노드가 없으면 (끝까지 갔으면) 0을 반환
        return 0
                                                                                            # 핵심: 레벨이 짝수이면 0을 더하고, 홀수이면 노드의 값을 더한다.
    total = node.value if level % 2 else 0 
    for child in node.children:                                                               # 현재 노드의 모든 자식들을 순회하며 재귀 호출
        total += s(child, level + 1)                                                           # 다음 레벨로 넘어가면서 재귀 호출 결과를 더한다.
    return total                                                                                       # 최종 합계 반환

li = [1, 5, 8, 12, 15, 18]                                                                                 # 입력 리스트
root = tree(li)                                                                                               # 리스트로 트리를 만든다.
print(s(root))                                                                                                 # s 함수를 호출해서 결과를 출력한다.


📌 설명 (트리 만들고 홀수 레벨만 더하기!)
야, 이 문제는 파이썬으로 **트리(Tree)**라는 자료구조를 만들고, 그걸 탐색하면서 특정 조건을 만족하는 값들만 더하는 코드야.

1. tree(li) 함수로 트리 만들기
li = [1, 5, 8, 12, 15, 18] 이 리스트로 tree 함수가 트리를 만들어. 코드를 보면 이진 트리처럼 연결하는데, 결과적으로 이런 모양이 돼.

레벨 0 (뿌리 노드): 1
(부모: 없음)

레벨 1 (1의 자식): 5, 8
(부모: 1)

레벨 2 (5와 8의 자식): 12, 15 (5의 자식), 18 (8의 자식)
(부모: 5, 8)


2. s(node, level) 함수로 값 더하기
s 함수가 트리를 처음부터 끝까지 돌아다니면서 값을 더하는데, 존나 중요한 조건이 있어.
total = node.value if level % 2 else 0 이 부분이지?
이건 level이 홀수일 때만 node.value를 total에 더하고, level이 짝수일 때는 0을 더하라는 뜻이야.
자, 이제 s(root)를 호출했을 때 어떻게 계산되는지 따라가 보자.

s(1번 노드, level=0) 호출:
레벨 0은 짝수니까, total에 1을 더하지 않고 **0**을 더해. (total = 0)
이제 1번 노드의 자식들을 재귀 호출한다.

s(5번 노드, level=1) 호출 (1번 노드의 첫 번째 자식):
레벨 1은 홀수니까, total에 5를 더해. (total = 5)
이제 5번 노드의 자식들을 재귀 호출한다.

s(12번 노드, level=2) 호출 (5번 노드의 첫 번째 자식):
레벨 2는 짝수니까, total에 0을 더해. (아무것도 더해지지 않음)
12번 노드는 자식이 없으니 여기서 끝. 0을 반환.

s(15번 노드, level=2) 호출 (5번 노드의 두 번째 자식):
레벨 2는 짝수니까, total에 0을 더해. (아무것도 더해지지 않음)
15번 노드는 자식이 없으니 여기서 끝. 0을 반환.
(여기까지 s(5번 노드, level=1)은 5 + 0 + 0 = 5를 반환하게 돼.)

s(8번 노드, level=1) 호출 (1번 노드의 두 번째 자식):
레벨 1은 홀수니까, total에 8을 더해. (total = 8)
이제 8번 노드의 자식들을 재귀 호출한다.

s(18번 노드, level=2) 호출 (8번 노드의 첫 번째 자식):
레벨 2는 짝수니까, total에 0을 더해. (아무것도 더해지지 않음)
18번 노드는 자식이 없으니 여기서 끝. 0을 반환.
(여기까지 s(8번 노드, level=1)은 8 + 0 = 8을 반환하게 돼.)

자, 이제 제일 처음 s(1번 노드, level=0)으로 돌아와서 최종 계산을 해보자.

s(1번 노드, level=0)은 (자기 값 0) + (s(5번 노드) 결과인 5) + (s(8번 노드) 결과인 8)

= 0 + 5 + 8 = 13

그래서 최종적으로 print(s(root))를 하면 **13**이 출력되는 거야.

---------------------------------------------------------------------------------------------------------

## 문제 18) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

#include <stdio.h>
#include <stdlib.h> // malloc, free 때문에 필요

typedef struct Data {
    int value;
    struct Data* next;                                                   // 다음 노드를 가리키는 포인터
} Data;

                                                                        // 새로운 노드를 만들어서 리스트 맨 앞에 추가하는 함수
Data* insert(Data* head, int value) {
    Data* new_node = (Data*)malloc(sizeof(Data));                               // 새 노드 공간 확보
    new_node->value = value;                                                     // 새 노드에 값 저장
    new_node->next = head;                                                     // 새 노드가 기존 맨 앞 노드를 가리키게 함
    return new_node;                                                     // 새 노드를 맨 앞 노드로 반환
}

// 특정 값을 가진 노드를 찾아서 리스트 맨 앞으로 옮기는 함수
Data* reconnect(Data* head, int value) {
                                                                              // 1. 리스트가 비었거나, 찾는 값이 이미 맨 앞이면 바로 반환
    if (head == NULL || head->value == value) return head;

    Data* prev = NULL; // 현재 노드 바로 앞 노드를 가리킬 포인터
    Data* curr = head; // 현재 보고 있는 노드를 가리킬 포인터

                                                                                // 2. 리스트를 돌면서 찾는 'value'를 가진 노드(curr)와 그 앞 노드(prev)를 찾는다.
    while (curr != NULL && curr->value != value) {
        prev = curr; // prev를 curr로 한 칸 이동
        curr = curr->next; // curr를 다음 노드로 한 칸 이동
    }

                                                                                      // 3. 찾는 노드(curr)를 찾았고, 그 노드가 맨 앞이 아니었다면 (prev가 존재)
    if (curr != NULL && prev != NULL) {
        prev->next = curr->next;                                                               // (prev) -> (curr) -> (curr->next) 에서 (prev) -> (curr->next) 로 연결
        curr->next = head;                                                                     // 찾은 노드(curr)의 다음을 기존 맨 앞 노드로 연결
        head = curr;                                                                           // 찾은 노드(curr)를 새로운 맨 앞 노드로 설정
    }
    return head;                                                                                               // 바뀐 맨 앞 노드를 반환
}

int main() {
    Data* head = NULL;                                                                               // 연결 리스트의 시작 (처음엔 비어있음)
    Data* curr;                                                                                     // 리스트를 순회할 때 쓸 임시 포인터

                                                                                                        // 1. insert 함수로 노드 추가 (1부터 5까지)
    for (int i = 1; i <= 5; i++)
        head = insert(head, i);                                                                             // 맨 앞에 계속 추가됨

                                                                                                            // 2. reconnect 함수 호출 (값 3을 가진 노드를 맨 앞으로)
    head = reconnect(head, 3);

                                                                                                                // 3. 리스트를 처음부터 끝까지 돌면서 값 출력
    for (curr = head; curr != NULL; curr = curr->next)
        printf("%d", curr->value);

                                                                                                                // 메모리 해제 (실제 실행에서는 중요하지만, 출력 예측에서는 무관)
                                                                                                  // free(nodes); // 이 코드에서는 'nodes'가 아니라 'head'부터 해제해야 함. 여기서는 생략.

    return 0;
}

답: 35421


📌 설명 (노드를 옮기고 정렬!)
야, 이 코드는 연결 리스트라는 자료구조를 가지고 노드(데이터 덩어리)를 넣고, 특정 노드의 위치를 바꾸는 과정을 보여주는 거야. 하나씩 따라가 보자.

1. insert 함수로 노드 만들기
main 함수에서 for 루프를 돌면서 insert(head, i)를 실행하지?
insert 함수는 새로운 노드를 만들어서 지금 리스트의 맨 앞에다가 추가하는 역할이야.

i = 1일 때: insert(NULL, 1) -> 리스트: 1 (head는 1을 가리킴)
i = 2일 때: insert(head, 2) -> 리스트: 2 -> 1 (head는 2를 가리킴)
i = 3일 때: insert(head, 3) -> 리스트: 3 -> 2 -> 1
i = 4일 때: insert(head, 4) -> 리스트: 4 -> 3 -> 2 -> 1
i = 5일 때: insert(head, 5) -> 리스트: 5 -> 4 -> 3 -> 2 -> 1

자, reconnect 함수가 호출되기 직전의 리스트 상태는 5 -> 4 -> 3 -> 2 -> 1 이고, head는 5를 가리키고 있어.

2. reconnect(head, 3) 함수 호출
이제 reconnect(head, 3)을 호출한다. 이 함수는 값 3을 가진 노드를 찾아서 리스트의 맨 앞으로 옮기는 역할을 해.

head는 5니까, head->value == 3은 아니야.

prev는 NULL, curr는 head (즉, 5)로 시작한다.

while (curr != NULL && curr->value != 3) 루프 시작:

curr는 5. 5 != 3이니까 계속.

prev는 5가 된다. curr는 4가 된다.
(리스트: 5(prev) -> 4(curr) -> 3 -> 2 -> 1)
curr는 4. 4 != 3이니까 계속.

prev는 4가 된다. curr는 3이 된다.
(리스트: 5 -> 4(prev) -> 3(curr) -> 2 -> 1)
curr는 3. 3 == 3이니까 루프 종료! prev는 4, curr는 3인 상태다.

if (curr != NULL && prev != NULL) 조건이 맞지? (curr는 3이고 prev는 4니까)

prev->next = curr->next;: prev(값 4)의 다음을 curr(값 3)의 다음인 **2**로 연결한다.
리스트는 이제 5 -> 4 -> 2 -> 1 처럼 보이고, 3은 잠시 연결이 끊어진 상태가 된다.

curr->next = head;: curr(값 3)의 다음을 기존 맨 앞 노드였던 head(값 5)로 연결한다.

이제 3은 5를 가리키게 된다: 3 -> 5

head = curr;: 새로운 맨 앞 노드를 curr(값 3)으로 설정한다.

결과적으로 reconnect(head, 3) 함수가 끝나면, 리스트는 이렇게 바뀐다:
3 -> 5 -> 4 -> 2 -> 1

3. printf로 최종 출력
이제 main 함수에서 for (curr = head; curr != NULL; curr = curr->next) 루프를 돌면서 리스트의 모든 값을 출력한다.

head는 3을 가리키니까 3 출력. curr는 5로 이동.

curr는 5니까 5 출력. curr는 4로 이동.
curr는 4니까 4 출력. curr는 2로 이동.
curr는 2니까 2 출력. curr는 1로 이동.
curr는 1이니까 1 출력. curr는 NULL로 이동.

curr가 NULL이므로 루프 종료.

그래서 최종 출력 결과는 **35421**이 된다.

---------------------------------------------------------------------------------------------------------

## 문제 19) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char name[10];
    unsigned char score[3];
} Node;

int f(unsigned char score) {
    return score & 0xA5;                                       // 핵심: 비트 AND 연산!
}

int main() {
    Node* nodes = (Node*) malloc(2 * sizeof(Node));
    nodes[0] = (Node){"Kim", {0xF0, 0xF5, 0xDB}};
    nodes[1] = (Node){"Lee", {0xED, 0xD3, 0xF2}};

    int result = 0;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            result += f(nodes[i].score[j]);                       // f 함수 호출 결과들을 계속 더한다.
        }
    }
    printf("%d\n", result);
    free(nodes);

    return 0;
}



📌 설명 (비트 AND 연산이 핵심!)
야, 이 문제는 f 함수 안에서 일어나는 비트(Bit) AND 연산이 핵심이야. score & 0xA5 이게 뭔지 알면 존나 쉬워.
& (앰퍼샌드) 기호는 비트 AND 연산자야. 이건 두 숫자를 2진수로 바꿔서, 같은 자리에 있는 비트(0 또는 1)를 비교하는 거지. 둘 다 1일 때만 결과가 1이 되고, 나머지는 다 0이 돼.
그리고 0xA5는 16진수인데, 이걸 2진수로 바꾸면 10100101이야. 이 값이 기준이 되는 거야.
이제 코드에서 f 함수가 호출되는 과정을 하나씩 따라가 보자. nodes 배열 안에 있는 모든 score 값들을 f 함수에 넣어서 나온 결과들을 result에 계속 더하는 거야.



1. nodes[0]의 score 값들 계산:
f(0xF0):

0xF0은 16진수로 11110000 (2진수)

0xA5는 10100101 (2진수)

11110000

& 10100101

10100000 (2진수) = 0xA0 (16진수) = 160 (10진수)

f(0xF5):

0xF5는 11110101 (2진수)

& 10100101

10100101 (2진수) = 0xA5 (16진수) = 165 (10진수)

f(0xDB):

0xDB는 11011011 (2진수)

& 10100101

10000001 (2진수) = 0x81 (16진수) = 129 (10진수)




2. nodes[1]의 score 값들 계산:
f(0xED):

0xED는 11101101 (2진수)

& 10100101

10100101 (2진수) = 0xA5 (16진수) = 165 (10진수)

f(0xD3):

0xD3는 11010011 (2진수)

& 10100101

10000001 (2진수) = 0x81 (16진수) = 129 (10진수)

f(0xF2):

0xF2는 11110010 (2진수)

& 10100101

10100000 (2진수) = 0xA0 (16진수) = 160 (10진수)


3. 모든 f 함수 결과 합산:
이제 result 변수에 위에서 계산한 모든 10진수 값들을 더하는 거야.

result = 160 + 165 + 129 + 165 + 129 + 160 = 908

그래서 최종적으로 printf("%d\n", result);를 하면 **908**이 출력되는 거지.
---------------------------------------------------------------------------------------------------------

## 문제 20) 다음은 Java 코드이다. 출력 결과를 쓰시오.

class Main {
    static int add(String s) {                               // 1. 문자열을 받는 add 함수
        int t = Integer.valueOf(s);                         // 문자열 's'를 정수 't'로 바꾼다.
        if (t <= 1) return t;                               // t가 1 이하면 t를 바로 돌려준다.
        return add(t - 1) + add(t - 3);                     // 핵심: 정수형 add 함수를 두 번 호출한다!
    }

    static int add(int i) {                               // 2. 정수를 받는 add 함수 (위의 add와 이름은 같지만 매개변수 타입이 다름)
        if (i <= 1) return i;                             // i가 1 이하면 i를 바로 돌려준다.
        return add(i - 1) + add(i - 2);                     // 핵심: 정수형 add 함수를 두 번 호출한다!
    }

    public static void main(String[] args) {
        System.out.println(add("5"));                               // 메인에서 문자열 "5"를 가진 add 함수를 호출한다.
    }
}

출력 결과
4


📌 설명 (두 개의 'add' 함수가 얽히고설켜!)
야, 이 코드는 이름은 똑같은데 매개변수가 다른 add 함수가 두 개 있는 게 핵심이야.
이걸 오버로딩이라고 부른다. 그리고 두 함수 모두 자기 자신을 다시 부르는 재귀 함수야. 존나 복잡해 보이지만, 하나씩 따라가면 별거 아니다.

메인 함수에서 add("5")를 호출했으니까, 문자열을 받는 add(String s) 함수부터 실행된다.

1. add("5") 호출 (문자열 타입)
int t = Integer.valueOf(s);: s가 "5"니까, t는 **5**가 된다.

if (t <= 1) 조건은 거짓이니까 넘어간다.

return add(t - 1) + add(t - 3);: 이게 중요해! t가 5니까, add(5 - 1)이랑 add(5 - 3)을 호출하는 거야.

add(4) 호출 (정수형 add 함수)

add(2) 호출 (정수형 add 함수)

2. add(int i) 함수가 본격적으로 작동!
이제 정수를 받는 add(int i) 함수가 호출되기 시작하는데, 이건 피보나치 수열이랑 존나 비슷하게 동작한다. (add(i-1) + add(i-2))

add(1)은 1을 반환한다. (기저 조건 i <= 1에 걸려서)

add(0)은 0을 반환한다. (기저 조건 i <= 1에 걸려서)

자, 이제 아래에서부터 차곡차곡 계산해서 올라오는 거야.

add(2) 호출 (정수형)

add(2 - 1) + add(2 - 2)

= add(1) + add(0)

= 1 + 0 = 1

add(3) 호출 (정수형)

add(3 - 1) + add(3 - 2)

= add(2) + add(1)

= (add(2)의 결과인 1) + (add(1)의 결과인 1) = 1 + 1 = 2

add(4) 호출 (정수형)

add(4 - 1) + add(4 - 2)

= add(3) + add(2)

= (add(3)의 결과인 2) + (add(2)의 결과인 1) = 2 + 1 = 3

3. 다시 add("5") (문자열 타입)으로 돌아와 최종 계산!
제일 처음에 add("5")가 호출했을 때 add(4) + add(2)를 계산해야 했지?

add(4)의 결과는 3

add(2)의 결과는 1

최종적으로 3 + 1 = 4가 된다.

그래서 4가 출력되는 거야. 
