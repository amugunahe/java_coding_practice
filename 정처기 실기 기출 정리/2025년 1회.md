## 문제 1) 다음 네트워크 보안과 관련된 공격 기법에 대한 설명이다.  
다음 설명을 읽고 물음에 답하시오.

네트워크상에서 클라이언트와 서버 간에 인증된 통신이 이루어지고 있을 때, 공격자가 중간에서 인증이 필요한  
특정한 정보를 가로채어 사용자의 권한을 탈취하는 공격을 (        )라고 한다.  
이 공격에 성공하면 공격자는 정상 사용자의 권한을 얻어 불법적으로 서버에 접근하거나 정보를 유출할 수 있다.  
대표적인 공격 기법으로는 네트워크 패킷을 스니핑하여 인증 정보를 탈취하거나, 웹 브라우저에 저장된  
인증용 쿠키를 탈취하여 이용하는 방식이 있다.

**답:** 세션 하이재킹(Session Hijacking)

---

📌 **관련 개념 설명:**

- **세션 하이재킹(Session Hijacking)**  
  사용자가 웹 애플리케이션에 로그인한 이후, 그 로그인 상태를 유지하기 위한 세션 ID(쿠키, 토큰 등)를 공격자가 탈취하여,  
  해당 사용자인 것처럼 가장하는 공격 기법이다. 세션 ID가 유출되면 공격자는 사용자 인증 절차를 우회하고,  
  사용자 권한으로 시스템에 접근할 수 있다.

- **공격 방법의 예:**
  - **스니핑(Sniffing):** 네트워크 상의 패킷을 감청하여 세션 ID 등의 민감 정보를 수집.
  - **쿠키 탈취(Cookie Theft):** XSS 등으로 클라이언트 측에 저장된 인증 쿠키를 가로챔.
  - **세션 고정(Session Fixation):** 미리 설정된 세션 ID를 사용자에게 강제로 사용하게 한 후 탈취.

- **방어 방법:**
  - HTTPS 프로토콜을 통한 암호화
  - 세션 타임아웃 설정
  - IP 주소나 User-Agent를 세션과 함께 확인
  - HttpOnly 속성을 통한 쿠키 보호
---------------------------------------------------------------------------------------------------------
## 문제 2) 다음은 관계형 데이터베이스의 무결성 제약 조건에 관한 설명이다.  
각 설명에 알맞은 무결성 제약 조건을 쓰시오.

(1) 기본키를 구성하는 모든 속성은 절대로 **null 값이나 중복된 값을 가질 수 없다는 규칙**이다.  
(2) 외래키의 값은 반드시 **참조하고 있는 테이블의 기본키 값으로 존재하거나 null이어야 한다는 규칙**이다.  
(3) 특정 속성(컬럼)에 대해 **미리 정의된 형식과 범위 내에서만 데이터가 입력되도록 제한하는 규칙**이다.

**답:**  
1) 개체 무결성  
2) 참조 무결성  
3) 도메인 무결성  

---

📌 **관련 개념 설명:**

- **개체 무결성(Entity Integrity)**  
  테이블의 기본키(PK)는 각 행(Row)을 고유하게 식별하기 위한 속성이다.  
  기본키는 반드시 **NOT NULL**이어야 하며, **중복된 값을 가질 수 없다**.  
  → 기본키 조건을 위반하면 해당 테이블의 개체 무결성이 손상된다.

- **참조 무결성(Referential Integrity)**  
  **외래키(FK)**는 다른 테이블의 기본키를 참조하는 속성이다.  
  외래키 값은 **해당하는 기본키 값이 존재해야 하며**, 존재하지 않으면 **NULL**이어야 한다.  
  → 데이터의 연결 관계를 유지하기 위한 필수 제약 조건.

- **도메인 무결성(Domain Integrity)**  
  컬럼에 저장될 수 있는 값의 **유형, 범위, 형식** 등을 제한한다.  
  예: 숫자형 컬럼에는 문자 불가, 나이 컬럼은 0 이상, '성별' 컬럼은 '남' 또는 '여'만 입력 가능 등.  
  → 데이터의 정확성과 일관성을 확보하기 위한 제약이다.
---------------------------------------------------------------------------------------------------------
## 문제 3) 다음 설명을 읽고 이에 해당하는 오류 검출 방식을 쓰시오.

네트워크 환경에서 데이터를 전송할 때 송신 측은 전송하려는 데이터에 특정 **다항식**을 적용하여 얻은  
**나머지 값을 데이터와 함께 전송**하고, 수신 측에서는 동일한 다항식으로 나누어 나머지를 비교하여  
**데이터의 손상 여부를 판단**한다. 이러한 방식으로 데이터 전송 중 발생할 수 있는 오류를  
효과적으로 검출하는 방법을 (        )라고 한다.  
이 방식은 **이더넷**과 같은 네트워크 통신 프로토콜에서 널리 사용된다.

**답:** CRC (Cyclic Redundancy Check, 순환 중복 검사)

---

📌 **관련 개념 설명:**

- **CRC (Cyclic Redundancy Check, 순환 중복 검사)**  
  데이터 오류 검출을 위해 **다항식 방식**을 사용하는 검출 기법이다.  
  송신 측에서 전송 데이터에 **다항식 나눗셈 연산**을 수행하고, 그 **나머지(Remainder)**를 데이터 뒤에 붙여 전송한다.  
  수신 측도 같은 다항식으로 나눗셈을 수행하여 **나머지가 0이 아니면 오류가 발생했음을 판단**한다.  
  - 주로 **이더넷, HDLC** 등 다양한 통신 프로토콜에서 사용됨.
  - 오류 **검출만 가능**하고, 오류 **수정은 불가능**하다.

---

📌 **전송 오류 제어 방식 요약:**

| 구분 | 설명 | 예시 |
|------|------|------|
| **전진 오류 수정 (FEC)** | 수신 측이 스스로 오류를 검출하고 수정 | 해밍 코드 |
| **후진 오류 수정 (BEC)** | 오류 발생 시 송신 측에 **재전송 요청** | 패리티 검사, CRC, 블록합 등 |
| **오류 검출 방식 예시** | 오류는 검출하되 수정은 못함 | 패리티 비트, 블록합, **CRC** 등 |

---------------------------------------------------------------------------------------------------------
## 문제 4) 다음 설명을 읽고, 괄호 안에 들어갈 가장 적합한 용어를 쓰시오.

컴퓨터 사용자에게 **악성코드에 감염되었다거나, 보안 위협이 존재한다는 허위 경고**를 띄워 사용자의 불안을 유발하고,  
이를 해결하기 위한 **가짜 보안 소프트웨어를 결제하도록 유도하여 금전적 이득**을 취하는 악성 소프트웨어를 (         )라고 한다.  
사용자는 실제로는 감염되지 않은 상태임에도 불구하고 이러한 허위 경고에 속아 결제 및  
**개인 정보를 탈취**당할 수 있어 주의가 필요하다.

**답:** 스캐어웨어 (Scareware)

---

📌 **관련 개념 설명:**

- **스캐어웨어(Scareware)**  
  "Scare(겁주다) + Software"의 합성어로,  
  사용자에게 허위 메시지를 띄워 **공포감을 유발**하고,  
  문제를 해결하려는 심리를 이용해 **가짜 보안 프로그램 구매나 설치를 유도**하는 악성코드 유형이다.

- **특징:**  
  - "당신의 PC가 바이러스에 감염되었습니다"라는 식의 팝업창을 띄움  
  - 클릭을 유도하여 가짜 백신 프로그램을 설치하게 함  
  - 프로그램 설치 후 결제를 요구하거나 개인정보를 입력하게 하여 **금전 탈취/정보 탈취**

- **예방 방법:**  
  - 공식 백신 소프트웨어 외 프로그램 설치 금지  
  - 정품 백신으로 실시간 감시 활성화  
  - 의심스러운 팝업창 클릭 금지

---------------------------------------------------------------------------------------------------------
## 문제 5) 다음은 JAVA 코드이다. 출력 결과를 쓰시오.

```java
class ExceptionTest {
    public static void main(String[] args) {
        int a = 5, b = 0;
        try {
            System.out.println(a / b);
        } catch (arithmeticException e) {
            System.out.printf("출력1");
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.printf("출력2");
        } catch (NumberFormatException e) {
            System.out.printf("출력3");
        } catch (Exception e) {
            System.out.printf("출력3");
        } finally {
            System.out.printf("출력5");
        }
    }
}
답: 출력3출력5

📌 해설:

a / b는 5 / 0으로 실행되며, ArithmeticException 예외가 발생함.

하지만 코드에서 catch (arithmeticException e)는 소문자 a로 작성되어 있어
**정확한 예외 클래스명(대소문자 구분)**이 아니므로 컴파일 오류가 발생한다.

✅ 따라서 올바르게 동작하려면 다음과 같이 고쳐야 함:

java
복사
편집
catch (ArithmeticException e)
위 오류가 없다고 가정하면 ArithmeticException이 발생하고, 가장 먼저 일치하는 catch 문이 실행된다.
그러나 문제가 제시한 코드에서는 소문자 arithmeticException 때문에 해당 블록은 컴파일되지 않으며,
실제 컴파일 가능한 가장 일반적인 Exception 블록이 실행되어 출력3이 출력된다.

이후 finally 블록은 항상 실행되므로 출력5가 함께 출력된다.

📌 즉, 컴파일 오류 없이 실행된다고 가정할 경우
예외는 ArithmeticException이므로 가장 상위 catch (Exception e)가 실행 → "출력3"
finally 블록 실행 → "출력5"

최종 출력: 출력3출력5

📌 보충 설명 – 예외 클래스 정리

예외 클래스	설명
ArithmeticException	0으로 나누기 등 산술 오류
ArrayIndexOutOfBoundsException	배열 인덱스 범위 초과 접근
NumberFormatException	문자열을 숫자로 변환할 때 형식 오류
Exception	모든 예외 클래스의 최상위 부모 클래스

---------------------------------------------------------------------------------------------------------
## 문제 6) 다음 네트워크 프로토콜에 대한 설명을 읽고, 빈칸 (1), (2)에 들어갈 올바른 프로토콜의 이름을 각각 쓰시오.

(1) 이란 IP 주소를 가지고 있는 호스트가 네트워크상에서 데이터를 전송할 때,  
수신 호스트의 IP 주소는 알고 있지만, 해당 IP 주소에 대응하는 물리적인 **MAC 주소를 모르는 경우**  
이를 얻기 위해 사용하는 프로토콜이다.

(2) 이란 네트워크에 연결된 호스트가 자신의 **MAC 주소는 알고 있지만, IP 주소를 모르는 경우**  
서버에 질의하여 자신의 IP 주소를 얻기 위해 사용하는 프로토콜이다.  
이 프로토콜은 주로 **디스크가 없는 클라이언트가 부팅 시** 자신의 IP 주소를 얻기 위해 사용되었다.

**답:**  
1) ARP  
2) RARP

---

📌 **관련 개념 설명:**

### 1) ARP (Address Resolution Protocol)
- **역할:** IP 주소를 MAC 주소로 변환 (IP ➝ MAC)
- **사용 예:** 로컬 네트워크에서 IP를 알고 있는 상대의 MAC 주소를 알아야 데이터 프레임을 전송할 수 있을 때
- **위치:** OSI 7계층 중 **데이터 링크 계층**

---

### 2) RARP (Reverse Address Resolution Protocol)
- **역할:** MAC 주소를 IP 주소로 변환 (MAC ➝ IP)
- **사용 예:** 디스크가 없는 클라이언트가 네트워크 부팅 시 자신의 IP 주소를 서버로부터 요청
- **현재는 잘 사용되지 않음**, 대신 **BOOTP** 또는 **DHCP** 사용
- **위치:** OSI 7계층 중 **데이터 링크 계층**

---

📌 **OSI 7계층 요약:**

| 계층 | 이름 | 주요 기능 |
|------|------|-----------|
| 7 | 응용 계층 | 사용자 인터페이스 제공 (HTTP, FTP 등) |
| 6 | 표현 계층 | 데이터 형식 변환, 암호화, 압축 |
| 5 | 세션 계층 | 세션 관리, 연결 설정/유지/종료 |
| 4 | 전송 계층 | 종단 간 신뢰성 있는 전송 (TCP/UDP, 세그먼트) |
| 3 | 네트워크 계층 | 주소 지정, 경로 설정 (IP, 패킷) |
| 2 | 데이터 링크 계층 | 오류 검출, MAC 주소 기반 전송 (프레임) |
| 1 | 물리 계층 | 전기적 신호 전송 (비트 단위) |
---------------------------------------------------------------------------------------------------------
## 문제 7) 다음 SQL 문제를 분석하고 실행 결과를 정확히 작성하시오.

### [emp] 테이블

| id   | name   |
|------|--------|
| 1001 | 김철수 |
| 1002 | 홍길동 |
| 1004 | 강감찬 |
| 1008 | 이순신 |

---

### [sal] 테이블

| id   | incentives |
|------|------------|
| 1002 | 300        |
| 1004 | 300        |
| 1008 | 1000       |
| 1009 | 500        |

---

### 실행 SQL

```sql
SELECT emp.name, sal.incentives
FROM emp, sal
WHERE emp.id = sal.id AND sal.incentives >= 500;
📌 해설:

emp, sal 두 테이블을 카티션 곱 후, emp.id = sal.id로 조인.

그리고 sal.incentives >= 500 조건 추가.

조건을 만족하는 sal.id는 1008 (incentives 1000).

해당 id는 emp 테이블에도 존재하므로 조인 가능.

📌 최종 결과:

name	incentives
이순신	1000

답:
name    incentives
이순신    1000
---------------------------------------------------------------------------------------------------------

## 문제 8) 다음은 관계형 데이터베이스 관련 용어에 대한 설명이다.  
각 설명과 올바르게 매칭되는 용어를 보기에서 찾아 기호를 쓰시오.

---

### 설명:

1. 하나의 테이블에 존재하는 속성(Attribute)의 개수  
2. 하나의 테이블에 존재하는 튜플(Tuple)의 개수  
3. 다른 테이블의 기본키를 참조하는 키  
4. 하나의 속성이 가질 수 있는 값의 범위

---

### 보기:

ㄱ. degree  
ㄴ. cardinality  
ㄷ. primary  
ㄹ. foreign key  
ㅁ. attribute  
ㅂ. domain  
ㅅ. candidate key  
ㅇ. tuple

---

### **답:**

1) ㄱ (degree)  
2) ㄴ (cardinality)  
3) ㄹ (foreign key)  
4) ㅂ (domain)

---

📌 **관련 개념 설명:**

| 설명 번호 | 용어           | 의미 |
|------------|----------------|------|
| 1          | **degree (차수)** | 테이블(릴레이션)에 있는 **열(Column, 속성)**의 수 |
| 2          | **cardinality (기수)** | 테이블에 있는 **행(Row, 튜플)**의 수 |
| 3          | **foreign key (외래 키)** | 다른 테이블의 **기본키를 참조**하는 키 |
| 4          | **domain (도메인)** | **속성이 가질 수 있는 값의 범위** 또는 타입 (예: 성별 = '남', '여') |

---------------------------------------------------------------------------------------------------------

## 문제 9) 다음 네트워크와 서브넷 마스크가 주어졌을 때  
브로드캐스트로 데이터를 전송할 경우 수신 가능한 IP 주소를 보기에서 모두 고르시오.

- **네트워크 주소:** 192.168.35.10  
- **서브넷 마스크:** 255.255.252.0 → **CIDR: /22**

---

### ✅ 서브넷 마스크 해석

- 서브넷 마스크: 255.255.252.0 → /22  
- 한 서브넷에 포함되는 IP 개수: 2^(32-22) = 1024개  
- 네트워크 주소는 4 단위로 블록 형성됨 (256 - 252 = 4)  

---

### 🎯 네트워크 범위 계산

- 192.168.x.x에서 /22의 경우,  
  네트워크 블록은 192.168.(32, 36, 40, ...) 등 4씩 증가함

- 따라서 192.168.35.10이 속한 네트워크는  
  - 네트워크 주소: **192.168.32.0**  
  - 브로드캐스트 주소: **192.168.35.255**  
  - 유효 호스트 IP 범위: 192.168.32.1 ~ 192.168.35.254

---

### 📌 보기별 포함 여부

| 보기 | IP 주소          | 포함 여부 | 설명                     |
|------|------------------|------------|--------------------------|
| ㄱ   | 192.168.32.100   | ✅ 포함   | 32.0 ~ 35.255 범위 내    |
| ㄴ   | 192.168.34.50    | ✅ 포함   | 범위 내                  |
| ㄷ   | 192.168.35.99    | ✅ 포함   | 범위 내                  |
| ㄹ   | 192.168.33.25    | ✅ 포함   | 범위 내 (32.0~35.255)    |
| ㅁ   | 192.168.35.99    | ✅ 포함   | 범위 내 (중복)           |
| ㅂ   | 192.168.36.10    | ❌ 미포함 | 36.0 이상은 다음 서브넷  |
| ㅅ   | 192.168.31.150   | ❌ 미포함 | 31.255 이하, 이전 서브넷 |
| ㅇ   | 192.168.38.200   | ❌ 미포함 | 범위 벗어남              |
| ㅈ   | 192.168.39.10    | ❌ 미포함 | 범위 벗어남              |

---

### ✅ 정답  
**ㄱ, ㄴ, ㄷ, ㄹ, ㅁ**

---

📌 **요약:**  
서브넷 마스크 255.255.252.0 (/22)일 때, 네트워크 범위는 192.168.32.0 ~ 192.168.35.255이며,  
이 범위 내의 IP 주소만 브로드캐스트 패킷을 수신할 수 있다.
---------------------------------------------------------------------------------------------------------
## 문제 10) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

```c
#include <stdio.h>

int main(){
    char arr[5] = {'B', 'A', 'D', 'E'};
    char c= 'C';
    int i;

    printf("%d\n", arr[3]- arr[1]);

    for(i=0; i<4; i++){
        if(arr[i] > c)
            break;
    }

    char temp = arr[i];
    arr[i] = c;
    i++;

    for(; i<5; i++){
        char temp2 = arr[i];
        arr[i] = temp;
        temp = temp2;
    }

    for(i=0; i<5; i++){
        printf("%c", arr[i]);
    }
    return 0;
}

해설 및 실행 흐름
배열 arr는 5칸짜리이며, 초기화는 {'B', 'A', 'D', 'E'} → 나머지 한 칸은 0 (널문자)으로 초기화됨.

printf("%d\n", arr[3] - arr[1]);

arr[3] = 'E' (ASCII 69)

arr[1] = 'A' (ASCII 65)

차이: 69 - 65 = 4 → 출력: 4

for문에서 i가 0부터 3까지 순회하면서 arr[i] > c ('C' = 67) 비교:

i=0: 'B'(66) > 'C'(67)? No

i=1: 'A'(65) > 'C'(67)? No

i=2: 'D'(68) > 'C'(67)? Yes → break → i=2에서 루프 종료

char temp = arr[i]; → temp = arr[2] = 'D'
arr[i] = c; → arr[2] = 'C'
i++ → i=3

두 번째 for문: i=3부터 4까지

i=3:
temp2 = arr[3] = 'E'
arr[3] = temp = 'D'
temp = temp2 = 'E'

i=4:
temp2 = arr[4] = '\0' (널문자, 초기화 안 된 공간)
arr[4] = temp = 'E'
temp = temp2 = '\0'

최종 배열 arr:

arr[0] = 'B'

arr[1] = 'A'

arr[2] = 'C'

arr[3] = 'D'

arr[4] = 'E'

마지막 for문에서 배열 출력 → BACDE

최종 출력 결과
4
BACDE
---------------------------------------------------------------------------------------------------------
## 문제 11) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

```c
#include <stdio.h>
#include <stdlib.h>

int A[9] = {8, 9, 3, 7, 2, 8, 3, 1, 4};

void func(int **res, int cols, int rows) {
    for(int i = 0; i < (cols * rows); i++) {
        int r = (i + 1) % (rows * cols);
        res[r / cols][r % cols] = A[i];
    }
}

int main() {
    int **res;
    int cols = 3;
    int rows = 3;
    int sum = 0;

    res = (int **)malloc(sizeof(int *) * rows);
    for(int i = 0; i < rows; i++) {
        res[i] = (int *)malloc(sizeof(int) * cols);
    }

    func(res, cols, rows);

    for(int i = 0; i < rows * cols; i++) {
        // (1%2==0 ? 1 : -1) → 1%2=1, so always -1 here (typo? probably intended i%2)
        // Assuming correct code should be:
        // sum += res[i / cols][i % cols] * ((i % 2 == 0) ? 1 : -1);

        sum += res[i / cols][i % cols] * ((i % 2 == 0) ? 1 : -1);
    }

    printf("%d", sum);

    for(int i = 0; i < rows; i++) {
        free(res[i]);
    }
    free(res);

    return 0;
}
코드 분석
A 배열: {8, 9, 3, 7, 2, 8, 3, 1, 4}

func 함수에서 res에 값을 채우는 방식:

배열 크기: 3x3 = 9

for i=0 to 8까지,

r = (i + 1) % 9

res[r/3][r%3] = A[i]

즉, res 인덱스가 1씩 미뤄져서 A가 채워진다.

i	r=(i+1)%9	r/3	r%3	A[i]	res[r/3][r%3] = A[i] 위치
0	1	0	1	8	res[0][1] = 8
1	2	0	2	9	res[0][2] = 9
2	3	1	0	3	res[1][0] = 3
3	4	1	1	7	res[1][1] = 7
4	5	1	2	2	res[1][2] = 2
5	6	2	0	8	res[2][0] = 8
6	7	2	1	3	res[2][1] = 3
7	8	2	2	1	res[2][2] = 1
8	0	0	0	4	res[0][0] = 4

res 배열 최종 상태:

0	1	2
0	4	8	9
1	3	7	2
2	8	3	1

sum 계산:

c
복사
편집
for (i = 0; i < 9; i++) {
    sum += res[i/3][i%3] * ((i % 2 == 0) ? 1 : -1);
}
i=0 → +res[0][0] = +4

i=1 → -res[0][1] = -8

i=2 → +res[0][2] = +9

i=3 → -res[1][0] = -3

i=4 → +res[1][1] = +7

i=5 → -res[1][2] = -2

i=6 → +res[2][0] = +8

i=7 → -res[2][1] = -3

i=8 → +res[2][2] = +1

계산 결과:

sum = 4 - 8 + 9 - 3 + 7 - 2 + 8 - 3 + 1

= (4 - 8) + 9 - 3 + 7 - 2 + 8 - 3 + 1

= -4 + 9 - 3 + 7 - 2 + 8 - 3 + 1

= 5 - 3 + 7 - 2 + 8 - 3 + 1

= 2 + 7 - 2 + 8 - 3 + 1

= 9 - 2 + 8 - 3 + 1

= 7 + 8 - 3 + 1

= 15 - 3 + 1

= 12 + 1

= 13

최종 출력
13


---------------------------------------------------------------------------------------------------------

## 문제 12) 아래 설명을 읽고 빈칸에 들어갈 결합도를 쓰시오.

---

### 문제 설명

1. 하나의 모듈이 다른 모듈 내부에 있는 변수나 기능을 **직접 접근하거나 사용하는 경우**를 의미하며,  
   가장 강한 결합도로 모듈 간 독립성을 크게 해친다.

2. 모듈 간의 인터페이스로 단순 자료형이 아니라 **배열(Array), 객체(Object), 구조체**와 같은  
   복합적인 자료 구조가 전달되는 경우를 의미한다.  
   호출하는 모듈이 필요하지 않은 정보까지 함께 전달받아 모듈의 독립성을 저하시킬 수 있다.

3. 두 개 이상의 모듈이 **파라미터로 데이터를 전달하지 않고**, 외부에 선언된 전역변수를 참조하거나 수정하면서  
   서로 상호작용하는 경우이다. 모듈 간 결합도가 강하고 모듈 독립성이 저하된다.

---

### 📌 결합도 유형 설명

| 결합도 종류 | 설명 |
|-------------|------|
| **내용 결합도** | 한 모듈이 다른 모듈 내부의 데이터나 기능을 직접 참조하거나 수정하는 경우로, 가장 강한 결합도이며, 모듈 간 독립성이 가장 낮음 |
| **스탬프 결합도** | 배열, 구조체 등 복합 자료형을 인터페이스로 주고받는 경우로, 필요하지 않은 데이터까지 전달되어 모듈 독립성을 저하시킴 |
| **공통 결합도** | 여러 모듈이 전역 변수를 공유하며 참조 및 수정하는 경우로, 결합도가 강하고 유지보수에 어려움이 있음 |

---

### 답

1) 내용 결합도  
2) 스탬프 결합도  
3) 공통 결합도

---------------------------------------------------------------------------------------------------------

## 문제 13) 다음은 Java 코드이다. 출력 결과를 쓰시오.

```java
class Parent {
    static int total = 0;

    int v = 1;

    public Parent() {
        total += (++v);  // v = 2, total = total + 2
        showValue();     // 호출 시점의 객체에 따라 동적 바인딩
    }

    public void showValue() {
        total += total;  // total = total + total (2배)
    }
}

class Child extends Parent {
    int v = 10;

    public Child() {
        v += 2;          // v = 12
        total += (v++);  // total += 12, v = 13
        showValue();     // Child 클래스의 오버라이딩된 메서드 호출
    }

    @Override
    public void showValue() {
        total += total * 2;  // total = total + total*2 = total*3
    }
}

class Main {
    public static void main(String[] args) {
        new Child();
        System.out.println(Parent.total);
    }
}
코드 분석
new Child() 생성 과정:

Parent 생성자 호출 (자바는 부모 생성자를 먼저 호출):

v는 Parent 클래스의 멤버 변수이며, v = 1로 초기화됨.

total += (++v);
→ v는 1에서 2로 증가
→ total = 0 + 2 = 2

showValue() 호출
→ 실제 객체는 Child 객체이므로 오버라이딩된 Child의 showValue() 호출
→ total += total * 2 → total = 2 + 2*2 = 2 + 4 = 6

Child 생성자 실행:

v = 10 (Child 클래스 변수)

v += 2; → v = 12

total += (v++);
→ total = 6 + 12 = 18
→ v는 13이 됨 (후위 증가)

showValue() 호출 → Child 클래스 showValue()
→ total = 18 + 18*2 = 18 + 36 = 54

최종 total 값은 54

출력 결과
54
---------------------------------------------------------------------------------------------------------

## 문제 14) 다음 설명을 읽고 어떤 디자인 패턴인지 보기에서 골라 쓰시오

### 문제 설명

- 이 패턴은 **Wrapper(래퍼)**라고도 불린다.  
- 서로 호환되지 않는 두 개의 클래스 사이에서 한 클래스의 인터페이스를 다른 클래스가 기대하는 형태로 변환하여  
  기존에 호환되지 않았던 클래스들이 함께 작동할 수 있도록 해주는 **구조적 디자인 패턴**이다.  
- 이 패턴을 활용하면 이미 존재하는 클래스를 수정하지 않고도 기존 코드와 새로운 코드의 통합을 용이하게 만들 수 있다.

---

### 답

**ㄹ. Adapter**

---

### 보기 및 각 패턴 설명

| 기호 | 디자인 패턴명       | 설명                                                                                              |
|------|--------------------|-------------------------------------------------------------------------------------------------|
| ㄱ   | **Singleton**       | 클래스의 인스턴스를 하나만 생성하고, 어디서든 접근할 수 있도록 하는 생성 패턴                       |
| ㄴ   | **Factory Method**   | 객체 생성 코드를 서브클래스에 위임하여, 객체 생성 과정을 캡슐화하는 생성 패턴                         |
| ㄷ   | **Abstract Factory** | 관련성 있거나 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 생성 패턴                |
| ㄹ   | **Adapter**          | 서로 호환되지 않는 인터페이스를 가진 클래스들을 연결해주는 구조적 패턴<br>기존 코드를 수정하지 않고 호환성을 높임 |
| ㅁ   | **Decorator**        | 객체에 동적으로 추가적인 책임을 부여하는 구조적 패턴<br>기능 확장이 필요할 때 사용                   |
| ㅂ   | **Observer**         | 객체의 상태 변화가 있을 때, 관련된 객체들에게 자동으로 통보하는 행동 패턴                            |
| ㅅ   | **Visitor**          | 객체 구조의 요소들에 대해 새로운 기능을 추가할 때 사용하는 행동 패턴<br>객체 구조와 기능을 분리      |

---


### 추가 설명

어댑터 패턴은 이미 존재하는 클래스나 라이브러리를 수정하지 않고도, 다른 시스템과 호환시키거나 통합할 때 매우 유용하다.  
예를 들어, 오래된 인터페이스를 새로운 인터페이스에 맞게 변환하는 역할을 하며, 클라이언트 코드는 어댑터를 통해 기존 클래스에 접근한다.
---------------------------------------------------------------------------------------------------------

## 문제 15) 구문(문장) 커버리지를 수행하려고 한다.  
아래 제어 흐름도의 빈칸에 맞는 소스코드를 쓰고, 구문 커버리지의 경로를 쓰시오.

---

### [소스코드]

```c
int fnc(int a){
    int total = 0;
    while (a >= 0){
        if (a % 2 == 0)
            total = total + a;
        a = a - 2;
    }
    return total;
}
[제어 흐름도]
markdown
복사
편집
    1 ←
    ↓ ↑ 
6 ← 2 ↑
    ↓ ↑
    3 ↑
    ↓ ↑
    4 ↑
    ↓ ↑
    5 →
[제어 흐름도의 빈칸에 들어갈 코드]
total = 0;

a >= 0

a % 2 == 0

total = total + a;

a = a - 2;

return total;

구문 커버리지 경로
1 → 2 → 3 → 4 → 5 → 2 → 6

해설
구문 커버리지는 프로그램 내 모든 문장을 최소 한 번 실행하는 테스트 경로를 의미한다.

주어진 경로는 초기화부터 반복 조건 검사, 조건문 검사, 조건 참일 때의 처리, 변수 감소, 반복 조건 재검사, 최종 반환까지 모든 구문을 한 번 이상 실행한다.
---------------------------------------------------------------------------------------------------------

## 문제 16) 다음은 Java 코드이다. 출력 결과를 쓰시오.

```java
class Main {
    static int func(int[] a, int st, int end) {
        if (st >= end) return 0;
        int mid = (st + end) / 2;
        return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));
    }

    public static void main(String[] args) {
        int[] a = new int[] {3, 5, 8, 12, 17};
        int result = func(a, 0, a.length - 1);
        System.out.println(result);
    }
}
코드 분석
func 함수는 재귀적으로 배열의 중간 인덱스 값을 기준으로 두 부분으로 나누어,
중간 값과 왼쪽 부분, 오른쪽 부분 중 큰 값을 더해 반환하는 함수이다.

배열 a : [3, 5, 8, 12, 17], 인덱스는 0부터 4까지.

func(a, 0, 4) 호출 시 동작:

mid = (0+4)/2 = 2
a[2] = 8

왼쪽 재귀: func(a, 0, 2)

mid = (0+2)/2 = 1

a[1] = 5

왼쪽 하위 재귀: func(a, 0, 1)

mid = (0+1)/2 = 0

a[0] = 3

왼쪽 하위 재귀: func(a,0,0) → st >= end → 0 반환

오른쪽 하위 재귀: func(a,1,1) → st >= end → 0 반환

반환값: 3 + max(0,0) = 3

오른쪽 하위 재귀: func(a, 2, 2) → st >= end → 0 반환

반환값: 5 + max(3, 0) = 8

오른쪽 재귀: func(a, 3, 4)

mid = (3+4)/2 = 3

a[3] = 12

왼쪽 하위 재귀: func(a, 3, 3) → st >= end → 0 반환

오른쪽 하위 재귀: func(a, 4, 4) → st >= end → 0 반환

반환값: 12 + max(0,0) = 12

최종 반환: 8 + max(8, 12) = 8 + 12 = 20

출력 결과
20
---------------------------------------------------------------------------------------------------------

## 문제 17) 다음은 파이썬 코드이다. 출력 결과를 쓰시오.

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []

def tree(li):
    nodes = [Node(i) for i in li]
    for i in range(1, len(li)):
        nodes[(i - 1) // 2].children.append(nodes[i])
    return nodes[0]

def s(node, level=0):
    if not node:
        return 0
    total = node.value if level % 2 else 0
    for child in node.children:
        total += s(child, level + 1)
    return total

li = [1, 5, 8, 12, 15, 18]
root = tree(li)
print(s(root))
코드 설명 및 실행 결과 분석
트리를 완성하는 tree() 함수는 리스트의 값을 이진트리 구조로 노드에 할당한다.

함수 s()는 재귀적으로 트리를 순회하며, 레벨이 홀수일 때 노드 값을 더하고, 짝수일 때는 더하지 않는다.

트리 구조
li = [1, 5, 8, 12, 15, 18]

트리 (레벨별 노드 값)

레벨 0 (짝수): 1

레벨 1 (홀수): 5, 8

레벨 2 (짝수): 12, 15, 18

계산 과정
레벨 0 (짝수) → 값 더하지 않음

레벨 1 (홀수) → 5 + 8 = 13

레벨 2 (짝수) → 값 더하지 않음

따라서 함수 s(root)의 반환값은 13이다.

출력 결과
13

---------------------------------------------------------------------------------------------------------

## 문제 18) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Data {
    int value;
    struct Data* next;
} Data;

Data* insert(Data* head, int value) {
    Data* new_node = (Data*)malloc(sizeof(Data));
    new_node->value = value;
    new_node->next = head;
    return new_node;
}

Data* reconnect(Data* head, int value) {
    if (head == NULL || head->value == value) return head;

    Data* prev = NULL;
    Data* curr = head;

    while (curr != NULL && curr->value != value) {
        prev = curr;
        curr = curr->next;
    }

    if (curr != NULL && prev != NULL) {
        prev->next = curr->next;
        curr->next = head;
        head = curr;
    }
    return head;
}

int main() {
    Data* head = NULL;
    Data* curr;

    for (int i = 1; i <= 5; i++)
        head = insert(head, i);

    head = reconnect(head, 3);

    for (curr = head; curr != NULL; curr = curr->next)
        printf("%d", curr->value);

    return 0;
}
코드 분석
insert 함수는 새 노드를 만들어 연결 리스트의 맨 앞(head) 에 삽입한다.

for 루프에서 1부터 5까지 순서대로 삽입하므로, 리스트는 역순으로 생성된다:
5 -> 4 -> 3 -> 2 -> 1

reconnect(head, 3) 함수의 동작:

리스트에서 값이 3인 노드를 찾아서

그 노드를 리스트 맨 앞으로 이동시킨다.

재배치 과정
현재 리스트: 5 -> 4 -> 3 -> 2 -> 1

값 3인 노드는 세 번째 노드(3)

prev는 4, curr는 3

4의 next가 3의 next(2)로 바뀌고

3의 next가 기존 헤드(5)로 바뀐다

헤드는 3이 된다

결과 리스트
3 -> 5 -> 4 -> 2 -> 1

출력 결과
35421


---------------------------------------------------------------------------------------------------------

## 문제 19) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char name[10];
    unsigned char score[3];
} Node;

int f(unsigned char score) {
    return score & 0xA5;
}

int main() {
    Node* nodes = (Node*) malloc(2 * sizeof(Node));
    nodes[0] = (Node){"Kim", {0xF0, 0xF5, 0xDB}};
    nodes[1] = (Node){"Lee", {0xED, 0xD3, 0xF2}};

    int result = 0;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            result += f(nodes[i].score[j]);
        }
    }
    printf("%d\n", result);
    free(nodes);

    return 0;
}
코드 분석
함수 f는 입력받은 score에 대해 비트 AND 연산을 0xA5 (2진수: 10100101)와 수행한다.

각 score 값에 대해 score & 0xA5 값을 구해 모두 더한다.

값	16진수	2진수	AND 0xA5 (10100101)	결과 (16진수)	결과 (10진수)
0xF0 (nodes[0])	0xF0	11110000	10100000	0xA0	160
0xF5	0xF5	11110101	10100101	0xA5	165
0xDB	0xDB	11011011	10000001	0x81	129
0xED (nodes[1])	0xED	11101101	10100101	0xA5	165
0xD3	0xD3	11010011	10000001	0x81	129
0xF2	0xF2	11110010	10100000	0xA0	160

합산
160 + 165 + 129 + 165 + 129 + 160 = 908

출력 결과
908

---------------------------------------------------------------------------------------------------------

## 문제 20) 다음은 Java 코드이다. 출력 결과를 쓰시오.

```java
class Main {
    static int add(String s) {
        int t = Integer.valueOf(s);
        if (t <= 1) return t;
        return add(t - 1) + add(t - 3);
    }

    static int add(int i) {
        if (i <= 1) return i;
        return add(i - 1) + add(i - 2);
    }

    public static void main(String[] args) {
        System.out.println(add("5"));
    }
}
코드 분석
add(String s)는 문자열을 정수로 변환한 뒤 다음과 같이 재귀호출 한다:

add(t-1) (정수형 오버로딩 함수 호출)

add(t-3) (정수형 오버로딩 함수 호출)

add(int i)는 피보나치 수열과 비슷한 재귀로 계산한다:

기저조건: i <= 1 이면 i 반환

그렇지 않으면 add(i-1) + add(i-2) 반환

계산 과정
add("5") 호출 → t=5

csharp
복사
편집
add(5) = add(4) + add(2)

add(4) = add(3) + add(2)
add(3) = add(2) + add(1)
add(2) = add(1) + add(0)
add(1) = 1
add(0) = 0

따라서,
add(2) = 1 + 0 = 1
add(3) = add(2) + add(1) = 1 + 1 = 2
add(4) = add(3) + add(2) = 2 + 1 = 3
add(2) = 1 (위 계산과 동일)

최종,
add(5) = add(4) + add(2) = 3 + 1 = 4

출력 결과
4
