## 문제 1) 다음 네트워크 보안과 관련된 공격 기법에 대한 설명이다.  
다음 설명을 읽고 물음에 답하시오.

네트워크상에서 클라이언트와 서버 간에 인증된 통신이 이루어지고 있을 때, 공격자가 중간에서 인증이 필요한  
특정한 정보를 가로채어 사용자의 권한을 탈취하는 공격을 (        )라고 한다.  
이 공격에 성공하면 공격자는 정상 사용자의 권한을 얻어 불법적으로 서버에 접근하거나 정보를 유출할 수 있다.  
대표적인 공격 기법으로는 네트워크 패킷을 스니핑하여 인증 정보를 탈취하거나, 웹 브라우저에 저장된  
인증용 쿠키를 탈취하여 이용하는 방식이 있다.

**답:** 세션 하이재킹(Session Hijacking)

---

# 📌 관련 개념 설명

### ✅ 세션 하이재킹 (Session Hijacking)
- 사용자가 로그인 후 받은 **세션 ID(쿠키, 토큰 등)**를 공격자가 탈취해 **그 사용자로 가장하는 공격**  
- 세션 ID만 있으면 **비밀번호 없이도 사용자 권한으로 시스템 접근 가능**

---

### 🔓 공격 방법 예시

| 공격 방식           | 설명                                   |
|---------------------|--------------------------------------|
| **스니핑(Sniffing)**      | 네트워크를 몰래 감청해 세션 ID 등 민감 정보 가로채기  |
| **쿠키 탈취(Cookie Theft)** | XSS 등으로 클라이언트에 저장된 쿠키 훔치기             |
| **세션 고정(Session Fixation)** | 공격자가 미리 만든 세션 ID를 사용자에게 할당 후 탈취     |

---

### 🛡️ 방어 방법

- **HTTPS 사용**: 세션 ID 전송 시 암호화하여 중간 탈취 방지  
- **세션 타임아웃 설정**: 일정 시간 후 세션 자동 만료  
- **User-Agent / IP 확인**: 세션이 다른 환경에서 재사용되지 않도록 체크  
- **HttpOnly 설정**: 자바스크립트가 쿠키에 접근 못하게 차단하여 탈취 방지  


---------------------------------------------------------------------------------------------------------
## 문제 2) 다음은 관계형 데이터베이스의 무결성 제약 조건에 관한 설명이다.  
각 설명에 알맞은 무결성 제약 조건을 쓰시오.

(1) 기본키를 구성하는 모든 속성은 절대로 **null 값이나 중복된 값을 가질 수 없다는 규칙**이다.  
(2) 외래키의 값은 반드시 **참조하고 있는 테이블의 기본키 값으로 존재하거나 null이어야 한다는 규칙**이다.  
(3) 특정 속성(컬럼)에 대해 **미리 정의된 형식과 범위 내에서만 데이터가 입력되도록 제한하는 규칙**이다.

**답:**  
1) 개체 무결성  
2) 참조 무결성  
3) 도메인 무결성  

---

# 📌 관련 개념 설명: 무결성 제약 조건

---

### ✅ 개체 무결성 (Entity Integrity)
- **기본키(PK)**는 테이블에서 각 행을 고유하게 식별하기 위한 필수 조건  
- 기본키는 **NULL이 될 수 없고, 중복된 값도 허용되지 않음**  
- 즉, **기본키 값은 반드시 존재하고 유일해야 함**  
- ✔ 위반 시 → 행의 고유성 깨짐 → **개체 무결성 손상**

```sql
-- ❌ 오류 예시: 동일한 학번 중복 입력 불가
INSERT INTO 학생 VALUES ('A101', '민수');
INSERT INTO 학생 VALUES ('A101', '지훈');  -- 중복 오류 발생

✅ 참조 무결성 (Referential Integrity)
**외래키(FK)**는 다른 테이블의 기본키를 참조

외래키 값은 참조하는 기본키 값이 반드시 존재해야 하며, 없으면 NULL이어야 함

테이블 간 관계를 안전하게 유지하는 핵심 조건

✔ 위반 시 → 데이터 연결 관계 파괴

sql
복사
편집
CREATE TABLE 학과 (
  학과코드 CHAR(3) PRIMARY KEY,
  학과명 VARCHAR(20)
);

CREATE TABLE 학생 (
  학번 CHAR(5) PRIMARY KEY,
  이름 VARCHAR(20),
  학과코드 CHAR(3),
  FOREIGN KEY (학과코드) REFERENCES 학과(학과코드)
);

-- ❌ 오류 예시: 존재하지 않는 학과코드 참조 불가
INSERT INTO 학생 VALUES ('A101', '민수', 'XYZ');  -- XYZ 학과 없음 오류


✅ 도메인 무결성 (Domain Integrity)
컬럼에 저장 가능한 데이터 형식, 값의 범위 등을 제한

목적: 데이터 정확성 및 일관성 유지
| 무결성 유형   | 핵심 내용                       | 오류 예시                      |
|--------------|-------------------------------|------------------------------|
| 개체 무결성  | 기본키는 반드시 존재하고 유일함 | 기본키 중복 입력              |
| 참조 무결성  | 외래키는 참조 기본키가 존재해야 함 | 없는 기본키를 외래키로 참조   |
| 도메인 무결성| 컬럼 값 범위 및 형식 제한       | 값 범위 벗어나거나 허용되지 않는 값 입력 |

---------------------------------------------------------------------------------------------------------
## 문제 3) 다음 설명을 읽고 이에 해당하는 오류 검출 방식을 쓰시오.

네트워크 환경에서 데이터를 전송할 때 송신 측은 전송하려는 데이터에 특정 **다항식**을 적용하여 얻은  
**나머지 값을 데이터와 함께 전송**하고, 수신 측에서는 동일한 다항식으로 나누어 나머지를 비교하여  
**데이터의 손상 여부를 판단**한다. 이러한 방식으로 데이터 전송 중 발생할 수 있는 오류를  
효과적으로 검출하는 방법을 (        )라고 한다.  
이 방식은 **이더넷**과 같은 네트워크 통신 프로토콜에서 널리 사용된다.

**답:** CRC (Cyclic Redundancy Check, 순환 중복 검사)

---

# 📌 관련 개념 설명

---

## ✅ CRC (Cyclic Redundancy Check, 순환 중복 검사)

---

### 🔍 수신 측의 동작 요약

- 수신 측은 **전체 수신 데이터를 동일한 생성 다항식(G)**으로 나눗셈 수행
- ➕ **나머지가 0이면**: 오류 없이 정상 수신  
- ➖ **나머지가 0이 아니면**: 전송 중 오류 발생으로 판단

---

### ✅ 전송 오류 제어 방식 정리표

| 구분                    | 설명                                  | 대표 기법                        |
|-------------------------|---------------------------------------|-----------------------------------|
| **전진 오류 수정 (FEC)** | 수신 측이 **오류를 감지하고 자체적으로 수정** | 해밍 코드, 리드-솔로몬 코드 등    |
| **후진 오류 수정 (ARQ)** | 수신 측이 **오류만 감지**하고 **송신 측에 재전송 요청** | 패리티, 블록합, CRC 등            |
| **오류 검출 전용 방식**   | **오류는 감지 가능, 수정은 불가**            | 패리티 비트, 블록합, CRC 등       |

---

### 📌 핵심 요약

- ✅ **CRC는 오류 “검출”만 가능**, **수정은 불가**
- ✅ **나눗셈 기반의 강력한 오류 검출 기법**
- ✅ **네트워크/디지털 통신**에서 폭넓게 활용
- ✅ 일반적으로 **재전송(ARQ)** 방식과 함께 사용

> 💡 **CRC = 데이터를 다항식처럼 나눠서, 나머지로 오류 체크!**



---------------------------------------------------------------------------------------------------------
## 문제 4) 다음 설명을 읽고, 괄호 안에 들어갈 가장 적합한 용어를 쓰시오.

컴퓨터 사용자에게 **악성코드에 감염되었다거나, 보안 위협이 존재한다는 허위 경고**를 띄워 사용자의 불안을 유발하고,  
이를 해결하기 위한 **가짜 보안 소프트웨어를 결제하도록 유도하여 금전적 이득**을 취하는 악성 소프트웨어를 (         )라고 한다.  
사용자는 실제로는 감염되지 않은 상태임에도 불구하고 이러한 허위 경고에 속아 결제 및  
**개인 정보를 탈취**당할 수 있어 주의가 필요하다.

**답:** 스캐어웨어 (Scareware)

---

# 📌 관련 개념 설명: 스캐어웨어 (Scareware)

---

## ✅ 스캐어웨어(Scareware)란?

- "Scare(겁주다)" + "Software(소프트웨어)"의 합성어
- 사용자에게 **허위 경고 메시지**를 띄워 **공포감을 유발**하고,  
  **가짜 보안 프로그램 설치나 구매를 유도**하는 악성코드

---

## ✅ 주요 특징

- “⚠️ 당신의 PC가 바이러스에 감염되었습니다” 같은 팝업창을 띄움  
- 가짜 백신, 최적화 프로그램 설치를 유도  
- 설치 후 결제를 요구하거나 개인정보 입력을 유도하여  
  → **금전 탈취** 또는 **정보 유출**

---

## ✅ 예시 상황

1. 웹사이트 접속 중 갑자기 팝업창 발생  
   → “PC 성능이 저하되었습니다! 지금 스캔하세요!”
2. 사용자 클릭  
   → 가짜 백신 다운로드
3. 설치 후 결제 유도  
   → 카드정보 탈취

---

## ✅ 예방 방법

- **정품 백신 소프트웨어**만 사용하고 실시간 감시 활성화  
- **출처 불명 소프트웨어 설치 금지**  
- **수상한 팝업 클릭 금지**, 닫을 수 없을 경우 작업 관리자 강제 종료  
- **OS 및 백신 프로그램 최신 업데이트 유지**

---

> 💡 요약: 겁주고 돈 뺏는 수법. 놀라지 말고 침착하게 닫고, 백신으로 점검하자!


---------------------------------------------------------------------------------------------------------
## 문제 5) 다음은 JAVA 코드이다. 출력 결과를 쓰시오.

class ExceptionTest {
    public static void main(String[] args) {
        int a = 5, b = 0;                                               // 정수 a는 5, b는 0으로 초기화한다.

        try {
                                                                        // 이 블록 안의 코드를 실행하다가 예외(에러)가 발생하면 catch 블록으로 점프한다.
            System.out.println(a / b);                                                     // 5를 0으로 나눈다.
                                                           // 이는 'ArithmeticException'이라는 예외를 발생시킨다.
        } catch (arithmeticException e) {                             // 소문자로 시작해서 컴파일 에러 발생
                                                                  // 'ArithmeticException'은 자바에서 런타임 예외(RuntimeException) 중 하나로,
                                                                  // 0으로 나누기 같은 산술적인 오류가 발생했을 때 던져진다.
            System.out.printf("출력1");                             // 이 catch 블록이 실행된다. (만약 예외 타입이 정확했다면)
        } catch (ArrayIndexOutOfBoundsException e) {
                                                                                  // 배열 인덱스 범위를 벗어났을 때 발생하는 예외.
                                                                                  // 여기서는 발생하지 않는다.
            System.out.printf("출력2");
        } catch (NumberFormatException e) {
                                                                          // 문자열을 숫자로 변환할 수 없을 때 발생하는 예외 (예: "abc"를 int로 변환 시도).
                                                                          // 여기서는 발생하지 않는다.
            System.out.printf("출력3");
        } catch (Exception e) {
                                                                          // 모든 종류의 예외를 잡을 수 있는 가장 일반적인 catch 블록이다.
                                                                          // 위에 있는 특정 예외 catch 블록들이 해당 예외를 처리하지 못했을 때 최종적으로 이곳으로 온다.
            System.out.printf("출력3");                                               // 이 catch 블록이 실행될 수도 있다. (만약 위에서 못 잡았다면)
        } finally {
                                                                                // finally 블록: 예외 발생 여부와 상관없이 '무조건' 실행되는 블록이다.
                                                                                // try 블록이 정상 종료되든, catch 블록이 실행되든, 항상 finally는 실행된다.
            System.out.printf("출력5");
        }
    }
}


답: 출력3출력5



---------------------------------------------------------------------------------------------------------
## 문제 6) 다음 네트워크 프로토콜에 대한 설명을 읽고, 빈칸 (1), (2)에 들어갈 올바른 프로토콜의 이름을 각각 쓰시오.

(1) 이란 IP 주소를 가지고 있는 호스트가 네트워크상에서 데이터를 전송할 때,  
수신 호스트의 IP 주소는 알고 있지만, 해당 IP 주소에 대응하는 물리적인 **MAC 주소를 모르는 경우**  
이를 얻기 위해 사용하는 프로토콜이다.

(2) 이란 네트워크에 연결된 호스트가 자신의 **MAC 주소는 알고 있지만, IP 주소를 모르는 경우**  
서버에 질의하여 자신의 IP 주소를 얻기 위해 사용하는 프로토콜이다.  
이 프로토콜은 주로 **디스크가 없는 클라이언트가 부팅 시** 자신의 IP 주소를 얻기 위해 사용되었다.

**답:**  
1) ARP  
2) RARP

# 📌 ARP vs RARP + OSI 7계층 한눈에 정리

---

## ✅ 1) ARP (Address Resolution Protocol)

| 항목       | 설명 |
|------------|------|
| 🎯 **역할** | IP 주소 ➡️ MAC 주소로 변환 |
| 📍 **계층** | OSI 2계층 (데이터 링크 계층) |
| 📌 **상황** | 같은 네트워크에서 상대의 MAC 주소를 알아야 할 때 사용 |
| 🔧 **작동** | 브로드캐스트로 ARP 요청 → 대상이 자신의 MAC 주소 응답 |

🧾 **예시**  
> 내가 `192.168.0.20`에게 데이터를 보내고 싶은데 MAC 주소를 모름  
> → ARP 요청 브로드캐스트  
> → `192.168.0.20`이 응답 (자기 MAC 주소 제공)  
> → 이제 MAC 주소로 데이터 전송 가능 ✅  

---

## ✅ 2) RARP (Reverse ARP)

| 항목       | 설명 |
|------------|------|
| 🎯 **역할** | MAC 주소 ➡️ IP 주소로 변환 |
| 📍 **계층** | OSI 2계층 (데이터 링크 계층) |
| 📌 **상황** | 디스크 없는 장치가 부팅 시 자기 IP를 서버에게 물을 때 |
| ⚠️ **주의** | 현재는 **거의 사용 안 함**. BOOTP 또는 DHCP로 대체됨 |

🧾 **예시**  
> 디스크 없는 컴퓨터가 부팅함  
> → 자기 MAC 주소만 알고 있음  
> → 브로드캐스트로 RARP 요청  
> → 서버가 해당 MAC에 대응하는 IP 주소 응답 📨  

---

## ✅ OSI 7계층 요약표

| 계층 번호 | 계층 이름       | 주요 역할 및 예시                        |
|-----------|------------------|------------------------------------------|
| 7         | 응용 계층         | 사용자와 가장 가까운 계층<br>예: HTTP, FTP |
| 6         | 표현 계층         | 데이터 압축, 암호화, 포맷 변환<br>예: JPEG, ASCII |
| 5         | 세션 계층         | 연결 수립/유지/종료 (대화 제어)         |
| 4         | 전송 계층         | 신뢰성 있는 전송, 오류 제어<br>예: TCP, UDP |
| 3         | 네트워크 계층     | IP 주소 기반 라우팅<br>예: IP, ICMP     |
| 2         | 데이터 링크 계층   | MAC 주소 기반 데이터 프레임 전송<br>예: Ethernet, ARP |
| 1         | 물리 계층         | 전기적 신호로 비트 전송<br>예: 케이블, 허브, 전압 |

---

## 🎯 핵심 요약 정리

| 항목 | ARP | RARP |
|------|-----|------|
| 변환 방향 | IP → MAC | MAC → IP |
| 동작 계층 | OSI 2계층 (데이터 링크) | OSI 2계층 (데이터 링크) |
| 사용 여부 | ✅ **현재도 널리 사용** | ❌ **현재는 거의 안 씀 (DHCP로 대체)** |
| 사용 시기 | 로컬 네트워크에서 상대 MAC 알아낼 때 | IP 없는 장치가 부팅 시 IP 요청할 때 |

---

> 📌 기억 꿀팁  
> - **ARP**: "상대 IP는 아는데 MAC을 몰라!" → 물어봄  
> - **RARP**: "MAC만 알고 부팅했는데 IP를 몰라!" → 물어봄  
> - **둘 다** 2계층에서 동작하지만, 요즘엔 ARP만 씀.


---------------------------------------------------------------------------------------------------------

## 문제 7) 다음 SQL 문제를 분석하고 실행 결과를 정확히 작성하시오.

### [emp] 테이블

| id   | name   |
|------|--------|
| 1001 | 김철수 |
| 1002 | 홍길동 |
| 1004 | 강감찬 |
| 1008 | 이순신 |

---

### [sal] 테이블

| id   | incentives |
|------|------------|
| 1002 | 300        |
| 1004 | 300        |
| 1008 | 1000       |
| 1009 | 500        |

SELECT name, incentive FROM emp, sal WHERE emp.id = sal.id and incentives >= 500

---

📌 설명 (테이블 합치고 조건 거는 게 핵심!)
야, 이 SQL 쿼리는 두 개의 테이블(emp, sal)을 합쳐서(조인) 특정 조건을 만족하는 데이터만 뽑아내는 거야. 존나 쉬워.

1. FROM emp, sal (카티션 곱)
FROM emp, sal 이건 emp 테이블의 모든 행이랑 sal 테이블의 모든 행을 그냥 다 붙여버린다는 뜻이야.
이걸 카티션 곱이라고 하는데, 일단 모든 경우의 수를 다 만들어 놓는 거지.

예를 들어, emp에 4줄, sal에 4줄 있으면 4 * 4 = 16줄이 만들어지는 거야.

2. WHERE emp.id = sal.id (조인 조건)
WHERE emp.id = sal.id 이건 위에서 존나게 많이 만들어진 줄 중에서, emp 테이블의 id랑 sal 테이블의 id가 똑같은 것만 골라내라는 조건이야.

이걸 하면 두 테이블이 id를 기준으로 연결돼.

emp.id = 1001 (김철수) -> sal 테이블에 id 1001 없어. 탈락.
emp.id = 1002 (홍길동) -> sal.id = 1002 (incentives 300) => 연결!
emp.id = 1004 (강감찬) -> sal.id = 1004 (incentives 300) => 연결!
emp.id = 1008 (이순신) -> sal.id = 1008 (incentives 1000) => 연결!
sal.id = 1009 (incentives 500) -> emp 테이블에 id 1009 없어. 탈락.

여기까지 하면 대충 이런 결과가 나와. (아직 조건 다 안 건 상태)

| emp.id | emp.name | sal.id | sal.incentives |
|--------|----------|--------|----------------|
| 1002   | 홍길동   | 1002   | 300            |
| 1004   | 강감찬   | 1004   | 300            |
| 1008   | 이순신   | 1008   | 1000           |


3. AND sal.incentives >= 500 (추가 조건 필터링)
AND sal.incentives >= 500 이건 위에서 연결된 결과 중에서 incentives 값이 500 이상인 것만 다시 골라내라는 조건이야.

홍길동 (incentives 300): 300 >= 500은 거짓. 탈락.
강감찬 (incentives 300): 300 >= 500은 거짓. 탈락.
이순신 (incentives 1000): 1000 >= 500은 참! 통과.

그래서 최종적으로 이순신 데이터만 남는다.

4. SELECT emp.name, sal.incentives (결과 선택)
마지막으로 SELECT emp.name, sal.incentives 이건 최종으로 걸러진 데이터 중에서 emp.name이랑 sal.incentives만 보여달라는 거지.

최종 결과:

| name   | incentives |
|--------|------------|
| 이순신 | 1000       |


---------------------------------------------------------------------------------------------------------

## 문제 8) 다음은 관계형 데이터베이스 관련 용어에 대한 설명이다.  
각 설명과 올바르게 매칭되는 용어를 보기에서 찾아 기호를 쓰시오.

---

### 설명:

1. 하나의 테이블에 존재하는 속성(Attribute)의 개수  
2. 하나의 테이블에 존재하는 튜플(Tuple)의 개수  
3. 다른 테이블의 기본키를 참조하는 키  
4. 하나의 속성이 가질 수 있는 값의 범위

---

### 보기:

ㄱ. degree  
ㄴ. cardinality  
ㄷ. primary  
ㄹ. foreign key  
ㅁ. attribute  
ㅂ. domain  
ㅅ. candidate key  
ㅇ. tuple

---

### **답:**

1) ㄱ (degree)  
2) ㄴ (cardinality)  
3) ㄹ (foreign key)  
4) ㅂ (domain)

---
## 📌 릴레이션(테이블)의 구성 요소 정리 (갓반인도 이해 가능하게!)

---

### 📚 용어 설명 + 갓반인 예시

| 용어                      | 의미 설명                                                         | 갓반인 상황 예시                                                  |
|---------------------------|--------------------------------------------------------------------|--------------------------------------------------------------------|
| **degree (차수)**         | 테이블에 있는 **열(Column)**의 개수 (속성 개수)                    | `학생` 테이블에 [이름, 학번, 나이] 3개의 항목이 있으면 → **차수는 3** |
| **cardinality (기수)**    | 테이블에 있는 **행(Row)**의 개수 (데이터 튜플 개수)               | `학생` 테이블에 학생이 10명 등록돼 있으면 → **기수는 10**         |
| **foreign key (외래 키)** | 다른 테이블의 **기본키를 참조**하여 테이블 간 **연결**을 표현      | `수강` 테이블의 `학번`이 `학생` 테이블의 `학번`을 참조 → **외래 키** |
| **domain (도메인)**       | 속성이 가질 수 있는 **값의 범위나 규칙**                          | `성별` 컬럼은 `'남'`, `'여'`만 가능하면 → 도메인은 `'남', '여'`     |

---

### 🎯 직관적 핵심 요약

- `degree` = 세로 열 수 = **속성(Attribute)**  
  → "학생정보에 어떤 항목들이 있냐?"  
- `cardinality` = 가로 행 수 = **튜플(Tuple)**  
  → "학생 몇 명이 등록돼 있냐?"

- `foreign key` = 테이블 간 **연결선**  
  → "학생 테이블의 학번을 수강 테이블에서 다시 쓰는 중이야!"
- `domain` = 속성의 **값 제한 규칙**  
  → "성별에는 ‘남’ 아니면 ‘여’만 입력 가능하게 하자!"

---

### ✅ 예제와 함께 이해하기

```sql
학생(학번, 이름, 성별)
-- 차수 = 3 (3개의 속성: 학번, 이름, 성별)
-- 기수 = 5 (학생이 5명 등록되어 있음)

수강(수강번호, 학번)
-- 외래 키: 학번 → 학생 테이블의 학번을 참조함

성별
-- 도메인: '남', '여'만 허용


🧠 암기 꿀팁
차수는 세로 → 속성 몇 개냐?

기수는 가로 → 데이터 몇 줄이냐?

외래 키는 → 테이블 간 연결선

도메인은 → 값 제한 조건

📌 갓반인 말투 요약
"차수는 어떤 정보들을 담는지,
기수는 몇 명 정보가 담겼는지,
외래키는 테이블끼리 줄 이어주는 고리,
도메인은 이 값만 써! 하는 필터야."

---------------------------------------------------------------------------------------------------------

## 문제 9) 다음 네트워크와 서브넷 마스크가 주어졌을 때  
브로드캐스트로 데이터를 전송할 경우 수신 가능한 IP 주소를 보기에서 모두 고르시오.

- **네트워크 주소:** 192.168.35.10  
- **서브넷 마스크:** 255.255.252.0 → **CIDR: /22**

### ✅ 정답  
**ㄱ, ㄴ, ㄷ, ㄹ, ㅁ**
---

## ✅ IP 주소와 서브넷 마스크로 네트워크 범위 정확히 찾기! (feat. 갓반인 설명)

---

### 🎯 문제 핵심
> "서브넷 마스크로 **네트워크 범위**를 정확히 구하고,  
해당 범위 안에 있는 IP만 **수신 가능**하다는 걸 파악하는 게 핵심!"

---

### 1️⃣ 서브넷 마스크 `255.255.252.0` → CIDR 표기 `/22`로 변환하기

| 옥텟 | 10진수 | 2진수         | 1의 개수 |
|------|--------|----------------|-----------|
| 1    | 255    | 11111111       | 8         |
| 2    | 255    | 11111111       | 8         |
| 3    | 252    | 11111100       | 6         |
| 4    | 0      | 00000000       | 0         |

→ 1의 개수 총합: 8 + 8 + 6 = **22비트** → **/22**

> 📌 의미:  
> 앞의 22비트 = 네트워크 주소  
> 뒤의 10비트 = 호스트 주소  
> → 하나의 네트워크에 **2¹⁰ = 1024개 IP**가 존재

---

### 2️⃣ 📍 /22의 네트워크 구간 계산 방법

> 세 번째 옥텟이 `252`일 때:
- 256 - 252 = **4**
- → 세 번째 옥텟은 **4단위**로 네트워크가 나뉨  
  예) `...0.0`, `...4.0`, `...8.0`, ..., `...32.0`, `...36.0`, ...

---

### 3️⃣ 💡 192.168.35.10이 속한 네트워크 범위 찾기

- IP: **192.168.35.10**
- 35에서 가장 가까운 4의 배수 = **32**

→ 네트워크 시작 주소 = **192.168.32.0**  
→ 하나의 네트워크 범위 = **1024개 IP**

| 옥텟 조합          | 개수 |
|--------------------|------|
| 192.168.32.0~255   | 256개 |
| 192.168.33.0~255   | 256개 |
| 192.168.34.0~255   | 256개 |
| 192.168.35.0~255   | 256개 |
| **합계**           | 1024개 ✅ |

→ 브로드캐스트 주소 = **192.168.35.255**  
→ 유효 호스트 범위 = **192.168.32.1 ~ 192.168.35.254**

---

### 4️⃣ 📌 보기 IP 수신 가능 여부 확인

| 보기 | IP 주소             | 네트워크 범위 포함 여부 | 이유 |
|------|---------------------|--------------------------|------|
| ㄱ    | 192.168.32.100      | ✅ 포함                   | 시작 범위 안 |
| ㄴ    | 192.168.34.50       | ✅ 포함                   | 중간 옥텟 범위 안 |
| ㄷ    | 192.168.35.99       | ✅ 포함                   | 끝 범위 안 |
| ㄹ    | 192.168.33.25       | ✅ 포함                   | 중간 범위 |
| ㅁ    | 192.168.35.99       | ✅ 포함                   | ㄷ과 동일 |
| ㅂ    | 192.168.36.10       | ❌ 제외                   | 다음 네트워크로 넘어감 |
| ㅅ    | 192.168.31.150      | ❌ 제외                   | 이전 네트워크임 |
| ㅇ    | 192.168.38.200      | ❌ 제외                   | 범위 바깥 |
| ㅈ    | 192.168.39.10       | ❌ 제외                   | 범위 바깥 |

---

### ✅ 최종 정리

| 항목              | 값 |
|-------------------|-----|
| 네트워크 주소     | 192.168.32.0 |
| 브로드캐스트 주소 | 192.168.35.255 |
| 유효 호스트 범위  | 192.168.32.1 ~ 192.168.35.254 |
| 포함된 보기       | ㄱ, ㄴ, ㄷ, ㄹ, ㅁ |

---

> 📚 **꿀팁 암기**  
> `서브넷 마스크 → /비트수로 바꾸고 → 2^남은 비트로 범위 계산`  
> `3번째 옥텟이 252면 → 4단위로 네트워크 시작 IP 정해짐`  
> **IP 포함 여부는 시작~브로드캐스트 주소 안에 있으면 OK!**


---

---------------------------------------------------------------------------------------------------------

## 문제 10) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

#include <stdio.h>                                                       // printf 같은 입출력 함수를 위해 필요

int main(){
    char arr[5] = {'B', 'A', 'D', 'E'};                               // 문자 배열 선언. 크기 5인데 4개만 초기화 -> arr[4]는 널문자('\0')
    char c = 'C';                                                       // 문자 변수 'c'에 'C' 저장
    int i;                                                               // 반복문 등에 사용될 정수형 변수

                                                                            // 1. 첫 번째 printf: 문자 빼기 (아스키 코드 값으로 계산)
    printf("%d\n", arr[3] - arr[1]);

                                                                                // 2. 첫 번째 for 루프: 특정 위치 찾기
    for(i = 0; i < 4; i++){
        if(arr[i] > c)                                                           // arr[i] 문자가 'C'보다 크면
            break;                                                                 // 루프를 멈춘다
    }

                                                                                      // 3. 찾은 위치에 'C'를 삽입하고 뒤의 문자들을 민다.
    char temp = arr[i];                                                                 // arr[i]의 원래 값을 temp에 임시 저장
    arr[i] = c;                                                                         // arr[i] 위치에 'C'를 넣는다
    i++;                                                                                 // i를 1 증가시켜서 다음 루프 시작점을 맞춘다

                                                                                          // 4. 두 번째 for 루프: 남은 문자들을 한 칸씩 뒤로 밀기
    for(; i < 5; i++){                                                                     // i는 위에서 증가된 값부터 시작한다. arr의 끝까지 반복
        char temp2 = arr[i];                                                                     // arr[i]의 현재 값을 temp2에 임시 저장
        arr[i] = temp;                                                                             // arr[i] 위치에 이전 루프에서 밀려난 temp 값을 넣는다
        temp = temp2;                                                                             // 다음 루프를 위해 temp 값을 업데이트한다
    }
                                                                                                            // 5. 최종 배열 출력
    for(i = 0; i < 5; i++){
        printf("%c", arr[i]);                                                                               // 문자 하나씩 출력
    }
    return 0;
}



답:
4
BACDE



---------------------------------------------------------------------------------------------------------

## 문제 11) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

#include <stdio.h>                                            // 표준 입출력 함수 (printf 등) 사용
#include <stdlib.h>                                         // 동적 메모리 할당 함수 (malloc, free) 사용

                                                                // 전역 1차원 배열 A
int A[9] = {8, 9, 3, 7, 2, 8, 3, 1, 4};                               // 총 9개의 원소 (인덱스 0~8)

                                                                    // func 함수: 1차원 배열 A의 값을 2차원 배열 res에 특정 규칙으로 채운다.
                                                                    // res: 값을 채울 대상인 2차원 배열 포인터 (int**)
                                                                    // cols: 2차원 배열의 열 개수
                                                                    // rows: 2차원 배열의 행 개수
void func(int **res, int cols, int rows) {
                                                          // 2차원 배열의 총 칸 수만큼 반복한다. (여기서는 3x3 = 9번)
    for(int i = 0; i < (cols * rows); i++) {
                                                                            // 핵심: 인덱스 r을 계산한다.
                                                                            // (i + 1) % (rows * cols) 는 0부터 시작하는 A 배열의 인덱스 i에 1을 더한 후,
                                                                            // 전체 크기로 나눈 나머지를 구한다.
                                                                            // 이는 A[i]의 값을 res 배열의 (i+1)번째 위치 (원형으로 돌아가는)에 넣겠다는 의미이다.
                                                                            // r은 res 배열 내의 1차원 인덱스처럼 생각할 수 있다.
                                                                            // r의 범위: (1 % 9) = 1, (2 % 9) = 2, ..., (8 % 9) = 8, (9 % 9) = 0
                                                                            // 즉, A[0]은 res의 1번째 칸에, A[1]은 res의 2번째 칸에, ..., A[8]은 res의 0번째 칸에 들어간다.
        int r = (i + 1) % (rows * cols);                                             // 예를 들어, i=0일 때 r=1, i=8일 때 r=0

                                                                                            // res[r / cols][r % cols] = A[i];
                                                                                            // r / cols: r을 열 개수로 나눈 몫. -> res 배열의 '행' 인덱스
                                                                                            // r % cols: r을 열 개수로 나눈 나머지. -> res 배열의 '열' 인덱스
                                                                                            // 이 공식을 사용하여 A[i] 값을 res의 특정 [행][열] 위치에 넣는다.
                                                                              
                                                                                      // 각 i에 따른 r, res[r/cols][r%cols] 위치, 그리고 들어가는 A[i] 값 추적
                                                                                      // (cols=3, rows=3 이므로 total_cells = 9)
                                                                                      // i | r (= (i+1)%9) | r/cols | r%cols | res[행][열]  | A[i] (값)
                                                                                      // --|---------------|--------|--------|--------------|-----------
                                                                                      // 0 | 1             | 0      | 1      | res[0][1]    | A[0] (8)
                                                                                      // 1 | 2             | 0      | 2      | res[0][2]    | A[1] (9)
                                                                                      // 2 | 3             | 1      | 0      | res[1][0]    | A[2] (3)
                                                                                      // 3 | 4             | 1      | 1      | res[1][1]    | A[3] (7)
                                                                                      // 4 | 5             | 1      | 2      | res[1][2]    | A[4] (2)
                                                                                      // 5 | 6             | 2      | 0      | res[2][0]    | A[5] (8)
                                                                                      // 6 | 7             | 2      | 1      | res[2][1]    | A[6] (3)
                                                                                      // 7 | 8             | 2      | 2      | res[2][2]    | A[7] (1)
                                                                                      // 8 | 0             | 0      | 0      | res[0][0]    | A[8] (4)
        res[r / cols][r % cols] = A[i];
    }
}

int main() {
    int **res;                                                                           // 2차원 배열 포인터 (int*를 가리키는 포인터)
    int cols = 3;                                                                                 // 열의 개수
    int rows = 3;                                                                                     // 행의 개수
    int sum = 0;                                                                                        // 최종 합계를 저장할 변수

                                                                                                // 2차원 배열 'res'를 동적으로 할당한다 (rows x cols 크기).
                                                                                                // 1단계: 행(row)을 가리킬 포인터 배열 할당
    res = (int **)malloc(sizeof(int *) * rows);
    if (res == NULL) { perror("malloc failed for rows"); return 1; }

                                                                              // 2단계: 각 행에 실제 데이터가 저장될 열(column) 배열 할당
    for(int i = 0; i < rows; i++) {
        res[i] = (int *)malloc(sizeof(int) * cols);
        if (res[i] == NULL) { perror("malloc failed for cols"); return 1; }
    }

                                                                                  // func 함수를 호출하여 res 배열에 값을 채운다.
    func(res, cols, rows);

                                                                                      // func 함수 실행 후 res 배열의 상태:
                                                                                      // res[0][0] = 4  ( <- A[8])
                                                                                      // res[0][1] = 8  ( <- A[0])
                                                                                      // res[0][2] = 9  ( <- A[1])
                                                                                      //
                                                                                      // res[1][0] = 3  ( <- A[2])
                                                                                      // res[1][1] = 7  ( <- A[3])
                                                                                      // res[1][2] = 2  ( <- A[4])
                                                                                      //
                                                                                      // res[2][0] = 8  ( <- A[5])
                                                                                      // res[2][1] = 3  ( <- A[6])
                                                                                      // res[2][2] = 1  ( <- A[7])
                                                                                  
                                                                                      // res 배열의 모든 값들을 순서대로 (0,0), (0,1), ..., (2,2) 순으로 접근하면서
                                                                                      // i가 짝수면 더하고, i가 홀수면 빼는 계산을 수행한다.
                                                                                      // ((i % 2 == 0) ? 1 : -1) 이 부분은 i가 짝수일 때 1, 홀수일 때 -1을 반환한다.
    for(int i = 0; i < rows * cols; i++) {
                                                                                      // res[i / cols][i % cols]는 res 배열을 1차원처럼 순차적으로 접근하는 방식이다.
                                                                                      // i | res[행][열] (값) | (i % 2 == 0 ? 1 : -1) | sum (누적)
                                                                                      // --|-----------------|-----------------------|--------------
                                                                                      // 0 | res[0][0] (4)   | +1                    | sum = 0 + 4 = 4
                                                                                      // 1 | res[0][1] (8)   | -1                    | sum = 4 - 8 = -4
                                                                                      // 2 | res[0][2] (9)   | +1                    | sum = -4 + 9 = 5
                                                                                      // 3 | res[1][0] (3)   | -1                    | sum = 5 - 3 = 2
                                                                                      // 4 | res[1][1] (7)   | +1                    | sum = 2 + 7 = 9
                                                                                      // 5 | res[1][2] (2)   | -1                    | sum = 9 - 2 = 7
                                                                                      // 6 | res[2][0] (8)   | +1                    | sum = 7 + 8 = 15
                                                                                      // 7 | res[2][1] (3)   | -1                    | sum = 15 - 3 = 12
                                                                                      // 8 | res[2][2] (1)   | +1                    | sum = 12 + 1 = 13
        sum += res[i / cols][i % cols] * ((i % 2 == 0) ? 1 : -1);
    }
    printf("%d", sum);                                                                         // 최종 합계 출력
                                            
                                                                                          // 동적으로 할당한 메모리를 해제한다. (메모리 누수 방지)
                                                                                          // 2단계 할당했던 열(column) 배열부터 먼저 해제한다.
    for(int i = 0; i < rows; i++) {
        free(res[i]);
    }
                                                                                    // 1단계 할당했던 행(row)을 가리키는 포인터 배열을 해제한다.
    free(res);

    return 0;                                                                         // 프로그램 성공 종료.
}

답: 13

---------------------------------------------------------------------------------------------------------

## 문제 12) 아래 설명을 읽고 빈칸에 들어갈 결합도를 쓰시오.

---

### 문제 설명

1. 하나의 모듈이 다른 모듈 내부에 있는 변수나 기능을 **직접 접근하거나 사용하는 경우**를 의미하며,  
   가장 강한 결합도로 모듈 간 독립성을 크게 해친다.

2. 모듈 간의 인터페이스로 단순 자료형이 아니라 **배열(Array), 객체(Object), 구조체**와 같은  
   복합적인 자료 구조가 전달되는 경우를 의미한다.  
   호출하는 모듈이 필요하지 않은 정보까지 함께 전달받아 모듈의 독립성을 저하시킬 수 있다.

3. 두 개 이상의 모듈이 **파라미터로 데이터를 전달하지 않고**, 외부에 선언된 전역변수를 참조하거나 수정하면서  
   서로 상호작용하는 경우이다. 모듈 간 결합도가 강하고 모듈 독립성이 저하된다.

---
### ✅ 문제

아래 설명에 해당하는 **결합도(Coupling)** 유형을 쓰시오.

1) 한 모듈이 다른 모듈의 내부 동작이나 데이터를 **직접 접근하거나 수정**한다.  
2) 배열이나 구조체 등 **복합 자료형을 통째로 전달**하여, **불필요한 정보까지 전달**된다.  
3) 여러 모듈이 **공유되는 전역 변수**를 사용한다.

---

### ✅ 정답

1) **내용 결합도**  
2) **스탬프 결합도**  
3) **공통 결합도**

---

## ✅ 결합도(Coupling) 쉽게 외우기 — 갓반인 스타일 예시 포함

---

### 📌 결합도란?

- **모듈 간 연결 정도를 나타내는 척도**
- **결합도가 낮을수록** 모듈끼리 **독립적**, 유지보수가 쉬움!
- 반대로 **결합도가 높을수록** 모듈끼리 **얽혀 있어서** 하나 고치면 연쇄 수정 💥

---

### ✅ 결합도 종류 및 설명 + 갓반인 예시

| 결합도 종류           | 설명                                                                 | 갓반인 예시 |
|----------------------|----------------------------------------------------------------------|-------------|
| **내용 결합도**       | 한 모듈이 다른 모듈의 **내부 로직**이나 **지역 변수**까지 직접 건드림.<br>**가장 나쁜 결합도** 🤯 | 옆 반 일지 몰래 들어가서 **개인 일기장 훔쳐보다가 줄 바꿔 씀** |
| **공통 결합도**       | **전역 변수**를 여러 모듈이 함께 써서, 어디서 바꿨는지 추적 어려움                   | **교실 한쪽 벽에 포스트잇** 붙여놓고 다 같이 메모장처럼 씀 |
| **외부 결합도**       | 외부 장치/파일/환경 변수를 통해 모듈끼리 소통                                  | **USB로 과제 전달**, 환경 변수로 저장 경로 공유 |
| **제어 결합도**       | 한 모듈이 **조건 플래그나 제어 변수**를 넘겨서 다른 모듈의 동작 흐름 결정              | 친구한테 "수업 시간에 **1이면 졸고, 2면 손들어**" 라고 미리 알려줌 |
| **스탬프 결합도**     | 구조체/배열 등 **덩어리째** 전달해서 일부 정보만 씀                              | 친구한테 **문제집 전체** 빌렸는데 **1문제만 보고 반납**함 |
| **자료 결합도**       | **정확히 필요한 데이터만** 전달. 가장 깔끔하고 이상적인 결합도 👍                  | "오늘 **급식 메뉴만 딱 알려줘**!" 처럼 필요한 정보만 공유 |
| **(결합 없음)**       | 모듈끼리 완전히 독립적. 서로 몰라도 작동함 → **최고의 이상향** 🌈                  | **반마다 시간표 따로**라서 전혀 간섭 없음 |

---

### 📌 갓반인 요약 정리

| 결합도         | 독립성 | 유지보수 용이성 | 비유 요약                                 |
|----------------|--------|------------------|--------------------------------------------|
| 내용 결합도     | 최악 ❌ | 매우 어려움       | 일기장 몰래 열어보고 수정함 (범죄)         |
| 공통 결합도     | 낮음 ❌ | 어려움           | 포스트잇 붙여놓고 전교생이 같이 씀         |
| 외부 결합도     | 낮음 ❌ | 중간             | USB로 파일 주고받는 느낌                   |
| 제어 결합도     | 보통 🤔 | 중간             | "1이면 일어나, 2면 자" 식 제어 신호 전달   |
| 스탬프 결합도   | 보통 🤔 | 보통             | 책 전체 빌려서 한 페이지만 봄              |
| 자료 결합도     | 최고 ✅ | 매우 쉬움         | 필요한 정보만 딱 전달 ("급식 뭐야?"만 물어봄) |
| 결합 없음       | 이상적 ✅ | 최상             | 서로 **전혀 안 엮임** (완전 독립 운영)       |

---

> 🔥 핵심은 딱 하나!  
> ✅ **"필요한 정보만 공유" → 자료 결합도 최고!**  
> ❌ **"내부 정보 침해/과도한 공유" → 내용/공통 결합도는 지양!**




---------------------------------------------------------------------------------------------------------

## 문제 13) 다음은 Java 코드이다. 출력 결과를 쓰시오.

                                                                    // 부모 클래스 정의
class Parent {
                                                                        // 1. static int total = 0;
                                                                        //    'static' 키워드 때문에 이 변수는 Parent 클래스에 딱 하나 존재한다.
                                                                        //    Parent와 Child 객체가 몇 개가 만들어지든 'total'은 하나를 공유한다.
    static int total = 0;

                                                                                    // 2. int v = 1;
                                                                                    //    '인스턴스 변수'. 각 Parent 또는 Child '객체마다' 별도로 존재하는 변수이다.
                                                                                    //    Child 클래스에도 동일한 이름의 'v'가 있지만, 그건 Child 객체 내의 또 다른 'v'이다.
    int v = 1;

                                                                                      // 3. 부모 클래스 생성자
    public Parent() {
                                                                                        // total += (++v);
                                                                                        // - 'v'를 먼저 1 증가시킨다. (pre-increment)
                                                                                        // - 이 시점에서 'v'는 'Parent 클래스의 인스턴스 변수 v' (초기값 1)를 의미한다.
                                                                                        //   Child 객체가 생성될 때도 이 부모 생성자가 먼저 호출되는데,
                                                                                        //   이때의 'v'는 아직 Child 클래스의 'v'로 초기화되지 않은, Parent의 'v'이다.
                                                                                        //   따라서 Parent.v는 1 -> 2가 된다.
                                                                                        // - total = total + 2
        total += (++v);                                                                       // Parent.total += 2

                                                                                            // showValue();
                                                                                            // - 여기서 호출되는 showValue()가 중요!
                                                                                            // - 자바의 다형성(Polymorphism)과 동적 바인딩(Dynamic Binding)에 따라,
                                                                                            //   현재 생성 중인 객체의 '실제 타입'에 해당하는 showValue()가 호출된다.
                                                                                            //   만약 new Child()로 Child 객체를 만들고 있다면, Child의 showValue()가 호출된다.
        showValue();                                                                         // 호출되는 시점의 total 값을 2배 또는 3배로 바꾼다.
    }

                                                                                                  // 4. 부모 클래스의 showValue() 메서드
    public void showValue() {
                                                                                                    // total = total * 2
        total += total; // Parent.total = Parent.total * 2
    }
}

                                                                                                      // 자식 클래스 정의 (Parent를 상속받음)
class Child extends Parent {
                                                                                                          // 6. int v = 10;
                                                                                                          //    자식 클래스만의 '인스턴스 변수'.
                                                                                                          //    이것은 부모의 'v'를 '오버라이딩(overriding)'하는 것이 아니라,
                                                                                                          //    '숨기는(hiding)' 것이다. 즉, Child 객체 내에는 Parent.v와 Child.v가 모두 존재한다.
                                                                                                          //    (일반적인 메서드 오버라이딩과는 다름)
    int v = 10;

                                                                                                              // 7. 자식 클래스 생성자
    public Child() {
                                                                                                                  // super() 호출이 명시적으로 없으면 자바 컴파일러가 자동으로 가장 첫 줄에 super()를 추가한다.
                                                                                                                  // 즉, Child 생성자가 호출되면 Parent() 생성자가 먼저 실행된다.
                                                                                                          
                                                                                                                  // 현재 Parent() 생성자 호출이 끝난 직후: Parent.total은 이미 변화된 상태.
                                                                                                                  // Parent.v는 2가 되었지만, Child.v는 아직 10으로 초기화된 상태이다.
                                                                                                          
                                                                                                                  // v += 2;
                                                                                                                  // - 여기서의 'v'는 Child 클래스의 인스턴스 변수 'v' (초기값 10)이다.
                                                                                                                  // - Child.v는 10 -> 12가 된다.
        v += 2;                                                                                                     // Child.v = 12

                                                                                                                // total += (v++);
                                                                                                                // - 'total'에 'v'의 현재 값(12)을 먼저 더하고, 'v'를 나중에 1 증가시킨다. (post-increment)
                                                                                                                // - 여기서의 'v'도 Child 클래스의 인스턴스 변수 'v'이다.
                                                                                                                // - total = total + 12
                                                                                                                // - Child.v는 12 -> 13이 된다.
        total += (v++);                                                                                           // Parent.total += 12

                                                                                                                  // showValue();
                                                                                                                  // - 다시 한번 showValue()가 호출된다.
                                                                                                                  // - 여전히 현재 생성 중인 객체의 실제 타입은 Child이므로, Child의 showValue()가 호출된다.
        showValue();                                                                                                 // 호출되는 시점의 total 값을 3배로 바꾼다.
    }

                                                                                                                  // 8. @Override public void showValue()
                                                                                                                  //    부모의 showValue() 메서드를 덮어쓰는(오버라이딩) 자식의 showValue() 메서드이다.
                                                                                                                  //    Child 객체에서는 항상 이 메서드가 호출된다.
    public void showValue() {
                                                                                                                      // total = total + (total * 2) = total * 3
        total += total * 2;                                                                                                 // Parent.total = Parent.total * 3
    }
}

class Main {
    public static void main(String[] args) {
                                                                                                            // Child 객체를 하나 생성한다.
                                                                                                            // 이 한 줄이 Parent() 생성자 -> Child() 생성자 순으로 연쇄 호출을 일으킨다.
        new Child();

                                                                                                              // Parent 클래스의 static 변수 'total' 값을 출력한다.
        System.out.println(Parent.total);
    }
}


답: 54


---------------------------------------------------------------------------------------------------------

## 문제 14) 다음 설명을 읽고 어떤 디자인 패턴인지 보기에서 골라 쓰시오

### 문제 설명

- 이 패턴은 **Wrapper(래퍼)**라고도 불린다.  
- 서로 호환되지 않는 두 개의 클래스 사이에서 한 클래스의 인터페이스를 다른 클래스가 기대하는 형태로 변환하여  
  기존에 호환되지 않았던 클래스들이 함께 작동할 수 있도록 해주는 **구조적 디자인 패턴**이다.  
- 이 패턴을 활용하면 이미 존재하는 클래스를 수정하지 않고도 기존 코드와 새로운 코드의 통합을 용이하게 만들 수 있다.

---

### 답

**ㄹ. Adapter**

---
# ✅ 디자인 패턴 보기 및 설명 정리 — 존나 쉽고 직관적 정리

---

## 📌 보기 및 핵심 요약표

| 기호 | 디자인 패턴명         | 분류       | 핵심 설명 |
|------|----------------------|------------|-----------|
| ㄱ   | **Singleton**        | 생성 패턴  | 인스턴스 **딱 하나만 존재**하게 만드는 패턴 |
| ㄴ   | **Factory Method**   | 생성 패턴  | 객체 생성을 **서브클래스에게 맡김** |
| ㄷ   | **Abstract Factory** | 생성 패턴  | 관련 객체들을 **묶음으로 생성** |
| ㄹ   | **Adapter**          | 구조 패턴  | **호환 안 되는 코드 연결**해줌 |
| ㅁ   | **Decorator**        | 구조 패턴  | **기능을 동적으로 추가** |
| ㅂ   | **Observer**         | 행위 패턴  | 상태 변화 → **자동으로 알림** 전파 |
| ㅅ   | **Visitor**          | 행위 패턴  | **기능을 객체 외부에서 확장** |

---

## 💡 각 패턴을 갓반인 예시로 아주 쉽게 설명하면?

---

### ㄱ. **Singleton (싱글톤)**  
- **정의**: 인스턴스를 오직 하나만 만들고, 어디서든 접근 가능  
- **실생활 비유**:  
  > "학교에 하나만 있는 **학생회장 자리**.  
  > 아무 반에서나 학생회장 부를 수는 있지만, **단 한 명만 존재**해."

- **갓반인 상황 예시**:  
  > "공용 프린터 하나 있는데, **모든 반에서 뽑을 때 그거만 써야 해.**"

---

### ㄴ. **Factory Method (팩토리 메소드)**  
- **정의**: 객체 생성 책임을 **서브클래스에게 넘기는** 방식  
- **실생활 비유**:  
  > "디자인은 본사에서 정했지만, **생산은 지점마다 다르게** 만들어."

- **갓반인 상황 예시**:  
  > "**학식은 종류는 같지만**, 식당마다 **메뉴 만드는 방식이 달라**!"

---

### ㄷ. **Abstract Factory (추상 팩토리)**  
- **정의**: 관련 있는 객체들을 **세트로 생성**  
- **실생활 비유**:  
  > "**컴퓨터 세트** 살 때, 본체 + 키보드 + 마우스를 **한꺼번에 맞춤 생성**"

- **갓반인 상황 예시**:  
  > "**졸업 앨범 패키지**: 개인사진 + 단체사진 + 명찰 전부 **같은 테마로 구성**됨"

---

### ㄹ. **Adapter (어댑터)**  
- **정의**: **기존 코드 수정 없이** 새 시스템에 맞춰주는 **중간자 역할**  
- **실생활 비유**:  
  > "**USB-C 포트밖에 없는 노트북에 HDMI 연결하려면** 어댑터 필요하지?"

- **갓반인 상황 예시**:  
  > "선생님이 **PDF만 받을 수 있는데**, 난 Word 파일이야.  
  > **변환기(어댑터)** 써서 넘기는 느낌."

```java
// 예시: 인터페이스 호환 안 되지만 Adapter로 연결
Client ----> Adapter ----> OldSystem
## ✅ 디자인 패턴 쉽게 외우기 — 데코레이터, 옵서버, 비지터 편

---

### ㅁ. **Decorator (데코레이터)**  
- **정의**: 기존 객체에 **동적으로 기능을 추가**  
- **실생활 비유**:  
  > "컵라면에 **치즈, 계란, 스팸 토핑** 추가해서 업그레이드하는 느낌"

- **갓반인 상황 예시**:  
  > "원래 교복에 **조끼** 입고, **학교 목도리** 추가해서 **꾸미기** 하는 거지."

---

### ㅂ. **Observer (옵서버)**  
- **정의**: 어떤 객체의 상태가 바뀌면, **등록된 객체들에게 자동 알림 전파**  
- **실생활 비유**:  
  > "단톡방에 **공지 하나 올리면**, 모든 반원들한테 **자동 알림** 가는 구조"

- **갓반인 상황 예시**:  
  > "**시간표 바뀌면** 반톡방, 출석부, 담임 선생님까지 전부 **자동으로 업데이트**됨"

---

### ㅅ. **Visitor (비지터)**  
- **정의**: 기존 객체 구조는 건드리지 않고, **기능만 외부에서 새로 추가**  
- **실생활 비유**:  
  > "**학교 건물이나 시스템은 그대로**, 외부 강사만 와서 **특강 하나 더 넣는 느낌**"

- **갓반인 상황 예시**:  
  > "진로체험 강사 와서 수업 하나 **추가**, 기존 수업은 그대로 두고 **기능만 확장**"

---

## ✅ 요약 표 – 갓반인 에디션

| 패턴명             | 유형     | 핵심 키워드         | 갓반인 예시 요약                                  |
|------------------|--------|--------------------|------------------------------------------------|
| **Singleton**        | 생성    | 인스턴스 1개        | 학교 프린터 하나, 전교생이 같이 씀                     |
| **Factory Method**   | 생성    | 생성 위임           | 식당은 똑같은 메뉴지만 만드는 방식은 각 반마다 다름         |
| **Abstract Factory** | 생성    | 객체 세트 생성       | 졸업 앨범: 사진 + 명찰 + 표지 디자인 **한 세트로 나옴**       |
| **Adapter**          | 구조    | 인터페이스 맞춤     | PDF만 받는 선생님에게 **Word → PDF 변환기** 써서 제출       |
| **Decorator**        | 구조    | 기능 동적 추가       | 교복 위에 조끼 + 목도리로 꾸미기                      |
| **Observer**         | 행위    | 상태 자동 알림       | 시간표 바꾸면 반톡/출석부/선생님까지 다 같이 바뀜            |
| **Visitor**          | 행위    | 외부 기능 확장       | 기존 수업은 그대로 두고 외부 강사가 와서 진로특강 추가함       |


---------------------------------------------------------------------------------------------------------

## 문제 15) 구문(문장) 커버리지를 수행하려고 한다.  
아래 제어 흐름도의 빈칸에 맞는 소스코드를 쓰고, 구문 커버리지의 경로를 쓰시오.

---

### [소스코드]

```c
int fnc(int a){
    int total = 0;
    while (a >= 0){
        if (a % 2 == 0)
            total = total + a;
        a = a - 2;
    }
    return total;
}

[제어 흐름도]
    1 ←
    ↓ ↑ 
6 ← 2 ↑
    ↓ ↑
    3 ↑
    ↓ ↑
    4 ↑
    ↓ ↑
    5 →

[제어 흐름도의 빈칸에 들어갈 코드]
total = 0;
a >= 0
a % 2 == 0
total = total + a;
a = a - 2;

return total;

구문 커버리지 경로
1 → 2 → 3 → 4 → 5 → 2 → 6


# ✅ 구문 커버리지 (Statement Coverage) — 존나 직관적인 설명

## 📌 한 줄 요약  
**"프로그램에 있는 모든 코드 줄을 최소 한 번씩 실행했는가?"**  
→ **코드 안에 있는 길은 모조리 한 번씩은 밟아본다!**

---

## 💡 쉬운 비유:  
> 네가 골목 탐험을 간다고 생각해봐.  
> 지나갈 수 있는 **모든 길(코드 줄)**은 최소 한 번은 지나가야 돼.  
> **그래야 길을 다 '탐색했다'고 할 수 있어.**  

---

## 🧠 예시 C 코드

```c
int total = 0;              // ① 초기화
while (a >= 0) {            // ② 반복 조건
  if (a % 2 == 0) {         // ③ 짝수 검사
    total = total + a;      // ④ 짝수일 때 합산
  }
  a = a - 2;                // ⑤ 감소
}
return total;               // ⑥ 결과 반환


# ✅ 구문 커버리지 (Statement Coverage) — 존나 직관적인 설명

## 📌 한 줄 요약  
**"코드에 있는 모든 줄(구문)을 최소 한 번씩 실행했냐?"**  
→ **코드 안의 모든 길을 다 한 번씩은 밟아봤냐는 뜻!**

---

## 🔁 제어 흐름도 번호

| 흐름도 번호 | 코드 줄                      |
|-------------|-----------------------------|
| ①           | `int total = 0;`            |
| ②           | `while (a >= 0)`           |
| ③           | `if (a % 2 == 0)`          |
| ④           | `total = total + a;`       |
| ⑤           | `a = a - 2;`               |
| ⑥           | `return total;`            |

---

## 🎯 구문 커버리지 100% 만드는 경로 예시  
① → ② → ③ → ④ → ⑤ → ② → ⑥

---

## 👣 경로 해석

| 단계 | 설명                                |
|------|-------------------------------------|
| **①** | 변수 초기화 → `total = 0;` 실행됨      |
| **②** | while 조건 검사                       |
| **③** | if 조건 검사 (짝수인지)               |
| **④** | 짝수면 합산 실행됨                    |
| **⑤** | `a` 값을 2 감소시켜서 다음 루프로 감   |
| **→ ②** | while 다시 검사 → 조건 안 맞아서 탈출 |
| **⑥** | 루프 종료 후 `return total;` 실행     |

---

## 🔍 이걸로 무엇을 검증할 수 있나?

✅ **각 코드 줄이 한 번이라도 실행됐는지 확인 가능**  
❌ **조건(if, while)의 true/false 양쪽 다 체크는 아님**  
→ 조건 분기는 "분기 커버리지"로 따로 확인해야 함!

---

## 👑 갓반인 예시

> 📘 "중간고사 범위가 1~6단원인데,  
> **각 단원의 맨 첫 페이지라도 다 펼쳐봤냐**? 이걸 보는 거야."

- 전부 꼼꼼히 공부했는지는 모르겠고  
- 일단 **범위 전체는 훑어봤는지 확인하는 정도**라고 보면 됨

---

## ✅ 정리 요약

| 항목       | 내용                                                        |
|------------|-------------------------------------------------------------|
| **커버 대상** | 모든 코드 줄 (구문)                                          |
| **만족 조건** | 각 줄이 최소 1번 이상 실행되었는가                              |
| **장점**     | 빠진 코드 없이 전체 흐름을 일단 실행해봤는지 확인 가능            |
| **한계**     | 조건의 참/거짓 양쪽 실행 여부는 모름 → 분기 커버리지 필요          |

---

---------------------------------------------------------------------------------------------------------

class Main {
                                                                      // func 함수: 배열의 특정 범위 내에서 중간값을 더하고 재귀적으로 호출된 부분 중 큰 값을 선택하여 반환한다.
                                                                      // a: 입력 정수 배열
                                                                      // st: 시작 인덱스 (start)
                                                                      // end: 끝 인덱스 (end)
    static int func(int[] a, int st, int end) {
                                                                  // 1. 재귀 탈출 조건:
                                                                  //    시작 인덱스가 끝 인덱스보다 크거나 같으면 (즉, 더 이상 유효한 범위가 없으면) 0을 반환한다.
                                                                  //    이는 빈 배열이거나, 단일 요소를 처리한 후 더 쪼갤 수 없을 때 발생한다.
        if (st >= end) return 0;

                                                                        // 2. 중간 인덱스 계산:
                                                                        //    (시작 + 끝)을 2로 나눈 정수 몫이다. (정수 나눗셈)
        int mid = (st + end) / 2;

                                                                                      // 3. 현재 중간 값과 양쪽 재귀 호출 결과 중 큰 값을 더하여 반환한다.
                                                                                      //    a[mid]: 현재 범위의 중간 인덱스에 해당하는 배열 값
                                                                                      //    func(a, st, mid): 왼쪽 절반에 대한 재귀 호출 결과
                                                                                      //    func(a, mid + 1, end): 오른쪽 절반에 대한 재귀 호출 결과
                                                                                      //    Math.max(...): 두 재귀 호출 결과 중 더 큰 값을 선택한다.
        return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));
    }

    public static void main(String[] args) {
        int[] a = new int[] {3, 5, 8, 12, 17};                                                       // 배열 초기화
                                                                                                    // 배열 인덱스:  0  1  2   3   4
                                                                                                    // 배열 값:    3  5  8  12  17
                                                                                            
                                                                                                    // func 함수를 호출한다. (전체 배열, 시작 인덱스 0, 끝 인덱스 4)
        int result = func(a, 0, a.length - 1);                                                                     // func(a, 0, 4)

        System.out.println(result);                                                                               // 최종 결과 출력
    }
}


답: 20 


---------------------------------------------------------------------------------------------------------

                                                                      # Node 클래스: 트리의 각 노드를 표현한다.
class Node:
    def __init__(self, value):
        self.value = value                                            # 노드가 저장할 값
        self.children = []                                            # 이 노드의 자식들을 저장할 리스트.
                                                                    # (여기서는 최대 2개의 자식을 가질 수 있는 이진 트리 형태로 사용됨)

                                                                # tree 함수: 주어진 리스트(li)로 트리를 생성하고 루트 노드를 반환한다.
def tree(li):
                                                                        # 리스트의 각 값으로 Node 객체들을 생성한다.
                                                                        # nodes 리스트의 인덱스는 트리의 인덱스와 일치하게 된다. (완전 이진 트리처럼)
    nodes = [Node(i) for i in li]

                                                                              # i는 1부터 리스트 길이 - 1까지 반복한다. (인덱스 0은 루트 노드이므로 자식이 됨)
    for i in range(1, len(li)):
                                                                                          # 부모 노드에 자식 노드를 추가한다.
                                                                                          # (i - 1) // 2 는 현재 노드(nodes[i])의 부모 노드 인덱스를 계산하는 식이다.
                                                                                          # 이 식은 배열 기반의 완전 이진 트리에서 부모 인덱스를 찾는 공식과 같다.
                                                                                          # 예: i=1 -> 부모 0, i=2 -> 부모 0
                                                                                          #     i=3 -> 부모 1, i=4 -> 부모 1
                                                                                          #     i=5 -> 부모 2
        nodes[(i - 1) // 2].children.append(nodes[i])

                                                                      # 리스트의 첫 번째 노드(nodes[0])를 트리의 '루트(root)'로 반환한다.
    return nodes[0]

                                                                                      # s 함수: 트리를 재귀적으로 순회하면서 특정 조건에 따라 노드 값을 합산한다.
                                                                                      # node: 현재 방문 중인 노드
                                                                                      # level: 현재 노드의 깊이 (루트 노드는 level 0)
def s(node, level=0):
                                                                                        # 재귀 종료 조건: 노드가 없으면 (트리의 끝에 도달했으면) 0을 반환한다.
    if not node:
        return 0

                                                                                          # 현재 노드의 값을 합계에 포함할지 여부를 결정한다.
                                                                                          # 핵심: 'level % 2'는 레벨이 짝수인지 홀수인지 판단한다.
                                                                                          # - level % 2 가 0 (짝수)이면: total = 0
                                                                                          # - level % 2 가 1 (홀수)이면: total = node.value (노드의 값)
    total = node.value if level % 2 else 0

                                                                                          # 현재 노드의 모든 자식들을 순회하며 재귀 호출한다.
    for child in node.children:
                                                                                          # 자식 노드를 호출할 때는 레벨을 1 증가시킨다.
                                                                                          # 재귀 호출의 결과를 현재 total에 더한다.
        total += s(child, level + 1)

    return total # 최종 합계 반환

                                                                                                    # --- 메인 실행 부분 ---
li = [1, 5, 8, 12, 15, 18] # 입력 리스트

                                                                                          # 1. tree 함수를 호출하여 리스트로 트리를 만든다.
                                                                                          #    nodes = [Node(1), Node(5), Node(8), Node(12), Node(15), Node(18)]
                                                                                          #
                                                                                          #    트리 구조 생성 과정:
                                                                                          #    i=1: nodes[0].children.append(nodes[1]) -> Node(1)의 자식: Node(5)
                                                                                          #    i=2: nodes[0].children.append(nodes[2]) -> Node(1)의 자식: Node(5), Node(8)
                                                                                          #    i=3: nodes[1].children.append(nodes[3]) -> Node(5)의 자식: Node(12)
                                                                                          #    i=4: nodes[1].children.append(nodes[4]) -> Node(5)의 자식: Node(12), Node(15)
                                                                                          #    i=5: nodes[2].children.append(nodes[5]) -> Node(8)의 자식: Node(18)
                                                                                          #
                                                                                          #    생성된 트리의 시각화 (값, [레벨]):
                                                                                          #             1 [0]
                                                                                          #            / \
                                                                                          #           5 [1]   8 [1]
                                                                                          #          / \     /
                                                                                          #        12 [2] 15 [2] 18 [2]
                                                                                          #

root = tree(li) # root는 Node(1)이 된다.

                                                                                          # 2. s 함수를 호출해서 결과를 출력한다.
                                                                                          #    s(root, level=0) 호출 추적:
                                                                                          #    - s(Node(1), level=0)
                                                                                          #      - level 0은 짝수 -> total = 0
                                                                                          #      - children: Node(5), Node(8)
                                                                                          #      - total += s(Node(5), level=1)
                                                                                          #      - total += s(Node(8), level=1)
                                                                                          #
                                                                                          #    - s(Node(5), level=1)
                                                                                          #      - level 1은 홀수 -> total = Node(5).value = 5
                                                                                          #      - children: Node(12), Node(15)
                                                                                          #      - total += s(Node(12), level=2)
                                                                                          #      - total += s(Node(15), level=2)
                                                                                          #
                                                                                          #    - s(Node(12), level=2)
                                                                                          #      - level 2는 짝수 -> total = 0
                                                                                          #      - children: 없음
                                                                                          #      - return 0
                                                                                          #
                                                                                          #    - s(Node(15), level=2)
                                                                                          #      - level 2는 짝수 -> total = 0
                                                                                          #      - children: 없음
                                                                                          #      - return 0
                                                                                          #
                                                                                          #    - Node(5)의 계산 계속: 5 + 0 + 0 = 5
                                                                                          #      - return 5
                                                                                          #
                                                                                          #    - s(Node(8), level=1)
                                                                                          #      - level 1은 홀수 -> total = Node(8).value = 8
                                                                                          #      - children: Node(18)
                                                                                          #      - total += s(Node(18), level=2)
                                                                                          #
                                                                                          #    - s(Node(18), level=2)
                                                                                          #      - level 2는 짝수 -> total = 0
                                                                                          #      - children: 없음
                                                                                          #      - return 0
                                                                                          #
                                                                                          #    - Node(8)의 계산 계속: 8 + 0 = 8
                                                                                          #      - return 8
                                                                                          #
                                                                                          #    - Node(1)의 계산 계속: 0 + s(Node(5), level=1) + s(Node(8), level=1)
                                                                                          #                         = 0 + 5 + 8 = 13
                                                                                          #

print(s(root))

📌 설명 (트리 만들고 홀수 레벨만 더하기!)
야, 이 문제는 파이썬으로 **트리(Tree)**라는 자료구조를 만들고, 그걸 탐색하면서 특정 조건을 만족하는 값들만 더하는 코드야.

1. tree(li) 함수로 트리 만들기
li = [1, 5, 8, 12, 15, 18] 이 리스트로 tree 함수가 트리를 만들어. 코드를 보면 이진 트리처럼 연결하는데, 결과적으로 이런 모양이 돼.

레벨 0 (뿌리 노드): 1
(부모: 없음)

레벨 1 (1의 자식): 5, 8
(부모: 1)

레벨 2 (5와 8의 자식): 12, 15 (5의 자식), 18 (8의 자식)
(부모: 5, 8)


2. s(node, level) 함수로 값 더하기
s 함수가 트리를 처음부터 끝까지 돌아다니면서 값을 더하는데, 존나 중요한 조건이 있어.
total = node.value if level % 2 else 0 이 부분이지?
이건 level이 홀수일 때만 node.value를 total에 더하고, level이 짝수일 때는 0을 더하라는 뜻이야.
자, 이제 s(root)를 호출했을 때 어떻게 계산되는지 따라가 보자.

s(1번 노드, level=0) 호출:
레벨 0은 짝수니까, total에 1을 더하지 않고 **0**을 더해. (total = 0)
이제 1번 노드의 자식들을 재귀 호출한다.

s(5번 노드, level=1) 호출 (1번 노드의 첫 번째 자식):
레벨 1은 홀수니까, total에 5를 더해. (total = 5)
이제 5번 노드의 자식들을 재귀 호출한다.

s(12번 노드, level=2) 호출 (5번 노드의 첫 번째 자식):
레벨 2는 짝수니까, total에 0을 더해. (아무것도 더해지지 않음)
12번 노드는 자식이 없으니 여기서 끝. 0을 반환.

s(15번 노드, level=2) 호출 (5번 노드의 두 번째 자식):
레벨 2는 짝수니까, total에 0을 더해. (아무것도 더해지지 않음)
15번 노드는 자식이 없으니 여기서 끝. 0을 반환.
(여기까지 s(5번 노드, level=1)은 5 + 0 + 0 = 5를 반환하게 돼.)

s(8번 노드, level=1) 호출 (1번 노드의 두 번째 자식):
레벨 1은 홀수니까, total에 8을 더해. (total = 8)
이제 8번 노드의 자식들을 재귀 호출한다.

s(18번 노드, level=2) 호출 (8번 노드의 첫 번째 자식):
레벨 2는 짝수니까, total에 0을 더해. (아무것도 더해지지 않음)
18번 노드는 자식이 없으니 여기서 끝. 0을 반환.
(여기까지 s(8번 노드, level=1)은 8 + 0 = 8을 반환하게 돼.)

자, 이제 제일 처음 s(1번 노드, level=0)으로 돌아와서 최종 계산을 해보자.

s(1번 노드, level=0)은 (자기 값 0) + (s(5번 노드) 결과인 5) + (s(8번 노드) 결과인 8)

= 0 + 5 + 8 = 13

그래서 최종적으로 print(s(root))를 하면 **13**이 출력되는 거야.

---------------------------------------------------------------------------------------------------------

## 문제 18) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

#include <stdio.h>                                  // 표준 입출력 함수 (printf 등) 사용
#include <stdlib.h>                                   // 동적 메모리 할당 함수 (malloc, free) 사용

                                                      // Data 구조체 정의 (연결 리스트의 각 노드)
typedef struct Data {
    int value;                                         // 노드가 저장할 정수 값
    struct Data* next;                                     // 다음 노드를 가리키는 포인터
} Data;

                                                                  // insert 함수: 새로운 노드를 만들어서 리스트 맨 앞에 추가하는 함수
                                                                  // head: 현재 리스트의 맨 앞 노드를 가리키는 포인터
                                                                  // value: 새로 추가할 노드의 값
                                                                  // 반환값: 새롭게 맨 앞이 된 노드의 주소
Data* insert(Data* head, int value) {
                                                                // 새 노드를 위한 메모리 공간을 동적으로 할당한다.
    Data* new_node = (Data*)malloc(sizeof(Data));
    if (new_node == NULL) {                                     // 메모리 할당 실패 시 처리 (실제 코드에서는 중요)
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }
    new_node->value = value;                                                           // 새 노드에 값 저장

    new_node->next = head;                                                       // 새 노드의 다음이 기존 맨 앞 노드를 가리키게 한다.
                                                                         // (새 노드가 리스트의 가장 앞에 위치하게 됨)
  
    return new_node;                                             // 새 노드를 새로운 맨 앞 노드(head)로 반환한다.
}

                                                      // reconnect 함수: 특정 값을 가진 노드를 찾아서 리스트 맨 앞으로 옮기는 함수
                                                      // head: 현재 리스트의 맨 앞 노드를 가리키는 포인터
                                                      // value: 맨 앞으로 옮기고 싶은 노드의 값
                                                      // 반환값: 새롭게 맨 앞이 된 노드의 주소
Data* reconnect(Data* head, int value) {
                                                                            // 1. 리스트가 비었거나 (head == NULL),
                                                                            //    찾는 값(value)이 이미 맨 앞 노드(head->value)의 값과 같으면
                                                                            //    아무것도 할 필요가 없으므로 현재 head를 바로 반환한다.
    if (head == NULL || head->value == value) return head;

    Data* prev = NULL;                                         // 현재 노드(curr) 바로 앞 노드를 가리킬 포인터
                                          Data* curr = head; // 현재 보고 있는 노드를 가리킬 포인터 (head부터 시작)

                                                                    // 2. 리스트를 처음부터 끝까지 돌면서 찾는 'value'를 가진 노드(curr)와 그 앞 노드(prev)를 찾는다.
                                                                    //    curr가 NULL이 되거나, curr의 값이 찾는 value와 같아질 때까지 반복한다.
    while (curr != NULL && curr->value != value) {
        prev = curr;                                                       // prev를 현재 curr 노드로 한 칸 이동
        curr = curr->next;                                                   // curr를 다음 노드로 한 칸 이동
    }

                                                                                // 3. 루프를 빠져나왔을 때의 조건:
                                                                                //    a) curr가 NULL이면: 리스트 끝까지 갔는데 찾는 value를 가진 노드를 찾지 못했다는 뜻.
                                                                                //       이 경우, 리스트 변경 없이 원래 head를 반환해야 한다.
                                                                                //    b) curr가 NULL이 아니고 (찾는 노드를 찾았고), prev가 NULL이 아니면:
                                                                                //       찾는 노드(curr)를 찾았는데, 그 노드가 맨 앞(head) 노드가 아니었다는 뜻.
                                                                                //       (만약 맨 앞 노드였다면 첫 번째 if문에서 이미 반환되었을 것이다.)
    if (curr != NULL && prev != NULL) {
                                                                                              // (prev) -> (curr) -> (curr->next) 였던 연결을
                                                                                              // (prev) -> (curr->next) 로 변경하여 curr 노드를 리스트에서 "떼어낸다".
        prev->next = curr->next;

                                                                                        // "떼어낸" curr 노드의 다음을 기존 맨 앞 노드(head)로 연결한다.
                                                                                        // curr -> (old head) -> ...
        curr->next = head;

                                                                                    // 이제 curr 노드가 리스트의 새로운 맨 앞 노드가 된다.
        head = curr;
    }
    return head; // 변경된 (또는 변경되지 않은) 맨 앞 노드를 반환한다.
}

int main() {
    Data* head = NULL;                                                                     // 연결 리스트의 시작 포인터를 NULL로 초기화 (빈 리스트)
    Data* curr;                                                                                            // 리스트를 순회할 때 사용할 임시 포인터

                                                                                        // 1. insert 함수로 노드 추가 (1부터 5까지)
                                                                                        // insert 함수는 노드를 '맨 앞'에 추가하므로, 리스트는 역순으로 쌓인다.
                                                                                        // i=1: head = insert(NULL, 1) -> 1 -> NULL
                                                                                        // i=2: head = insert(1, 2)    -> 2 -> 1 -> NULL
                                                                                        // i=3: head = insert(2, 3)    -> 3 -> 2 -> 1 -> NULL
                                                                                        // i=4: head = insert(3, 4)    -> 4 -> 3 -> 2 -> 1 -> NULL
                                                                                        // i=5: head = insert(4, 5)    -> 5 -> 4 -> 3 -> 2 -> 1 -> NULL
    for (int i = 1; i <= 5; i++)
        head = insert(head, i);

                                                                                          // 현재 리스트 상태: 5 -> 4 -> 3 -> 2 -> 1 -> NULL

                                                                                                      // 2. reconnect 함수 호출 (값 3을 가진 노드를 맨 앞으로 옮긴다.)
    head = reconnect(head, 3);

                                                                                              // reconnect(head, 3) 실행 추적:
                                                                                              // head = 5 -> 4 -> 3 -> 2 -> 1 -> NULL
                                                                                              // value = 3
                                                                                              //
                                                                                              // 첫 번째 if 조건 (head == NULL || head->value == value) -> (5 == 3) False
                                                                                              //
                                                                                              // prev = NULL, curr = &5 (value 5)
                                                                                              //
                                                                                              // while 루프 시작:
                                                                                              // - 1차: curr(5) != NULL && curr->value(5) != 3 (True)
                                                                                              //        prev = &5, curr = &4 (value 4)
                                                                                              // - 2차: curr(4) != NULL && curr->value(4) != 3 (True)
                                                                                              //        prev = &4, curr = &3 (value 3)
                                                                                              // - 3차: curr(3) != NULL && curr->value(3) != 3 (False -> curr->value == value 조건 만족)
                                                                                              //        while 루프 종료.
                                                                                              //
                                                                                              // 루프 종료 후: prev = &4, curr = &3
                                                                                              //
                                                                                              // if (curr != NULL && prev != NULL) 조건 -> (curr=&3 != NULL && prev=&4 != NULL) (True)
                                                                                              //    prev->next = curr->next;  // &4->next = &3->next (즉, &4->next = &2)
                                                                                              //                               // 이제 5 -> 4 -> 2 -> 1 -> NULL 로 연결된다. (3이 리스트에서 떨어져 나옴)
                                                                                              //    curr->next = head;        // &3->next = head (즉, &3->next = &5)
                                                                                              //                               // 이제 3 -> 5 -> 4 -> 2 -> 1 -> NULL 로 연결된다.
                                                                                              //    head = curr;              // head = &3
                                                                                              //                               // 새로운 head는 3이 된다.
                                                                                              //
                                                                                              // reconnect 함수 종료 후 리스트 상태: 3 -> 5 -> 4 -> 2 -> 1 -> NULL

                                                                                    // 3. 리스트를 처음부터 끝까지 돌면서 값 출력
    for (curr = head; curr != NULL; curr = curr->next)
        printf("%d", curr->value);                                                           // 각 노드의 값을 연달아 출력한다.

                                                                                    // 메모리 해제: 실제 프로그램에서는 동적으로 할당된 모든 노드를 해제해야 한다.
                                                                                    // (이 예제에서는 출력 결과에 영향을 미치지 않으므로 주석 처리하거나 단순화)
                                                                                    // Data* temp_node;
                                                                                    // curr = head;
                                                                                    // while (curr != NULL) {
                                                                                    //     temp_node = curr;
                                                                                    //     curr = curr->next;
                                                                                    //     free(temp_node);
                                                                                    // }

    return 0;                                                                   // 프로그램 성공 종료.
}

답: 35421
---------------------------------------------------------------------------------------------------------

## 문제 19) 다음은 C언어 코드이다. 출력 결과를 쓰시오.

#include <stdio.h>                                        // 표준 입출력 함수 (printf 등) 사용
#include <stdlib.h>                                     // 동적 메모리 할당 함수 (malloc, free) 사용

                                                          // Node 구조체 정의
                                                          // name: 최대 9글자의 이름 + NULL 종료 문자 (총 10바이트)
                                                          // score: 3개의 unsigned char 배열 (각 요소는 0~255 사이의 값)
typedef struct {
    char name[10];
    unsigned char score[3];                                   // unsigned char는 0부터 255까지의 값을 저장하는 1바이트 정수 타입
} Node;

                                                                  // f 함수: 주어진 score 값과 0xA5를 비트 AND 연산한다.
                                                                  // score: 0~255 범위의 unsigned char 값
                                                                  // 0xA5는 16진수 값으로, 이진수로는 10100101 이다.
int f(unsigned char score) {
                                                                      // 비트 AND 연산: 두 수의 같은 비트 위치가 모두 1일 경우에만 1이 된다.
                                                                      // 0xA5 (10100101)는 '마스크' 역할을 한다.
                                                                      // 즉, 0xA5의 비트가 0인 위치의 score 비트는 결과에서 무조건 0이 된다.
                                                                      // 0xA5의 비트가 1인 위치의 score 비트만 그대로 유지된다.
    return score & 0xA5;
}

int main() {
                                                                    // Node 타입의 포인터 'nodes'를 선언하고, Node 2개를 저장할 수 있는 메모리 공간을 동적으로 할당한다.
                                                                    // sizeof(Node)는 Node 구조체의 크기 (10바이트(name) + 3바이트(score) = 13바이트).
                                                                    // 2 * sizeof(Node)는 총 26바이트를 할당한다.
    Node* nodes = (Node*) malloc(2 * sizeof(Node));
                                                                    
                                                                        // nodes[0] 초기화:
                                                                        // name: "Kim"
                                                                        // score: {0xF0, 0xF5, 0xDB}
                                                                        // 각 16진수 값을 이진수로 보면:
                                                                        // 0xF0 = 11110000
                                                                        // 0xF5 = 11110101
                                                                        // 0xDB = 11011011
    nodes[0] = (Node){"Kim", {0xF0, 0xF5, 0xDB}};

                                                                                          // nodes[1] 초기화:
                                                                                          // name: "Lee"
                                                                                          // score: {0xED, 0xD3, 0xF2}
                                                                                          // 각 16진수 값을 이진수로 보면:
                                                                                          // 0xED = 11101101
                                                                                          // 0xD3 = 11010011
                                                                                          // 0xF2 = 11110010
    nodes[1] = (Node){"Lee", {0xED, 0xD3, 0xF2}};

    int result = 0;                                                           // f 함수의 반환값들을 누적할 변수를 0으로 초기화한다.

                                                                    // 이중 for 루프를 돌면서 각 Node의 score 배열 요소에 대해 f 함수를 호출하고 결과를 result에 더한다.
                                                                    // 외부 루프 (i): 0부터 1까지 (nodes[0], nodes[1])
                                                                    // 내부 루프 (j): 0부터 2까지 (score[0], score[1], score[2])
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            // f 함수 호출 결과들을 계속 더한다.
            result += f(nodes[i].score[j]);
        }
    }

                                                                                                            // 각 f(score) 호출의 비트 연산 결과 추적:
                                                                                                            // 0xA5 (마스크) = 10100101 (이진수)
                                                                                                        
                                                                                                            // i = 0 (nodes[0] - "Kim")
                                                                                                            // j = 0: f(0xF0) = 0xF0 & 0xA5 = 11110000 & 10100101 = 10100000 = 0xA0 (십진수 160)
                                                                                                            // j = 1: f(0xF5) = 0xF5 & 0xA5 = 11110101 & 10100101 = 10100101 = 0xA5 (십진수 165)
                                                                                                            // j = 2: f(0xDB) = 0xDB & 0xA5 = 11011011 & 10100101 = 10000001 = 0x81 (십진수 129)
                                                                                                        
                                                                                                            // i = 1 (nodes[1] - "Lee")
                                                                                                            // j = 0: f(0xED) = 0xED & 0xA5 = 11101101 & 10100101 = 10100101 = 0xA5 (십진수 165)
                                                                                                            // j = 1: f(0xD3) = 0xD3 & 0xA5 = 11010011 & 10100101 = 10000001 = 0x81 (십진수 129)
                                                                                                            // j = 2: f(0xF2) = 0xF2 & 0xA5 = 11110010 & 10100101 = 10100000 = 0xA0 (십진수 160)
                                                                                                        
                                                                                                            // result 누적 계산:
                                                                                                            // result = 0
                                                                                                            // result += 160  (0xA0)
                                                                                                            // result += 165  (0xA5)
                                                                                                            // result += 129  (0x81)
                                                                                                            // result += 165  (0xA5)
                                                                                                            // result += 129  (0x81)
                                                                                                            // result += 160  (0xA0)
                                                                                                            //
                                                                                                            // result = 160 + 165 + 129 + 165 + 129 + 160
                                                                                                            // result = 908

    printf("%d\n", result);                                                                                 // 최종 result 값을 출력한다.
    
    free(nodes);                                                                                   // 동적으로 할당된 메모리를 해제한다. (메모리 누수 방지)
    return 0;                                                                                            // 프로그램 성공 종료.
}



📌 답: 908
---------------------------------------------------------------------------------------------------------

## 문제 20) 다음은 Java 코드이다. 출력 결과를 쓰시오.
public class Main {

                                                  // 1. String을 파라미터로 받는 add 함수 (오버로드된 첫 번째 함수)
    static int add(String s) {
        int t = Integer.valueOf(s);                           // 문자열 's'를 정수 't'로 변환한다.
                                                                      // 예: "5" -> 5
        if (t <= 1) return t;                               // t가 1 이하면 t를 그대로 반환한다. (재귀 종료 조건)
                                            
                                                    // 재귀 호출: '정수형' add 함수를 두 번 호출한다.
                                                    // 여기서 중요한 건 'add(t - 1)'과 'add(t - 3)'이 정수형 파라미터를 받으므로,
                                                    // 아래에 정의된 'static int add(int i)' 함수가 호출된다는 점이다.
        return add(t - 1) + add(t - 3);
    }

    // 2. int를 파라미터로 받는 add 함수 (오버로드된 두 번째 함수)
    static int add(int i) {
        if (i <= 1) return i;                           // i가 1 이하면 i를 그대로 반환한다. (재귀 종료 조건)

                                                    // 재귀 호출: '정수형' add 함수를 두 번 호출한다.
                                                    // 이것은 피보나치 수열과 비슷한 형태의 재귀 호출이다.
        return add(i - 1) + add(i - 2);
    }

    public static void main(String[] args) {
                                                // 메인에서 문자열 "5"를 가진 add 함수를 호출한다.
                                                // 이 호출은 'static int add(String s)' 함수를 처음으로 실행시킨다.
        System.out.println(add("5"));
    }
}

출력 결과
4

