## ✅ 문제 1

AAA, Triple-A라고 읽는 이 용어는 보안의 세 가지 요소를 합쳐 축약한 것이다.  
다음 (1)~(3)에 해당하는 용어를 <보기>에서 찾아 쓰시오.

---

### 🔹 <보기>

- authentication  
- application  
- accounting  
- ascii  
- avalanche  
- authorization

---

### 🔹 설명

(1): 보안 기능에서, 사람이나 프로세스의 **신분을 확인**하는 것  
(2): 검증된 사용자에게 어떤 수준의 **권한과 서비스를 허용**하는 것  
(3): 사용자의 자원에 대한 **사용 정보를 수집**하여 과금, 감사, 용량 증설 리포팅 등을 실시하는 것

---

### ✅ 정답

- (1): **Authentication** (인증)  
- (2): **Authorization** (인가)  
- (3): **Accounting** (계정관리)

---
### 📌 해설

**AAA (Authentication, Authorization, Accounting)**는 보안에서 매우 중요한 세 가지 개념입니다.  
사용자를 확인하고, 권한을 주고, 사용 기록을 남기는 과정을 말합니다.

| 항목 | 용어 (영문)    | 의미 설명                                      |
|------|----------------|-----------------------------------------------|
| (1)  | Authentication | 사용자가 진짜 누구인지 확인하는 과정 (ex. ID/PW 로그인)  |
| (2)  | Authorization  | 인증된 사용자에게 어떤 자원이나 서비스에 접근할 권한을 주는 과정 |
| (3)  | Accounting     | 누가 언제 무엇을 했는지 기록하고 추적하는 과정         |

---

### 📎 쉽게 이해하는 예

- 회사 출입증을 대는 것 → **Authentication** (당신이 직원인지 확인)  
- 사무실, 회의실 출입 허가 여부 결정 → **Authorization** (어디까지 들어갈 수 있는지)  
- 출입 기록과 시간 저장 → **Accounting** (누가 언제 어디서 출입했는지 기록)  

---

### 📎 실제 적용 분야

- VPN 접속 제어  
- RADIUS / TACACS+ 서버  
- 무선 네트워크 인증  
- 기업 네트워크 접근 관리  



---------------------------------------------------------------------------------------------
## ✅ 문제 2

데이터 제어어 (DCL)의 하나인 **GRANT**의 기능에 대해 간략히 서술하시오.

---

### ✅ 답

사용자에게 접속 권한, 생성 권한 등을 부여하는 명령어

---

### 📌 해설

**GRANT**는 데이터베이스에서 특정 사용자나 역할(role)한테  
특정 작업할 수 있는 권한을 주는 명령어야.  
쉽게 말해서, 누가 뭘 할 수 있는지 허락해주는 거지.

#### 🔹 주요 특징
- 사용자한테 데이터 조회, 삽입, 수정, 삭제 권한을 줌  
- 보안 때문에 꼭 필요함  
- 준 권한은 **REVOKE**로 다시 뺄 수 있어  

---

### 📚 주요 권한 종류

| 권한    | 설명                      |
|---------|---------------------------|
| SELECT  | 데이터 조회할 수 있는 권한  |
| INSERT  | 데이터 넣을 수 있는 권한    |
| UPDATE  | 데이터 고칠 수 있는 권한    |
| DELETE  | 데이터 지울 수 있는 권한    |
| EXECUTE | 저장 프로시저, 함수 실행 권한 |
| ALL     | 다 합친 모든 권한          |

---

### ✅ 쉽게 이해하는 예시

회사 문서함 생각해봐!

- `GRANT SELECT ON EMPLOYEE TO MARY;`  
  → “메리한테 직원 명단 볼 수 있게 허락했어.”  
- `GRANT INSERT ON EMPLOYEE TO JOHN;`  
  → “존한테 직원 명단에 새 직원 추가할 수 있게 허락했어.”  
- `REVOKE SELECT ON EMPLOYEE FROM JOHN;`  
  → “존한테 준 명단 조회 권한 다시 뺐어.”

---

### 🧠 같이 알면 좋은 명령어

| 명령어 | 역할      |
|--------|-----------|
| GRANT  | 권한 주기 |
| REVOKE | 권한 빼기 |

---

### 📎 정리  
- **GRANT**: “너 이거 해도 돼!”  
- **REVOKE**: “야, 그거 하지 마!”  
- 데이터베이스 보안 기본 중에 기본임.


---------------------------------------------------------------------------------------------

### 문제 3) 다음에 설명하는 보안 위협에서 괄호에 들어갈 알맞은 답을 쓰시오

() 스푸핑은 MAC 주소를 속여 LAN에서 통신 흐름을 왜곡시키는 공격이다.  
공격 대상 컴퓨터와 서버 사이의 트래픽을 공격자의 컴퓨터로 우회시켜  
패스워드 정보 등 원하는 정보를 획득할 수 있다.

---

### 답  
**ARP**  
(주소 결정 프로토콜: Address Resolution Protocol)

---

### 📌 해설: ARP 스푸핑 (ARP Spoofing)

- **ARP 스푸핑이 뭐냐면**,  
  공격자가 네트워크에 가짜 ARP 메시지를 보내서  
  내 컴퓨터가 공격자 MAC 주소를 ‘서버나 게이트웨이’인 줄 착각하게 만드는 거야.  
- 그래서 내 패킷이 공격자한테 먼저 가게 돼서,  
  공격자가 내 정보(비밀번호, 계좌번호 등)를 몰래 훔쳐볼 수 있어.

---

### 어떻게 방어해?

- **정적 ARP 테이블**을 만들어서 ARP 정보가 바뀌지 않게 고정하기  
- **ARP 감시 시스템**(예: Dynamic ARP Inspection) 사용하기  
- 스위치에서 **MAC 주소 고정(바인딩)** 설정해서 이상한 MAC 못 들어오게 막기

---

### 비슷한 스푸핑 공격들

| 종류         | 설명                              |
|--------------|---------------------------------|
| IP 스푸핑    | IP 주소를 가짜로 바꿔서 공격하는 것 (예: DDoS 공격) |
| DNS 스푸핑   | DNS 답변을 조작해 가짜 사이트로 유도하는 공격      |
| MAC 스푸핑   | MAC 주소를 위조해 접근 권한을 속이는 공격           |

---

### 용어 짚고 가기

- **LAN**: 집이나 회사 안에서 쓰는 네트워크  
- **MAC 주소**: 내 컴퓨터 네트워크 카드 고유번호  
- **ARP**: IP 주소로 MAC 주소 찾아주는 프로토콜  

---

### 쉽게 예로 설명하면?

네가 집에 택배 올 때, 택배기사가 "나 집주인인데 나한테 줘!" 하고 거짓말 하는 거야.  
그럼 너는 진짜 집주인인 줄 알고 택배를 주는데, 그게 가짜면 큰일 나잖아?  
ARP 스푸핑도 그와 비슷하게 네트워크에서 “내가 진짜 서버야!” 하고 거짓말 하는 거야.  
그래서 네 데이터가 공격자한테 가게 되는 거지.


---------------------------------------------------------------------------------------------

### 문제 4) 결합도의 종류 중, 어떤 모듈이 다른 모듈을 호출할 때,  
단순히 값만 전달되는 형태가 아닌 제어 신호를 전달할 때 생기는 결합도를 영문으로 쓰시오

---

### 답  
**CONTROL COUPLING**  
(제어 결합도)

---

### 결합도 종류 (Coupling Types)

| 종류 (Type)           | 설명 (Description)                              |
|-----------------------|------------------------------------------------|
| 자료 결합도 (Data Coupling)      | 값만 전달 (필요한 데이터만 주고받음)                  |
| 스탬프 결합도 (Stamp Coupling)  | 배열, 구조체 같은 복합 데이터 전달                       |
| 제어 결합도 (Control Coupling)  | 제어 신호(플래그 등)까지 같이 전달해서 제어 흐름 조작         |
| 외부 결합도 (External Coupling) | 다른 모듈의 전역 변수나 외부 자원에 의존                  |
| 공통 결합도 (Common Coupling)   | 전역 변수 직접 사용 (모든 모듈이 공유하는 변수)              |
| 내용 결합도 (Content Coupling)  | 다른 모듈 내부 코드나 기능을 직접 접근하거나 수정             |

---

### 응집도 종류 (Cohesion Types)

| 종류 (Type)                | 설명 (Description)                                    |
|----------------------------|-----------------------------------------------------|
| 기능적 응집도 (Functional Cohesion)    | 한 가지 기능만 딱 수행 (가장 좋은 응집도)                 |
| 순차적 응집도 (Sequential Cohesion)    | 한 작업의 출력이 다음 작업 입력으로 연결됨                    |
| 통신적 응집도 (Communicational Cohesion) | 같은 데이터(입출력)를 공유해서 처리                          |
| 절차적 응집도 (Procedural Cohesion)      | 특정 순서에 따라 작업 수행                                   |
| 시간적 응집도 (Temporal Cohesion)        | 동시에 실행되는 기능 묶음                                    |
| 논리적 응집도 (Logical Cohesion)         | 비슷한 성격 기능들을 한곳에 모아놓음 (조건문으로 구분)           |
| 우연적 응집도 (Coincidental Cohesion)   | 아무 관련 없는 기능들이 막 섞여 있음 (최악의 응집도)              |

---

### 📌 보충 설명

- **제어 결합도**는 단순 데이터 전달뿐 아니라, 제어 흐름까지 함께 전달하는 거라서  
  모듈 간 의존성이 좀 더 커진다. 그래서 유지보수 어렵고 재사용성 떨어짐.  
- 좋은 설계는 **낮은 결합도**와 **높은 응집도**를 지향하는 거야.  
- 특히 제어 결합도는 가급적 줄이는 게 좋다!  


---------------------------------------------------------------------------------------------

### 문제 5) 디자인 패턴에 관한 설명에서 알맞은 답을 <보기>에서 고르시오

<보기>  
ABSTRACT FACTORY, FACTORYMETHOD, PROTOTYPE, BUILDER, OBSERVER  
FACADE, COMPOSITE, TEMPLATE METHOD, SINGLETON

---

- 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴  
- 객체 생성 코드를 별도의 클래스/메서드로 분리함으로써 객체 생성의 변화에 대비하는데 유용하다.  
- 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식  
- VIRTUAL - CONSTRUCTOR 패턴이라고 함  

---

### 답  
**FACTORYMETHOD**

---

### 📌 보충 설명: 팩토리 메서드 패턴 (Factory Method Pattern)

- 팩토리 메서드 패턴은 **객체를 직접 만드는 대신, 생성 책임을 서브클래스에게 맡기는 패턴**이야.  
- 그래서 클라이언트 코드는 어떤 구체 클래스가 만들어질지 신경 쓸 필요 없이, **인터페이스나 부모 클래스만 알고 있으면 돼**.  
- 이걸 '가상 생성자(Virtual Constructor)'라고도 부르는데, 객체 생성 코드를 한 곳에 모아둬서 나중에 바꾸기 편함!  
- 예를 들어, 자동차 공장이 있는데 차 만드는 방법(생성 방법)을 여러 서브 공장(서브클래스)에 맡겨서, 필요할 때마다 원하는 차(객체)를 만들게 하는 거야.  
- 반면, **추상 팩토리(Abstract Factory)**는 서로 연관된 여러 제품군을 한꺼번에 만드는 데 초점이 있으니, 팩토리 메서드랑 헷갈리지 말자!

---

### 쉽게 말해

- 직접 "이거 만들어!" 하지 말고  
- "어떤 걸 만들지 결정하는 방법만 알려줄게, 니가 알아서 만들어!"  
- 그래서 새로운 제품 추가해도 기존 코드는 안 건드려도 됨, 완전 편함.


---------------------------------------------------------------------------------------------
### 문제 6) 다음 파일 구조에 대한 설명이다. 빈칸에 알맞은 답을 작성하시오.

- 파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성하는 방식을 의미하는 것으로  
  편성방법에 따라 순차, () 랜덤, 해싱 등이 있다.  
- () 은 순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키 값 순으로  
  정렬하여 기록하여 데이터에 접근한다. 자기디스크에서 주로 사용된다.

---

### 답  
**색인**

---

### 파일 구조 쉽게 이해하기

- **순차 파일**  
  레코드들이 순서대로 쭉쭉 저장된 파일.  
  → 대량 데이터를 한 번에 쭉 처리할 때 좋음.  

- **직접 파일 (랜덤 파일)**  
  레코드가 저장 공간 여기저기에 흩어져 있음.  
  → 필요한 데이터만 바로 찾아서 쓸 때 딱임.  

- **색인 순차 파일**  
  순차 파일과 직접 파일의 좋은 점만 합친 것.  
  → 색인(index)을 만들어서, 원하는 레코드 빠르게 찾고 순서대로도 처리 가능!  

---

### 예시로 딱!  
- 순차 파일: 도서관 책이 제목 순서대로 쫙 꽂혀 있는 상태  
- 직접 파일: 책이 아무 데나 막 꽂혀 있는데, 도서관 컴퓨터가 바로 어디 있는지 알려줌  
- 색인 순차 파일: 책은 순서대로 꽂혀 있는데, 도서관 컴퓨터가 책 위치를 색인으로 바로 알려줘서 더 빠름

---

### 핵심 포인트  
- 순차 파일 = 한 줄로 쭉 읽는 용도  
- 직접 파일 = 필요한 데이터만 빠르게 꺼내는 용도  
- 색인 순차 파일 = 둘 다 가능한 하이브리드  
- 주로 하드디스크, DB 시스템에서 많이 쓰임

---------------------------------------------------------------------------------------------

### 문제 7) 다음은 소프트웨어 테스트에 관한 설명이다. (1), (2)에 들어갈 알맞은 답을 쓰시오

- (1)는 소프트웨어의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트 하는 기법이다.  
- 상위 모듈의 역할을 하는 (2)가 필요하다  
- (2)는 하위 모듈을 순서에 맞게 호출하고, 호출할 때 필요한 매개변수를 제공하며,  
  반환값을 전달하는 역할을 한다.

---

### 답  
(1) 상향식 테스트  
(2) 테스트 드라이버

---

### 상향식 테스트 & 테스트 드라이버 쉽게 이해하기

- **상향식 테스트 (Bottom-Up Testing)**  
  말 그대로 아래(하위 모듈)부터 차근차근 테스트하는 방식.  
  먼저 하위 모듈이 제대로 작동하는지 확인하고, 그다음에 상위 모듈과 합쳐서 테스트함.

- **테스트 드라이버 (Test Driver)**  
  상위 모듈이 아직 없을 때, 대신 상위 모듈 역할을 해주는 가짜 프로그램.  
  하위 모듈을 호출하고, 필요한 입력값 주고, 결과도 받아서 테스트할 수 있게 해줌.

---

### 테스트 흐름 (쉽게 정리)  
요구사항 분석 → 기능 명세 분석 → 설계 → 개발 →  
단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트

---

### 통합 테스트 방법  
- 상향식 테스트 : 하위부터 위로  
- 하향식 테스트 : 상위부터 아래로  
- 빅뱅 테스트 : 다 한꺼번에  
- 샌드위치 테스트 : 위, 아래 동시에 진행

---

### 핵심!  
상향식 테스트는 하위 모듈이 먼저 완성돼야 하니까,  
상위 모듈이 없으면 테스트 드라이버를 만들어서 대신 불러서 테스트함.




---------------------------------------------------------------------------------------------

## ✅ 문제 8

WINDOWS 나 MAC OS 등에서 사용하는 인터페이스로,  
사용자가 명령을 직접 입력하지 않고, **아이콘 등을 클릭하여 작업을 수행**하는  
사용자 인터페이스를 **영문 약어로 작성**하시오.

---

### ✅ 정답  
**GUI**

---

### GUI(그래픽 사용자 인터페이스) 쉽게 이해하기

- **GUI**는 마우스나 터치 같은 그래픽 요소를 이용해 컴퓨터를 다루는 방식이야.  
- 아이콘, 버튼, 창 같은 걸 직접 클릭해서 명령을 내리니까 누구나 쉽게 쓸 수 있어.

---

### 예시로 비교해보자면

- **CLI (Command Line Interface)**는 명령어를 직접 타이핑해서 컴퓨터에 말하는 느낌  
  (예: DOS 창, 리눅스 터미널)  
- **GUI**는 화면에 보이는 그림들(아이콘, 메뉴 등)을 손가락이나 마우스로 클릭해서 사용하는 느낌

---

### 대표적인 GUI 환경  
- 윈도우즈(Windows)  
- 맥OS(macOS)  
- 스마트폰 운영체제인 안드로이드(Android), 아이폰(iOS)

---

**즉, GUI는 컴퓨터가 어려운 사람도 쉽게 쓸 수 있게 만든 '친절한 인터페이스'라고 생각하면 딱임!**

---------------------------------------------------------------------------------------------
## ✅ 문제 9

다음 UML에 관한 설명에서 괄호에 들어갈 알맞은 답을 쓰시오.

---

### 문제: ( )는 자기만의 속성과 행동으로 이루어져 있고, 서로 연관·상속·의존 관계로 연결된다.  
**이걸 그린 대표적인 구조 다이어그램 이름은?**

---

### 정답  
**클래스 다이어그램**

---

### 쉽게 이해하기

- 클래스 다이어그램은 ‘객체들의 설계도’ 같은 거야.  
- 각 클래스는 속성(데이터)과 행동(함수)을 가지고 있어.  
- 클래스들끼리는 서로 연결되어 있는데, 그게 연관(서로 알고 있음), 상속(물려받음), 의존(잠깐 빌려씀) 같은 관계야.

---

### 예를 들어볼게

- 자동차 클래스(Car): 색깔, 바퀴 개수 같은 속성 + 달린다(Drive), 멈춘다(Stop) 같은 행동  
- 엔진 클래스(Engine): 마력, 종류 같은 속성 + 작동한다(Start) 행동  
- 자동차는 엔진을 ‘가지고 있으니까’ 연관 관계  
- 스포츠카 클래스(SportsCar)는 자동차 클래스를 상속받아서 기능을 더 추가할 수도 있음

---

### UML 다이어그램 분류

#### 구조적 다이어그램 (구조 보여줌)  
- 클래스 다이어그램: 객체 설계도  
- 패키지 다이어그램: 큰 단위 묶음  
- 객체 다이어그램: 특정 시점 객체 상태  
- 컴포넌트/배치 다이어그램: 시스템 부품과 배치

#### 행위적 다이어그램 (동작 보여줌)  
- 유스케이스: 누가, 뭘 하는지  
- 순차 다이어그램: 시간 흐름 따라 메시지 주고받기  
- 상태 다이어그램: 상태 변화  
- 활동 다이어그램: 프로세스 흐름도

---

### 핵심 요약

- 클래스 다이어그램은 객체 지향 설계의 기초.  
- ‘누가 어떤 속성 가지고, 무슨 행동 하는지’ + ‘서로 어떻게 연결되어 있는지’를 한눈에 보여줘서 개발할 때 필수임.

---------------------------------------------------------------------------------------------

## ✅ 문제 10

블록 암호의 일종으로 IBM에서 개발하고, 미국 NBS(현재 NIST)에서  
국가 표준으로 정한 암호화 알고리즘이나 취약점이 발견되어 현재는 잘 사용되지 않는다.  
블록 크기는 64비트, 키 길이는 56비트이며, 16라운드를 수행한다.  
**페이스텔 구조**를 사용하는 암호화 알고리즘은 무엇인지 쓰시오.

---

### ✅ 정답  
**DES** (Data Encryption Standard)

---

### DES 암호 쉽게 정리

- **DES**는 1977년에 IBM이 만든 **대칭키 블록 암호**야.  
- 쉽게 말해, 같은 키로 암호화랑 복호화를 한다는 뜻이고, 데이터는 일정 크기(64비트)씩 끊어서 암호화해.  
- 암호화 과정은 16번의 라운드(복잡한 변환 단계)를 거쳐서 안전하게 만든다고 알려져 있어.

| 특징          | 설명                                    |
|---------------|---------------------------------------|
| 암호 방식     | 대칭키 블록 암호                        |
| 블록 크기    | 64비트 (한 번에 64비트씩 암호화)        |
| 키 길이      | 56비트 (64비트 중 8비트는 오류 체크용)   |
| 구조        | 페이스텔(Feistel) 구조                   |
| 라운드 수    | 16번 반복 처리                           |
| 문제점      | 키가 짧아서 요즘은 보안 취약               |
| 지금은     | 3DES나 AES 같은 더 안전한 알고리즘으로 대체 |

---

### 암호 알고리즘 종류 한눈에 보기

| 분류      | 종류          | 대표 알고리즘                          |
|-----------|--------------|-------------------------------------|
| 대칭키    | 블록 암호     | DES, 3DES, AES, SEED (한국), ARIA (한국), LEA, IDEA, SKIPJACK |
| 대칭키    | 스트림 암호   | RC4, LFSR, A5                       |
| 공개키    | 소인수분해 문제 | RSA, Rabin                         |
| 공개키    | 이산대수 문제  | Diffie-Hellman, DSA, ElGamal       |
| 공개키    | 타원곡선 문제  | ECC (타원곡선 암호)                 |
| 해시함수  | 단방향 암호    | MD5 (충돌 취약), SHA (표준), HAS-160 (한국) |

---

### 예시로 이해하기

- **대칭키 블록 암호 (DES, AES 등)**  
  회사 사무실 문 앞에 똑같은 열쇠 2개를 만들어서 한 개는 너가, 한 개는 사무실에 둠.  
  문을 잠글 때 그 열쇠로 잠그고, 열 때도 같은 열쇠로 열어야 함.  
  데이터도 똑같은 키로 암호화, 복호화 하는 거야.

- **공개키 암호 (RSA, ECC 등)**  
  우체통에 편지를 넣을 때는 모두가 열 수 있는 자물쇠(공개키)로 잠그고,  
  편지를 읽을 때는 오직 사장님만 가진 비밀 열쇠(개인키)로 여는 방식.

- **해시 함수 (MD5, SHA 등)**  
  편지봉투에 특수 인주 찍듯, 내용이 변조됐는지 빠르게 확인하는 도구.

---

### 핵심 정리  
DES는 옛날 암호라 지금은 보안 약해서 요즘은 AES나 3DES 같은 더 좋은 걸 씀.  
암호는 크게 ‘대칭키’랑 ‘공개키’로 나뉘고, 상황에 맞게 골라 써야 안전함!



---------------------------------------------------------------------------------------------

## ✅ 문제 11

다음은 테스트 케이스의 구성 요소에 대한 설명이다.  
괄호 ( ) 안에 들어갈 알맞은 답을 쓰시오.

---

### 🔹 테스트 케이스 예시

| 식별자_ID   | 테스트 항목 | (1)            | (2)                          | (3)          |
|-------------|--------------|----------------|-----------------------------|--------------|
| LS_001_1    | 로그인       | 로그인 화면     | 아이디(test), 패스워드(qwe123) | 로그인 성공   |
| LS_001_2    | 회원가입     | 로그인 화면     | 아이디(test), 패스워드(qwe321) | 로그인 실패   |

---

### ✅ 정답

- (1): **테스트 조건**  
- (2): **테스트 데이터**  
- (3): **예상 결과**

---

### 📌 해설: 테스트 케이스 구성 요소

| 구성 요소        | 설명                                    |
|------------------|---------------------------------------|
| **테스트 조건**   | 테스트를 수행하기 위한 전제 조건이나 환경 (ex: 로그인 화면에 접속한 상태) |
| **테스트 데이터** | 테스트 중 입력하는 실제 값 (ex: 아이디, 패스워드)                       |
| **예상 결과**     | 테스트가 정상적으로 완료되었을 때 기대되는 결과 (ex: 로그인 성공 여부)   |

---

### 📌 추가 예시

- 테스트 케이스 ID: TC_LOGIN_01  
- 테스트 항목: 로그인 기능  
- 테스트 조건: 로그인 화면에 접속함  
- 테스트 데이터: ID = user01 / PW = pass123  
- 예상 결과: 로그인 성공 후 메인 페이지로 이동  

---

**요약:**  
테스트 케이스는 ‘어디서(조건)’, ‘뭘 넣고(데이터)’, ‘어떤 결과가 나와야 한다(예상 결과)’를 명확하게 정리해서 버그 없는 프로그램 만들 때 필수임.


---------------------------------------------------------------------------------------------
문제 12) UML 관계에 대한 설명이다 다음 (1), (2)에 들어갈 알맞은 용어를 쓰시오

(1): 클래스들 사이의 전체 또는 부분 같은 관계
(2): 한 클래스가 다른 클래스를 포함하는 상위개념일때의 IS- A 관계

답: 1) aggregation
   2) generalization

### UML 관계 쉽게 정리

| 관계 종류       | 뜻                                   | 핵심 포인트 / 예시                       |
|----------------|------------------------------------|-----------------------------------------|
| **일반화 관계** (Generalization) | 상속 관계                          | 부모 → 자식, “~이다” 관계 (ex: 동물 → 강아지) |
| **연관 관계** (Association)      | 관련된 관계                       | 서로 연결되어 있지만 독립적 (ex: 학생 ↔ 학교) |
| **의존 관계** (Dependency)       | 잠깐 쓰고 말 관계                | 한쪽이 잠시 다른 쪽을 참조할 때 (ex: 시험 문제 → 학생) |
| **실체화 관계** (Realization)    | 추상 메서드 구현 (오버라이딩)   | 인터페이스 구현할 때 (ex: 인터페이스 → 클래스) |
| **집합 관계 - 집약** (Aggregation) | 부분 객체는 독립적               | 부품이지만 따로 존재 가능 (ex: 자동차와 바퀴) |
| **집합 관계 - 합성** (Composition) | 부분 객체는 의존적               | 부품이 없으면 전체도 없음 (ex: 집과 방) |

---

### 한줄 요약  
- 상속은 “~이다” 관계  
- 연관은 “~와 관련 있다”  
- 의존은 “잠깐 빌려 쓴다”  
- 실체화는 “인터페이스를 구현한다”  
- 집합-집약은 “부품은 독립적”  
- 집합-합성은 “부품이 생명 줄다리기”

---

### 직관 예시

```plantuml
class 동물
class 강아지
동물 <|-- 강아지       // 일반화 (상속)

class 학생
class 학교
학생 --> 학교       // 연관 관계

class 시험문제
class 학생
시험문제 ..> 학생   // 의존 관계

interface 인터페이스
class 구현클래스
인터페이스 <|.. 구현클래스  // 실체화 (인터페이스 구현)

class 자동차
class 바퀴
자동차 o-- 바퀴    // 집합 - 집약 (바퀴는 독립적)

class 집
class 방
집 *-- 방           // 집합 - 합성 (방은 집 없으면 못 존재)

---------------------------------------------------------------------------------------------
### 문제 13) OSI 7 계층에 대한 설명에서 (1)~(3)에 들어갈 알맞은 계층을 쓰시오

(1) "포인트 투 포인트의 신뢰성 있는 데이터 전송을 보장하며, 물리 계층의 오류를 감지하고 수정한다."

(2) 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능

(3) 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고 암호화한다.

---

### ✅ 정답

(1) 데이터 링크 계층
(2) 네트워크 계층
(3) 표현 계층


---

### OSI 7계층 완전 쉽고 직관 정리

| 계층           | 역할 & 대표 프로토콜/기능                             |
|----------------|-----------------------------------------------------|
| **응용 계층**    | 사용자랑 직접 소통하는 계층<br>예) HTTP, FTP, SMTP, DNS, DHCP |
| **표현 계층**    | 데이터 모양 바꾸고 암호화/복호화 담당                  |
| **세션 계층**    | 통신 연결 관리, 세션 유지 및 종료                       |
| **전송 계층**    | 데이터 전송 책임지고 오류 체크<br>예) TCP, UDP         |
| **네트워크 계층**| 데이터가 갈 길 찾아주는 길 안내자<br>예) IP, ICMP      |
| **데이터 링크 계층** | 에러 검사하고 데이터 프레임으로 쪼개서 전달<br>예) ARP, RARP |
| **물리 계층**    | 전기신호, 케이블, 전송 매체 담당                       |

---

### 핵심 정리

- **데이터 링크 계층**: ‘데이터 안전하게 보냄’ + 에러 체크  
- **네트워크 계층**: ‘최단 경로 찾아서 전달’  
- **표현 계층**: ‘데이터 형식 바꾸고 암호화함’

---

### 한줄 요약

“내가 보내는 데이터가 잘 포장(표현), 안전하게 연결(세션), 정확히 전달(전송), 길 잘 찾아서(네트워크), 안전하게 보내짐(데이터 링크), 결국 전기 신호로 물리적으로 보내짐(물리)”  


---------------------------------------------------------------------------------------------
### 문제 14) 테스트 기법 중 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석하여 효용성 높은 검사 사례를 선정하여 검사하는 기법을 아래에서 찾아 쓰시오

- Equivalence partitioning  
- Boundary value analysis  
- Cause-effect graphing  
- Fault based  
- Base path test  
- Loop test  
- Comparison testing  

---

### ✅ 정답

cause-effect graphing


---
### 블랙박스 테스트 기법 완전 쉽게 정리

- **동등분할 기법 (Equivalence Partitioning)**  
  → 입력 데이터를 비슷한 그룹(동등 클래스)으로 나누고,  
  대표 값만 뽑아 테스트하는 방법.  
  예: 나이 입력 0~100살 → 0~17, 18~64, 65~100 이렇게 나눠서 각각 대표값 테스트

- **경계값 분석 (Boundary Value Analysis)**  
  → 입력 조건의 딱 경계값(최소, 최대, 바로 위/아래 값)만 테스트하는 방법.  
  예: 18살 이상만 회원가입 가능 → 17, 18, 19 살을 꼭 테스트

- **원인-효과 그래프 검사 (Cause-Effect Graphing)**  
  → 입력과 출력 간 관계를 표로 그려서,  
  중요한 테스트 케이스만 뽑아내는 똑똑한 방법

- **오류 예측 검사 (Fault Based Testing)**  
  → 과거 경험이나 감으로 문제 될만한 부분만 집중해서 테스트하는 방법

- **비교 검사 (Comparison Testing)**  
  → 여러 버전 프로그램에 똑같은 입력 넣고,  
  결과가 똑같이 나오는지 확인하는 방법

---

### 한줄 요약  
"입력 케이스 똑똑하게 골라서, 경계 조심하고, 경험 믿고, 여러 버전 비교해보는 테스트 방식들!"

---------------------------------------------------------------------------------------------

### 문제 15) t1 테이블과 t2 테이블을 참고하여 SQL 실행 결과를 쓰시오

| t1  |       | t2  |    |
|------|-------|-----|----|
| NAME |       | RULE |    |
| ALLEN |       | S%  |    |
| SCOTT |       | %T% |    |
| SMITH |       |     |    |

```sql
SELECT COUNT(*) AS CNT
FROM A CROSS JOIN B
WHERE A.NAME LIKE B.NAME;

✅ 정답
4

🔍 해설
### CROSS JOIN + WHERE LIKE 조건 결과 분석

- CROSS JOIN:  
  A 테이블(3행) × B 테이블(3행) → 총 9행 조합 생성

- 조건:  
  `A.NAME LIKE B.RULE` → A.NAME이 B.RULE 패턴과 맞는 경우만 필터링

| A.NAME | B.RULE | A.NAME LIKE B.RULE? |
|--------|--------|---------------------|
| ALLEN  | S%     | NO                  |
| ALLEN  | %T%    | NO                  |
| ALLEN  | (NULL) | FALSE (NULL 취급)    |
| SCOTT  | S%     | NO                  |
| SCOTT  | %T%    | YES (SCOTT에 'T' 포함) |
| SCOTT  | (NULL) | FALSE               |
| SMITH  | S%     | YES (SMITH가 'S'로 시작) |
| SMITH  | %T%    | YES (SMITH에 'T' 포함) |
| SMITH  | (NULL) | FALSE               |

---

- LIKE 조건 통과 행 수: **4개** (SCOTT-%T%, SMITH-S%, SMITH-%T%)

- NULL 패턴은 조건이 거짓 처리되니 결과에 포함되지 않음

---

**결론:** CROSS JOIN 결과에서 WHERE절 `LIKE` 필터를 적용하면,  
조건에 맞는 4개의 행만 최종 선택됨.


---------------------------------------------------------------------------------------------

### 문제 16) 다음 Python 프로그램을 분석하여 실행 결과를 쓰시오

x, y = 100, 200 # 변수 'x'에 100을, 변수 'y'에 200을 동시에 할당한다.

print(x == y)                         # 'x'의 값과 'y'의 값이 같은지 비교하는 연산이다.
                                      # 'x'는 100이고, 'y'는 200이니 서로 같지 않다.
                                      # 따라서 이 비교의 결과는 참(True)이 아닌 거짓(False)이 된다.
✅ 정답

False

🔍 해설
x = 100, y = 200 으로 변수에 각각 정수를 할당함.

x == y 는 두 값이 같은지를 비교하는 연산.

100 == 200 → False

📌 참고
== : 값(value) 이 같은지 비교하는 연산자

is : 객체(object) 가 같은지를 비교하는 연산자


a = [1, 2]
b = [1, 2]

print(a == b)   # True (값이 같음)
print(a is b)   # False (다른 객체)
---------------------------------------------------------------------------------------------
### 문제 17) 다음 C언어 프로그램을 분석하여 실행 결과를 쓰시오

                                                              // jsu라는 이름의 구조체(struct)를 정의했다.
                                                              // 이름, OS 점수, DB 점수, 합계(hab), 그리고 또 다른 합계(hhab)를 저장할 수 있어.
struct jsu {
    char name[12];                                               // 이름을 저장할 문자 배열 (최대 11글자 + 널 문자)
    int os, db, hab, hhab;                                           // OS 점수, DB 점수, 'hab' (합계), 'hhab' (총합계)
};

int main() {
                                                                // 'jsu' 구조체 타입의 배열 'st'를 3칸짜리로 선언하고 바로 초기화했다.
                                                                // 여기서 중요한 건, 'hab'과 'hhab'은 초기화할 때 값을 안 줬으니 기본적으로 0이 들어간다.
    struct jsu st[3] = {
        {"데이터1", 95, 88},                                 // st[0]: name="데이터1", os=95, db=88, hab=0, hhab=0
        {"데이터2", 84, 91},                               // st[1]: name="데이터2", os=84, db=91, hab=0, hhab=0
        {"데이터3", 86, 75}                                            // st[2]: name="데이터3", os=86, db=75, hab=0, hhab=0
    };

    struct jsu *p;                                                         // 'jsu' 구조체를 가리키는 포인터 'p'를 선언했다.
    p = &st[0];                                              // 포인터 'p'에 배열 'st'의 첫 번째 요소 (st[0])의 주소를 저장한다.
                                                                     // 이제 'p'는 st[0]을 가리키고 있어.

                                                                        // 첫 번째 계산: (p+1)->hab 값 구하기
    (p+1)->hab = (p+1)->os + (p+2)->db;
                                                                        // (p+1): 'p'가 st[0]을 가리키고 있으니, 'p+1'은 st[1]을 가리킨다.
                                                                        // (p+1)->os: st[1].os 값, 즉 84.
                                                                        // (p+2): 'p'가 st[0]을 가리키고 있으니, 'p+2'는 st[2]를 가리킨다.
                                                                        // (p+2)->db: st[2].db 값, 즉 75.
                                                                        // 따라서 (p+1)->hab = 84 + 75 = 159가 된다.
                                                                        // st[1]은 이제 {..., os=84, db=91, hab=159, hhab=0} 상태다.

                                                                          // 두 번째 계산: (p+1)->hhab 값 구하기
    (p+1)->hhab = (p+1)->hab + p->os + p->db;
                                                                              // (p+1)->hhab: st[1].hhab 값을 계산.
                                                                              // (p+1)->hab: 방금 위에서 계산한 st[1].hab 값, 즉 159.
                                                                              // p->os: 'p'는 st[0]을 가리키고 있으니 st[0].os 값, 즉 95.
                                                                              // p->db: 'p'는 st[0]을 가리키고 있으니 st[0].db 값, 즉 88.
                                                                              // 따라서 (p+1)->hhab = 159 + 95 + 88 = 342가 된다.
                                                                              // st[1]은 이제 {..., os=84, db=91, hab=159, hhab=342} 상태다.

                                                                                          // 최종 출력: (p+1)->hab + (p+1)->hhab 값
    printf("%d\n", (p+1)->hab + (p+1)->hhab);                                        
                                                                                        // (p+1)->hab: 159
                                                                                        // (p+1)->hhab: 342
                                                                                        // 159 + 342 = 501
}

✅ 정답

501


### 📌 요약

| 항목          | 값   |
|---------------|-------|
| st[1].hab     | 159   |
| st[1].hhab    | 342   |
| **최종 출력** | **501** |

---------------------------------------------------------------------------------------------
✅ 문제 18) C언어 코드 분석

void main() {                                                       // 메인 함수 시작
    int *arr[3];                                                 // 'arr'은 'int형 포인터'를 3개 저장할 수 있는 배열이다.
                                                         // 즉, arr[0], arr[1], arr[2] 각각이 int 변수의 주소를 저장할 수 있다는 뜻.

    int a = 12, b = 24, c = 36;                                         // 정수형 변수 'a', 'b', 'c'를 선언하고 초기화한다.

    arr[0] = &a;                                 // arr[0]에 변수 'a'의 주소를 저장한다. (arr[0]은 이제 12가 있는 곳을 가리킴)
    arr[1] = &b;                               // arr[1]에 변수 'b'의 주소를 저장한다. (arr[1]은 이제 24가 있는 곳을 가리킴)
    arr[2] = &c;                               // arr[2]에 변수 'c'의 주소를 저장한다. (arr[2]은 이제 36이 있는 곳을 가리킴)

                                                                              // 최종 출력 부분: printf("%d\n", *arr[1] + **arr + 1);
                                                                              // 이 부분을 뜯어보자.

                                                                    // 1. *arr[1]
                                                                    //    arr[1]은 변수 'b'의 주소(24가 있는 곳)를 가리킨다.
                                                                    //    *arr[1]은 그 주소에 있는 '값'을 의미하니, **24**다.
                                                                
                                                                    // 2. **arr
                                                                    //    arr는 배열의 이름이므로, 배열의 첫 번째 요소의 주소, 즉 arr[0]의 주소를 가리킨다.
                                                                    //    *arr은 arr[0]의 '값', 즉 변수 'a'의 주소(&a)를 의미한다.
                                                                    //    **arr은 *(&a)와 같으니, 변수 'a'의 '값'인 **12**다.
                                                                
                                                                    // 3. 1
                                                                    //    그냥 숫자 1

    printf("%d\n", 24 + 12 + 1);                               // 이제 이 값들을 모두 더한다.
                                                                 // 24 + 12 + 1 = 37

                                                                // 최종적으로 37이 출력된다.
}


🎯 정답
37

📌 요약
arr은 포인터 배열이며 각각 &a, &b, &c를 저장

*arr[1] → b = 24

**arr → a = 12

+1 포함하면 → 24 + 12 + 1 = 37

---------------------------------------------------------------------------------------------
## ✅ 문제 19

다음 Java 언어 프로그램을 분석하여 실행 결과를 쓰시오.
public class Main {
    public static void main(String[] args) {
        int a = 3, b = 4, c = 3, d = 5;

        if ((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d)) {
            a = b + c; // a = 7
            if (7 == b ^ c != a) {
                System.out.println(a);
            } else {
                System.out.println(b);
            }
        } else {
            a = c + d;
            if (7 == c ^ d != a) {
                System.out.println(a);
            } else {
                System.out.println(d);
            }
        }
    }
}

✅ 정답
7


✅ 우선 연산자 우선순위 점검
코드 해설 드간다  
이 코드는 복잡해 보이는 **논리 연산자(&, |, !, ^)**와 **조건문(if-else)**을 섞어서 최종적으로 어떤 값이 출력되는지 확인하는 문제야. 한 단계씩 꼼꼼히 따라가야 함.

---

초기값 세팅  
a = 3  
b = 4  
c = 3  
d = 5

---

첫 번째 if 문 조건 확인
if ((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d))

각 부분별로 쪼개서 보자.

- (a == 2 | a == c)  
  - a == 2 : 3 == 2 ➡️ False  
  - a == c : 3 == 3 ➡️ True  
  - False | True ➡️ True (OR 연산: 둘 중 하나라도 참이면 참)

- !(c > d)  
  - c > d : 3 > 5 ➡️ False  
  - !False ➡️ True (NOT 연산: 거짓의 반대는 참)

- (1 == b ^ c != d)  
  - 1 == b : 1 == 4 ➡️ False  
  - c != d : 3 != 5 ➡️ True  
  - False ^ True ➡️ True (XOR 연산: 서로 다를 때만 참)

---

이제 이 세 부분의 결과를 & (AND) 연산으로 묶는다.  
True & True & True ➡️ True (AND 연산: 모두 참이어야 참)

---

첫 번째 if 문 실행 블록 진입  
전체 조건이 True이므로, if 블록 안으로 진입한다.

a = b + c;
a = 4 + 3;
a의 값은 이제 **7**이 된다.
---

두 번째 if 문 (내부 if) 조건 확인
if (7 == b ^ c != a)

각 부분별로 쪼개서 보자. (현재 a는 7, b는 4, c는 3)

- 7 == b  
  - 7 == 4 ➡️ False  

- c != a  
  - 3 != 7 ➡️ True  

- False ^ True ➡️ True (XOR 연산: 서로 다를 때만 참)

---

두 번째 if 문 실행 블록 진입  
조건이 True이므로, if 블록 안으로 진입한다.


현재 a의 값은 **7**이다.

---

✅ 정답
7

---------------------------------------------------------------------------------------------
## ✅ 문제 20

다음 Java 언어 프로그램을 분석하여 실행 결과를 쓰시오.

### 🔸 원문 코드 (오타 포함)
class Connection {
    private static Connection _in = null;                         // (1) private static: 이 클래스 내에서만 접근 가능하고, 객체가 아니라 클래스 자체에 속한 단 하나의 인스턴스를 저장할 변수. 처음엔 null.
    private int count = 0;                                                              // (2) 인스턴스 변수: 각 Connection 객체가 가질 count 값.

    static public Connection get() {                                       // (3) static public 메소드: Connection 객체를 얻는 유일한 방법. 'static'이라 클래스 이름으로 바로 호출 가능.
        if (_in == null) {                                               // (4) _in이 null이면 (아직 객체가 안 만들어졌으면)
            _in = new Connection();                                    // (5) 새로운 Connection 객체를 만들어서 _in에 저장. 딱 한 번만 실행됨.
        }
        return _in;                                               // (6) 이미 만들어진 _in 객체를 반환. (처음 이후에는 계속 이 객체만 반환함)
    }

    public void count() {                                       // (7) count 값을 1 증가시키는 메소드.
        count++;
    }

    public int getCount() {                                     // (8) 현재 count 값을 반환하는 메소드.
        return count;
    }
}

public class testcon {
public class testcon {
    public static void main(String[] args) {
        Connection conn1 = Connection.get();               // (A) get() 메소드 호출. _in이 null이므로, 새로운 Connection 객체가 생성되어 _in에 저장되고 conn1에 반환된다.
        conn1.count();                                       // (B) conn1의 count() 메소드 호출. _in.count가 1이 된다.

        Connection conn2 = Connection.get();               // (C) get() 메소드 호출. _in은 이미 생성되어 있으므로, 새로운 객체 생성 없이 기존 _in 객체가 conn2에 반환된다. (conn1과 같은 객체를 가리킴)
        conn2.count();                                             // (D) conn2의 count() 메소드 호출. 사실상 _in.count를 또 증가시키는 것. _in.count는 2가 된다.

        Connection conn3 = Connection.get();                             // (E) get() 메소드 호출. 마찬가지로 기존 _in 객체가 conn3에 반환된다. (conn1, conn2와 같은 객체를 가리킴)
        conn3.count();                                                 // (F) conn3의 count() 메소드 호출. _in.count는 3이 된다.

        System.out.print(conn1.getCount());                        // (G) conn1의 getCount() 메소드 호출. conn1은 _in 객체를 가리키므로, _in의 현재 count 값인 3을 반환한다.
    }
}


✅ 정답        
3

최종 결과
모든 conn1, conn2, conn3 변수는 결국 **하나의 동일한 Connection 객체(_in)**를 참조한다.
따라서 count() 메소드를 세 번 호출했으므로, 그 객체의 count 값은 최종적으로 3이 돰


