## ✅ 문제 1

AAA, Triple-A라고 읽는 이 용어는 보안의 세 가지 요소를 합쳐 축약한 것이다.  
다음 (1)~(3)에 해당하는 용어를 <보기>에서 찾아 쓰시오.

---

### 🔹 <보기>

- authentication  
- application  
- accounting  
- ascii  
- avalanche  
- authorization

---

### 🔹 설명

(1): 보안 기능에서, 사람이나 프로세스의 **신분을 확인**하는 것  
(2): 검증된 사용자에게 어떤 수준의 **권한과 서비스를 허용**하는 것  
(3): 사용자의 자원에 대한 **사용 정보를 수집**하여 과금, 감사, 용량 증설 리포팅 등을 실시하는 것

---

### ✅ 정답

- (1): **Authentication** (인증)  
- (2): **Authorization** (인가)  
- (3): **Accounting** (계정관리)

---

### 📌 해설

**AAA (Authentication, Authorization, Accounting)** 는 보안 체계에서 사용자 식별, 권한 부여, 사용 이력을 기록하는 핵심 개념을 의미합니다.

| 항목 | 용어 (영문)    | 의미 설명 |
|------|----------------|------------|
| (1)  | Authentication | 사용자가 누구인지 신원을 검증하는 절차 (ex. ID/PW 로그인) |
| (2)  | Authorization  | 인증된 사용자에게 특정 자원 또는 서비스 접근 권한을 부여하는 절차 |
| (3)  | Accounting     | 사용자의 활동 내역(로그인 시간, 사용량 등)을 기록하고 추적하는 절차 |

---

### 📎 관련 적용 분야

- VPN 접속 제어
- RADIUS / TACACS+ 서버
- 무선 네트워크 인증
- 기업 네트워크 접근 관리


---------------------------------------------------------------------------------------------
## ✅ 문제 2

데이터 제어어 (DCL)의 하나인 **GRANT**의 기능에 대해 간략히 서술하시오.

---

### ✅ 답

사용자에게 접속 권한, 생성 권한 등을 부여하는 명령어

---

### 📌 해설

**GRANT**는 DCL(**Data Control Language**, 데이터 제어어)에 속하는 SQL 명령어로,  
**특정 사용자 또는 역할(role)**에게 **데이터베이스 객체에 대한 권한을 부여**할 때 사용된다.

#### 🔹 주요 특징
- 데이터베이스 접근 및 조작에 필요한 권한을 사용자에게 할당
- 보안 및 접근 제어를 위한 중요한 기능
- 권한은 REVOKE 명령어로 다시 회수할 수 있음

---

### 📚 부여할 수 있는 대표적인 권한 종류

| 권한        | 설명                                  |
|-------------|---------------------------------------|
| SELECT      | 테이블 데이터를 조회할 수 있는 권한       |
| INSERT      | 테이블에 데이터를 삽입할 수 있는 권한     |
| UPDATE      | 테이블의 데이터를 수정할 수 있는 권한     |
| DELETE      | 테이블에서 데이터를 삭제할 수 있는 권한   |
| EXECUTE     | 저장 프로시저나 함수 등을 실행할 수 있는 권한 |
| ALL         | 위의 모든 권한 포함 (전체 권한 부여)     |

---

### ✅ 예시

```sql
-- EMPLOYEE 테이블에 대한 SELECT 권한을 MARY와 JOHN에게 부여
GRANT SELECT ON EMPLOYEE TO MARY, JOHN;

-- EMPLOYEE 테이블에 대한 SELECT 권한을 JOHN에게서 회수
REVOKE SELECT ON EMPLOYEE FROM JOHN;
🧠 함께 알아두면 좋은 명령어
명령어	설명
GRANT	권한을 부여하는 명령어
REVOKE	부여한 권한을 회수하는 명령어

---------------------------------------------------------------------------------------------

### 문제 3) 다음에 설명하는 보안 위협에서 괄호에 들어갈 알맞은 답을 쓰시오

() 스푸핑은 MAC 주소를 속여 LAN에서 통신 흐름을 왜곡시키는 공격이다.  
공격 대상 컴퓨터와 서버 사이의 트래픽을 공격자의 컴퓨터로 우회시켜  
패스워드 정보 등 원하는 정보를 획득할 수 있다.

---

### 답  
**ARP**  
(주소 결정 프로토콜: Address Resolution Protocol)

---

### 📌 해설 (Explanation)

#### 🔹 ARP 스푸핑 (ARP Spoofing)
- **정의**: 공격자가 위조된 ARP 메시지를 네트워크에 보내어,  
  대상 컴퓨터의 ARP 캐시 테이블을 조작하는 공격 방식.
- **동작 원리**: 공격자가 자신의 MAC 주소를 서버나 게이트웨이의 주소인 것처럼 속여서  
  대상의 패킷이 공격자에게 먼저 전달되도록 유도함.
- **결과**: 사용자가 모르게 공격자를 통해 트래픽이 흐르면서 민감한 정보(패스워드, 계좌 등)를 가로챌 수 있음.
- **방어 방법**: 
  - 정적 ARP 테이블 설정
  - ARP 감시 시스템(ARP Inspection)
  - 스위치 보안 기능(MAC 바인딩 등)

---

### 🔸 유사 스푸핑 공격과 비교

| 스푸핑 유형       | 설명 |
|------------------|------|
| **IP 스푸핑** (IP Spoofing) | IP 주소를 위조해 자신을 신뢰된 호스트로 가장하는 공격. DOS 공격 등에 사용됨 |
| **DNS 스푸핑** (DNS Spoofing) | DNS 응답을 조작해 사용자가 의도하지 않은(가짜) 사이트로 접속하게 만드는 공격 |
| **MAC 스푸핑** (MAC Spoofing) | MAC 주소를 위조해 인증 우회를 시도하거나 접근 제어를 무력화시키는 공격 |

---

### 🧠 참고 용어 정리
- **LAN** (Local Area Network): 근거리 통신망
- **MAC 주소** (Media Access Control address): 네트워크 인터페이스에 부여된 고유 식별자
- **ARP**: IP 주소에 대응하는 MAC 주소를 찾기 위한 프로토콜


---------------------------------------------------------------------------------------------

### 문제 4) 결합도의 종류 중, 어떤 모듈이 다른 모듈을 호출할 때,  
단순히 값만 전달되는 형태가 아닌 제어 신호를 전달할 때 생기는 결합도를 영문으로 쓰시오

---

### 답  
**CONTROL COUPLING**  
(제어 결합도)

---

### 결합도 종류 (Coupling Types)

| 종류 (Type)       | 설명 (Description)                              |
|------------------|----------------------------------------------|
| 자료 결합도 (Data Coupling)      | 값 전달 (Passing data only)                      |
| 스탬프 결합도 (Stamp Coupling)  | 배열 등 복합 자료 전달 (Passing composite data like arrays) |
| 제어 결합도 (Control Coupling)  | 제어 요소(제어 신호) 전달 (Passing control signals)         |
| 외부 결합도 (External Coupling) | 다른 모듈의 변수를 사용 (Using variables from other modules) |
| 공통 결합도 (Common Coupling)   | 전역 변수 사용 (Using global variables)                    |
| 내용 결합도 (Content Coupling)  | 다른 모듈의 기능을 직접 이용 (One module directly using another module's functionality) |

---

### 응집도 종류 (Cohesion Types)

| 종류 (Type)              | 설명 (Description)                               |
|-------------------------|------------------------------------------------|
| 기능적 응집도 (Functional Cohesion)   | 단일한 목적 수행 (Performs a single well-defined task)  |
| 순차적 응집도 (Sequential Cohesion)   | 출력값을 다음 입력값으로 사용 (Output of one part is input to another) |
| 통신적 응집도 (Communicational Cohesion) | 동일한 입력과 출력을 사용 (Parts operate on same data)       |
| 절차적 응집도 (Procedural Cohesion)    | 순차적 수행 (Parts follow a specific sequence)               |
| 시간적 응집도 (Temporal Cohesion)      | 같은 시간에 수행되는 기능 (Tasks executed at the same time)   |
| 논리적 응집도 (Logical Cohesion)       | 유사한 성격의 기능들이 묶여 있음 (Related functions grouped together) |
| 우연적 응집도 (Coincidental Cohesion) | 연관관계 없는 기능이 묶여 있음 (Functions with no meaningful relationship) |

---

### 📌 보충 설명 (Additional Explanation)  
- 제어 결합도(Control Coupling)란, 한 모듈이 다른 모듈에 단순 데이터뿐 아니라 제어 정보(예: 플래그, 상태 등)를 전달하는 결합 형태를 말한다.  
- 낮은 결합도는 시스템 유지보수성, 재사용성을 높이고, 모듈 간 독립성을 보장하는 중요한 설계 원칙이다.  
- 따라서 제어 결합도를 최소화하는 것이 이상적이다.

---------------------------------------------------------------------------------------------

### 문제 5) 디자인 패턴에 관한 설명에서 알맞은 답을 <보기>에서 고르시오

<보기>  
ABSTRACT FACTORY, FACTORYMETHOD, PROTOTYPE, BUILDER, OBSERVER  
FACADE, COMPOSITE, TEMPLATE METHOD, SINGLETON

---

- 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴  
- 객체 생성 코드를 별도의 클래스/메서드로 분리함으로써 객체 생성의 변화에 대비하는데 유용하다.  
- 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식  
- VIRTUAL - CONSTRUCTOR 패턴이라고 함  

---

### 답  
**FACTORYMETHOD**

---

### 📌 보충 설명  
- 팩토리 메서드 패턴(Factory Method Pattern)은 객체 생성 과정을 서브클래스에 위임하여, 생성할 객체의 클래스를 결정하는 책임을 분리한다.  
- 이로 인해 클라이언트 코드는 구체적인 클래스의 인스턴스를 생성하지 않고, 인터페이스를 통해 객체를 생성할 수 있어 유연성과 확장성이 증가한다.  
- 'VIRTUAL CONSTRUCTOR'라고도 불리며, 객체 생성 로직을 캡슐화하여 변경에 유리하다.  
- **추상 팩토리(Abstract Factory)**는 관련된 여러 객체를 함께 생성하는 데 집중하는 패턴으로, 팩토리 메서드와 개념이 다름에 주의.



---------------------------------------------------------------------------------------------
### 문제 6) 다음 파일 구조에 대한 설명이다. 빈칸에 알맞은 답을 작성하시오.

- 파일의 구조는 파일을 구성하는 레코드들이 보조기억장치에 편성하는 방식을 의미하는 것으로  
  편성방법에 따라 순차, () 랜덤, 해싱 등이 있다.  
- () 은 순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키 값 순으로  
  정렬하여 기록하여 데이터에 접근한다. 자기디스크에서 주로 사용된다.

---

### 답  
**색인**

---

### 파일의 구조

- **순차 파일**  
  레코드를 논리적인 처리 순서에 따라 연속된 물리적 공간에 기록하는 방식

- **직접 파일**  
  파일을 구성하는 레코드를 임의의 물리적 저장공간에 기록하는 방식

- **색인 순차 파일**  
  순차 파일과 직접 파일의 편성 방법을 결합한 형태로,  
  순차 처리와 랜덤 처리가 모두 가능함

---

### 📌 보충 설명  
- **순차 파일**은 주로 대량의 데이터를 한꺼번에 처리하는 데 적합하며, 읽기와 쓰기가 순차적으로 이루어진다.  
- **직접 파일(랜덤 파일)**은 특정 레코드에 빠르게 접근할 수 있어 온라인 처리에 적합하다.  
- **색인 순차 파일**은 색인(index)을 이용해 레코드의 위치를 빠르게 찾을 수 있고, 색인 덕분에 순차 및 직접 접근이 모두 가능하여 효율성이 높다.
- 자기디스크(하드디스크)에서 주로 사용되며, 데이터베이스 시스템에서 많이 활용됨.


---------------------------------------------------------------------------------------------

### 문제 7) 다음은 소프트웨어 테스트에 관한 설명이다. (1), (2)에 들어갈 알맞은 답을 쓰시오

- (1)는 소프트웨어의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트 하는 기법이다.  
- 상위 모듈의 역할을 하는 (2)가 필요하다  
- (2)는 하위 모듈을 순서에 맞게 호출하고, 호출할 때 필요한 매개변수를 제공하며,  
  반환값을 전달하는 역할을 한다.

---

### 답  
(1) 상향식 테스트  
(2) 테스트 드라이버

---

### 📌 보충 설명  
- **상향식 테스트 (Bottom-Up Testing)**  
  하위 모듈부터 테스트를 시작하여 점차 상위 모듈과 통합해 나가는 방식이다.  
  각 하위 모듈이 제대로 동작하는지를 먼저 확인하고, 상위 모듈과의 통합을 진행한다.

- **테스트 드라이버 (Test Driver)**  
  상위 모듈이 아직 개발되지 않았거나 준비되지 않은 경우, 테스트 목적으로 상위 모듈을 흉내 내는 프로그램이나 코드이다.  
  하위 모듈을 호출하고 테스트하는 역할을 하며, 테스트 시나리오에 필요한 매개변수를 전달하고 반환값을 받는다.

- **테스트 단계 흐름**  
  요구사항 분석 → 기능 명세 분석 → 설계 → 개발 →  
  단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트

- **통합 테스트 방법**  
  - 상향식 테스트  
  - 하향식 테스트  
  - 빅뱅 테스트  
  - 샌드위치 테스트

상향식 테스트는 단위 모듈이 먼저 완성되어야 하며, 테스트 드라이버를 통해 상위 모듈 역할을 대신해 통합 테스트를 진행할 수 있다.



---------------------------------------------------------------------------------------------

## ✅ 문제 8

WINDOWS 나 MAC OS 등에서 사용하는 인터페이스로,  
사용자가 명령을 직접 입력하지 않고, **아이콘 등을 클릭하여 작업을 수행**하는  
사용자 인터페이스를 **영문 약어로 작성**하시오.

---

### ✅ 정답  
**GUI**

---

### 📌 해설

| 용어 | 원어 | 설명 |
|------|------|------|
| GUI | **Graphical User Interface** | 그래픽을 기반으로 사용자가 마우스나 터치 등을 이용하여 명령을 수행할 수 있는 사용자 인터페이스 방식입니다. |

---

### 📎 추가 정보

- CLI (Command Line Interface): 사용자가 텍스트 명령어를 직접 입력하여 조작하는 방식  
  예: DOS, Linux 터미널 등  
- GUI는 CLI보다 사용이 직관적이고 학습 곡선이 낮아 **일반 사용자에게 적합**합니다.
- 대표적인 GUI 환경:  
  - **Windows** 운영체제  
  - **macOS**  
  - **Android**, **iOS**


---------------------------------------------------------------------------------------------
## ✅ 문제 9

다음 UML에 관한 설명에서 괄호에 들어갈 알맞은 답을 쓰시오.

---

### 🔹 문제 설명

- **( )는 자기만의 속성과 일정한 행동으로 구성되어 있다.**  
- 서로 연관이나 상속, 의존 관계 등으로 서로 간의 상호작용을 표현한다.  
- 대표적인 **구조 다이어그램**이다.

---

### ✅ 정답  
**클래스 다이어그램**

---

### 📌 해설

**클래스 다이어그램 (Class Diagram)** 은 UML에서 가장 기본적이고 중요한 **구조적 다이어그램**으로,  
시스템을 구성하는 클래스들의 **속성(필드)**과 **행위(메서드)**, 그리고 **클래스 간의 관계(연관, 상속, 의존 등)**를 시각화합니다.

| 요소 | 설명 |
|------|------|
| 클래스 | 속성과 메서드를 가진 객체 유형 |
| 연관 관계 | 클래스 간의 연결 (Association) |
| 상속 관계 | 상위 클래스의 속성과 메서드를 하위 클래스가 상속 (Generalization) |
| 의존 관계 | 한 클래스가 다른 클래스에 의존하여 동작 (Dependency) |

---

### 📎 UML 다이어그램 분류

#### 🏗 구조적 다이어그램
| 다이어그램 | 설명 |
|------------|------|
| **클래스 다이어그램** | 클래스와 클래스 간의 관계 표현 |
| 패키지 다이어그램 | 시스템의 패키지 간 구조 |
| 복합체 구조 다이어그램 | 복합 객체 내부 구조 |
| 객체 다이어그램 | 특정 시점 객체 간 관계 |
| 컴포넌트 다이어그램 | 시스템 구성 요소 간 관계 |
| 배치 다이어그램 | 물리적 장비 및 구성요소 배치 |

#### 🎭 행위적 다이어그램
| 다이어그램 | 설명 |
|------------|------|
| 유스케이스 다이어그램 | 사용자와 시스템의 상호작용 |
| 순차 다이어그램 | 시간 순서에 따른 메시지 흐름 |
| 커뮤니케이션 다이어그램 | 객체 간 통신 관계 |
| 상태 다이어그램 | 상태 변화 표현 |
| 활동 다이어그램 | 흐름도 형식으로 프로세스 표현 |
| 상호작용 개요 다이어그램 | 상호작용 전체 워크플로우 |
| 타이밍 다이어그램 | 시간에 따른 객체 상태 변화 |

---

### 📌 UML의 특징

- **가시화 언어**: 시스템을 시각적으로 표현
- **명세화 언어**: 요구사항과 동작을 명세
- **구축 언어**: 소프트웨어 구축을 지원
- **문서화 언어**: 시스템의 구조와 행위를 문서화
---------------------------------------------------------------------------------------------

## ✅ 문제 10

블록 암호의 일종으로 IBM에서 개발하고, 미국 NBS(현재 NIST)에서  
국가 표준으로 정한 암호화 알고리즘이나 취약점이 발견되어 현재는 잘 사용되지 않는다.  
블록 크기는 64비트, 키 길이는 56비트이며, 16라운드를 수행한다.  
**페이스텔 구조**를 사용하는 암호화 알고리즘은 무엇인지 쓰시오.

---

### ✅ 정답  
**DES** (Data Encryption Standard)

---

### 📌 해설

**DES**는 IBM에서 개발하고 1977년 미국 NBS(NIST 전신)에서 공식 표준으로 채택된  
**대칭키 블록 암호 알고리즘**입니다.

| 항목            | 설명 |
|-----------------|------|
| **암호 방식**   | 대칭키 블록 암호 |
| **구조**        | 페이스텔(Feistel) 구조 |
| **블록 크기**   | 64비트 |
| **키 길이**     | 56비트 (실제는 64비트 중 8비트는 패리티) |
| **라운드 수**   | 16라운드 |
| **취약점**      | 키 길이가 짧아 현재는 보안성이 낮음 |
| **현황**        | 3DES, AES 등의 알고리즘으로 대체됨 |

---

### 🔐 암호 알고리즘 분류

#### 📦 블록 암호 알고리즘

| 알고리즘 | 설명 |
|----------|------|
| **DES**        | 초기 표준 암호, 현재는 취약 |
| **3-DES**      | DES를 3번 반복 (더 강한 보안) |
| **AES**        | 현재 가장 널리 사용되는 표준 |
| **SEED**       | 한국에서 개발 |
| **ARIA**       | 한국 국가표준 |
| **LEA**        | 경량 암호화에 적합 |
| **IDEA**       | 스위스에서 개발 |
| **SKIPJACK**   | 미국 NSA가 설계 |

#### 🔄 스트림 암호 알고리즘

| 알고리즘 | 설명 |
|----------|------|
| **LFSR** | 선형 피드백 시프트 레지스터 |
| **RC4**  | SSL/TLS에서 사용, 현재는 사용 줄어듦 |
| **A5**   | GSM 통신에서 사용 |

#### 🔑 공개키 암호 알고리즘

| 기반 수학 | 알고리즘 |
|-----------|----------|
| **소인수분해** | RSA, Rabin |
| **이산대수 문제** | Diffie-Hellman, DSA, ElGamal |
| **타원곡선 문제** | ECC (Elliptic Curve Cryptography) |

#### 🔁 단방향 암호 알고리즘 (해시 함수)

| 알고리즘 | 설명 |
|----------|------|
| **MD5**   | 빠르지만 충돌 취약점 발견됨 |
| **SHA**   | NIST에서 개발한 표준 해시 함수 |
| **HAS-160** | 한국에서 개발, KCDSA에 사용됨 |

---

### 📌 암호 방식 분류 요약

| 방식         | 종류      | 대표 알고리즘 |
|--------------|-----------|----------------|
| 대칭키 (비밀키) | 스트림    | RC4, LFSR       |
|               | 블록     | DES, AES, SEED |
| 비대칭키 (공개키) | 인수분해 | RSA, Rabin      |
|               | 이산대수 | ElGamal, DSA    |
|               | 타원곡선 | ECC             |



---------------------------------------------------------------------------------------------

## ✅ 문제 11

다음은 테스트 케이스의 구성 요소에 대한 설명이다.  
괄호 ( ) 안에 들어갈 알맞은 답을 쓰시오.

---

### 🔹 테스트 케이스 예시

| 식별자_ID   | 테스트 항목 | (1)            | (2)                          | (3)          |
|-------------|--------------|----------------|-------------------------------|--------------|
| LS_001_1    | 로그인       | 로그인 화면     | 아이디(test), 패스워드(qwe123) | 로그인 성공   |
| LS_001_2    | 회원가입     | 로그인 화면     | 아이디(test), 패스워드(qwe321) | 로그인 실패   |

---

### ✅ 정답

- (1): **테스트 조건**  
- (2): **테스트 데이터**  
- (3): **예상 결과**

---

### 📌 해설: 테스트 케이스 구성 요소

| 구성 요소        | 설명 |
|------------------|------|
| **테스트 조건**   | 테스트를 수행하기 위한 전제 조건 또는 환경 |
| **테스트 데이터** | 실제 테스트에 사용될 입력 값 |
| **예상 결과**     | 테스트 수행 후 기대되는 출력이나 동작 결과 |

테스트 케이스(Test Case)는 소프트웨어 테스트에서 **입력 값, 실행 조건, 예상 결과** 등을 정의하여  
해당 기능이 요구사항을 만족하는지를 검증하는 데 사용됩니다.

---

### 📌 추가 예시

- 테스트 케이스 ID: TC_LOGIN_01
- 테스트 항목: 로그인 기능
- 테스트 조건: 로그인 화면에 접속함
- 테스트 데이터: ID = user01 / PW = pass123
- 예상 결과: 로그인 성공 후 메인 페이지로 이동

---------------------------------------------------------------------------------------------
문제 12) UML 관계에 대한 설명이다 다음 (1), (2)에 들어갈 알맞은 용어를 쓰시오

(1): 클래스들 사이의 전체 또는 부분 같은 관계
(2): 한 클래스가 다른 클래스를 포함하는 상위개념일때의 IS- A 관계

답: 1) aggregation
   2) generalization


uml 관계
일반화 관계 : 상속 관계
연관 관계 : 관련된 관계
의존 관계: 짧은 시간만 사용하는 관계
실체화 관계: 추상 메서드를 오버라이딩
집합관계 - 집약관계 : 부분 객체는 독립적
집합관계 - 합성관계: 부분 객체는 의존적
---------------------------------------------------------------------------------------------
### 문제 13) OSI 7 계층에 대한 설명에서 (1)~(3)에 들어갈 알맞은 계층을 쓰시오

(1) "포인트 투 포인트의 신뢰성 있는 데이터 전송을 보장하며, 물리 계층의 오류를 감지하고 수정한다."

(2) 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능

(3) 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고 암호화한다.

---

### ✅ 정답

(1) 데이터 링크 계층
(2) 네트워크 계층
(3) 표현 계층


---

### 🔍 OSI 7 계층 참조 모델

| 계층          | 역할 및 프로토콜 예시                  |
|---------------|------------------------------------|
| 응용 계층     | POP, SMTP, Telnet, DHCP, FTP, SNMP, HTTP, DNS |
| 표현 계층     | 데이터 표현, 암호화                  |
| 세션 계층     | 세션 관리                          |
| 전송 계층     | TCP, UDP                         |
| 네트워크 계층 | IP, ICMP                         |
| 데이터 링크 계층 | ARP, RARP                        |
| 물리 계층     | 전기적 신호, 케이블, 허브 등             |

---

### 📌 요약

- 데이터 링크 계층: 신뢰성 있는 데이터 전송, 오류 검출 및 수정 담당  
- 네트워크 계층: 최적의 경로를 통해 데이터 전달 담당  
- 표현 계층: 데이터 표현 형식 변환과 암호화 담당  

---------------------------------------------------------------------------------------------
### 문제 14) 테스트 기법 중 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석하여 효용성 높은 검사 사례를 선정하여 검사하는 기법을 아래에서 찾아 쓰시오

- Equivalence partitioning  
- Boundary value analysis  
- Cause-effect graphing  
- Fault based  
- Base path test  
- Loop test  
- Comparison testing  

---

### ✅ 정답

cause-effect graphing


---

### 🔍 해설

- **블랙박스 테스트 기법**

  - **동등분할 기법 (Equivalence partitioning)**  
    입력 자료에 초점을 맞춰 테스트 케이스를 만들어 검사하는 방법

  - **경계값 분석 (Boundary value analysis)**  
    입력조건의 경계값을 테스트 케이스로 선정하는 방법

  - **원인-효과 그래프 검사 (Cause-effect graphing)**  
    입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음  
    효용성이 높은 테스트 케이스를 선정하여 검사하는 기법

- **오류 예측 검사 (Fault based)**  
  과거 경험이나 테스터의 감각으로 테스트하는 기법

- **비교 검사 (Comparison testing)**  
  여러 버전의 프로그램에 동일한 테스트 자료를 제공하여  
  동일한 결과가 출력되는지 테스트하는 기법

---------------------------------------------------------------------------------------------

### 문제 15) t1 테이블과 t2 테이블을 참고하여 SQL 실행 결과를 쓰시오

| t1  |       | t2  |    |
|------|-------|-----|----|
| NAME |       | RULE |    |
| ALLEN |       | S%  |    |
| SCOTT |       | %T% |    |
| SMITH |       |     |    |

```sql
SELECT COUNT(*) AS CNT
FROM A CROSS JOIN B
WHERE A.NAME LIKE B.NAME;

✅ 정답
4

🔍 해설
CROSS JOIN은 두 테이블의 모든 조합을 만듦 (3행 × 3행 = 9행)

WHERE A.NAME LIKE B.NAME 조건은 A.NAME이 B.NAME 패턴과 일치하는 경우만 필터링

각 조합을 살펴보면:

A.NAME	B.RULE	A.NAME LIKE B.RULE?
ALLEN	S%	NO
ALLEN	%T%	NO
ALLEN	(NULL)	NULL (False)
SCOTT	S%	NO
SCOTT	%T%	YES (SCOTT 안에 T 있음)
SCOTT	(NULL)	NULL (False)
SMITH	S%	YES (SMITH는 S로 시작)
SMITH	%T%	YES (SMITH 안에 T 있음)
SMITH	(NULL)	NULL (False)

LIKE 조건에 만족하는 행은 총 4개입니다.

---------------------------------------------------------------------------------------------

### 문제 16) 다음 Python 프로그램을 분석하여 실행 결과를 쓰시오

```python
x, y = 100, 200
print(x == y)

✅ 정답

False

🔍 해설
x = 100, y = 200 으로 변수에 각각 정수를 할당함.

x == y 는 두 값이 같은지를 비교하는 연산.

100 == 200 → False

📌 참고
== : 값(value) 이 같은지 비교하는 연산자

is : 객체(object) 가 같은지를 비교하는 연산자


a = [1, 2]
b = [1, 2]

print(a == b)   # True (값이 같음)
print(a is b)   # False (다른 객체)
---------------------------------------------------------------------------------------------
### 문제 17) 다음 C언어 프로그램을 분석하여 실행 결과를 쓰시오

struct jsu {
    char name[12];
    int os, db, hab, hhab;
};

int main() {
    struct jsu st[3] = {
        {"데이터1", 95, 88},   // st[0]
        {"데이터2", 84, 91},   // st[1]
        {"데이터3", 86, 75}    // st[2]
    };

    struct jsu *p;
    p = &st[0];

    (p+1)->hab = (p+1)->os + (p+2)->db;
    (p+1)->hhab = (p+1)->hab + p->os + p->db;

    prinf("%d\n", (p+1)->hab + (p+1)->hhab);
}

✅ 정답

501

🔍 해설

struct jsu st[3] = {
    {"데이터1", 95, 88},  // st[0]
    {"데이터2", 84, 91},  // st[1]
    {"데이터3", 86, 75}   // st[2]
};
초기값은 다음과 같음:

index	name	os	db	hab	hhab
st[0]	데이터1	95	88	?	?
st[1]	데이터2	84	91	?	?
st[2]	데이터3	86	75	?	?

➤ 연산 1
(p+1)->hab = (p+1)->os + (p+2)->db;
(p+1)->os = st[1].os = 84

(p+2)->db = st[2].db = 75

→ st[1].hab = 84 + 75 = 159


➤ 연산 2
(p+1)->hhab = (p+1)->hab + p->os + p->db;
(p+1)->hab = 159

p->os = st[0].os = 95

p->db = st[0].db = 88

→ st[1].hhab = 159 + 95 + 88 = 342

➤ 출력

printf("%d\n", (p+1)->hab + (p+1)->hhab);
→ 159 + 342 = 501


📌 요약
항목	값
st[1].hab	159
st[1].hhab	342
최종 출력	501

---------------------------------------------------------------------------------------------
✅ 문제 18) C언어 코드 분석

void main(){
    int *arr[3];
    int a = 12, b = 24, c = 36;
    arr[0] = &a;
    arr[1] = &b;
    arr[2] = &c;
    printf("%d\n", *arr[1] + **arr + 1);
}

🔍 주요 포인트
💡 선언 정리
변수	의미
int *arr[3];	포인터 배열, 즉 포인터 3개를 저장할 수 있는 배열
arr[0] = &a;	arr[0]은 a의 주소
arr[1] = &b;	arr[1]은 b의 주소
arr[2] = &c;	arr[2]은 c의 주소

즉, arr은 다음과 같은 상태가 됨:

인덱스	값 (arr[i])	실제 값 (*arr[i])
arr[0]	&a	12
arr[1]	&b	24
arr[2]	&c	36

🔢 핵심 표현 분석
*arr[1] + **arr + 1
이걸 하나씩 분석해 보면:

*arr[1] → arr[1]은 &b → *arr[1] = b = 24

**arr

arr은 포인터 배열 → arr[0]은 &a

*arr는 arr[0] → *arr = &a

**arr = *(*arr) = *(&a) = a = 12

**arr + 1 → 12 + 1 = 13

✅ 최종 계산

*arr[1] + **arr + 1
= 24 + 12 + 1
= 37

🎯 정답
37

📌 요약
arr은 포인터 배열이며 각각 &a, &b, &c를 저장

*arr[1] → b = 24

**arr → a = 12

+1 포함하면 → 24 + 12 + 1 = 37

---------------------------------------------------------------------------------------------
## ✅ 문제 19

다음 Java 언어 프로그램을 분석하여 실행 결과를 쓰시오.
public class Main {
    public static void main(String[] args) {
        int a = 3, b = 4, c = 3, d = 5;

        if ((a == 2 | a == c) & !(c > d) & (1 == b ^ c != d)) {
            a = b + c; // a = 7
            if (7 == b ^ c != a) {
                System.out.println(a);
            } else {
                System.out.println(b);
            }
        } else {
            a = c + d;
            if (7 == c ^ d != a) {
                System.out.println(a);
            } else {
                System.out.println(d);
            }
        }
    }
}

✅ 우선 연산자 우선순위 점검
Java의 연산자 우선순위에서:

==, != → 비교 연산자

^ → 비트 XOR 연산자

^는 ==보다 우선순위가 낮다.

즉,


1 == b ^ c != d
는 다음과 같이 해석됩니다:


((1 == b) ^ (c != d))
즉 괄호가 없다면, 1 == b 를 먼저 비교한 뒤, 결과값과 c != d 를 XOR 연산합니다.

🔢 조건 분석 시작
초기값:

a = 3, b = 4, c = 3, d = 5

✅ 첫 번째 if

if ((a == 2 | a == c) & !(c > d) & ((1 == b) ^ (c != d)))
(a == 2 | a == c)
→ 3 == 2 | 3 == 3 → false | true → true

!(c > d)
→ !(3 > 5) → !(false) → true

(1 == b) ^ (c != d)
→ 1 == 4 → false
→ c != d → 3 != 5 → true
→ false ^ true → true

➡ 전체 조건: true & true & true → true

✅ if 블록 진입
a = b + c; // a = 4 + 3 = 7
다음 조건:


if (7 == b ^ c != a)
→ 연산자 우선순위에 따라 해석:


(7 == b) ^ (c != a)
7 == b → 7 == 4 → false

c != a → 3 != 7 → true

false ^ true → true

➡ 참이므로 System.out.println(a); → 7 출력

✅ 정답
7

---------------------------------------------------------------------------------------------
## ✅ 문제 20

다음 Java 언어 프로그램을 분석하여 실행 결과를 쓰시오.

### 🔸 원문 코드 (오타 포함)
class Connection {
    private static Connection _in = null;  // static 싱글톤 인스턴스
    private int count = 0;

    static public Connection get() {
        if (_in == null) {
            _in = new Connection();
        }
        return _in;
    }

    public void count() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class testcon {
    public static void main(String[] args) {
        Connection conn1 = Connection.get();
        conn1.count();  // count = 1

        Connection conn2 = Connection.get();
        conn2.count();  // count = 2

        Connection conn3 = Connection.get();
        conn3.count();  // count = 3

        System.out.print(conn1.getCount()); // 출력: 3
    }
}
✅ 정답
복사
편집
3


