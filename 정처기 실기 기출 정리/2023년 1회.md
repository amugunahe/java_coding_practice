## ✅ 정보처리기사 실기 – 웹 기반 기술 용어 정리

### 문제 1) 다음 괄호 안에 들어갈 용어를 영문 약어로 쓰시오

**문제**  
`()은 웹페이지를 새로 고치지 않고 서버로부터 데이터를 비동기적으로 가져오는 기술이다.`  
Javascript를 이용하여 비동기적으로 서버에 데이터를 요청하고 응답을 처리하는 기술이다.  
Javascript를 이용하여 서버로부터 XML 또는 JSON 형식의 데이터를 비동기적으로 받아오는 프로그래밍 기법이다.

**답:** `AJAX`

---
## 📌 관련 개념 정리 — 존나 직관적이고 쉬운 설명 + 갓반인 예시

---

### 🔹 REST (Representational State Transfer)

> **쉽게 말해서:**  
> URL로 자원을 딱딱 지정해서, HTTP 메서드(GET, POST, PUT, DELETE)로 조작하는 방식이야.  
> "자원" = 데이터 조각이라고 생각하면 됨.  

- **무상태 (Stateless)**  
  서버가 클라이언트 상태를 기억 안 함.  
  > 🧑‍🎓 예: 갓반인이 게시글 수정 요청을 보낼 때마다 **누구인지 매번 알려줘야 함.** 서버는 너를 기억 못 하니까.

- **캐시 가능 (Cacheable)**  
  자주 쓰는 자원은 캐시에 저장해서 빠르게 처리 가능.  
  > 🧑‍🎓 예: 갓반인이 수강신청 시간표를 여러 번 조회할 때, 이전 결과를 **캐시**해서 속도 향상.

- **계층형 구조**  
  클라이언트는 중간 서버를 거쳐도 **구현 세부사항을 몰라도 됨**.  
  > 🧑‍🎓 예: 갓반인이 본 서버 말고 **프록시 서버**를 거쳐도, 동작엔 영향 없음.

- **인터페이스 일관성**  
  URL+HTTP 조합만 보면 뭐 하는 API인지 **직관적으로 알 수 있음**.  
  > 🧑‍🎓 예:  
  - `GET /students/123` → 학번 123인 학생 조회  
  - `DELETE /students/123` → 삭제  
  - 구조 보자마자 무슨 동작인지 감 오지?

#### 🔸 REST에서 쓰는 전송 데이터 형식

| 형식 | 설명 | 갓반인 예시 |
|------|------|-------------|
| **JSON** | 키-값으로 구성, 가볍고 표준 | `{"name":"갓반인", "major":"컴공"}` |
| **XML** | 태그 기반, 무겁지만 정형화됨 | `<student><name>갓반인</name></student>` |
| **YAML** | 들여쓰기로 구조 표현 | `name: 갓반인\nmajor: 컴공` |
| **CSV** | 쉼표로 구분, 진짜 단순함 | `갓반인,컴공,3학년` |

---

### 🔹 SOAP (Simple Object Access Protocol)

> **쉽게 말해서:**  
> 정해진 형식(XML)으로 요청/응답을 주고받는 **무거운** 웹 서비스 방식이야.  
> REST보다 빡세고, **기업 시스템 간 통신**에 많이 쓰여.

- **XML 기반 통신**  
  SOAP 메시지는 무조건 XML로 구성됨.  
  > 🧑‍🎓 예: 갓반인이 도서관 시스템과 학사시스템을 **연동**하려면 XML 기반 SOAP 메시지를 써야 함.

- **HTTP, SMTP 등 다양한 전송 수단 사용 가능**  
  단순히 웹이 아니어도 됨.

#### 🔸 SOAP 관련 구성요소

| 구성 요소 | 설명 | 갓반인 예시 |
|-----------|------|-------------|
| **SOAP** | XML로 메시지 교환하는 **프로토콜** | `<soap:Envelope>...</soap:Envelope>` 안에 요청 넣음 |
| **WSDL** | 웹 서비스의 설명서 | 갓반인이 "수강신청 서비스" 제공 시, WSDL로 사용법 공개 |
| **UDDI** | 서비스 등록소 | 학내 모든 서비스들 목록화해서, 학우들이 찾아 쓸 수 있게 등록함 |

---

### ✅ 정리 요약

| 구분 | REST | SOAP |
|------|------|------|
| **형식** | JSON, XML 등 다양함 | XML만 가능 |
| **가볍냐?** | ✔️ 매우 가벼움 | ❌ 무거움 |
| **사용 목적** | 웹 API 설계에 최적 | 기업간 통신, 보안 중요 시스템 |
| **배우기 쉬움** | ✔️ 쉬움 | ❌ 복잡 |
| **갓반인 용도** | 자기소개 앱 만들 때 | 학사 시스템 연동할 때 |

---



-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 네트워크 교환 방식 정리

### 문제 2) 다음 괄호 안에 들어갈 용어를 쓰시오

#### (1)
**문제:**  
물리적인 연결 선로가 아니라 **데이터 패킷이 전송될 경로를 미리 설정**하는 방식을 말한다.  
전송을 시작하기 전에 데이터가 송신자에서 수신자까지 이동할 경로를 설정하고,  
그 경로를 통해 데이터 패킷들이 순차적으로 전달된다.  
이 방식은 **데이터의 순서를 보장**하며, **신뢰성이 높은 통신**을 제공하지만,  
전송 경로를 미리 설정하는 과정으로 인해 **초기 세팅에 시간이 필요**하다는 단점이 있다.

**답:** `가상회선 방식`

---

#### (2)
**문제:**  
각각의 패킷이 **독립적으로 경로를 찾아 수신자에게 전달되는 방식**이다.  
이 방식에서는 패킷들이 **서로 다른 경로를 통해 전달**될 수 있으며,  
결과적으로 **도착하는 순서가 달라질 수 있다**.  
이 방식은 **패킷의 독립성** 때문에 **유연성이 높고**,  
**네트워크 혼잡 상태에 대응 가능**하다는 장점이 있다.  
그러나 **패킷의 순서 보장이나 손실 보장**이 없으므로,  
이러한 측면에 대한 별도의 관리가 필요하다.

**답:** `데이터그램 방식`

---

## 📌 관련 개념 정리 — 교환 방식 (존나 쉽고 직관적 + 갓반인 예시)

---

### 🔹 교환 방식 분류

통신을 할 때 **데이터를 어떤 방식으로 전달하냐에 따라** 나뉘는 개념이야.  
각 방식마다 성격이 다르고, 상황에 따라 맞는 방식이 따로 있음.  
갓반인 입장에서 보자면 아래처럼 이해할 수 있어.

---

### ▶ 회선 교환 (Circuit Switching)

> 📞 전화처럼 먼저 **전용 회선 연결부터 한 다음**, 통신하는 방식이야.

- 통신 시작 전에 송신자와 수신자 사이에 **전용 회선(길)**을 설정
- 데이터는 **끊기지 않고 연속적으로 흐름**
- 주로 **전화 통화** 같은 실시간 서비스에 사용

🧑‍🎓 **갓반인 예시:**  
> 너랑 친구가 **전화 연결하고 나서만** 통화 가능한 거랑 똑같아.  
> 통화 중에는 **둘만 연결되어 있어서 끊기지 않고 말할 수 있음.**

- ✅ 장점: 실시간성 짱임 (끊김 X), 대역폭 고정이라 안정적
- ❌ 단점: 통화 안 해도 회선 점유함 (비효율), 연결 시간 오래 걸림

---

### ▶ 축적 교환 (Store and Forward)

> 데이터를 중간 노드에 **잠깐 저장했다가** 다음 노드로 넘기는 방식

#### 🔸 1. 메시지 교환 (Message Switching)

- 전체 메시지를 **한 번에 저장**했다가 다음 노드로 전송
- 단위: 메시지 전체
- 💥 지연 큼 → **받는 쪽은 기다림의 미학**

🧑‍🎓 **갓반인 예시:**  
> 친구한테 레포트 pdf 파일 보내는데,  
> 중간 컴퓨터가 **전부 저장**한 뒤에야 보내줘서 친구는 기다려야 함

- ❌ 단점: 큰 메시지일수록 기다리는 시간도 커짐

---

#### 🔸 2. 패킷 교환 (Packet Switching)

> 데이터를 **작게 나눠서** 보내는 방식. 요즘 인터넷은 전부 이거 씀!

- 메시지를 여러 개의 **패킷으로 나눠서 전송**
- 각각의 패킷은 **독립적으로** 이동 가능

🧑‍🎓 **갓반인 예시:**  
> 갓반인이 유튜브 보는데, 영상이 **조각조각 나눠져서** 전송되고 합쳐지는 구조야

---

##### 📦 데이터그램 방식 (Datagram Switching)

- 패킷 하나하나가 **독립적으로** 전송됨
- 경로가 **패킷마다 달라질 수 있음**
- 순서 보장 X, 유연성 O

🧑‍🎓 **갓반인 예시:**  
> 친구한테 쪽지 5장 보냈는데, **순서 섞여서 도착함**  
> 알아서 잘 조립해야 함

- ✔️ 장점: 빠름, 유연함  
- ❌ 단점: 순서 꼬일 수 있음, 재조립 필요

---

##### 📦 가상회선 방식 (Virtual Circuit Switching)

- **논리적인 경로**를 먼저 설정한 다음 패킷을 보냄
- **모든 패킷이 같은 경로**를 따라가니까 **순서 보장**

🧑‍🎓 **갓반인 예시:**  
> 교수님한테 파일 5개 보내기 전에 **메일 전용 폴더 만들고**,  
> 그 경로로만 하나하나 차례대로 보내는 느낌

- ✔️ 장점: 순서 정확히 도착함  
- ❌ 단점: 경로 설정에 시간 좀 걸림

---

### ✅ 총정리 한방에

| 방식 | 설명 | 갓반인 예시 | 장점 | 단점 |
|------|------|-------------|------|------|
| 회선 교환 | 전용 회선 먼저 연결 | 전화 통화 | 실시간성 | 비효율, 연결 지연 |
| 메시지 교환 | 전체 메시지 저장 후 전달 | 레포트 파일 저장 후 전달 | 전송 신뢰성 | 지연 큼 |
| 패킷-데이터그램 | 패킷별 독립 전송 | 쪽지 각각 보냄 | 유연 | 순서 꼬임 |
| 패킷-가상회선 | 논리 경로 따라 전송 | 메일 폴더에 순차 전송 | 순서 보장 | 경로 설정 시간 |

---



-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 보안 프로토콜 정리

### 문제 3) 다음에서 설명하는 답을 작성하시오

**문제 설명:**  
- VPN 연결을 생성하는 데 사용되는 프로토콜이다.  
- 마이크로소프트의 **PPTP**와 시스코의 **L2F**를 결합해 만들어졌다.  
- 데이터를 **안전하게 터널링**하는 기능을 제공한다.  
- 그러나 **자체적으로 암호화를 제공하지 않으며**,  
  일반적으로 **IPsec과 함께 사용**되어 데이터의 암호화를 보장하고,  
  **보안성이 향상된 VPN 연결**을 제공한다.

**답:** `L2TP` (Layer 2 Tunneling Protocol)

---

## 📌 보안 관련 프로토콜 정리 (존나 쉽고 직관적 + 갓반인 예시 포함)

---

### 🔹 보안 관련 주요 프로토콜

웹이나 네트워크에서 **데이터를 안전하게 주고받기 위해** 사용하는 기술들이야.  
갓반인처럼 **딱 쓸 만큼만** 쉽고 빠르게 정리해줄게.

| 프로토콜 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **SSL / TLS** | 웹 브라우저와 서버 간 **암호화된 연결 제공**<br>HTTPS(주소창 자물쇠 아이콘 있는 거) | 너가 네이버 로그인할 때 **아이디/비번**이 **암호화되어 전달**되는 거 |
| **IPsec** | IP 계층에서 데이터를 **암호화 + 인증**해서 안전하게 전송 | 회사에서 VPN 쓸 때 외부에서 내부망 접속하는데 **정보 유출 안 되게 보호**함 |

- **AH (Authentication Header)**  
  → 무결성 + 인증 O, 암호화는 X  
  👉 **데이터가 바뀌지 않았는지** + **보낸 사람이 맞는지**만 확인함  
  🧑‍🎓 갓반인 예시: 친구가 보낸 쪽지 내용은 누구 건지 알 수 있고 안 바뀐 건 아는데, **남이 훔쳐보면 내용은 다 보임**

- **ESP (Encapsulating Security Payload)**  
  → 무결성 + 인증 + 암호화 전부 O  
  👉 AH 기능에 **암호화까지 포함**된 완전체  
  🧑‍🎓 갓반인 예시: 쪽지도 보내고 **내용 봉투에 싸서** 보냄.  
  **누가 보냈고, 안 바뀌었고, 못 염탐당함**

---

| 프로토콜 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **SSH** | 원격 컴퓨터에 **암호화된 접속**으로 **명령어 실행 가능** | 리눅스 서버를 원격에서 터미널로 안전하게 조작 |
| **PGP** | 이메일 내용 **암호화 + 디지털 서명** 기능 제공 | 친구한테 메일 보낼 때 **비번 잠긴 문서**처럼 전송함 |
| **Kerberos** | 클라이언트와 서버가 서로 **인증**하는 보안 프로토콜 | 로그인 한 번 하면 회사 내부 시스템 **다 인증됨 (SSO 느낌)** |
| **S/MIME** | 이메일 **암호화 + 전자서명** 표준 | 회사에서 메일 보낼 때 서명 + 내용 암호화까지 완료해서 보냄 |

---

### 🔹 L2TP (Layer 2 Tunneling Protocol)

> 🔒 **VPN 연결용 터널 만드는 애.**  
> 다만 **암호화는 못함**, 그래서 보통 **IPsec이랑 같이 씀**.

- Microsoft의 **PPTP** + Cisco의 **L2F** 합쳐서 만든 터널링 프로토콜
- L2TP만 쓰면 그냥 **터널만 파놓은 상태**라서 데이터가 **그냥 다 보일 수도 있음**
- 그래서 실전에서는 **IPsec과 함께 사용**해서 **암호화 + 무결성 보장**함

🧑‍🎓 **갓반인 예시:**  
> L2TP는 그냥 **비닐봉지**고, IPsec은 **자물쇠 잠긴 철제 박스**  
> 둘이 합쳐져야 **진짜 안전한 VPN**이 완성됨

---

### ✅ 요약 정리

| 이름 | 핵심 기능 | 갓반인 느낌 요약 |
|------|-----------|-------------------|
| SSL/TLS | 웹 브라우저 ↔ 서버 암호화 | 웹사이트 로그인 정보 보호 |
| IPsec | IP계층 데이터 암호화 | VPN에서 안전한 데이터 전송 |
| SSH | 원격 명령 안전하게 실행 | 서버에 몰래 접속 X |
| PGP | 이메일 암호화 + 서명 | 메일 잠금 + 보낸 사람 인증 |
| Kerberos | 상호 인증 + 세션 인증 | 로그인 한 번으로 모든 시스템 접근 |
| S/MIME | 이메일 암호화 + 서명 | 메일 보안 패키지 |
| L2TP | VPN 터널용 / 암호화는 없음 | 터널만 파주는 기술 (IPsec이랑 세트로 씀) |

---


-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 네트워크 보안 프로토콜 및 포트 정리

### 문제 4) 다음에서 설명하는 답을 작성하시오

**문제 설명:**  
- 네트워크 상에서 **다른 컴퓨터에 로그인하거나 원격에서 명령을 실행할 수 있는 애플리케이션 프로토콜**이다.  
- 이 프로토콜은 주로 **원격 컴퓨터 관리**에 사용되며, **보안성이 뛰어나 데이터의 무단 접근 및 변조를 방지**한다.  
- 인터넷을 통해 데이터를 전송할 때, 모든 트래픽(명령과 응답, 로그인 정보, 파일 전송 등)을 **암호화하여 전송**한다.  
- **22번 포트**를 사용한다.

**답:** `SSH` (Secure Shell)

---

## 📌 관련 개념 정리 (쉽고 직관적 + 갓반인 예시 포함)

---

### 🔹 SSH (Secure Shell)

> 💻 원격 컴퓨터에 접속해서 **명령어를 치거나**, **파일을 전송할 때**,  
> 안전하게 암호화된 통신을 보장해주는 **보안 터널 프로토콜**.

- **보안이 강화된 원격 접속용 프로토콜**
- 텔넷(Telnet)이랑 비슷한 역할이지만, **텔넷은 다 들킴(암호화 X)** → SSH는 **암호화 O**
- **22번 포트 사용**
- **명령어 실행, 파일 전송, 로그인** 모두 **암호화해서 안전하게 처리**
- 주로 **리눅스/유닉스 서버 원격 관리에 필수**

🧑‍🎓 **갓반인 예시:**  
> 원격으로 리눅스 서버에 로그인해서 파일 삭제할 때  
> 텔넷은 **누가 보면 다 보이는 유리문**, SSH는 **비번 걸린 금고**.  
> 진짜 실무에선 다 SSH 씀. 텔넷은 박제감.

---

### 🔹 주요 포트 번호 정리

> 📦 컴퓨터 통신에서 **각 서비스들이 사용하는 고정 번호**  
> 갓반인도 외워야 하는 최소한의 보안/네트워크 숫자들임.

| 포트 | 프로토콜 | 설명 | 갓반인 예시 |
|------|----------|------|--------------|
| 20, 21 | **FTP** | 파일 전송 (20: 데이터 / 21: 제어) | 예전 웹서버에 파일 올릴 때 FTP 씀. 21로 접속해서 20으로 옮김. |
| 22 | **SSH** | 원격 접속 (암호화됨) | 리눅스 서버 원격 접속해서 터미널 명령어 입력할 때 |
| 23 | **Telnet** | 원격 접속 (암호화 X) | 진짜 구식. 다 까발려짐. 실전 사용 ❌ |
| 25 | **SMTP** | 메일 전송 | 메일 서버가 다른 서버로 메일 보낼 때 |
| 53 | **DNS** | 도메인 → IP 변환 | 네이버.com을 IP 주소로 바꿔줌 |
| 80 | **HTTP** | 웹 페이지 요청 (비암호화) | 주소창에 http://로 시작하면 이거 |
| 110 | **POP3** | 메일 수신 (받기 전용) | 메일 클라이언트가 서버에서 메일 가져올 때 |
| 143 | **IMAP** | 메일 수신 (서버 동기화형) | 메일 내용을 서버와 계속 동기화할 때 |
| 443 | **HTTPS** | 웹 페이지 요청 (암호화 O) | 🔒자물쇠 있는 안전한 웹사이트, 로그인 시 필수 |

---

### ✅ 갓반인 꿀팁 요약

- 🔐 **SSH**: 원격 접속할 땐 무조건 이걸로. 22번 외워라.
- ❌ **Telnet**: 시대의 유물. 무조건 보안 뚫림.
- 🌐 **웹 접속은 80(HTTP), 443(HTTPS)** → 443은 **자물쇠 HTTPS**
- 📧 **메일 송수신도 각각 포트 다름** → 보낼 땐 25, 받을 땐 110 or 143
- 📌 **DNS는 53**: 주소를 숫자로 바꿔주는 전화번호부

---

-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 악성코드 및 서비스 공격 유형 정리

### 문제 5) 아래 설명에 대한 알맞은 답을 쓰시오

#### (1)
- 네트워크를 통해 **스스로 복사하고 분산되는 독립적인 프로그램**  
- 네트워크 취약점을 이용하여 **다른 시스템으로 전파**됨  
- 감염된 시스템의 리소스를 사용해 **네트워크 장애나 속도 저하** 유발  
- **사용자의 실행 없이도 자동으로 전파**

**답:** `웜 (WORM)`

---

#### (2)
- 사용자가 유용하거나 흥미로운 프로그램으로 위장  
- 사용자가 실행하면 **악성 행위 수행**  
- **개인 정보 탈취**, 시스템 제어권 탈취 등의 피해 발생

**답:** `트로이목마 (TROJAN HORSE)`

---

#### (3)
- 다른 프로그램에 **붙어서 감염**되는 악성코드  
- 감염된 프로그램이 실행되면 함께 실행되어 **시스템을 감염시킴**  
- **파일 삭제, 시스템 설정 변경** 등의 피해 발생  
- **사용자의 실행이 필요**함 (웜과의 차이점)

**답:** `바이러스 (VIRUS)`

---

## 📌 관련 개념 정리 (진짜 쉽고 직관적 + 갓반인 예시 포함)

---

### 🔹 DoS / DDoS 공격

#### ▶ 🧨 DoS (Denial of Service, 서비스 거부 공격)
- 혼자서 서버에 **요청 폭탄 날려서 다운시키는 공격**.
- 서버는 버티다 죽음 = 사용자 접속 못 함.

🧑‍🎓 **갓반인 예시:**  
> 시험 전날 수강신청 사이트에 1명이 마구 새로고침해서 서버 느려지는 상황  
> (하지만 요즘은 혼자 힘으론 별 타격 안 됨)

**주요 DoS 기법들:**
| 기법 | 설명 |
|------|------|
| **Smurf Attack** | ICMP 패킷을 브로드캐스트로 날려서 서버 응답 과부하 |
| **SYN Flooding** | TCP 연결 요청만 보내고 응답은 무시 → 서버 연결 자원 고갈 |
| **UDP Flooding** | 포트를 랜덤하게 찍으며 무작위 UDP 패킷 전송 |
| **Ping Flooding** | 계속 ping 보내서 응답만 하다가 서버 다운 |
| **Ping of Death** | 너무 큰 ping 패킷 보내서 서버 버퍼 넘침 |
| **Teardrop Attack** | IP 조각화 패킷을 이상하게 보내서 재조합 실패 유도 |
| **LAND Attack** | 출발지랑 목적지 IP를 **같이 설정**해서 자기 자신 공격 |

---

#### ▶ 🌪 DDoS (Distributed DoS, 분산 서비스 거부 공격)
- **수천 대 좀비 PC(=봇넷)**를 동원해서 **동시에 공격하는 대규모 DoS**.
- 규모가 크고 치명적. 요즘 쓰이는 건 거의 다 이거.

🧑‍🎓 **갓반인 예시:**  
> 시험 전날 전공 수강신청에 **전 학년이 동시에 새로고침 누르는 느낌**  
> 서버: “못 해먹겠다…”

---

## 📌 기타 보안 공격 용어 (진짜 실무/시험 다 나옴)

| 🧨 공격 | 📌 개념 설명 | 갓반인 예시 |
|--------|---------------|--------------|
| **피싱** | 가짜 이메일/사이트로 개인정보 유도 | 은행 사칭 문자 + 가짜 로그인 페이지 |
| **파밍** | DNS를 조작해서 **진짜 주소 쳐도 가짜 페이지**로 감 | 네이버 쳤는데 가짜 네이버 뜸 |
| **스니핑** | 네트워크 몰래 엿보는 도청 | 공공 와이파이에서 로그인하면 털릴 수 있음 |
| **스미싱** | 문자로 링크 보내서 개인정보 탈취 | 택배 조회 문자 눌렀더니 악성앱 설치 |
| **큐싱** | QR코드로 악성사이트 유도 | 포스터 QR 찍었더니 해킹된 앱 다운로드 |
| **랜섬웨어** | 파일 잠그고 돈 요구 | 과제 파일 열었더니 “비트코인 내놔” 메시지 |
| **키로거** | 키보드 입력 기록해서 정보 훔침 | 타자 친 거 다 캡처 → 비번, 카드번호 털림 |
| **SQL 삽입** | 웹 입력창에 SQL문 넣어서 DB 뚫기 | 로그인창에 `' OR '1'='1` 입력해서 우회 로그인 |
| **XSS** | 웹페이지에 **악성 스크립트 삽입** | 댓글에 `<script>alert('해킹')</script>` 넣음 |

---

### 🔹 그 외 공격 기법

| 공격 | 설명 | 갓반인 예시 |
|------|------|--------------|
| **Brute Force** | 비밀번호를 하나씩 다 시도 | “abc123, abc124...” 반복해서 로그인 시도 |
| **Spear Phishing** | **타겟 맞춤형 피싱** 공격 | “김갓반님, 연봉조정안 확인하세요” 첨부 파일 O |
| **APT** | 정찰부터 내부 침투까지 **은밀한 장기 해킹** | 대기업 내부망에 몇 달간 숨어있음 |
| **제로데이 공격** | 보안 취약점 발견과 동시에 **즉시 공격** | 패치도 안 된 취약점 바로 뚫기 |
| **백도어** | 공격자가 몰래 만든 **비밀통로** | 겉으론 닫힌 서버인데 몰래 입장 가능한 구멍 있음 |
| **레인보우 테이블** | 해시값을 미리 계산해서 **역추적** | 암호화된 비번을 빠르게 복호화 |
| **CSRF** | 사용자의 인증을 악용해 **의도치 않은 요청 수행** | 로그인 된 상태에서 공격자가 몰래 게시글 작성시킴 |

---

### ✅ 갓반인 요약 꿀팁

- **DDoS = 다수 좀비 PC로 서버 폭격**
- **피싱/파밍/스미싱/큐싱 → 다 낚시임 (수단만 다름)**
- **SQL 삽입, XSS = 웹 해킹의 양대산맥**
- **브포 / 레인보우 = 비번 뚫기**
- **APT / 제로데이 = 진짜 무서운 놈들**
- **CSRF = 사용자를 들러리로 세움**

---


-----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – 네트워크 프로토콜 정리

### 문제 6) 다음에서 설명하는 프로토콜을 영문 약어로 쓰시오

**문제 설명:**  
- 인터넷 프로토콜 스위트의 **핵심 프로토콜 중 하나**  
- 네트워크 컴퓨터가 **정보를 교환하거나 문제를 보고**할 때 사용됨  
- 운영 중인 네트워크의 **문제 진단, 오류 메시지 전송, 정보 요청** 등에 사용  
- **일반적인 데이터 전송에는 사용되지 않음**  
- TCP, UDP 등 다른 프로토콜과 함께 동작하여 네트워크 운영을 지원

**답:** `ICMP` (Internet Control Message Protocol)

---

## 📌 관련 개념 정리 (개념은 직관적! 예시는 갓반인 버전)

---

### 🔹 ICMP (Internet Control Message Protocol)

- 네트워크에 **문제 생기면 알려주는 메신저 같은 존재**
- 데이터를 보내는 게 아니라, **“에러 났어!” 혹은 “얘랑 연결 안 됨”** 같은 걸 알려줌
- **IP랑 한몸**, IP 패킷 내부에 포함되어 다님
- **Ping, Traceroute** 도구에서 사용

🧑‍🎓 **갓반인 예시:**  
> 교수님께 메일 보냈는데 안 간 이유가 궁금해서 ‘메일 배달 실패 알림’ 받는 느낌  
> Ping = “야 너 거기 살아있냐?”  
> 응답 없으면 = 서버 죽었거나 막혔거나

---

## 📌 OSI 7계층 + 대표 프로토콜 정리 (진짜 필요한 것만)

---

### 🧱 OSI 7계층: 개념 한줄 요약
> "아줌마 프세 날데 전사물"  
> = 응용, 표현, 세션, 전송, 네트워크, 데이터링크, 물리 (위→아래)

---

| 📶 계층 | 🌐 대표 프로토콜 | 💡 설명 | 👨‍🏫 갓반인 예시 |
|--------|------------------|---------|------------------|
| **7. 응용 계층** | HTTP (80) | 웹페이지 전송 | 웹사이트 들어갈 때 쓰는 핵심 프로토콜 |
|  | SMTP (25) | 이메일 전송 | 메일 보낼 때 서버랑 대화함 |
|  | FTP (20/21) | 파일 업/다운로드 | 옛날에 자주 쓰던 파일 전송 방식 |
|  | DNS (53) | 도메인 ↔ IP 변환 | `naver.com` 치면 내부에선 IP로 바꿔줌 |
|  | SNMP (161) | 장비 상태 모니터링 | 스위치, 라우터 관리자가 쓰는 프로토콜 |

---

| **4. 전송 계층** | TCP | 연결형, **신뢰성 O**, 속도 느림 | 중요한 데이터(예: 이메일, 파일) 전송용 |
|                   | UDP | 비연결형, **속도 빠름**, 신뢰성 X | 스트리밍, 게임, 영상통화 |
|                   | SCTP | TCP+UDP 합친 느낌 | 전화망(VoIP) 같은 특수 용도에서 사용 |

🧑‍🎓 갓반인 이해 포인트:
> TCP = 택배 (확실히 도착, 추적 가능)  
> UDP = 편지 (빠르지만 잃어버릴 수도 있음)

---

| **3. 네트워크 계층** | IP | 주소 역할 (누구한테 보낼지 지정) | 집 주소처럼 데이터 목적지 정의 |
|                      | **ICMP** | 네트워크 오류 알림, 진단 | "이 사람 집 없음", "주소 잘못됨" 같은 경고 알림 |

🧑‍🎓 Ping은 ICMP로 “거기 살아있어?”라고 묻는 거!

---

✅ **요약 정리 (시험/실무 둘 다 씹어먹기)**

- ICMP는 **문제 생기면 알려주는 네트워크 경고방송**
- TCP/UDP는 **데이터 보낼 때의 성격 차이**
- OSI 계층 중 7, 4, 3계층은 무조건 알아야 함
- 포트 번호는 서비스와 묶어서 암기 (FTP = 20,21 / HTTP = 80 / SSH = 22 등)

---
## 📌 네트워크 & 데이터 링크 계층 프로토콜 한눈에 정리

갓반인도 이해 가능한 방식으로! 개념은 직관적으로, 예시는 찰떡같이!

---

### 🔹 네트워크 계층 (3계층)

| 프로토콜 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **IP** | 네트워크 간 데이터 전송 시 **주소 지정 & 라우팅** 담당 | 데이터가 “어디로 가야 할지”를 정해주는 **네비게이션** |
| **ICMP** | 오류나 상태 정보 전송. Ping, Traceroute에서 사용 | 택배 기사님이 “주소 잘못됨”이라고 보내주는 메시지 |
| **RIP** | **거리 벡터 기반** 동적 라우팅 프로토콜<br>홉 수가 적은 경로를 선택 | “몇 개 거쳐서 가냐?”만 따지는 단순한 길찾기 |
| **OSPF** | **링크 상태 기반** 라우팅 프로토콜, 내부 네트워크용 | 지도를 보고 경로 직접 계산하는 똑똑한 길찾기 |
| **BGP** | 인터넷처럼 **다른 조직 간 경로 선택** 담당 | “네이버 → 카카오” 사이의 길을 정해주는 **국제 네비** |
| **ARP** | IP 주소 → MAC 주소로 변환 | “집 주소(IP)를 누구네 집(MAC)인지 찾는 작업” |
| **RARP** | MAC 주소 → IP 주소로 변환 | “이 컴퓨터 누구야?”를 알아내는 방식 (거의 안 씀) |

---

### 🔹 데이터 링크 계층 (2계층)

| 프로토콜 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **PPP (Point-to-Point Protocol)** | 두 장비 간 1:1 연결 시 **데이터 전송** 담당 | **모뎀 ↔ 인터넷** 연결할 때 쓰던 프로토콜 (요즘도 VPN에서 씀) |
| **HDLC (High-Level Data Link Control)** | 데이터 전송 시 **오류 제어 + 흐름 제어** 지원 | “한 번에 너무 많이 보내지 마” 같은 신호 주고받는 기능 |
| **L2TP (Layer 2 Tunneling Protocol)** | **VPN 연결을 위한 터널링 프로토콜**<br>암호화는 없고, 보통 **IPsec과 함께 사용** | VPN 쓰면 내부망처럼 보이게 해주는 “가상 터널” 만들기용 |

---

✅ **요약 암기 팁 (시험에 잘 나오는 것만)**

- **IP**: 주소 + 라우팅 담당, 중심축
- **ICMP**: 에러 전달 전문
- **RIP/OSPF/BGP**: 라우팅 3총사 (단순/복잡/국제)
- **ARP ↔ RARP**: IP↔MAC 매핑
- **PPP/HDLC**: 1:1 통신에서 데이터 전송 제어
- **L2TP**: 터널만 파는 VPN 도우미 (보안은 IPsec이 해줌)

---

-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 디자인 패턴 정리

### 문제 7) 다음에서 설명하는 디자인 패턴을 쓰시오

**문제 설명:**  
- 소프트웨어 디자인 패턴 중 하나  
- 어떤 객체에 대한 **접근을 제어**하거나 **간접적으로 이루어지도록 하는 패턴**  
- **중개자 역할을 하는 객체(프록시)**를 통해 실제 객체에 접근  
- 내부적으로 **실제 객체의 참조**를 가지고 있으며  
  클라이언트의 요청을 받아 **실제 객체에 전달하고 결과를 반환**

**답:** `PROXY 패턴`

---

## 📌 디자인 패턴 개념 정리 - 갓반인도 알 수 있게!

---

### 🔹 프록시 패턴 (Proxy Pattern)

> ✅ **프록시는 말 그대로 “대리인”**  
> 실제 객체 대신 중간에서 대신 일처리해주는 녀석임!

#### 🔸 핵심 개념
- **실제 객체에 직접 접근하지 않고**  
  **중간 객체(Proxy)를 통해 간접적으로 접근**
- 구조 패턴 중 하나
- **접근 제어, 성능 최적화, 보안** 등 다양한 목적

#### 🔸 구조
Client ──▶ Proxy ──▶ RealSubject

- `Client`: 사용하는 사람 (갓반인)
- `Proxy`: 대리인 (정문 경비 아저씨)
- `RealSubject`: 실제 처리 주체 (연예인, 서버, 무거운 객체)

#### 🔸 갓반인 예시로 이해해보자

| 유형 | 설명 | 갓반인 예시 |
|------|------|-------------|
| **가상 프록시** | 무거운 객체는 **진짜 필요할 때만 생성** | 고화질 게임 리소스, **게임 시작 후에만 로딩** |
| **보호 프록시** | 접근 권한을 검사 | 회사 문서 접근 시, **로그인 여부 체크** |
| **원격 프록시** | 원격지의 객체 대신 처리 | **갓반인 PC → AWS 서버 접근**, 중간에 통신 프록시가 중개 |
| **스마트 프록시** | 부가기능 붙이기 (로깅, 캐싱 등) | DB 접근 전 **"로그 찍기", 결과 캐싱하기** 등 추가 처리 |

---

### 🔹 관련 패턴과의 차이

| 패턴 | 하는 일 | 갓반인 스타일 요약 |
|------|---------|-------------------|
| **Proxy** | **접근 제어 / 대리 처리** | "진짜 대신 처리하는 사람" |
| **Adapter** | **인터페이스 바꿔줌** | "110V → 220V 변환기" |
| **Decorator** | **기능 확장 (랩핑)** | "커피에 시럽 추가" |
| **Facade** | **단순한 통합 인터페이스 제공** | "리모컨 하나로 집 전체 제어" |

---

✅ **한 줄 요약 (갓반인 암기법)**  
> **프록시는 직접 못 만나니까 대리인이 대신 처리해줌!**  
> (무겁거나, 위험하거나, 멀거나, 기능 더 붙일 때 씀)


-----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – 데이터베이스 기본 용어 정리

### 문제 8) 다음은 데이터베이스에 관련된 내용이다. 각 괄호에 맞는 답을 쓰시오

#### (1)
- 데이터 테이블의 **한 행(row)**을 말한다.  
- 특정 테이블에 속하는 **한 개체(entity)에 대한 정보를 나타내는 데이터 집합**이다.  

**답:** `튜플 (Tuple)`

---

#### (2)
- 특정 시점에서의 **관계(Relation)** 또는 **테이블의 상태**를 나타낸다.  
- 즉, 테이블에 **현재 저장되어 있는 실제 데이터**들의 모임이다.

**답:** `릴레이션 인스턴스 (Relation Instance)`

---

#### (3)
- 특정 테이블의 **행(row) 수**를 나타낸다.  
- 즉, 테이블에 존재하는 **튜플의 개수**이다.  

**답:** `카디널리티 (Cardinality)`

---

## 📌 갓반인도 이해하는 릴레이션 개념 정리

> 관계형 데이터베이스 용어, **그냥 테이블이라고 생각하면 됨!**  
> 아래 용어들만 알면 RDB 용어는 끝임. 진짜루.

---

| 용어 | 설명 | 갓반인 예시 |
|------|------|-------------|
| **릴레이션 (Relation)** | 하나의 **테이블 자체** (형태 + 내용 포함) | `학생`이라는 테이블 전체 (열 + 행 포함된 모습) |
| **릴레이션 스키마 (Relation Schema)** | 테이블의 **틀(구조)**: 열의 이름, 데이터 타입 등 | `학생(학번: 정수, 이름: 문자열, 학년: 정수)` |
| **릴레이션 인스턴스 (Relation Instance)** | 테이블 안에 **현재 들어있는 실제 데이터(행들)** | 지금 `학생` 테이블에 저장된 **모든 학생 정보** |
| **튜플 (Tuple)** | 테이블의 **한 행**, 하나의 레코드 | `2024001, 김갓반, 2` 같은 한 명의 학생 정보 |
| **속성 (Attribute)** | 테이블의 **열(Column)** 이름 | `학번`, `이름`, `학년` 같은 열 |
| **카디널리티 (Cardinality)** | 테이블에 있는 **행(튜플)의 수** | 총 등록된 **학생 수** (예: 123명) |
| **차수 (Degree)** | 테이블에 있는 **열(속성)의 수** | `학번`, `이름`, `학년` → **총 3개 속성 = 차수 3** |

---

### ✅ 갓반인 10초 요약 정리
- 테이블 = 릴레이션
- 열 이름/구조 = 스키마
- 행 하나 = 튜플
- 데이터 전부 = 인스턴스
- 열 몇 개? → 차수  
- 행 몇 개? → 카디널리티

> 📢 암기 꿀팁:  
> "릴레이션은 테이블,  
> 튜플은 행,  
> 속성은 열,  
> 나머진 그냥 단어 뜻 그대로 보면 된다"


-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 데이터베이스 스키마 정리

### 문제 9) 다음은 스키마와 관련된 내용이다. 괄호에 알맞은 답을 쓰시오

#### (1)
- 사용자 또는 애플리케이션의 관점에서 본 **데이터베이스의 뷰(View)**  
- 여러 개의 (1)이 존재할 수 있으며,  
  각각은 **사용자 그룹의 요구를 반영**하여 데이터베이스의 **일부만 보여주는 역할**을 한다.  

**답:** `외부 스키마 (External Schema)`

---

#### (2)
- 전체 데이터베이스의 **구조와 제약 조건을 정의**함  
- 모든 사용자와 애플리케이션이 **공통적으로 참조**하는 **데이터 통합 뷰** 제공  
- 데이터베이스의 모든 개체, 속성, 관계 등을 정의  

**답:** `개념 스키마 (Conceptual Schema)`

---

#### (3)
- 데이터가 **물리적으로 저장되는 방식**을 설명  
- **인덱싱, 해싱, 접근 경로, 저장 공간 할당 등 물리적 구조**를 정의  
- DBMS가 실제 데이터를 저장하고 관리하는 방법을 기술  

**답:** `내부 스키마 (Internal Schema)`

---

## 📌 갓반인도 바로 이해하는 DB 스키마 구조 & 설계

---

### 🔹 ✅ 스키마의 3계층 구조 (ANSI-SPARC)

> 데이터베이스도 건물처럼 **겉모습 / 설계도 / 시공 구조**로 나뉨  
> **사용자, 설계자, 컴퓨터 입장 각각의 관점**

| 스키마 계층 | 설명 | 독립성 | 갓반인 예시 |
|-------------|------|--------|-------------|
| **외부 스키마** | 사용자 입장에서 보이는 **부분적 데이터 뷰** | 🔹 논리적 독립성 | 교수: 학생 성적만 봄 / 학생: 자기 성적만 봄 |
| **개념 스키마** | DB 전체의 **논리적 설계 구조 및 제약조건** | (중간계층) | 설계자: 학생-교수-강의 관계 전체를 설계 |
| **내부 스키마** | 데이터의 **물리적 저장 방식 정의** | 🔹 물리적 독립성 | 컴퓨터: 데이터가 인덱스냐 해시냐 어떻게 저장할지 |

🧠 핵심 요약:
- 외부: 내가 보는 것만  
- 개념: 설계도  
- 내부: 실제 저장 방식  
- 논리적 독립성: **개념 ↔ 외부** 바뀌어도 서로 영향 없음  
- 물리적 독립성: **내부 ↔ 개념** 바뀌어도 논리 구조 영향 없음

---

### 🔹 ✅ 데이터베이스 설계 단계

> 현실 세상을 **데이터베이스로 바꾸는 과정**,  
> 상상 → 설계도 → 실제 건물 짓기 느낌

| 단계 | 설명 | 주요 산출물 | 갓반인 예시 |
|------|------|-------------|--------------|
| **개념적 설계** | 현실 세계 → 데이터 개체, 관계 추상화 | E-R 다이어그램, 트랜잭션 흐름 | 학생·강의·성적 관계 그리기 (그냥 그림으로 표현) |
| **논리적 설계** | 개념 모델 → 논리 테이블로 변환 | 정규화된 테이블, 논리적 스키마 | 관계형 테이블로 바꾸기 (`학생(학번, 이름...)`) |
| **물리적 설계** | 실제 저장 구조 및 성능 고려 | 인덱스 설계, 파일 구조 등 | `학번`에 인덱스 달기, 성적은 클러스터로 묶기 |

📌 암기 꿀팁:
- 개념적: "무슨 데이터가 필요하지?"
- 논리적: "그걸 테이블로 어떻게 만들지?"
- 물리적: "이걸 빠르게 어떻게 저장하지?"

---

🧠 갓반인 한 줄 요약:
- 외부는 사용자 눈, 개념은 설계도, 내부는 저장 방식  
- 개념 → 논리 → 물리 설계는 **현실 → 구조 → 성능 최적화** 흐름!

 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 제어 흐름 그래프와 테스트 커버리지

### 문제 10) 다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 순서를 쓰시오

---

### 📌 제시된 흐름도

(1) POINTER = FALSE
↓
(2) X > Y ? ───▶ YES ──▶ (3) POINTER = TRUE
↓ NO
(4) X = X + 1
↓
(5) CALL SUB
↓
(6) X > Y ? ──▶ YES ──▶ (7) PRINT RESULT



---

### 📌 분기 커버리지(Branch Coverage)란?

- **모든 조건문의 true/false 분기**를 **최소 한 번씩 실행**하는 테스트 기법  
- 즉, 조건문에서 **YES 경로와 NO 경로를 모두 포함**해야 한다

---

### 🔍 조건문 및 분기 분석

- 조건문 ①: `(2) X > Y?`  
  - YES → 다음 노드 (3)  
  - NO → 다음 노드 (4)  
- 조건문 ②: `(6) X > Y?`  
  - YES → 다음 노드 (7)  
  - NO → 없음 (종료 혹은 루프)

> **분기 커버리지 충족하려면**  
> 반드시 `(2)`번 조건에서 YES와 NO 경로 모두 수행해야 함

---

### ✅ 분기 커버리지를 만족하는 경로 예시

| 순서 경로              | 설명                                |
|-----------------------|-----------------------------------|
| `1 → 2 → 3 → 4 → 5 → 6 → 1` | (2)번 조건 YES 경로 포함, 루프 후 재진입  |
| `1 → 2 → 4 → 5 → 6 → 7`     | (2)번 조건 NO 경로 포함, (6)번 조건 YES   |
| `1 → 2 → 3 → 4 → 5 → 6 → 7` | (2)번 조건 YES, (6)번 조건 YES           |
| `1 → 2 → 4 → 5 → 6 → 1`     | (2)번 조건 NO, (6)번 조건 NO (루프 재진입) |

---

### ✅ 핵심 정리

- **분기 커버리지 = 모든 조건문에서 True/False 경로 모두 테스트하는 것**  
- 위 경로들은 (2)번 조건의 YES, NO 분기 모두 포함해서  
- 분기 커버리지 조건을 완벽히 만족함

---

### 🧠 갓반인 꿀팁

- 조건문 한 개라도 **한쪽만 테스트하면 분기 커버리지 실패**  
- 반드시 두 갈래 길(YES/NO) 다 가봐야 함  
- 경로 짤 때는 각 조건문의 분기 모두 포함하는지 확인하기!

 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – SQL 기본문제

### 문제 11) [학생] 테이블에서 학생 이름이 '민수'인 튜플을 삭제하는 쿼리를 작성하시오.

```sql
DELETE FROM 학생 WHERE 이름 = '민수';

- **DELETE 문**은 데이터베이스에서 특정 조건에 맞는 행(튜플)을 삭제하는 SQL 명령어입니다.
- 구문은 `DELETE FROM 테이블명 WHERE 조건;` 형태로 작성합니다.
- 여기서는 학생 테이블에서 이름이 '민수'인 행을 삭제하기 위해  
  `DELETE FROM 학생 WHERE 이름 = '민수';` 라고 작성합니다.
- **WHERE 절이 없으면 테이블의 모든 데이터가 삭제되므로 주의**해야 합니다.
 -----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – SQL GROUP BY와 HAVING 문제

### 문제 12) 다음 성적 테이블에서 조건에 맞게 SQL을 작성하시오.

| 순번 | 과목이름  | 점수 |
|-------|------------|------|
| 1     | DB         | 95   |
| 2     | DB         | 92   |
| 3     | NETWORK    | 90   |
| 4     | S/W        | 70   |
| 5     | NETWORK    | 65   |
| 6     | S/W        | 95   |

- 조건:  
  - 반드시 `GROUP BY`, `HAVING` 사용  
  - `WHERE` 절 사용 불가  
  - `SELECT`절에 별칭 사용  
  - 집계 함수 사용

---

### 정답 SQL

```sql
SELECT 
  과목이름, 
  MIN(점수) AS 최소점수, 
  MAX(점수) AS 최대점수
FROM 성적
GROUP BY 과목이름
HAVING AVG(점수) >= 90;


해설
GROUP BY 과목이름 으로 과목별로 묶음

MIN(점수), MAX(점수)로 각 그룹별 최소, 최대 점수 출력

HAVING AVG(점수) >= 90으로 그룹별 평균 점수가 90 이상인 과목만 필터링

WHERE는 그룹화 이전 필터링에 사용되므로, 그룹별 조건은 반드시 HAVING 절을 사용

별칭(AS 최소점수, AS 최대점수)으로 결과 컬럼 이름 지정

 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 자바 코드 결과 분석

### 문제 13) 다음 자바코드의 결과값을 쓰시오.

class TestClass {                                           // TestClass라는 설계도(클래스)를 만든다.
    public int a = 20;                                   // 'a'는 인스턴스 변수(멤버 변수)다.
                                                            // 이 클래스로 객체를 만들 때마다 각각의 객체 안에 'a'라는 변수가 생긴다.
                                                            // 각 객체마다 자기만의 'a'를 가지며, 초기값은 20이다.
    static int b = 0;                                      // 'b'는 'static' 변수(클래스 변수)다. 💡핵심!
                                                          // 이 변수는 TestClass의 '모든' 객체들이 '공유'하는 단 하나의 변수다.
                                                          // 객체를 만들든 안 만들든, TestClass 이름으로 접근할 수 있고,
                                                          // 값이 바뀌면 그 변경은 모든 객체에 반영된다. 초기값은 0이다.
}

class Main {                                               // 자바 프로그램의 시작점인 main 함수를 포함하는 Main 클래스다.
    public static void main(String[] args){                   // 프로그램이 시작될 때 가장 먼저 실행되는 메인 함수다.
                                                                      // public: 어디서든 접근 가능. static: 객체 생성 없이 바로 실행 가능.
                                                                      // void: 아무 값도 반환하지 않음. String[] args: 외부 입력 인자.
        int a;                                             // 'main' 함수 안에 지역 변수 'a'를 선언한다.
                                                                 // 이 'a'는 TestClass의 'a'나 static 변수 'b'랑은 전혀 다른, 별개의 변수다.
                                                                 // 초기값은 아직 없다 (쓰레기값).

        a = 10;                                                               // 'main' 함수 안의 지역 변수 'a'에 10을 할당한다.
                                                              // TestClass.a나 TestClass.b에는 아무 영향도 주지 않는다.

        TestClass.b = a;                                               // 💡 중요! 'static' 변수 'b'에 접근해서 값을 바꾼다.
                                                                 // TestClass.b는 static 변수이므로, 클래스 이름(TestClass)으로 바로 접근 가능하다.
                                                                 // 'a'의 현재 값인 10이 TestClass.b에 할당된다.
                                                                 // 이제 TestClass.b의 값은 10이다.

        TestClass tc = new TestClass();                                     // 'TestClass'의 새로운 '객체(인스턴스)'를 생성하고 'tc'라는 이름으로 참조한다.
                                                                            // 이 시점에 tc.a는 초기값 20을 갖는다. (tc.a = 20)
                                                                            // 하지만 static 변수 TestClass.b는 이미 위에서 10으로 설정되어 있었으므로,
                                                                            // 새로 객체를 만들었다고 해서 TestClass.b가 초기값 0으로 바뀌지 않는다!

        System.out.println(TestClass.b++);                         // 💡 중요! TestClass.b의 현재 값을 출력하고, 그 다음에 1 증가시킨다.
                                                                      // TestClass.b의 현재 값은 10이다.
                                                                      // 따라서 화면에는 '10'이 출력된다.
                                                                      // 출력이 끝난 후 TestClass.b의 값은 10 + 1 = 11이 된다.

        System.out.println(tc.b);                                     // 💡 중요! tc 객체를 통해 static 변수 'b'에 접근한다.
                                                                        // 'b'는 static 변수이므로 모든 객체가 공유하는 변수다.
                                                                        // 바로 위에서 TestClass.b가 11이 되었으므로, tc.b도 당연히 11이다.
                                                                        // 따라서 화면에는 '11'이 출력된다.

        System.out.println(a);                                   // 'main' 함수 안의 지역 변수 'a'의 값을 출력한다.
                                                                      // 이 'a'는 위에 10으로 설정된 그대로다.
                                                                      // 따라서 화면에는 '10'이 출력된다.    

        System.out.print(tc.a);                                     // 💡 중요! tc 객체의 인스턴스 변수 'a'의 값을 출력한다.
                                                                          // 'a'는 인스턴스 변수이므로 객체마다 별개다.
                                                                          // tc 객체를 생성할 때 tc.a는 초기값 20으로 설정되었다.
                                                                          // 이 값은 코드 어디에서도 변경된 적이 없다.
                                                                          // 따라서 화면에는 '20'이 출력된다.
                                                                          // System.out.print()는 줄바꿈을 하지 않으므로, 다음 출력이 있다면 이어서 나온다.
    }
}

답
10
11
10
20


 -----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – C언어 출력 결과 분석

### 문제 14) 다음 C언어 코드의 결과값을 쓰시오.

#include <stdio.h>                                   // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일이다.

int main() {                                             // C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                                     // 여기서는 int를 반환하지만, 예제에는 return 0;이 생략되어 있다.

    char a[] = "Art";                                     // 'a'라는 이름의 'char' 타입 배열을 선언하고 "Art"라는 문자열로 초기화한다.
                                                           // C에서 문자열은 항상 널 문자('\0')로 끝난다.
                                                           // 그래서 실제 메모리에는 'A', 'r', 't', '\0' 이렇게 4칸이 할당된다.
                                                           // 배열 이름 'a' 자체는 배열의 첫 번째 요소의 주소(메모리 위치)를 나타낸다.

    char *p = NULL;                                         // 'p'라는 이름의 'char' 타입 포인터를 선언한다.
                                                             // 포인터는 메모리 주소를 저장하는 변수다.
                                                             // NULL로 초기화하는 건, 일단 아무것도 가리키지 않는다는 뜻이다.

    p = a;                                                         // 💡 중요! 포인터 'p'에 배열 'a'의 시작 주소를 할당한다.
                                                               // 이제 포인터 'p'는 배열 'a'의 첫 번째 문자('A')를 가리키게 된다.
                                                               // 즉, 'p'와 'a'는 둘 다 'A'가 있는 메모리 공간의 시작점을 가리키게 된 거다.

    printf("%s\n", a);                                             // 💡 중요! 'a' 배열을 문자열(%s)로 출력한다.
                                                                                    // 배열 이름 'a'는 그 자체로 문자열의 시작 주소로 해석된다.
                                                                                    // '\n'은 줄 바꿈을 의미한다.
                                                                                    // 결과: "Art"가 출력되고 줄이 바뀐다.

    printf("%c\n", *p);                                             // 💡 중요! 포인터 'p'가 가리키는 '값'을 문자(%c)로 출력한다.
                                                                // '*'는 '역참조 연산자'다. 포인터 'p'가 가리키는 메모리 주소에 있는 값을 가져오라는 뜻.
                                                                // 'p'는 'A'를 가리키고 있으므로 'A'가 출력된다.
                                                                // 결과: 'A'가 출력되고 줄이 바뀐다.

    printf("%c\n", *a);                                                 // 💡 중요! 배열 이름 'a'가 가리키는 '값'을 문자(%c)로 출력한다.
                                                                                // 배열 이름 'a'도 포인터처럼 첫 번째 요소의 주소를 나타낸다.
                                                                                // 따라서 '*a'는 'a' 배열의 첫 번째 요소인 'A'를 의미한다.
                                                                                // 결과: 'A'가 출력되고 줄이 바뀐다.

    printf("%s\n", p);                               // 💡 중요! 포인터 'p'가 가리키는 주소부터 문자열(%s)로 출력한다.
                                                            // 'p'는 배열 'a'의 시작점, 즉 "Art" 문자열의 시작점을 가리키고 있다.
                                                            // '%s' 서식 지정자는 포인터가 가리키는 주소부터 널 문자('\0')를 만날 때까지 출력한다.
                                                            // 결과: "Art"가 출력되고 줄이 바뀐다.

                                                            // for 루프: 배열 'a'의 각 문자를 하나씩 순서대로 출력한다.
                                                            // a[i] != '\0': 'a' 배열의 i번째 문자가 널 문자('\0')가 아닐 때까지 반복한다.
                                                            // 문자열의 끝은 항상 널 문자로 표시되므로, 널 문자를 만나면 반복을 멈춘다.
    for(int i = 0; a[i] != '\0'; i++)
        printf("%c", a[i]);                                                 // 현재 a[i]의 문자(%c)를 출력한다.
                                                                        // 줄 바꿈 없이 문자가 연달아 출력된다.
                                                                        // 결과: "Art"가 출력된다. (마지막에 줄바꿈 없음)
                                                                      
                                                                      // return 0; // main 함수가 int를 반환하도록 선언되었으므로, 보통 0을 반환하여 정상 종료를 알린다.
                                                                                 // 이 예제에서는 생략되어 있지만, 실제 컴파일 시에는 자동으로 추가되거나 경고가 뜰 수 있다.
}
답
Art
A
A
Art
Art


 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – C언어 코드 결과 분석

### 문제 15) 다음 C언어 코드의 결과값을 쓰시오
#include <stdio.h>                               // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일이다.

int main() {                                     // C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                                           // 이 예제에서는 return 0;이 생략되어 있다.
  
    char *a = "qwer";                                 // 'a'라는 char 포인터를 선언하고 "qwer"이라는 문자열의 시작 주소를 가리키게 한다.
                                                      // 메모리에는 'q', 'w', 'e', 'r', '\0' 이렇게 저장된다.
    char *b = "qwtety";                         // 'b'라는 char 포인터를 선언하고 "qwtety"라는 문자열의 시작 주소를 가리키게 한다.
                                                     // 메모리에는 'q', 'w', 't', 'e', 't', 'y', '\0' 이렇게 저장된다.

                                                        // 첫 번째 (바깥쪽) for 반복문: 문자열 'a'의 모든 문자를 하나씩 순회한다.
                                                        // 'a[i] != '\0''는 'a'의 i번째 문자가 널 문자(문자열의 끝)가 아닐 때까지 반복하라는 의미다.
    for (int i = 0; a[i] != '\0'; i++) { // i는 0, 1, 2, 3 (각각 'q', 'w', 'e', 'r'에 해당)
                                                                // 두 번째 (안쪽) for 반복문: 문자열 'b'의 모든 문자를 하나씩 순회한다.
                                                                // 'b[j] != '\0''는 'b'의 j번째 문자가 널 문자가 아닐 때까지 반복하라는 의미다.
        for (int j = 0; b[j] != '\0'; j++) { // j는 0, 1, 2, 3, 4, 5 (각각 'q', 'w', 't', 'e', 't', 'y'에 해당)
                                                    // if 조건문: 현재 'a'의 문자(a[i])와 'b'의 문자(b[j])가 서로 같은지 비교한다.
            if (a[i] == b[j])
                                                        // 만약 두 문자가 같으면, 해당 문자(a[i])를 화면에 출력한다.
                                                        // printf("%c", a[i]);는 문자를 출력하며, 줄 바꿈이나 공백 없이 바로 이어서 출력된다.
                printf("%c", a[i]);
        }
    }
                                                      // 모든 반복문이 끝나면 프로그램이 종료된다.
                                                      // return 0; // main 함수가 int를 반환하도록 선언되었으므로, 일반적으로 프로그램이 정상 종료되었음을 알리기 위해 0을 반환한다.
                                                                 // 이 예제에서는 생략되어 있다.
}

답
qwe

### 🔍 실행 과정 상세 분석

이 코드는 문자열 `a`의 각 문자와 문자열 `b`의 모든 문자를 일일이 비교하여, 같은 문자가 있을 경우 그 문자를 출력한다.

---

#### i = 0 (`a[0] = 'q'`)

- j = 0 (`b[0] = 'q'`): 'q' == 'q' → **q 출력**
- j = 1 (`b[1] = 'w'`): 'q' != 'w'
- j = 2 (`b[2] = 't'`): 'q' != 't'
- j = 3 (`b[3] = 'e'`): 'q' != 'e'
- j = 4 (`b[4] = 't'`): 'q' != 't'
- j = 5 (`b[5] = 'y'`): 'q' != 'y'

---

#### i = 1 (`a[1] = 'w'`)

- j = 0 (`b[0] = 'q'`): 'w' != 'q'
- j = 1 (`b[1] = 'w'`): 'w' == 'w' → **w 출력**
- j = 2 (`b[2] = 't'`): 'w' != 't'
- j = 3 (`b[3] = 'e'`): 'w' != 'e'
- j = 4 (`b[4] = 't'`): 'w' != 't'
- j = 5 (`b[5] = 'y'`): 'w' != 'y'

---

#### i = 2 (`a[2] = 'e'`)

- j = 0 (`b[0] = 'q'`): 'e' != 'q'
- j = 1 (`b[1] = 'w'`): 'e' != 'w'
- j = 2 (`b[2] = 't'`): 'e' != 't'
- j = 3 (`b[3] = 'e'`): 'e' == 'e' → **e 출력**
- j = 4 (`b[4] = 't'`): 'e' != 't'
- j = 5 (`b[5] = 'y'`): 'e' != 'y'

---

#### i = 3 (`a[3] = 'r'`)

- j = 0 (`b[0] = 'q'`): 'r' != 'q'
- j = 1 (`b[1] = 'w'`): 'r' != 'w'
- j = 2 (`b[2] = 't'`): 'r' != 't'
- j = 3 (`b[3] = 'e'`): 'r' != 'e'
- j = 4 (`b[4] = 't'`): 'r' != 't'
- j = 5 (`b[5] = 'y'`): 'r' != 'y'

---

### 🚀 최종 출력 결과

조건에 맞는 문자가 있을 때마다 바로바로 출력되므로,  
최종 결과는 줄바꿈 없이 이어서 출력되어 다음과 같다:


 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – C언어 이진수 → 십진수 변환 코드 빈칸 채우기

### 문제 16) 다음 코드는 이진수를 십진수로 변환하는 코드이다. 빈칸에 알맞은 답을 쓰시오.

`#include <stdio.h> // 표준 입출력 함수 (printf 등)를 사용하기 위해 필요한 헤더 파일이다.

int main() { // C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.

    int input = 101110;                                                                 // 'input'이라는 정수형 변수를 선언하고 101110으로 초기화한다.
                                                                                    // 이 코드는 이 숫자를 2진수 '101110'으로 간주하고 10진수로 변환할 거다.
    int di = 1;                                                                             // 'di'라는 정수형 변수를 1로 초기화한다.
                                                                                                  // 이 변수는 각 2진수 자릿수(0 또는 1)에 곱해질 '가중치'를 나타낸다.
                                                                                                  // 2진수 변환에서 2의 0승(1), 2의 1승(2), 2의 2승(4) ... 같은 역할을 한다.
    int sum = 0;                                                                        // 'sum'이라는 정수형 변수를 0으로 초기화한다.
                                                                                    // 변환된 10진수 값을 누적해서 저장할 변수다.

    while (1) {                                         // 무한 루프를 시작한다. 조건이 항상 참이므로 내부에서 'break'를 만나기 전까지 계속 반복된다.
        if (input == 0) break;                                           // 만약 'input' 값이 0이 되면 루프를 'break'(탈출)한다.
                                                                          // 이는 'input'의 모든 자릿수를 다 처리했다는 의미다.
        else { // 'input'이 0이 아니면 (아직 처리할 자릿수가 남아있으면)
                                                          // sum = sum + (input % 10) * di; // 주석 (①)과 (②)는 input % 10을 나타내는 것으로 보인다.
                                                          // 1. input % 10: 'input'을 10으로 나눈 나머지를 구한다.
                                                          //    이는 'input'의 가장 오른쪽(1의 자리) 숫자를 뽑아내는 효과가 있다. (예: 101110 % 10 = 0)
                                                          // 2. (... ) * di: 뽑아낸 자릿수(0 또는 1)에 현재 '가중치(di)'를 곱한다.
                                                          // 3. sum = sum + ...: 계산된 값을 'sum'에 누적하여 더한다.
            sum = sum + (input % 10) * di; // 'input % 10'은 input의 1의 자리 숫자를 가져온다.

            di = di * 2;                                             // 'di'(가중치)를 2배로 증가시킨다.
                                                 // 다음 루프에서는 다음 자릿수(10의 자리, 100의 자리 등)에 해당하는 더 큰 가중치(2, 4, 8 ...)를 사용한다.

            input = input / 10;                                       // 'input' 값을 10으로 나눈 몫을 다시 'input'에 저장한다.
                                                                            // 이는 'input'의 가장 오른쪽 자릿수를 '버리는' 효과가 있다.
                                                                            // (예: 101110 / 10 = 10111)
                                                                            // 다음 반복에서는 남은 숫자들로 계산을 계속하게 된다.
        }
    }
                                          // while 루프가 모두 끝나면, 'sum' 변수에는 2진수 '101110'에 해당하는 최종 10진수 값이 저장되어 있다.
    printf("%d", sum);                                           // 최종적으로 계산된 'sum' 값을 화면에 출력한다.
                                                                               // '%d'는 정수를 출력하라는 서식 지정자다.
                                                                               // 출력 후에는 줄 바꿈이 없다.

    // return 0; // int main() 함수가 정수를 반환하도록 선언되었으므로,
               // 보통 0을 반환하여 프로그램이 정상적으로 종료되었음을 운영체제에 알린다.
               // 이 예제에서는 코드가 생략되어 있다.  
}

🚀 **최종 출력 결과:**  
### 답변

| 빈칸 위치 | 정답 | 설명                                  |
|-----------|-------|-------------------------------------|
| (1)       | `%`   | `input % 10` → input의 마지막 자리 숫자 추출 |
| (2)       | `10`  | `input / 10` → 마지막 자리 숫자 제거 (몫)    |

완성된 코드

### input = 101110일 때 while 루프 실행 과정

| 반복 횟수 | input (시작) | di (시작) | input % 10 (현재 자릿수) | (input % 10) * di | sum (누적) | input / 10 (다음 input) | di * 2 (다음 di) |
|-----------|--------------|-----------|--------------------------|-------------------|------------|-------------------------|------------------|
| 시작      | 101110       | 1         | -                        | -                 | 0          | -                       | -                |
| 1회차     | 101110       | 1         | 0                        | 0 * 1 = 0         | 0 + 0 = 0  | 10111                   | 1 * 2 = 2        |
| 2회차     | 10111        | 2         | 1                        | 1 * 2 = 2         | 0 + 2 = 2  | 1011                    | 2 * 2 = 4        |
| 3회차     | 1011         | 4         | 1                        | 1 * 4 = 4         | 2 + 4 = 6  | 101                     | 4 * 2 = 8        |
| 4회차     | 101          | 8         | 1                        | 1 * 8 = 8         | 6 + 8 = 14 | 10                      | 8 * 2 = 16       |
| 5회차     | 10           | 16        | 0                        | 0 * 16 = 0        | 14 + 0 = 14| 1                       | 16 * 2 = 32      |
| 6회차     | 1            | 32        | 1                        | 1 * 32 = 32       | 14 + 32=46 | 0                       | 32 * 2 = 64      |
| 종료      | 0            | -         | -                        | -                 | 46         | -                       | -                |

---

🚀 **최종 출력 결과:**  
while 루프 종료 후 `sum` 변수에는 `46`이 저장되어 있습니다.

 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – C언어 변수명 채우기 문제

### 문제 17) 다음 코드에 알맞은 변수명을 쓰시오

```c
#include <stdio.h>                                         // 표준 입출력 함수 (printf 등)를 사용하기 위해 필요한 헤더 파일이다.

                                                                      // swap 함수: 배열의 두 요소 위치를 서로 바꾼다 (교환한다).
                                                                      // ary[]: 값을 바꿀 대상 배열
                                                                      // idx1: 첫 번째 요소의 인덱스
                                                                      // idx2: 두 번째 요소의 인덱스
void swap(int ary[], int idx1, int idx2){
    int tmp = ary[idx1];                                         // 1. ary[idx1]의 값을 임시 변수 'tmp'에 저장한다. (값 백업)
    ary[idx1] = ary[idx2];                                           // 2. ary[idx2]의 값을 ary[idx1] 위치로 옮긴다.
    ary[idx2] = tmp;                                                   // 3. 임시 변수 'tmp'에 저장했던 원래 ary[idx1]의 값을 ary[idx2] 위치로 옮긴다.
                                                                           // (①)은 당연히 'idx2'가 들어가야 한다.
}

                                                          // sort 함수: '버블 정렬' 알고리즘을 사용해서 배열을 오름차순으로 정렬한다.
                                                          // 버블 정렬은 인접한 두 요소를 비교하여 큰 값을 뒤로 계속 '버블링'하는 방식이다.
                                                          // ary[]: 정렬할 대상 배열
                                                          // len: 배열의 길이
void sort(int ary[], int len){
                                                                      // 바깥쪽 for 문: 이 루프는 배열의 '정렬된 부분'이 점차 늘어나는 것을 제어한다.
                                                                      // len번의 반복이 필요하지만, 매 반복마다 가장 큰 값이 뒤로 가므로 비교 범위가 1씩 줄어든다.
    for(int i = 0; i < len; i++){
                                                                          // 안쪽 for 문: 이 루프는 인접한 요소들을 비교하고 교환하는 실제 정렬 작업을 수행한다.
                                                                          // len - i - 1: 이미 정렬이 완료되어 가장 뒤로 간 요소들은 다시 비교할 필요가 없으므로,
                                                                          // 비교 범위를 매 반복마다 1씩 줄여 나간다.
                                                                          // 예를 들어, len이 5일 때, i=0이면 0~3까지 비교하고, i=1이면 0~2까지 비교한다.
        for(int j = 0; j < len - i - 1; j++){
                                                                            // if 조건문: 현재 요소(ary[j])가 바로 다음 요소(ary[j+1])보다 크다면,
                                                                            // (즉, 순서가 잘못되어 있다면)
            if(ary[j] > ary[j+1]){
                                                                      // swap 함수를 호출하여 ary[j]와 ary[j+1]의 위치를 바꾼다.
                                                                      // 이렇게 하면 큰 값이 오른쪽(뒤쪽)으로 이동하게 된다.
                swap(ary, j, j+1);
            }
        }
    }
}

답
①	idx2
②	nx

### 실행 과정 및 결과 분석

- 초기 `ary` 배열: `[15, 5, 20, 11, 8]`

- `sort(ary, 5)` 함수 호출 → **버블 정렬** 시작

- **버블 정렬 과정:**

  1. **첫 번째 바깥 루프 (i = 0)**  
     - 인접한 요소들을 비교하며 가장 큰 값인 `20`이 배열 맨 뒤로 이동  
     - 배열 상태: `[5, 11, 8, 15, 20]`

  2. **두 번째 바깥 루프 (i = 1)**  
     - 두 번째로 큰 값인 `15`가 뒤에서 두 번째 자리로 이동  
     - 배열 상태: `[5, 8, 11, 15, 20]`

  3. 이후 루프에서도 같은 방식으로 비교와 교환이 반복되어 정렬 완료

- **정렬 완료 후 배열:** `[5, 8, 11, 15, 20]`

- 마지막 `for` 루프에서 정렬된 배열의 모든 요소를 차례대로 출력함

 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 파이썬 집합(Set) 출력 결과

### 문제 18) 다음 파이썬 코드의 출력 결과를 쓰시오

                                                                                  # 'a'라는 이름의 set(집합)을 생성하고 초기값으로 '한국', '중국', '일본' 문자열을 넣는다.
                                                                                  # set은 파이썬의 자료형 중 하나로, 다음 두 가지 특징이 존나 중요하다:
                                                                                  # 1. 중복된 요소를 허용하지 않는다. (같은 값을 여러 번 넣어도 한 번만 저장됨)
                                                                                  # 2. 요소들의 순서가 없다. (저장된 순서대로 출력되지 않고, 매번 다를 수 있다.)
a = {'한국', '중국', '일본'}

                                                                                        # a.add('베트남'): 'a' set에 '베트남'이라는 요소를 추가한다.
                                                                                        # 이제 'a'는 {'한국', '중국', '일본', '베트남'} (순서는 보장 안 됨)
a.add('베트남')

                                                                        # a.add('중국'): 'a' set에 '중국'이라는 요소를 추가한다.
                                                                        # 하지만 '중국'은 이미 'a' set 안에 존재하므로, set의 '중복 불허' 특성 때문에 아무 변화도 일어나지 않는다.
                                                                        # 'a'는 여전히 {'한국', '중국', '일본', '베트남'} 상태다.
a.add('중국')

                                                                                  # a.remove('일본'): 'a' set에서 '일본'이라는 요소를 제거한다.
                                                                                  # 만약 제거하려는 요소가 set에 없으면 에러가 발생한다.
                                                                                  # 이제 'a'는 {'한국', '중국', '베트남'} 상태가 된다.
a.remove('일본')

                                                                            # a.update({'홍콩', '한국', '태국'}): 'a' set에 다른 집합({'홍콩', '한국', '태국'})의 요소들을 한꺼번에 추가한다.
                                                                            # - '홍콩'은 'a'에 없었으므로 추가된다.
                                                                            # - '한국'은 'a'에 이미 있으므로 중복이 허용되지 않아 아무 변화 없다.
                                                                            # - '태국'은 'a'에 없었으므로 추가된다.
                                                                            # 이 라인 실행 후 'a'는 {'한국', '중국', '베트남', '홍콩', '태국'} (순서는 보장 안 됨)
a.update({'홍콩', '한국', '태국'})

                                                                  # print(a): 최종적으로 현재 'a' set에 저장된 모든 요소를 화면에 출력한다.
                                                                  # set은 순서가 없기 때문에, 출력될 때마다 요소들의 순서가 위에서 예시로 든 것과 다를 수 있다.
                                                                  # 하지만 포함된 요소들은 항상 동일하다.
print(a)

답
{'홍콩', '중국', '태국', '한국', '베트남'}

 -----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – 자바 코드 출력 결과 분석

### 문제 19) 다음은 Java로 작성된 프로그램이다. 실행한 출력 결과를 쓰시오.

abstract class Vehicle {                               // 'Vehicle'이라는 추상 클래스다.
                                                     // 'abstract' 키워드 때문에 이 클래스 자체로는 객체를 직접 만들 수 없다.
                                                     // 무조건 다른 클래스가 얘를 '상속'받아서 써야 한다.
    String name;                                   // 인스턴스 변수 'name'이다. 접근 제어자가 없어서 같은 패키지 안에서는 접근 가능하다.
                                                         // Vehicle 객체가 만들어질 때마다 이 'name' 변수가 생긴다.

    public Vehicle(String val){                               // Vehicle 클래스의 '생성자'다.
                                                                // Vehicle 객체가 만들어질 때 'val'이라는 문자열을 받아서 초기화한다.
        this.name = val;                                   // 전달받은 'val' 값을 현재 객체의 'name' 변수에 넣어준다.
    }

    public String getName(){                             // 'getName'이라는 메서드다.
                                                       // 매개변수는 없고, String 타입의 값을 반환한다.
        return "Vehicle name:" + name;                           // "Vehicle name:" 문자열 뒤에 현재 객체의 'name' 값을 붙여서 돌려준다.
    }
}

class Car extends Vehicle {                                 // 'Car' 클래스다. 'Vehicle' 클래스를 상속받는다.
                                                            // 즉, Vehicle에 있는 멤버들(name 변수, 생성자, getName() 메서드)을 물려받는다.
    private String name;                                    // 💡 개중요! Car 클래스 안에서 'private' 접근 제어자로 'name'이라는 인스턴스 변수를 '또' 선언했다.
                                                              // 이건 부모 클래스 Vehicle의 'name'과는 '완전히 다른', Car 클래스만의 변수다!
                                                              // 'private'이니까 이 'name'은 Car 클래스 안에서만 접근할 수 있다.

    public Car(String val){                                       // Car 클래스의 '생성자'다.
                                                                    // Car 객체가 만들어질 때 'val' 문자열을 받아서 초기화한다.
                                                            // name = super.name = val; // 💡 중요! 이 한 줄로 부모의 name과 자식의 name을 동시에 건드린다.
                                                                                      // 'super.name = val;': 부모 클래스(Vehicle)에 있는 'name' 변수에 'val' 값을 넣어준다.
                                                                                      // 'name = val;': (자식 클래스인) Car 자신의 'private String name;' 변수에 'val' 값을 넣어준다.
                                                                                      // 참고로, 자바에선 일반적으로 'super(val);'처럼 부모 생성자를 먼저 명시적으로 호출하는 게 정석이다.
                                                                                      // 이 코드는 컴파일러가 암묵적으로 부모 생성자를 처리하면서 두 변수에 값을 넣는 식으로 동작할 수 있다.
        super(val);                                                             // 자바 문법적으로는 이렇게 부모 생성자를 먼저 호출해야 한다.
                                                                            // 이렇게 하면 부모의 name (super.name)이 val로 초기화된다.
        this.name = val;                                               // 그리고 Car 클래스 자신의 name 변수에 val 값을 할당한다.
    }

    public String getName(String val) {                                                         // 💡 중요! 'getName'이라는 메서드를 정의하는데,
                                                                                          // 부모의 getName()과는 '매개변수'가 다르다 (String val).
                                                                                        // 이건 '메서드 오버로딩'이다! (오버라이딩이 아니다)
                                                                                        // 즉, 부모의 메서드를 덮어쓴 게 아니라, 이름만 같은 '새로운' 메서드를 하나 더 만든 거다.
        return "Car name: " + val;                                               // "Car name:" 문자열과 전달받은 매개변수 'val'을 붙여서 반환한다.
    }

    public String getName(byte val[]){                                           // 💡 중요! 'getName'이라는 메서드를 또 정의하는데,
                                                                                // 이번엔 매개변수가 byte 배열이다 (byte val[]).
                                                                                // 이것도 또 다른 '메서드 오버로딩'이다!
        return "Car name: " + val;                                           // "Car name:" 문자열과 전달받은 byte 배열 'val'을 붙여서 반환한다.
                                                                            // (참고: byte 배열을 그냥 문자열로 바꾸면 메모리 주소 같은 이상한 값이 나올 수도 있다.)
    }
}

## 🚗 클래스 상속과 메서드 오버로딩 핵심 정리

### 1. 변수 중복 선언과 스코프
- `Vehicle` 클래스에 `private String name;` 변수가 있음  
- `Car` 클래스에서 같은 이름 `private String name;` 변수를 다시 선언  
- **두 변수는 완전히 별개의 변수**로,  
  `Car` 객체에는 `Vehicle`의 `name` 변수와 `Car`의 `name` 변수 두 개가 존재함

---

### 2. 생성자 동작
- `Car` 생성자는 매개변수 `val`을 받아서  
  `super.name` (부모 클래스 변수)과  
  `this.name` (자식 클래스 변수)에 **둘 다 값을 할당**함  
- 부모와 자식 클래스의 각각의 `name` 변수를 초기화하는 것

---

### 3. 메서드 오버로딩 (Overloading)
- `Car` 클래스에는 `getName` 메서드가 총 3개 존재  
  - 부모 `Vehicle` 클래스의 매개변수 없는 `getName()` (반환 예: `"Vehicle name: ..."`)  
  - `Car` 클래스 내 `getName(String val)` (반환 예: `"Car name: " + val`)  
  - `Car` 클래스 내 `getName(byte val[])` (반환 예: `"Car name: " + val`)  
- **오버로딩은 같은 이름의 메서드가 매개변수 타입이나 개수에 따라 여러 개 존재하는 것**  
- **오버라이딩과 다름**: 오버라이딩은 부모 메서드를 자식이 재정의하는 것

---

### 💡 요약
- `Vehicle`과 `Car`의 `name` 변수는 서로 다른 별개 변수  
- `Car` 생성자는 부모와 자식 변수 모두 초기화  
- `getName()` 메서드는 매개변수에 따라 호출되는 메서드가 달라짐 (오버로딩)


 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 자바 상속 및 생성자 실행 결과

### 문제 20) 다음은 Java로 작성된 프로그램이다. 실행한 출력 결과를 쓰시오.

```java
class Parent {                             // 'Parent'라는 클래스를 정의한다.
    int x = 100;                             // 인스턴스 변수 'x'를 선언하고 100으로 초기화한다.
                                             // Parent 객체가 만들어질 때마다 각 객체는 자신만의 x를 가진다.

    Parent() {                           // 매개변수 없는 Parent 클래스의 '기본 생성자'다.
        this(500);                     // 💡 중요! 현재 클래스의 다른 생성자(매개변수 있는 Parent(int x))를 호출한다.
                                           // 이 호출이 먼저 실행되면서, 아래의 Parent(int x) 생성자로 이동하여 this.x에 500이 할당된다.
    }

    Parent(int x) {                 // 정수형 매개변수 'x'를 받는 Parent 클래스의 '생성자'다.
        this.x = x;                   // 💡 중요! 매개변수로 받은 'x' 값을 현재 객체의 인스턴스 변수 'this.x'에 할당한다.
                                        // 만약 기본 생성자를 통해 호출되면 this.x는 500이 된다.
                                          // 만약 Parent(123)처럼 직접 호출되면 this.x는 123이 된다.
    }

    int getX() {                   // 'x' 변수의 값을 반환하는 메서드다.
        return x;                       // 현재 객체의 인스턴스 변수 'x' 값을 돌려준다.
    }
}

class Child extends Parent {                         // 'Child' 클래스를 정의한다. 얘는 'Parent' 클래스를 상속받는다.
                                                         // Parent의 모든 멤버(x 변수, 생성자, getX() 메서드)를 물려받는다.
    int x = 2000;                                // 💡 개중요! Child 클래스 안에서 'int x = 2000;'으로 'x'라는 인스턴스 변수를 '또' 선언했다.
                                                           // 이건 부모 클래스 Parent의 'x'와는 '별개의' 변수다!
                                                           // Child 객체를 만들면, Parent의 x(물려받은 것)와 Child의 x(새로 선언한 것) 두 개가 존재한다.
                                                           // 이 현상을 '변수 가려짐 (variable shadowing)'이라고 부른다.
                                                           // Child 클래스 내부에서 'x'라고만 쓰면 Child의 x(2000)가 우선된다.
                                                           // Parent의 x에 접근하려면 'super.x'라고 명시해야 한다.

    Child() {                                               // 매개변수 없는 Child 클래스의 '기본 생성자'다.
        this(5000);                                         // 💡 중요! 현재 클래스의 다른 생성자(매개변수 있는 Child(int x))를 호출한다.
                                                            // 이 호출이 먼저 실행되면서, 아래의 Child(int x) 생성자로 이동한다.
                                                            // 참고로, 이 'this()' 호출 전에 'super()' (부모 생성자 호출)가 암묵적으로 먼저 일어난다!
                                                            // 즉, Child() -> this(5000) -> super() (Parent() 호출) -> Parent(500) 순으로 호출된다.
    }

    Child(int x) {                                           // 정수형 매개변수 'x'를 받는 Child 클래스의 '생성자'다.
                                                           // 💡 중요! 이 생성자 실행 전에 'super()' (매개변수 없는 Parent() 생성자)가 먼저 암묵적으로 호출된다.
                                                           // super() 호출 -> Parent() 호출 -> Parent(500) 호출 -> super.x (Parent의 x)가 500으로 초기화된다.
                                                           // 이후 Child(int x)의 코드인 this.x = x;가 실행된다.
        this.x = x;                                     // 매개변수로 받은 'x' 값을 현재 Child 객체의 인스턴스 변수 'this.x'에 할당한다.
                                                                      // 만약 Child()를 통해 호출되면 this.x는 5000이 된다.
                                                                      // 이 'x'는 Child의 'x' (2000으로 초기화되었던 그 x)를 덮어씌운다.
    }
}


답
500


## 💡 변수 가려짐과 생성자 호출 흐름 정리

### 원본 설명
- 변수 `x`:  
  Child 클래스에 새로 선언된 `x`는 `2000`으로 초기화됨.  
  Parent의 `x`와 별개의 변수이며, Child 내부에서는 Child의 `x`가 우선 참조됨 (변수 가려짐).

- `Child()` 생성자:  
  `this(5000)` 호출 (Child의 다른 생성자를 호출).

- `Child(int x)` 생성자:  
  실행 전에 암묵적으로 `super()` (Parent의 기본 생성자) 호출됨.  
  Parent 생성자에서 Parent의 `x`가 `500`으로 설정됨.  
  이후, 매개변수 `x` 값을 Child 자신의 `x`에 할당.

---

### 💡 핵심 요약 및 동작 방식

#### 생성자 호출 체인
1. `new Child()` 생성 시,  
2. `Child()` → `this(5000)` 호출 (Child의 다른 생성자)  
3. → `super()` 호출 (자동으로 Parent의 기본 생성자 `Parent()` 호출)  
4. → `Parent()` 내에서 `this(500)` 호출 (Parent의 다른 생성자)  
5. → `Parent(int x)` 실행, 여기서 **Parent의 `x`**가 `500`으로 설정됨  
6. Parent 생성자 종료 후, 다시 `Child(int x)`로 돌아와 `this.x = 5000;` 실행  
7. 여기서 **Child의 `x`**가 `5000`으로 설정됨

---

#### 변수 가려짐 (Variable Shadowing)
- Parent 클래스: `int x = 100;`
- Child 클래스: `int x = 2000;` (별도로 선언)  
- Child 객체는 **두 개의 `x` 변수**를 가짐:  
  - `Parent.x` (부모 클래스 변수)  
  - `Child.x` (자식 클래스 변수)

---

#### 메서드 호출 시 변수 참조
- Child 객체에서 `getX()` 호출 시, Parent 클래스의 `getX()`가 실행됨  
- 이 메서드는 **Parent 자신의 `x`** 값을 반환 (`500`)  
- Child의 `x` 값 (`5000`)은 반환되지 않음

---

### 📝 결론
- `new Child()` 실행 시:  
  - Parent의 `x` = `500`  
  - Child의 `x` = `5000`  
- `Child` 객체로 `getX()` 호출 시 → `500` 반환 (부모 변수 참조)  
- 핵심: **super()와 this() 생성자 호출 순서 + 변수 가려짐 현상** 이해가 중요  
- 확인용: main 함수에서 `Child` 객체 생성 후 각 `x` 값 출력해 보면 명확해짐


 -----------------------------------------------------------------------------------------
