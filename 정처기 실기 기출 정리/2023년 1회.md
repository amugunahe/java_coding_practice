## ✅ 정보처리기사 실기 – 웹 기반 기술 용어 정리

### 문제 1) 다음 괄호 안에 들어갈 용어를 영문 약어로 쓰시오

**문제**  
`()은 웹페이지를 새로 고치지 않고 서버로부터 데이터를 비동기적으로 가져오는 기술이다.`  
Javascript를 이용하여 비동기적으로 서버에 데이터를 요청하고 응답을 처리하는 기술이다.  
Javascript를 이용하여 서버로부터 XML 또는 JSON 형식의 데이터를 비동기적으로 받아오는 프로그래밍 기법이다.

**답:** `AJAX`

---

## 📌 관련 개념 정리

### 🔹 REST (Representational State Transfer)
- 웹 서비스와 웹 API를 설계할 때 사용되는 **아키텍처 스타일**.
- 클라이언트-서버 통신에서 **자원(Resource)** 을 정의하고, 자원에 대한 **주소(URL)** 를 지정하는 방법을 제공함.
- **특징:**
  - 무상태(Stateless)
  - 캐시 가능(Cacheable)
  - 계층형 구조
  - 인터페이스 일관성

#### 🔸 전송 데이터 형식
- **JSON (JavaScript Object Notation)**: 키-값 쌍으로 구성된 데이터 형식. 가볍고 가독성이 좋으며 대부분의 프로그래밍 언어에서 지원됨.
- **XML (eXtensible Markup Language)**: 사용자 정의 태그를 이용해 데이터를 구조화. SOAP 등에서 주로 사용됨.
- **YAML (YAML Ain’t Markup Language)**: 구성 파일 작성에 자주 사용되는 데이터 직렬화 형식. 들여쓰기로 구조 표현.
- **CSV (Comma-Separated Values)**: 쉼표(,)로 필드를 구분하는 간단한 텍스트 기반 데이터 형식.

---

### 🔹 SOAP (Simple Object Access Protocol)
- 웹 서비스에서 데이터를 교환하기 위해 사용되는 **XML 기반 메시지 프로토콜**.
- HTTP, HTTPS, SMTP 등을 통해 **네트워크 상에서 XML 기반의 메시지를 교환**함.
- **플랫폼 및 언어 독립적**임.

#### 🔸 SOAP 구성 요소
- **SOAP**: XML 기반의 메시지를 HTTP/HTTPS 등을 통해 주고받는 **프로토콜**.
- **UDDI (Universal Description, Discovery, and Integration)**: 웹 서비스에 대한 **비즈니스 목록 등록**을 위한 XML 기반 규격.
- **WSDL (Web Services Description Language)**: 웹 서비스의 **기능, 데이터 형식, 통신 방식** 등을 정의하는 **기술 언어(XML 기반)**.



-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 네트워크 교환 방식 정리

### 문제 2) 다음 괄호 안에 들어갈 용어를 쓰시오

#### (1)
**문제:**  
물리적인 연결 선로가 아니라 **데이터 패킷이 전송될 경로를 미리 설정**하는 방식을 말한다.  
전송을 시작하기 전에 데이터가 송신자에서 수신자까지 이동할 경로를 설정하고,  
그 경로를 통해 데이터 패킷들이 순차적으로 전달된다.  
이 방식은 **데이터의 순서를 보장**하며, **신뢰성이 높은 통신**을 제공하지만,  
전송 경로를 미리 설정하는 과정으로 인해 **초기 세팅에 시간이 필요**하다는 단점이 있다.

**답:** `가상회선 방식`

---

#### (2)
**문제:**  
각각의 패킷이 **독립적으로 경로를 찾아 수신자에게 전달되는 방식**이다.  
이 방식에서는 패킷들이 **서로 다른 경로를 통해 전달**될 수 있으며,  
결과적으로 **도착하는 순서가 달라질 수 있다**.  
이 방식은 **패킷의 독립성** 때문에 **유연성이 높고**,  
**네트워크 혼잡 상태에 대응 가능**하다는 장점이 있다.  
그러나 **패킷의 순서 보장이나 손실 보장**이 없으므로,  
이러한 측면에 대한 별도의 관리가 필요하다.

**답:** `데이터그램 방식`

---

## 📌 관련 개념 정리

### 🔹 교환 방식 분류

#### ▶ 회선 교환 (Circuit Switching)
- 통신을 시작하기 전에 **송수신자 간에 전용 회선을 설정**.
- 설정된 회선을 통해 **연속적인 데이터 전송** 가능.
- **전화 통신에 주로 사용됨.**
- 장점: 실시간성, 고정 대역폭 확보  
- 단점: 회선 비효율, 연결 설정 시간 소요

---

#### ▶ 축적 교환 (Store and Forward)

##### 🔸 1. 메시지 교환 (Message Switching)
- 전체 메시지를 저장한 후 다음 노드로 전달.
- 단위: 메시지
- **지연 시간이 큼** (전체 메시지를 저장하고 전송)

##### 🔸 2. 패킷 교환 (Packet Switching)
- 메시지를 일정한 **패킷 단위로 분할**하여 전송.
- 단위: 패킷  
- 교환 방식:
  - **데이터그램 방식 (Datagram)**  
    - 각 패킷이 독립적으로 전송됨.  
    - 경로는 매번 달라질 수 있음.  
    - **순서 보장 X, 유연성 O**
  
  - **가상회선 방식 (Virtual Circuit)**  
    - 통신 전에 논리적인 경로 설정  
    - **모든 패킷이 동일한 경로로 전송**됨  
    - **순서 보장 O, 설정 지연 존재**


-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 보안 프로토콜 정리

### 문제 3) 다음에서 설명하는 답을 작성하시오

**문제 설명:**  
- VPN 연결을 생성하는 데 사용되는 프로토콜이다.  
- 마이크로소프트의 **PPTP**와 시스코의 **L2F**를 결합해 만들어졌다.  
- 데이터를 **안전하게 터널링**하는 기능을 제공한다.  
- 그러나 **자체적으로 암호화를 제공하지 않으며**,  
  일반적으로 **IPsec과 함께 사용**되어 데이터의 암호화를 보장하고,  
  **보안성이 향상된 VPN 연결**을 제공한다.

**답:** `L2TP` (Layer 2 Tunneling Protocol)

---

## 📌 관련 개념 정리

### 🔹 보안 관련 주요 프로토콜

| 프로토콜 | 설명 |
|----------|------|
| **SSL / TLS** | 웹 브라우저와 서버 간 **암호화된 연결 제공**<br>HTTPS를 통해 웹 트래픽을 **안전하게 전송** |
| **IPsec** | IP 네트워크에서 **데이터의 기밀성, 무결성, 인증** 보장을 위한 프로토콜 |
| &nbsp;&nbsp;&nbsp;• AH (Authentication Header) | **무결성, 인증** 제공 (암호화 기능 없음) |
| &nbsp;&nbsp;&nbsp;• ESP (Encapsulating Security Payload) | **무결성, 인증, 기밀성** 제공 |
| **SSH (Secure Shell)** | 원격 컴퓨터에 **안전하게 접속 및 명령 실행** |
| **PGP (Pretty Good Privacy)** | **이메일 암호화** 및 **디지털 서명** 기능 제공 |
| **Kerberos** | 클라이언트와 서버 간의 **상호 인증**을 제공하는 **네트워크 인증 프로토콜** |
| **S/MIME (Secure / Multipurpose Internet Mail Extensions)** | 이메일의 **암호화**와 **디지털 서명**을 위한 표준 |

---

### 🔹 L2TP (Layer 2 Tunneling Protocol)
- **PPTP**(Point-to-Point Tunneling Protocol, MS)와  
  **L2F**(Layer 2 Forwarding, Cisco)를 기반으로 개발됨.
- **VPN 연결 시 터널링을 위한 프로토콜**.
- **암호화 기능은 없음**, 따라서 일반적으로 **IPsec과 함께 사용**하여  
  **기밀성과 무결성 보장**.

-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 네트워크 보안 프로토콜 및 포트 정리

### 문제 4) 다음에서 설명하는 답을 작성하시오

**문제 설명:**  
- 네트워크 상에서 **다른 컴퓨터에 로그인하거나 원격에서 명령을 실행할 수 있는 애플리케이션 프로토콜**이다.  
- 이 프로토콜은 주로 **원격 컴퓨터 관리**에 사용되며, **보안성이 뛰어나 데이터의 무단 접근 및 변조를 방지**한다.  
- 인터넷을 통해 데이터를 전송할 때, 모든 트래픽(명령과 응답, 로그인 정보, 파일 전송 등)을 **암호화하여 전송**한다.  
- **22번 포트**를 사용한다.

**답:** `SSH` (Secure Shell)

---

## 📌 관련 개념 정리

### 🔹 SSH (Secure Shell)
- **보안성이 강화된 원격 접속 프로토콜**
- **명령 실행, 파일 전송, 로그인 정보** 등을 **암호화하여 전송**
- **Telnet**과 유사하지만, Telnet은 **암호화되지 않음**
- **22번 포트 사용**
- 주로 **리눅스/유닉스 서버 원격 관리**에 사용

---

### 🔹 주요 포트 번호 정리

| 포트 번호 | 프로토콜 | 설명 |
|-----------|----------|------|
| 20, 21     | **FTP**     | 파일 전송 (20: 데이터, 21: 제어) |
| 22         | **SSH**     | 원격 로그인, 명령 실행 (암호화됨) |
| 23         | **Telnet**  | 원격 로그인 (비암호화) |
| 25         | **SMTP**    | 이메일 전송 |
| 53         | **DNS**     | 도메인 이름 해석 |
| 80         | **HTTP**    | 웹 페이지 전송 |
| 110        | **POP3**    | 이메일 수신 (받기 전용) |
| 143        | **IMAP**    | 이메일 수신 (서버와 동기화) |
| 443        | **HTTPS**   | 암호화된 웹 페이지 전송 (SSL/TLS 기반) |


-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 악성코드 및 서비스 공격 유형 정리

### 문제 5) 아래 설명에 대한 알맞은 답을 쓰시오

#### (1)
- 네트워크를 통해 **스스로 복사하고 분산되는 독립적인 프로그램**  
- 네트워크 취약점을 이용하여 **다른 시스템으로 전파**됨  
- 감염된 시스템의 리소스를 사용해 **네트워크 장애나 속도 저하** 유발  
- **사용자의 실행 없이도 자동으로 전파**

**답:** `웜 (WORM)`

---

#### (2)
- 사용자가 유용하거나 흥미로운 프로그램으로 위장  
- 사용자가 실행하면 **악성 행위 수행**  
- **개인 정보 탈취**, 시스템 제어권 탈취 등의 피해 발생

**답:** `트로이목마 (TROJAN HORSE)`

---

#### (3)
- 다른 프로그램에 **붙어서 감염**되는 악성코드  
- 감염된 프로그램이 실행되면 함께 실행되어 **시스템을 감염시킴**  
- **파일 삭제, 시스템 설정 변경** 등의 피해 발생  
- **사용자의 실행이 필요**함 (웜과의 차이점)

**답:** `바이러스 (VIRUS)`

---

## 📌 관련 개념 정리

### 🔹 서비스 공격 유형 (DoS / DDoS)

#### ▶ DoS (Denial of Service, 서비스 거부 공격)
- 하나의 시스템에서 다수의 요청을 보내 **서버 과부하 유발**
- 주요 기법:
  - `Smurf Attack`
  - `SYN Flooding`
  - `UDP Flooding`
  - `Ping Flooding`
  - `Ping of Death`
  - `Teardrop Attack`
  - `LAND Attack`

#### ▶ DDoS (Distributed Denial of Service, 분산 서비스 거부 공격)
- 여러 대의 시스템을 통해 동시에 공격 수행  
- 좀비 PC(봇넷)를 이용해 대규모 트래픽 유발

---

## 📌 기타 보안 공격 용어

| 공격 유형 | 설명 |
|-----------|------|
| **피싱 (Phishing)** | 가짜 웹사이트나 이메일로 사용자의 정보를 유도 |
| **파밍 (Pharming)** | DNS 변조 등을 통해 **정상 웹사이트로 가장** |
| **스니핑 (Sniffing)** | 네트워크 트래픽 **몰래 수집** |
| **스미싱 (Smishing)** | 문자메시지를 이용한 피싱 |
| **큐싱 (Qshing)** | QR코드를 통한 악성 사이트 유도 |
| **랜섬웨어 (Ransomware)** | 파일 암호화 후 **금전 요구** |
| **키로거 (Key Logger)** | 사용자의 **키보드 입력**을 기록하여 정보 탈취 |
| **SQL 삽입 (SQL Injection)** | 웹 입력값에 **악의적인 SQL문 삽입** |
| **XSS (Cross Site Scripting)** | 웹사이트에 **악성 스크립트 삽입** |

---

### 🔹 기타 사이버 공격 기법

- **무작위 대입 공격 (Brute Force)**  
- **스피어 피싱 (Spear Phishing)**: 특정 대상에게 정밀하게 공격  
- **APT (Advanced Persistent Threat)**: **지능적 지속 위협**, 장기간 은밀히 침투  
- **제로데이 공격 (Zero-day Attack)**: **발견되자마자 즉시 이용**되는 보안 취약점 공격  
- **백도어 (Backdoor)**: 시스템에 **은밀히 접근할 수 있는 비정상적인 통로**  
- **레인보우 테이블 공격 (Rainbow Table Attack)**: 해시 값을 빠르게 역산하는 공격  
- **CSRF (Cross Site Request Forgery)**: 사용자의 권한으로 **의도치 않은 요청을 수행**

-----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – 네트워크 프로토콜 정리

### 문제 6) 다음에서 설명하는 프로토콜을 영문 약어로 쓰시오

**문제 설명:**  
- 인터넷 프로토콜 스위트의 **핵심 프로토콜 중 하나**  
- 네트워크 컴퓨터가 **정보를 교환하거나 문제를 보고**할 때 사용됨  
- 운영 중인 네트워크의 **문제 진단, 오류 메시지 전송, 정보 요청** 등에 사용  
- **일반적인 데이터 전송에는 사용되지 않음**  
- TCP, UDP 등 다른 프로토콜과 함께 동작하여 네트워크 운영을 지원

**답:** `ICMP` (Internet Control Message Protocol)

---

## 📌 관련 개념 정리

### 🔹 ICMP (Internet Control Message Protocol)
- **네트워크 상태 보고 및 오류 알림**을 위한 제어 메시지 프로토콜  
- **데이터 전송이 아닌 제어/진단 목적**  
- **핑(Ping), 트레이서트(Traceroute)** 등의 도구에서 사용  
- **TCP/UDP와 함께 작동**, 네트워크의 원활한 운영 지원  
- IP 프로토콜과 함께 작동하며, **IP 패킷의 일부로 포함되어 전송됨**

---

## 📌 OSI 7계층 및 대표 프로토콜

| 계층 | 프로토콜 | 설명 |
|------|----------|------|
| **7. 응용계층** |  |
| HTTP (80) | 웹 브라우저와 서버 간의 데이터 전송 |
| SMTP (25) | 이메일 전송 |
| FTP (20/21) | 파일 전송 |
| DNS (53) | 도메인 이름 ↔ IP 주소 변환 |
| SNMP (161) | 네트워크 장치의 모니터링 및 관리 |
| **4. 전송계층** |  |
| TCP | 연결 지향, **신뢰성 있는 데이터 전송** |
| UDP | 비연결형, **빠르지만 신뢰성은 낮음** |
| SCTP | TCP + UDP의 특징을 결합한 프로토콜 |
| **3. 네트워크 계층** |  |
| IP | 데이터 전송을 위한 기본 주소 지정 |
| **ICMP** | **제어 메시지, 오류 보고, 진단용** |


-----------------------------------------------------------------------------------------
네트워크 계층
- IP: 네트워크 간의 패킷 라우팅과 주소 지정을 담당하는 프로토콜
- ICMP: 오류 메시지 전송과 제어 메시지 전송을 수행하는 프로토콜
- RIP: 동적 라우팅 프로토콜
- OSPF: 내부 게이트웨이 프로토콜
- BGP: 외부 게이트웨이 간의 경로 선택을 위한 프로토콜
- ARP: IP 주소와 MAC 주소 간의 매핑을 수행하는 역할 
- RARP: ARP 반대 역할 

데이터 링크 계층
- PPP: 포인트 투 포인트 연결에서 데이터 전송을 관리하는 프로토콜
- HDLC: 동기화 및 흐름 제어, 오류 검출 및 복구를 수행하는 프로토콜
- L2TP: VPN 연결을 구성하기 위해 사용되는 프로토콜

-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 디자인 패턴 정리

### 문제 7) 다음에서 설명하는 디자인 패턴을 쓰시오

**문제 설명:**  
- 소프트웨어 디자인 패턴 중 하나  
- 어떤 객체에 대한 **접근을 제어**하거나 **간접적으로 이루어지도록 하는 패턴**  
- **중개자 역할을 하는 객체(프록시)**를 통해 실제 객체에 접근  
- 내부적으로 **실제 객체의 참조**를 가지고 있으며  
  클라이언트의 요청을 받아 **실제 객체에 전달하고 결과를 반환**

**답:** `PROXY 패턴`

---

## 📌 관련 개념 정리

### 🔹 프록시 패턴 (Proxy Pattern)
- **구조 패턴 (Structural Pattern)** 중 하나  
- **실제 객체에 대한 접근을 제어**하거나 **대리 수행**  
- **목적**: 객체에 직접 접근하지 않고 중간 객체를 통해 기능 제공

#### ▶ 주요 목적
| 유형             | 설명 |
|------------------|------|
| **가상 프록시**     | 리소스가 크거나 무거운 객체를 **필요할 때만 생성** |
| **보호 프록시**     | **접근 권한 제어** (예: 사용자 인증) |
| **원격 프록시**     | 네트워크를 통해 원격 객체에 접근 |
| **스마트 프록시**   | 접근 전/후에 **부가 기능 추가** (예: 캐싱, 로깅)

#### ▶ 구조

Client → Proxy → RealSubject

- `Proxy`: RealSubject를 참조하고 요청을 전달
- `RealSubject`: 실제 기능 수행 객체
- `Client`: 프록시를 통해 실제 객체를 사용

---

### 🔹 관련 디자인 패턴 비교

| 패턴         | 주요 역할 |
|--------------|-----------|
| **Proxy**    | **접근 제어, 대리자** |
| **Adapter**  | 인터페이스 변환 |
| **Decorator**| 기능 확장 (랩핑 구조) |
| **Facade**   | 서브시스템에 대한 단순 인터페이스 제공 |


-----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – 데이터베이스 기본 용어 정리

### 문제 8) 다음은 데이터베이스에 관련된 내용이다. 각 괄호에 맞는 답을 쓰시오

#### (1)
- 데이터 테이블의 **한 행(row)**을 말한다.  
- 특정 테이블에 속하는 **한 개체(entity)에 대한 정보를 나타내는 데이터 집합**이다.  

**답:** `튜플 (Tuple)`

---

#### (2)
- 특정 시점에서의 **관계(Relation)** 또는 **테이블의 상태**를 나타낸다.  
- 즉, 테이블에 **현재 저장되어 있는 실제 데이터**들의 모임이다.

**답:** `릴레이션 인스턴스 (Relation Instance)`

---

#### (3)
- 특정 테이블의 **행(row) 수**를 나타낸다.  
- 즉, 테이블에 존재하는 **튜플의 개수**이다.  

**답:** `카디널리티 (Cardinality)`

---

## 📌 관련 개념 정리

| 용어 | 설명 |
|------|------|
| **릴레이션 (Relation)** | 테이블 자체, 구조(스키마 포함) |
| **릴레이션 스키마 (Relation Schema)** | 릴레이션의 구조, 속성(열)의 이름과 타입 정의 |
| **릴레이션 인스턴스 (Relation Instance)** | 특정 시점의 테이블에 저장된 실제 데이터 (행들의 집합) |
| **튜플 (Tuple)** | 테이블의 한 행, 하나의 레코드 |
| **속성 (Attribute)** | 테이블의 열(Column), 데이터 항목의 이름 |
| **카디널리티 (Cardinality)** | 테이블에 포함된 튜플(행)의 수 |
| **차수 (Degree)** | 테이블에 포함된 속성(열)의 수 |

-----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 데이터베이스 스키마 정리

### 문제 9) 다음은 스키마와 관련된 내용이다. 괄호에 알맞은 답을 쓰시오

#### (1)
- 사용자 또는 애플리케이션의 관점에서 본 **데이터베이스의 뷰(View)**  
- 여러 개의 (1)이 존재할 수 있으며,  
  각각은 **사용자 그룹의 요구를 반영**하여 데이터베이스의 **일부만 보여주는 역할**을 한다.  

**답:** `외부 스키마 (External Schema)`

---

#### (2)
- 전체 데이터베이스의 **구조와 제약 조건을 정의**함  
- 모든 사용자와 애플리케이션이 **공통적으로 참조**하는 **데이터 통합 뷰** 제공  
- 데이터베이스의 모든 개체, 속성, 관계 등을 정의  

**답:** `개념 스키마 (Conceptual Schema)`

---

#### (3)
- 데이터가 **물리적으로 저장되는 방식**을 설명  
- **인덱싱, 해싱, 접근 경로, 저장 공간 할당 등 물리적 구조**를 정의  
- DBMS가 실제 데이터를 저장하고 관리하는 방법을 기술  

**답:** `내부 스키마 (Internal Schema)`

---

## 📌 관련 개념 정리

### 🔹 스키마(Schema)의 3계층 구조 (ANSI-SPARC 3계층 아키텍처)

| 스키마 계층 | 설명 | 독립성 |
|-------------|------|--------|
| **외부 스키마** | 사용자 관점의 **부분적 뷰** | 🔹 논리적 독립성 |
| **개념 스키마** | 전체 데이터베이스의 논리적 구조 및 제약조건 정의 | |
| **내부 스키마** | 데이터의 **물리적 저장 방식** 정의 (인덱스, 해싱 등) | 🔹 물리적 독립성 |

---

## 📌 데이터베이스 설계 단계 요약

| 단계 | 설명 | 주요 산출물 |
|------|------|-------------|
| **개념적 설계** | 현실 세계 → 데이터 모델로 추상화 | E-R 다이어그램, 트랜잭션 정의 |
| **논리적 설계** | DBMS에 맞는 논리 모델 변환 | 정규화된 테이블, 논리적 스키마 |
| **물리적 설계** | 저장 구조 및 성능 고려 | 인덱스 설계, 저장소 구조, 물리적 스키마 |
 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 제어 흐름 그래프와 테스트 커버리지

### 문제 10) 다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 순서를 쓰시오

---

### 📌 제시된 흐름도

(1) POINTER = FALSE
↓
(2) X > Y ? ───▶ YES ──▶ (3) POINTER = TRUE
↓ NO
(4) X = X + 1
↓
(5) CALL SUB
↓
(6) X > Y ? ──▶ YES ──▶ (7) PRINT RESULT



---

### 📌 분기 커버리지(Branch Coverage)란?

- **모든 조건문의 true/false 분기**를 **최소한 한 번씩 수행**하도록 하는 테스트 기법
- 즉, 각 조건문에서 **YES 경로, NO 경로를 모두 포함**해야 함

---

### 🔍 조건문 및 분기 분석

- 조건문 ①: **(2) X > Y?** → YES → (3), NO → (4)  
- 조건문 ②: **(6) X > Y?** → YES → (7), NO 없음 (종료)

**분기 커버리지를 위해서는 (2)번 조건에서 YES와 NO 모두 수행해야 함.**

---

### ✅ 정답: 분기 커버리지를 만족하는 경로

| 순서 | 설명 |
|------|------|
| `1 → 2 → 3 → 4 → 5 → 6 → 1` | (2)에서 YES 분기 |
| `1 → 2 → 4 → 5 → 6 → 7`     | (2)에서 NO 분기, (6)에서 YES 분기 |
| 또는 `1 → 2 → 3 → 4 → 5 → 6 → 7` | YES 후 진행, (6)에서 YES |
| 또는 `1 → 2 → 4 → 5 → 6 → 1`     | NO 후 진행, (6)에서 조건 실패 후 다시 루프 |

---

### ✅ 가능한 정답 예시

- `1234561`, `124567`
- `1234567`, `1234561`

> 위 경로들 모두 조건문 (2)의 YES/NO 분기를 모두 포함하며, 분기 커버리지를 충족함.

---

### 📌 정리

- **분기 커버리지** = 모든 분기 조건의 **True/False 모두 수행**
- 문제에서 요구한 경로들은 **분기 노드(2)의 YES/NO 분기 모두 포함**하기 때문에 적절함
 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – SQL 기본문제

### 문제 11) [학생] 테이블에서 학생 이름이 '민수'인 튜플을 삭제하는 쿼리를 작성하시오.

```sql
DELETE FROM 학생 WHERE 이름 = '민수';

- **DELETE 문**은 데이터베이스에서 특정 조건에 맞는 행(튜플)을 삭제하는 SQL 명령어입니다.
- 구문은 `DELETE FROM 테이블명 WHERE 조건;` 형태로 작성합니다.
- 여기서는 학생 테이블에서 이름이 '민수'인 행을 삭제하기 위해  
  `DELETE FROM 학생 WHERE 이름 = '민수';` 라고 작성합니다.
- **WHERE 절이 없으면 테이블의 모든 데이터가 삭제되므로 주의**해야 합니다.
 -----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – SQL GROUP BY와 HAVING 문제

### 문제 12) 다음 성적 테이블에서 조건에 맞게 SQL을 작성하시오.

| 순번 | 과목이름  | 점수 |
|-------|------------|------|
| 1     | DB         | 95   |
| 2     | DB         | 92   |
| 3     | NETWORK    | 90   |
| 4     | S/W        | 70   |
| 5     | NETWORK    | 65   |
| 6     | S/W        | 95   |

- 조건:  
  - 반드시 `GROUP BY`, `HAVING` 사용  
  - `WHERE` 절 사용 불가  
  - `SELECT`절에 별칭 사용  
  - 집계 함수 사용

---

### 정답 SQL

```sql
SELECT 
  과목이름, 
  MIN(점수) AS 최소점수, 
  MAX(점수) AS 최대점수
FROM 성적
GROUP BY 과목이름
HAVING AVG(점수) >= 90;
해설
GROUP BY 과목이름 으로 과목별로 묶음

MIN(점수), MAX(점수)로 각 그룹별 최소, 최대 점수 출력

HAVING AVG(점수) >= 90으로 그룹별 평균 점수가 90 이상인 과목만 필터링

WHERE는 그룹화 이전 필터링에 사용되므로, 그룹별 조건은 반드시 HAVING 절을 사용

별칭(AS 최소점수, AS 최대점수)으로 결과 컬럼 이름 지정

 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 자바 코드 결과 분석

### 문제 13) 다음 자바코드의 결과값을 쓰시오.

```java
class TestClass {
    public int a = 20;
    static int b = 0; 
}

class Main {
    public static void main(String[] args){
        int a;
        a = 10; 
        TestClass.b = a;
        TestClass tc = new TestClass();
        System.out.println(TestClass.b++); // 10 출력 후 b는 11로 증가
        System.out.println(tc.b);          // 11 출력 (static 변수 b는 클래스 공유)
        System.out.println(a);             // 10 출력
        System.out.print(tc.a);            // 20 출력 (인스턴스 변수 a)
    }
}

답
10
11
10
20

해설
TestClass.b = a; 에서 static 변수 b에 a값 10이 할당됨

System.out.println(TestClass.b++); 는 후위 증가 연산자이므로
출력은 현재 값 10, 이후 b는 11로 증가

System.out.println(tc.b); 는 static 변수 b를 참조하므로 11 출력

System.out.println(a); 는 지역 변수 a값 10 출력

System.out.print(tc.a); 는 인스턴스 변수 a값 20 출력

 -----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – C언어 출력 결과 분석

### 문제 14) 다음 C언어 코드의 결과값을 쓰시오.

```c
char a[] = "Art";
char *p = NULL;
p = a;

printf("%s\n", a);
printf("%c\n", *p);
printf("%c\n", *a);
printf("%s\n", p);

for(int i = 0; a[i] != '\0'; i++)
    printf("%c", a[i]);

답
Art
A
A
Art
Art

해설
char a[] = "Art"; : 문자 배열 a에 문자열 "Art" 저장

char *p = NULL; p = a; : 포인터 p가 a의 시작 주소를 가리킴

출력문	설명
printf("%s\n", a);	문자열 전체 출력 → Art
printf("%c\n", *p);	p가 가리키는 문자의 첫 글자 → A
printf("%c\n", *a);	배열 이름은 주소 → 첫 글자 출력 → A
printf("%s\n", p);	p는 문자열 시작 주소 → 문자열 출력 → Art
for 루프 내부 printf("%c", a[i]);	a 배열을 문자 단위로 순서대로 출력 → Art

핵심 포인트
문자열 배열 이름(a)은 배열의 첫 요소 주소로 사용됨

%s는 문자열 출력, %c는 단일 문자 출력

포인터 p와 배열 이름 a는 같은 문자열 시작 위치를 가리킴

for 루프는 \0 널 종료 문자를 만나기 전까지 문자열 출력

 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – C언어 코드 결과 분석

### 문제 15) 다음 C언어 코드의 결과값을 쓰시오

```c
char *a = "qwer";
char *b = "qwtety";

for (int i = 0; a[i] != '\0'; i++) {
    for (int j = 0; b[j] != '\0'; j++) {
        if (a[i] == b[j]) 
            printf("%c", a[i]);
    }
}

답
qwe

해설
문자열 a = "qwer", b = "qwtety"

이중 for문으로 a의 각 문자와 b의 각 문자를 비교

조건 if (a[i] == b[j]) 일치하면 문자 출력

문자 비교 및 출력
a[i]	b 문자열 내 포함 여부	출력 횟수 및 문자
'q'	b에 있음 (b[0] = 'q')	'q' 1회 출력
'w'	b에 있음 (b[1] = 'w')	'w' 1회 출력
'e'	b에 있음 (b[4] = 'e')	'e' 1회 출력
'r'	b에 없음	출력 없음

주의점
for문 조건에 콤마(,)가 아닌 세미콜론(;)을 사용해야 올바른 문법임

출력된 결과는 일치하는 문자들을 순서대로 연결한 "qwe"
 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – C언어 이진수 → 십진수 변환 코드 빈칸 채우기

### 문제 16) 다음 코드는 이진수를 십진수로 변환하는 코드이다. 빈칸에 알맞은 답을 쓰시오.

```c
int input = 101110;
int di = 1;
int sum = 0;
while (1) {
    if(input == 0) break;
    else {
        sum = sum + (input (1) (2)) * di; 
        di = di * 2;
        input = input / 10;
    }
}
printf("%d", sum);


답변
빈칸 위치	정답	설명
(1)	%	input % 10 → input의 마지막 자리 숫자 추출
(2)	10	input / 10 → 마지막 자리 숫자 제거 (몫)

완성된 코드

int input = 101110;
int di = 1;
int sum = 0;
while (1) {
    if (input == 0) break;
    else {
        sum = sum + (input % 10) * di;
        di = di * 2;
        input = input / 10;
    }
}
printf("%d", sum);

설명
input % 10 : 이진수 숫자의 가장 오른쪽 자리(1자리)를 가져온다

input / 10 : 이진수 숫자의 오른쪽 자리 하나를 없앤다

di는 2의 거듭제곱으로 자리값을 나타내며, 매 반복마다 2배가 된다

결과적으로 이진수 101110은 십진수 46으로 변환됨
 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – C언어 변수명 채우기 문제

### 문제 17) 다음 코드에 알맞은 변수명을 쓰시오

```c
void swap(int ary[], int idx1, int idx2){
    int tmp = ary[idx1];
    ary[idx1] = ary[idx2];
    ary[①] = tmp;
}

void sort(int ary[], int len){
    for(int i = 0; i < len; i++){
        for(int j = 0; j < len - i - 1; j++){
            if(ary[j] > ary[j+1]){
                swap(ary, j, j+1);
            }
        }
    }
}

void main(){
    int ary[] = {15, 5, 20, 11, 8};
    int nx = 5;
    sort(ary, ②);
    for(int i = 0; i < nx; i++){
        printf("%d\n", ary[i]);
    }
}

답
위치	변수명
①	idx2
②	nx

해설
swap 함수에서 tmp에 저장한 값을 ary[idx2] 위치에 다시 넣어야 하므로 ①은 idx2

sort 함수 호출 시 배열 길이를 나타내는 변수인 nx를 넘겨야 하므로 ②는 nx
 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 파이썬 집합(Set) 출력 결과

### 문제 18) 다음 파이썬 코드의 출력 결과를 쓰시오

```python
a = {'한국', '중국', '일본'}
a.add('베트남')
a.add('중국')
a.remove('일본')
a.update({'홍콩', '한국', '태국'})
print(a)

답

{'홍콩', '중국', '태국', '한국', '베트남'}
해설
a = {'한국', '중국', '일본'}: 초기 집합

a.add('베트남'): 집합에 '베트남' 추가

a.add('중국'): 이미 있는 요소라 변화 없음

a.remove('일본'): '일본' 삭제

a.update({'홍콩', '한국', '태국'}): 여러 요소 추가 (중복은 무시)

최종 집합: {'홍콩', '중국', '태국', '한국', '베트남'}

집합은 순서가 없으므로 출력 순서는 다를 수 있습니다.

 -----------------------------------------------------------------------------------------
## ✅ 정보처리기사 실기 – 자바 코드 출력 결과 분석

### 문제 19) 다음은 Java로 작성된 프로그램이다. 실행한 출력 결과를 쓰시오.

```java
abstract class Vehicle {
    String name;
    public Vehicle(String val){
        this.name = val;
    }
    public String getName(){
        return "Vehicle name:" + name;
    }
}

class Car extends Vehicle {
    private String name;
    public Car(String val){
        name = super.name = val;
    }
    public String getName(String val) {
        return "Car name: " + val;
    }
    public String getName(byte val[]){
        return "Car name: " + val;
    }
}

// main 메서드 예시
Vehicle obj = new Car("Spark");
System.out.println(obj.getName());
답
nginx
복사
편집
Vehicle name:Spark
해설
Vehicle 클래스의 getName() 메서드는 "Vehicle name:" + name 을 반환한다.

Car 클래스는 Vehicle을 상속하고, getName()을 오버라이딩하지 않았다.

따라서 obj.getName() 호출 시 Vehicle 클래스의 getName()이 실행됨

Car 클래스의 getName(String val)와 getName(byte val[])는 오버로딩 메서드이며,
매개변수가 없으므로 호출되지 않음

결과는 "Vehicle name:Spark" 출력됨

 -----------------------------------------------------------------------------------------

## ✅ 정보처리기사 실기 – 자바 상속 및 생성자 실행 결과

### 문제 20) 다음은 Java로 작성된 프로그램이다. 실행한 출력 결과를 쓰시오.

```java
class Parent {
    int x = 100;
    Parent() {
        this(500);
    }

    Parent(int x) {
        this.x = x;
    }

    int getX() {
        return x;
    }
}

class Child extends Parent {
    int x = 2000;
    Child() {
        this(5000);
    }

    Child(int x) {
        this.x = x;
    }
}

// main 메서드 예시
Child obj = new Child();
System.out.println(obj.getX());

답
500

해설
Child obj = new Child(); 호출 시 Child() 생성자 실행

Child() 생성자에서 this(5000); 호출 → Child(int x) 생성자 실행

Child(int x) 생성자에서 this.x = x;로 Child 클래스 멤버 변수 x를 5000으로 설정

하지만 getX()는 Parent 클래스의 메서드이며, Parent 클래스의 x 변수를 반환한다.

Parent 클래스 생성자 호출 순서:

Child 생성자 실행 시 먼저 Parent() 생성자가 암묵적으로 호출됨

Parent() 생성자는 this(500); 호출 → Parent(int x) 실행 → Parent의 x 값을 500으로 설정

따라서 obj.getX()는 Parent 클래스의 x 값인 500을 반환함

Child의 x 변수와 Parent의 x 변수는 서로 다른 변수임 (변수 숨김, shadowing 현상)

핵심 포인트
생성자 체인에서 부모 클래스 생성자가 먼저 호출되고, 그 과정에서 Parent의 x가 500으로 설정됨

getX() 메서드는 Parent 클래스의 멤버 변수를 반환하기 때문에 500 출력

Child 클래스의 x는 Parent 클래스의 x를 가림(shadowing)

 -----------------------------------------------------------------------------------------
