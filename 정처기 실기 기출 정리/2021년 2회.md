### ✅ 문제 1

네트워크의 구성 및 유지를 위해 기지국이나 액세스 포인트와 같은  
기반 네트워크 장치를 필요로 하지 않고, **멀티 홉 라우팅 기능**에 의해  
무선 인터페이스가 가지는 **통신 거리상의 제약**을 극복하며,  
**노드들의 이동이 자유롭기 때문에 네트워크 토폴로지가 동적으로 변화**되는 특징이 있다.  
응용분야로는 **긴급구조, 긴급회의, 전쟁터에서의 군사 네트워크** 등이 있다.

**➤ 답: Ad-hoc Network**

---

## 📡 Ad-hoc Network – 갓반도 3초 컷 이해

---

### 🤔 뭐냐 이건?

> **Ad-hoc Network**란?  
와이파이 공유기나 기지국 같은 **고정된 장비 없이**  
**노드들끼리 직접 무선으로 연결**해서 네트워크를 만드는 방식이야.

---

### 📦 진짜 쉬운 예시

- **전쟁터**: 기지국 없음. 군인들 장비끼리 바로 연결해서 통신
- **지진 피해 현장**: 통신 인프라 붕괴 → 드론, 구조대 단말기끼리 연결
- **MT 가서 발표자료 공유**: 노트북끼리 직접 연결해서 파일 주고받기

---

### 🔁 핵심 특징 요약

| 특징            | 설명 |
|-----------------|------|
| **인프라 없음**     | 공유기, 기지국 없이 노드들끼리 바로 연결함 |
| **멀티 홉 라우팅** | 멀리 있는 노드랑은 중간 노드를 거쳐서 데이터 전달함 |
| **유동적인 네트워크** | 노드가 이동하거나 꺼져도 자동으로 다시 구성됨 |
| **자율적 구성**     | 알아서 연결, 알아서 라우팅. 중앙 서버 필요 없음 |

---

### 📌 한 줄 요약

**"공유기 없는 와이파이 네트워크"**  
필요한 곳에서, 장비끼리 알아서 연결해서 쓰는 똑똑한 네트워크



------------------------------------------------------------------------------------------------------------

### ✅ 문제 2

다음 (1), (2)에 설명하는 알맞은 답안을 쓰시오

(1): 사용자가 제품/서비스와 **상호작용**할 수 있도록 만들어진 **매개체**  
(2): 사용자 경험의 약자로, 사용자가 어떤 서비스/제품을 **직·간접적으로 이용**하면서 느끼는 **종합적인 만족**

**➤ 답:**
- (1) UI (User Interface)
- (2) UX (User Experience)

---

## 🎨 UI 설계 원칙 – 갓반도 3초 컷 정리

---

### 🤔 UI가 뭐임?

> **UI (User Interface)** = 사용자랑 시스템이 만나는 "접점"  
예: 앱 화면, 버튼, 메뉴, 드롭다운 등 눈에 보이고 조작 가능한 것들

---

### 🧠 핵심 설계 원칙 + 존나 쉬운 예시

| 항목       | 설명                                                                 | 예시 |
|------------|----------------------------------------------------------------------|------|
| **직관성** | 누구나 **처음 봐도** 어떻게 쓰는지 감이 와야 함                            | 카카오톡에서 '말풍선' 누르면 바로 답장 느낌 옴 |
| **유효성** | 사용자가 원하는 걸 **정확히** 할 수 있어야 함                              | 검색창에 입력하면 진짜로 관련 결과가 떠야 함 |
| **학습성** | 써보면 쉽게 **금방 익숙해지는** UI여야 함                                  | 인스타 스토리 올리는 법 – 처음만 어려움, 금방 익힘 |
| **유연성** | 실수해도 복구 가능하고, 다양한 상황에 **융통성 있게 대응** 가능해야 함         | 글 쓰다 끄면 “저장할까요?” 창 떠서 날아가지 않음 |

---

### ✅ 한 줄 요약

> UI는 **보기 좋아야 하고, 누르기 쉬워야 하며, 실수해도 괜찮아야 함**  
> 그래야 진짜로 **"사용자 친화적"**이라고 불림

---

### 💡 UX도 한 줄 정리

- **UX (User Experience)** = 사용자가 UI를 **쓰고 나서 느끼는 전반적 만족도**
- 좋은 UI는 UX를 **편하고 기분 좋게 만듦**  
  (예: 배민에서 3초 만에 결제 끝 → 기분 좋음 → UX 굿)





------------------------------------------------------------------------------------------------------------

### ✅ 문제 3

디자인 패턴 중 **클래스나 서로 상호작용하는 방법이나 책임 분배 방법**을  
정의하는 패턴으로, `Chain of Responsibility`, `Command`, `Iterator`, `Observer` 패턴 등이 있다.

**➤ 답: 행위 패턴 (Behavioral Pattern)**

---
## 🤖 행위 패턴 (Behavioral Pattern) – 갓반도 3초 컷 요약

---

### 🧠 개념 먼저

> **행위 패턴**이란?  
객체들끼리 **일을 어떻게 나눌지**, **서로 어떻게 대화할지** 정해주는 패턴들임.  
즉, 누가 뭘 하고, 누가 누구한테 알려주는지, 역할 분담 & 소통 방식 정의하는 거임.

---

### 🔍 진짜 쉬운 예시들

| 패턴 이름 | 설명 | 존나 쉬운 예시 |
|-----------|------|----------------|
| **Chain of Responsibility** | 요청을 체인처럼 연결된 객체들한테 순서대로 전달함 | 회사에서 문서 결재 → 팀장 → 부장 → 이사 순으로 넘김 |
| **Command** | 명령을 객체로 만들어서 처리함 | 리모컨 버튼 누르면 TV 꺼짐 → 버튼 누름 = 명령 객체 실행 |
| **Iterator** | 컬렉션 내부를 순서대로 접근 가능하게 해줌 | 유튜브 재생목록에서 '다음 영상' 눌러가며 탐색함 |
| **Observer** | 어떤 객체의 상태가 바뀌면 관련된 객체들이 자동으로 반응 | 유튜버가 영상 올리면 구독자한테 자동 알림 옴 |

---

### 🧩 디자인 패턴 분류 간단 요약

- ✅ **생성 패턴**: "객체를 어떻게 만들까?"  
  예: `new` 대신 `Factory` 써서 객체 생성 방식 유연하게
- ✅ **구조 패턴**: "객체를 어떻게 엮을까?"  
  예: `Adapter`로 안 맞는 인터페이스끼리 연결함
- ✅ **행위 패턴**: "객체들이 어떻게 협업할까?"  
  예: `Observer`로 변화 자동 반영되게 알림 주고받음

---

### 💬 한 줄 정리

> 행위 패턴은 **객체들이 "어떻게 같이 일할지" 짜주는 협업 설계도**임  
→ 코드가 더 유연하고, 재사용성도 높아짐!




------------------------------------------------------------------------------------------------------------
### ✅ 문제 4

트랜잭션의 특성 중 **원자성(Atomicity)**에 대해 설명하시오.

**➤ 답:**  
연산의 결과는 **모두 반영되거나 모두 반영되지 않아야 한다.**

---
## 💥 원자성 (Atomicity) – 갓반도 3초 컷 정리

---

### 🧠 개념 먼저

> **원자성(Atomicity)** = 트랜잭션 안의 모든 작업이 **올-or-낫씽(All or Nothing)**  
하나라도 실패하면 **전부 취소(Rollback)** 되고, 전부 성공해야만 **커밋(Commit)** 됨.

---

### 🍜 존나 쉬운 예시: 라면 끓이기

- 트랜잭션: "라면 끓이기" 작업 전체
- 단계: 물 끓이기 → 면 넣기 → 스프 넣기 → 계란 넣기

**👉 면까지 넣고 가스 꺼지면? → 전체 실패! (먹을 수 없음)  
→ 다시 처음부터 시작해야 함!**

> ✅ 전부 성공 = 라면 완성  
> ❌ 중간 실패 = **처음부터 다시 (Rollback)**

---

### 📦 ACID 4대 특성 한눈에 보기

| 특성        | 설명 |
|-------------|------|
| **A - Atomicity (원자성)** | 트랜잭션은 전부 성공하거나, 전부 실패해야 함 |
| **C - Consistency (일관성)** | 트랜잭션 전후 데이터가 항상 유효하고 일관된 상태 유지 |
| **I - Isolation (격리성)** | 동시에 여러 트랜잭션이 실행돼도 서로 간섭하면 안 됨 |
| **D - Durability (지속성)** | 트랜잭션 성공 후엔 시스템 꺼져도 결과는 유지됨 |

---

### 🧪 진짜 쉬운 은행 예시

> **계좌 이체 트랜잭션**  
- A 계좌에서 -10,000원  
- B 계좌에 +10,000원

**→ A는 빠졌는데 B에 안 들어갔음? ❌ 원자성 위반!**  
**→ 둘 다 성공해야 OK, 하나라도 실패하면 모두 취소!**

---

### ✅ 한 줄 요약

> **원자성 = "트랜잭션은 한 덩어리다. 쪼갤 수 없다!"**




------------------------------------------------------------------------------------------------------------
### ✅ 문제 5

**부분 함수적 종속성**을 제거하여 **완전 함수 종속**을 만족하는 정규형이 무엇인지 쓰시오.

**➤ 답:**  
제2정규형 (2NF)

---

## 🧩 제2정규형 (2NF) – 갓반도도 이해하는 정규화

---

### 📌 개념 요약

> **부분 함수적 종속**: 복합 기본키 중 **일부**에만 의존하는 속성이 있는 상태  
> 👉 이걸 제거해서 모든 속성이 **기본키 전체에 종속**되도록 만드는 게 **제2정규형(2NF)**

---

### 🏫 존나 쉬운 예시: 수강 테이블

| 학번 | 과목명 | 교수명 |
|------|--------|--------|
| 1001 | DB     | 김교수 |
| 1001 | OS     | 박교수 |
| 1002 | DB     | 김교수 |

- 기본키: **(학번, 과목명)**  
- 교수명은? ➜ 과목명에만 종속됨 → ❗ **부분 함수적 종속 발생**

---

### 🔨 해결 방법 → 2NF 정규화

✔️ 테이블을 두 개로 나눔:

1. **수강 테이블**  
| 학번 | 과목명 |
|------|--------|
| 1001 | DB     |
| 1001 | OS     |
| 1002 | DB     |

2. **과목 테이블**  
| 과목명 | 교수명 |
|--------|--------|
| DB     | 김교수 |
| OS     | 박교수 |

→ 이제 **모든 속성이 기본키 전체에 종속됨** → ✅ 제2정규형 만족!

---

### 🧠 정규형 단계 빠르게 복습

| 정규형 | 핵심 조건 |
|--------|------------|
| **1NF** | 원자값만 있어야 함 (반복 그룹 ❌) |
| **2NF** | 부분 함수적 종속 ❌ |
| **3NF** | 이행적 종속 ❌ (A → B → C 형태 제거) |
| **BCNF** | 결정자는 반드시 후보키여야 함 |

---

### ✅ 한 줄 요약

> **2NF = 기본키 “일부분”에만 종속된 속성은 다 쪼개라!**


------------------------------------------------------------------------------------------------------------

### ✅ 문제 6

다음에 설명하는 **대칭키 암호**를 쓰시오.

- NIST가 주최한 공모전에서 채택된 **Rijndael 알고리즘**을 가리킨다.  
- DES를 대신하여 **새로운 표준**이 되었다.  
- **블록 크기**는 128bit이고, **키 길이**는 128 / 192 / 256 bit이다.  
- **SPN 구조**이다.

**➤ 답: AES (Advanced Encryption Standard)**

---
## 🔐 AES와 블록 암호 – 갓반도도 이해하는 암호학 입문

---

### 📌 AES가 뭐냐고?

> **AES (Advanced Encryption Standard)** =  
**"보안성 개좋고, 빠르고, 믿고 쓰는 암호화 알고리즘"**  
미국 정부가 표준으로 채택했음 (2001년, NIST)

- **Rijndael(레인달)** 알고리즘 기반
- **SPN 구조**: 치환(substitution) + 전치(permutation)
- **128비트 블록**, **128/192/256비트 키**
- 빠르고, 튼튼하고, 전 세계적으로 씀

---

### 🔧 주요 블록 암호들 비교표 (갓반도도 읽기 쉬운 요약)

| 알고리즘   | 키 길이         | 라운드 수     | 구조     | 비고          |
|------------|------------------|---------------|----------|---------------|
| **DES**     | 56비트           | 16라운드       | Feistel  | 옛날 거 (보안 취약) |
| **3DES**    | 112/168비트      | 48라운드       | Feistel  | DES 3번 돌림 |
| **AES**     | 128/192/256비트 | 10/12/14라운드 | SPN      | ✅ 표준 / 제일 많이 씀 |
| **SEED**    | 128비트         | 16라운드       | Feistel  | 🇰🇷 한국 개발 |
| **ARIA**    | 128~256비트     | 12~16라운드    | SPN      | 🇰🇷 한국 공식 암호 |
| **LEA**     | 128~256비트     | 24~32라운드    | SPN      | 🇰🇷 경량 암호 (빠름) |

📝 Feistel 구조 = 좌우 나눠서 반복,  
📝 SPN 구조 = 박살내고 섞고 반복하는 방식 (현대 표준)

---

### 📚 암호 알고리즘 큰 그림 (분류 요약)

#### 🔒 대칭키 암호
- **블록 암호**: AES, DES, ARIA 등  
- **스트림 암호**: RC4, A5 등 → 한 글자씩 암호화

#### 🔓 공개키 암호
- **RSA**: 소인수 분해 기반
- **DH / ElGamal / DSA**: 이산대수 기반
- **ECC**: 타원 곡선 기반 (속도 👍, 보안 👍)

#### 🧩 해시 함수 (단방향)
- **SHA-256, SHA-3, MD5** 등  
→ 암호화 아님! 무결성 검사용

---

### 🍜 존나 쉬운 예시: AES 쓰는 장면

- **웹 브라우저 HTTPS 연결**  
  → 비밀번호/카드번호 AES로 암호화해서 전송함
- **스마트폰 저장소 암호화**  
  → 분실해도 데이터 못 염
- **압축파일 비번 걸기 (.zip)**  
  → 요즘은 대부분 AES 씀

---

### ✅ 한 줄 요약

> **AES = 속도, 보안성, 신뢰성 모두 갖춘 세계 표준 암호 알고리즘**  
> → 옛날 DES는 이제 **은퇴**, AES가 진짜 주인공임!




------------------------------------------------------------------------------------------------------------

## 💡 문제 8 – 병행제어 기법

---

### ❓ 문제

> 하나의 트랜잭션이 데이터를 액세스하는 동안  
> 다른 트랜잭션이 그 데이터 항목을 액세스할 수 없도록 하는 병행제어 기법은?

✅ **답: 로킹 (Locking)**

---

### 🔒 병행제어(Concurrency Control)란?

> 여러 트랜잭션이 **동시에 데이터에 접근**할 때  
> **데이터 무결성을 지키기 위해 제어**하는 기법

---

### 🚨 병행제어 안 하면 생기는 문제들

| 문제 유형       | 설명 |
|----------------|------|
| **갱신 분실**   | 둘이 동시에 수정 → 한 쪽 수정이 덮여서 사라짐 |
| **비완료 의존성** | 중간에 실패한 트랜잭션의 결과를 다른 트랜잭션이 참조 |
| **모순성**     | 트랜잭션끼리 데이터 꼬여서 모순 발생 |
| **연쇄 복귀**   | 하나 롤백되면, 그거 참조한 애들도 전부 롤백해야 됨 |

---

### 🧰 병행제어 기법 종류

| 기법 이름           | 설명 |
|---------------------|------|
| **로킹 (Locking)**        | 데이터에 잠금 설정해서 다른 트랜잭션 접근 못하게 함 |
| **2단계 로킹 (2PL)**      | 잠금은 확장 → 해제는 축소 단계로 → 교착 상태 방지 |
| **타임스탬프 기법**       | 트랜잭션에 시간 순번 부여 → 충돌 없게 처리 |
| **낙관적 병행제어**       | 일단 처리하고 나중에 충돌 검사 → 충돌 땐 롤백 |
| **다중 버전 병행제어(MVCC)** | 데이터를 버전별로 복사 → 읽기/쓰기 분리로 동시성 ↑ |

---

### 🔁 회복 기법 (트랜잭션 실패 대비)

| 회복 기법              | 설명 |
|------------------------|------|
| **로그 기반 회복**         | 변경 내역을 로그에 기록 → REDO / UNDO 처리 |
| **검사점 회복**            | 일정 시점 상태 저장 → 복구 시 빠르게 돌아감 |
| **그림자 페이징**          | 원본 페이지 놔두고 복사본 수정 → 실패 시 원본 유지 |
| **미디어 회복**            | 디스크 자체가 망가졌을 때 복구용 백업 활용 |
| **ARIES**                 | 고급 회복 기법. 단계: 분석 → REDO → UNDO |

---

### ✅ 한 줄 요약

> 🔒 **로킹(Locking)**은 트랜잭션끼리 **서로 건드리지 못하게 잠금 걸어서 충돌 방지**하는 병행제어 기술이다.



------------------------------------------------------------------------------------------------------------
### ✅ 문제 9

다음 (1), (2), (3)에 설명하는 알맞은 답안을 쓰시오.

(1): 모듈이 다수의 관련 기능을 가질 때, 모듈 내부의 기능 요소들이 그 기능을 **순차적으로 수행**할 경우  
(2): **동일한 입력과 출력을 사용하는 소작업들**이 모인 경우  
(3): 모듈 내부의 모든 기능 요소들이 **한 문제와 연관되어 수행**되는 경우

**➤ 답:**
- (1) 절차적 응집도
- (2) 교환적 응집도
- (3) 기능적 응집도

---

## 🧲 응집도(Cohesion) – 갓반도도 이해하는 모듈 설계 원칙

---

### 📌 개념 정리

> **응집도**는 한 모듈 안에 들어있는 기능들이 **서로 얼마나 관련이 깊은지** 나타내는 정도  
→ **높을수록 좋은 설계** (기능이 하나로 딱 맞게 모여 있는 상태)

---

### 📶 응집도 종류 & 갓반 예시

| 응집도 종류         | 설명 | 갓반도 예시 | 수준 |
|----------------------|------|--------------|------|
| **기능적 응집도**     | 모듈이 **하나의 일만** 딱 수행 | "계산기 = 덧셈만 함" | 🔼 최고 |
| **순차적 응집도**     | **출력이 다음 입력**으로 연계 | "주문 → 결제 → 영수증 출력" | 🔼 |
| **교환적 응집도**     | **같은 입출력** 사용하는 작업들 | "같은 문서에 저장/인쇄/미리보기 버튼" | 중 |
| **절차적 응집도**     | 순서대로 해야 할 기능 모음 | "1단계 인증 → 2단계 로그인 → 3단계 홈 이동" | 중하 |
| **논리적 응집도**     | 같은 종류지만 **조건 따라** 분기 | "버튼 하나로 ‘저장’, ‘삭제’, ‘수정’ 다함" | 🔽 낮음 |
| **우연적 응집도**     | 기능들이 **관련 없이** 막 섞임 | "메일 앱에 갑자기 계산기, 게임도 있음" | 🔽 최악 |

---

### 🎯 갓반용 응답 정리 문제

| 설명 | 응집도 유형 |
|------|-------------|
| (1) 순차적으로 수행되는 관련 기능 | ✅ **절차적 응집도** |
| (2) 동일한 입출력을 사용하는 작업 모음 | ✅ **교환적 응집도** |
| (3) 하나의 문제 해결만을 위한 구성 | ✅ **기능적 응집도** |

---

### ✅ 한 줄 요약

> **응집도는 높을수록 좋다!**  
> → **기능 하나만 잘하는 모듈**이 최고다 (기능적 응집도 🥇)



------------------------------------------------------------------------------------------------------------
### ✅ 문제 10

학생 테이블에서 **점수가 90점 이상인 학생의 과목 평가를 'A'로 수정**하는 SQL문을 완성하시오.

---

#### 📌 빈칸

(1) 학생  
(2)  
과목평가 = 'A'  
WHERE 점수 >= 90

---

**➤ 답:**
- (1) `UPDATE`
- (2) `SET`

---

### ✅ 전체 SQL문

```sql
UPDATE 학생
SET 과목평가 = 'A'
WHERE 점수 >= 90;


📌 해설
UPDATE: 테이블의 데이터를 수정할 때 사용하는 명령어

SET: 수정할 **열(Column)**과 새로운 값을 지정

WHERE: 조건에 맞는 행(Row)만 선택적으로 수정

✅ 예시 설명
예를 들어, 학생 테이블에 다음과 같은 데이터가 있을 경우:

학번	이름	점수	과목평가
2023001	김철수	92	B
2023002	이영희	85	C
2023003	박민수	90	B

위 SQL문을 실행하면 점수 ≥ 90인 김철수, 박민수의 과목평가가 'A'로 변경됩니다.
------------------------------------------------------------------------------------------------------------
### ✅ 문제 11

다음 **패킷 교환 방식**에 대한 설명으로 (1), (2)에 알맞은 용어를 쓰시오.

---

(1): 패킷을 전송하기 전에 **논리적인 연결**을 먼저 수행하여 패킷을 주고 받는다.  
(2): 각 전송 패킷을 **미리 정해진 경로 없이**, **독립적으로 처리**하여 교환하는 방식이다.

---

**➤ 답:**
- (1) 가상 회선 방식 (Virtual Circuit)
- (2) 데이터그램 방식 (Datagram)

---

## 📡 패킷 교환 방식 – 가상 회선 vs 데이터그램 (갓반 버전)

---

### 🧠 먼저 개념부터!

#### 1️⃣ 가상 회선 방식 (Virtual Circuit)

> 📞 "전화처럼 먼저 연결하고 말함"  
- 통신 전에 **가상의 연결 경로 설정**
- 모든 패킷이 **같은 경로**로 감
- 순서 보장 O  
- 📌 예시: **X.25, ATM**

#### 2️⃣ 데이터그램 방식 (Datagram)

> 📦 "택배처럼 그냥 보내는 방식"  
- 연결 없이 그냥 패킷 보내버림  
- **패킷마다 다른 경로**로 갈 수도 있음  
- 순서 보장 ❌ (도착 순서 뒤죽박죽 가능)  
- 📌 예시: **IP, UDP**

---

### ⚖️ 비교 요약표

| 항목          | 가상 회선 방식         | 데이터그램 방식          |
|---------------|------------------------|---------------------------|
| 연결 설정      | O (먼저 연결함)         | X (연결 없이 보냄)         |
| 경로          | 고정됨 (모든 패킷 동일) | 동적으로 결정됨 (패킷마다 다름) |
| 순서 보장      | ✅ O                    | ❌ X                      |
| 속도/유연성   | 느리지만 안정적          | 빠르지만 순서 무질서         |
| 대표 예시      | X.25, ATM              | IP, UDP                  |

---

### 🎯 갓반도 예시로 이해해보기

- **가상 회선**: 전화를 먼저 걸고 말하는 것 (통신 시작 전 연결)  
- **데이터그램**: 문자나 택배 보내듯이 그냥 보내고 끝 (연결 없음)

---

### ✅ 한 줄 요약

> 🔄 **가상 회선 = 먼저 연결 → 순서 지킴**  
> 📦 **데이터그램 = 그냥 보냄 → 순서 보장 없음, 속도 빠름**




------------------------------------------------------------------------------------------------------------

### ✅ 문제 12

학생정보와 학과 정보를 조인하여 결과값을 출력하는 SELECT문을 완성하시오.

```sql
SELECT * FROM 학생정보 T1 
JOIN 학과정보 T2 (1) T1.학과 = T2.(2)

➤ 답:

(1) ON

(2) 학과

✅ 완성된 SQL문
SELECT * FROM 학생정보 T1
JOIN 학과정보 T2 ON T1.학과 = T2.학과;

📌 해설
JOIN 구문에서 테이블 간의 연결 조건을 명시할 때는 ON 키워드를 사용한다.

T1.학과 = T2.학과는 학생정보 테이블과 학과정보 테이블을 학과 컬럼 기준으로 연결한다는 의미이다.

SELECT *는 조인된 모든 컬럼을 결과로 반환한다.

📌 추가 설명
JOIN의 기본 형태는 INNER JOIN이며, 양쪽 테이블에서 일치하는 데이터만 출력한다.

ON 절에는 조인 조건을 정확하게 명시해야 하며, 보통 키 컬럼을 사용한다.

------------------------------------------------------------------------------------------------------------

### ✅ 문제 13

<보기>에 해당하는 용어를 쓰시오.

- 특정 시스템 컴포넌트의 개발이 완료되지 않은 상황에서 필요한 시험을 진행하기 위해 생성된 더미 컴포넌트이다.  
- 하향식 통합 테스트에서 사용하는 임시 모듈이다.

**➤ 답:** 스텁 (Stub)

---

### 📌 해설: 스텁(Stub) 쉽게 이해하기

- **스텁(Stub)**은 아직 완성되지 않은 하위 모듈 대신에  
  임시로 만든 **가짜(더미) 모듈**이다.  
- 주로 **하향식(Top-down) 통합 테스트**에서 사용하며,  
  하위 모듈이 없더라도 상위 모듈이 잘 작동하는지 확인할 수 있게 도와준다.  
- 스텁은 기능을 간단히 흉내 내서 호출만 받으면 되는 역할만 한다.

---

### 📌 관련 용어

| 용어       | 쉽게 말하면              |
|------------|-------------------------|
| **스텁**   | 하위 모듈 대신하는 가짜 모듈 (하향식 테스트용)   |
| **드라이버** | 상위 모듈 대신하는 가짜 모듈 (상향식 테스트용)   |

---

### ✨ 갓반 요약

> 스텁 = 아직 없는 하위 모듈 대신, 상위 모듈 테스트를 위해 만든 ‘가짜’ 친구  
> 드라이버 = 아직 없는 상위 모듈 대신, 하위 모듈 테스트를 위해 만든 ‘가짜’ 친구  




------------------------------------------------------------------------------------------------------------
### ✅ 문제 14

화이트박스 테스트에서 수행하는 **구조적 커버리지**의 설명으로 알맞은 것을 쓰시오.

---

(1): 시험 대상의 전체 **구문** 중에 테스트에 의해 실행된 구문을 측정한다.  
(2): 시험 대상의 전체 **분기** 중 테스트에 의해 실행된 것을 측정한다.  
(3): 모든 **조건식의 TRUE, FALSE** 중 테스트에 의해 실행된 것을 측정한다.

---

**➤ 답:**  
- (1) 구문(문장) 커버리지  
- (2) 결정(분기) 커버리지  
- (3) 조건 커버리지

---

### 📌 코드 커버리지 종류 쉽게 설명

| 커버리지 종류           | 쉽게 이해하기 (설명)                                                |
|-------------------------|---------------------------------------------------------------------|
| **구문 커버리지**         | 코드의 각 문장(줄)이 한 번이라도 실행되었는지 체크하는 것             |
| **조건 커버리지**         | 조건문 안의 각각 조건이 TRUE와 FALSE가 모두 실행되었는지 확인          |
| **결정(분기) 커버리지**   | if나 switch 같은 분기문에서 모든 가능한 갈래(분기)를 다 실행해봤는지 점검 |
| **조건/결정 커버리지**     | 분기문 결과와 조건식 결과 둘 다 TRUE/FALSE가 다 실행되었는지 검사       |
| **변경 조건/결정 커버리지** | 분기문 내 각 조건이 최소 한 번씩 TRUE, 한 번씩 FALSE인 경우를 확인       |
| **다중 조건 커버리지**     | 모든 조건들의 가능한 모든 조합을 전부 테스트했는지 보장하는 것          |

---

### ✨ 갓반 요약

- **화이트박스 테스트**는 코드 속을 샅샅이 파악해서 테스트하는 것  
- 커버리지가 높으면 테스트가 꼼꼼하다는 뜻이지만, 비용도 더 들 수 있음  
- 테스트 설계할 때 커버리지 종류별로 골고루 챙기는 게 중요함  


------------------------------------------------------------------------------------------------------------
### ✅ 문제 15

럼바우 객체지향 분석 기법의 설명이다. 해당 설명의 유형을 쓰시오.

---

(1): 자료 흐름도(DFD) 프로세스들의 **자료 흐름**을 중심으로 처리 과정을 표현  
(2): 상태 다이어그램, 시간 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 **동적인 행위**를 표현  
(3): 객체 다이어그램, 정보 모델링이라고도 하며, 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의, 가장 중요하며 선행되어야 함

---

**➤ 답:**  
- (1) 기능 모델링  
- (2) 동적 모델링  
- (3) 객체 모델링

---

### 📌 해설 및 객체지향 분석 방법론 쉽게 설명

- **럼바우(Rumbaugh) 방법**은 객체지향 분석할 때  
  3가지 모델로 시스템을 여러 관점에서 설명하는 기법임.

| 모델 유형      | 쉽게 이해하기 (설명)                           | 대표 다이어그램       |
|---------------|-----------------------------------------------|----------------------|
| **기능 모델링**  | 시스템이 데이터를 어떻게 처리하는지, 흐름 중심으로 표현 | 자료 흐름도(DFD)       |
| **동적 모델링**  | 시간 따라 객체 상태가 어떻게 변하는지, 동작 순서 표현  | 상태 다이어그램         |
| **객체 모델링**  | 시스템에 필요한 객체들과 객체들 간의 관계 정의          | 객체 다이어그램         |

---

### 📌 관련 주요 객체지향 분석 방법론 한줄 요약

| 방법론            | 특징 및 설명                                           |
|-------------------|------------------------------------------------------|
| **럼바우 방법**      | 기능/동적/객체 모델 세 가지를 모두 활용하는 삼중 모델 분석법   |
| **부치(Booch) 방법**  | 세부와 전체 개발 과정을 나눠서 단계별로 진행하는 방법             |
| **제이콥슨(Jacobson)** | Use Case(사용자 시나리오) 중심으로 분석하는 방법               |
| **코드 & 유어돈**    | ER 다이어그램을 객체지향 분석에 활용하는 기법                   |
| **위르프스-브록**    | 분석과 설계 구분 없이 한꺼번에 처리하는 통합적 접근법             |

---

✨ **요약:** 럼바우는 기능, 동작, 객체라는 세 가지 눈으로 보는 멀티뷰 분석법이라 생각하면 쉽다!


------------------------------------------------------------------------------------------------------------

### ✅ 문제 16

public class ClassA {
    public static void main(String args[]){
        System.out.println(check(1));                           // 여기서 'check' 메소드를 바로 호출하고 있지?
                                                                  // ClassA 객체(인스턴스)를 안 만들고도 호출하려면 'static'이어야 해.
    }

    public static String check(int num){                             // ( ) 안에 'static'이 들어가야 한다.
                                                                  // 참고: 'return num;' 에서 에러가 날 수 있음. num은 int고, 반환 타입은 String이니까.
                                                                  // 아마 return String.valueOf(num); 이나 return "" + num; 처럼 바꿔야 할 거다.
        return "" + num;                                     // 일단 문자열로 변환해서 반환하는 걸로 가정하자.
    }
}


📌 해설
왜 static을 써야 하는데?  
원래 자바에서 어떤 클래스 안에 있는 메소드를 쓰려면 그 클래스의 **객체(인스턴스)**를 먼저 만들어야 해.
예를 들면 `ClassA myObject = new ClassA();` 이렇게 만든 다음에 `myObject.check(1);` 이런 식으로 불러야 정상이라고.

근데 `static`이 붙으면 얘기가 달라진다. `static` 메소드는 클래스에 '속해 있는' 메소드지, 특정 객체에 '속해 있는' 메소드가 아니거든.
 그래서 클래스 이름으로 바로 호출할 수 있어. `ClassA.check(1);` 이런 식으로 말이야.

니 코드에서는 `main` 메소드 안에서 `check(1)`을 그냥 호출하고 있잖아? `
ClassA.check(1)`처럼 클래스 이름을 앞에 안 붙였어도, 같은 클래스 안에 있는 `static` 메소드끼리는 그냥 이름만으로 호출이 가능하다.

그래서 빈칸에 들어갈 명령어는 `static`이다. 깔끔하게 이해했지?


------------------------------------------------------------------------------------------------------------ 

### ✅ 문제 17

다음 Java 프로그램의 실행 결과를 쓰시오.

public class Class01 {                                                   // 부모 클래스 Class01
    public static void main(String[] args) {
        Class01 c1 = new Class01();                                   // Class01 객체 c1 생성
        Class02 c2 = new Class02();                                 // Class02 객체 c2 생성 (Class01을 상속받음)

                                                              // c1.sum(3, 2) 결과와 c2.sum(3, 2) 결과를 더해서 출력한다.
        System.out.println(c1.sum(3, 2) + c2.sum(3, 2));
    }

    int sum(int x, int y) {                                                     // Class01의 sum 메소드: 두 수를 더해서 반환.
        return x + y;
    }
}

class Class02 extends Class01 {                                                     // Class02는 Class01을 상속받았다.
    @Override                                                               // 이거 붙으면 부모 메소드를 재정의했다는 뜻.
    int sum(int x, int y) {                                               // Class02의 sum 메소드: Class01의 sum 메소드를 오버라이딩했다.
        return x - y + super.sum(x, y);                                 // 여기가 핵심!
                                                                    // x - y: 3 - 2 = 1
                                                                  // super.sum(x, y): super는 부모 클래스(Class01)를 의미한다.
                                                                  //                 즉, Class01의 sum(3, 2)를 호출하는 거지.
                                                                  //                 Class01.sum(3, 2)는 3 + 2 = 5가 됨.
                                                                  // 결과적으로 Class02.sum(3, 2)는 (3 - 2) + (3 + 2) = 1 + 5 = 6이 된다.
    }
}

✅ 실행 결과
11

📌 코드 분석 및 해설
실행 과정 추적  
c1.sum(3, 2) 계산:

- c1은 Class01 타입의 객체이므로, Class01의 sum 메소드가 실행된다.
- return 3 + 2;
- 결과: 5

c2.sum(3, 2) 계산:

- c2는 Class02 타입의 객체이므로, Class02의 sum 메소드가 실행된다.
- return x - y + super.sum(x, y);
- x - y는 3 - 2 = 1
- super.sum(x, y)는 Class01의 sum(3, 2)를 호출한다. (부모 메소드 호출)
- Class01.sum(3, 2)는 3 + 2 = 5
- 따라서 Class02.sum(3, 2)는 1 + 5 = 6

최종 출력:

```java
System.out.println(c1.sum(3, 2) + c2.sum(3, 2));
System.out.println(5 + 6);
결과: 11


핵심 개념 정리

상속: Class02 extends Class01은 Class02가 Class01의 모든 멤버를 물려받았다는 뜻.

메소드 오버라이딩: 자식 클래스(Class02)가 부모 클래스(Class01)에 있는 똑같은 이름의 메소드(sum)를 자기 방식대로 다시 정의하는 것.

super 키워드: 자식 클래스에서 super를 사용하면 부모 클래스의 멤버(메소드나 생성자)에 접근할 수 있어. 여기서는 오버라이딩된 메소드 안에서 부모 메소드를 호출할 때 사용했지.
------------------------------------------------------------------------------------------------------------ 

### ✅ 문제 18

다음 C 프로그램의 실행 결과를 쓰시오.

int main() {
    int array[3];                                           // 'array'라는 정수형 배열 선언. 3개의 int 공간 (array[0], array[1], array[2])
    int s = 0;                                            // 합계를 저장할 변수 's'를 0으로 초기화.

    *(array + 0) = 1;                                       // **포인터 연산:** *(array + 0)은 array[0]과 같다.
                                                            // array[0]에 1을 저장한다.
                                                            // 현재 array = [1, ?, ?]

    array[1] = *(array + 0) + 2;                               // array[1]에 값을 저장.
                                                                 // *(array + 0)은 array[0]의 값, 즉 1이다.
                                                                 // array[1] = 1 + 2 = 3이 된다.
                                                                 // 현재 array = [1, 3, ?]

    array[2] = *array + 3;                                             // array[2]에 값을 저장.
                                                                           // *array는 *(array + 0)과 같고, array[0]의 값, 즉 1이다.
                                                                           // array[2] = 1 + 3 = 4가 된다.
                                                                           // 현재 array = [1, 3, 4]

                                                                                    // 이제 배열 'array'에는 [1, 3, 4]가 들어있다.

    for(int i = 0; i < 3; i++) {                                                     // 'i'가 0, 1, 2가 되면서 총 3번 반복.
                                                                                 // 배열의 모든 요소를 순서대로 접근한다.
        s = s + array[i];                                                    // 's'에 현재 'array[i]' 값을 더해서 누적한다.
    }
                                                                                // 각 단계별 's' 값:
                                                                                // i = 0: s = 0 + array[0] (1) = 1
                                                                                // i = 1: s = 1 + array[1] (3) = 4
                                                                                // i = 2: s = 4 + array[2] (4) = 8

    printf("%d", s); // 최종 합계인 's' 값을 출력한다.
}

✅ 실행 결과
8


------------------------------------------------------------------------------------------------------------ 

### ✅ 문제 19

다음 파이썬 프로그램의 실행 결과를 쓰시오.
a = 100                                             # 정수형 변수 'a'에 100을 할당한다.
                                                  # 100을 2진수로 나타내면 01100100 이다. (편의상 8비트)

result = 0                                           # 'result' 변수를 0으로 초기화한다.

for i in range(1, 3):                                     # 'i'가 1부터 시작해서 3 전까지, 즉 1과 2로 반복된다.
                                                          # 루프는 총 2번 돈다는 뜻이다.
    result = a >> i                                         # 여기가 핵심! 'a'의 비트를 'i'만큼 오른쪽으로 시프트하는 연산이다.
                                                            # 오른쪽 시프트는 비트를 오른쪽으로 옮기면서 빈자리를 0으로 채우고,
                                                            # 가장 오른쪽 비트들은 버려진다.
                                                            # 쉽게 말해, 숫자를 2의 i승으로 나누는 것과 같다.

                                                              # 첫 번째 루프 (i = 1):
                                                              # result = a >> 1  # 100을 1비트 오른쪽 시프트
                                                              # 100 (01100100) >> 1 = 00110010 (50)
                                                              # result는 이제 50이 된다.
                                                          
                                                              # 두 번째 루프 (i = 2):
                                                              # result = a >> 2  # 100을 2비트 오른쪽 시프트
                                                              # 100 (01100100) >> 2 = 00011001 (25)
                                                              # result는 이제 25가 된다. (이전 50은 덮어씌워짐)
                                                              # for 루프가 끝난다.

result = result + 1                                         # for 루프가 끝난 후, 최종 result 값(25)에 1을 더한다.
                                                              # result = 25 + 1 = 26

print(result)                                         # 최종 result 값인 26을 출력한다.



✅ 실행 결과
26

------------------------------------------------------------------------------------------------------------ 

### ✅ 문제 20

다음 C 프로그램의 실행 결과를 쓰시오.

                                                                // fp 함수: 'base'를 'exp'번 곱하는 함수 (즉, base의 exp 제곱)
int fp(int base, int exp) {
    int result = 1;                                                   // 결과를 저장할 변수 'result'를 1로 초기화한다. (어떤 수의 0제곱은 1이니까)

                                                                        // 'exp' 횟수만큼 'base'를 'result'에 계속 곱하는 반복문
    for (int i = 0; i < exp; i++) {                                     // 'i'가 0부터 'exp-1'까지 반복한다. 총 'exp'번 반복.
        result = result * base;                                         // 'result'에 'base'를 곱해서 다시 'result'에 저장한다.
    }
    return result;                                                       // 최종 계산된 'result' 값을 반환한다.
}

int main() {
    int result;                                                         // 'main' 함수 내에서 결과를 저장할 변수 'result'를 선언한다.

                                                                          // fp 함수 호출: base에 2를, exp에 10을 넘겨준다.
    result = fp(2, 10);                                                 // 이는 2의 10승 (2^10)을 계산하라는 뜻이다.

                                                                          // fp(2, 10)의 계산 과정:
                                                                          // 초기: result = 1
                                                                          // i = 0: result = 1 * 2 = 2
                                                                          // i = 1: result = 2 * 2 = 4
                                                                          // i = 2: result = 4 * 2 = 8
                                                                          // i = 3: result = 8 * 2 = 16
                                                                          // i = 4: result = 16 * 2 = 32
                                                                          // i = 5: result = 32 * 2 = 64
                                                                          // i = 6: result = 64 * 2 = 128
                                                                          // i = 7: result = 128 * 2 = 256
                                                                          // i = 8: result = 256 * 2 = 512
                                                                          // i = 9: result = 512 * 2 = 1024 (i가 9일 때 마지막으로 곱하고, i가 10이 되면 반복문 종료)
                                                                          // fp 함수는 1024를 반환한다.

    printf("%d", result);                                                 // fp 함수에서 반환된 값(1024)을 출력한다.

    return 0;                                                             // 프로그램 정상 종료
}
}


✅ 실행 결과
1024


------------------------------------------------------------------------------------------------------------

