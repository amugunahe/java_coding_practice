### ✅ 문제 1

네트워크의 구성 및 유지를 위해 기지국이나 액세스 포인트와 같은  
기반 네트워크 장치를 필요로 하지 않고, **멀티 홉 라우팅 기능**에 의해  
무선 인터페이스가 가지는 **통신 거리상의 제약**을 극복하며,  
**노드들의 이동이 자유롭기 때문에 네트워크 토폴로지가 동적으로 변화**되는 특징이 있다.  
응용분야로는 **긴급구조, 긴급회의, 전쟁터에서의 군사 네트워크** 등이 있다.

**➤ 답: Ad-hoc Network**

---

### 📌 해설

- **Ad-hoc Network**는 고정된 인프라(기지국, AP 등) 없이, 노드들 간의 **직접적인 무선 연결**을 통해 네트워크를 구성하는 방식이다.
- **멀티 홉 라우팅(Multi-hop Routing)**을 사용하여, 노드 간 직접 통신이 불가능한 경우 중간 노드를 경유하여 통신을 수행한다.
- **자율적이고 유동적인 구성**이 가능하며, 네트워크 토폴로지가 지속적으로 변화해도 자체적으로 재구성할 수 있는 특징이 있다.
- 응용 분야로는 다음과 같은 상황이 대표적:
  - **전쟁터**의 군사 네트워크
  - **재난 지역**에서의 긴급 구조 통신
  - **임시 회의** 공간 등 인프라가 없는 환경


------------------------------------------------------------------------------------------------------------

### ✅ 문제 2

다음 (1), (2)에 설명하는 알맞은 답안을 쓰시오

(1): 사용자가 제품/서비스와 **상호작용**할 수 있도록 만들어진 **매개체**  
(2): 사용자 경험의 약자로, 사용자가 어떤 서비스/제품을 **직·간접적으로 이용**하면서 느끼는 **종합적인 만족**

**➤ 답:**
- (1) UI (User Interface)
- (2) UX (User Experience)

---

### 📌 UI 설계 원칙

| 항목 | 설명 |
|------|------|
| **직관성** | 누구나 쉽게 이해하고 사용할 수 있어야 한다. |
| **유효성** | 사용자의 목적을 정확하게 달성해야 한다. |
| **학습성** | 누구나 쉽게 배우고 익힐 수 있어야 한다. |
| **유연성** | 사용자의 요구사항을 최대한 수용하며, 오류를 최소화해야 한다. |

---

### 🔍 추가 설명

- **UI (User Interface)**: 사용자와 제품(또는 시스템) 사이의 상호작용이 이루어지는 지점, 예: 버튼, 화면, 조작기 등
- **UX (User Experience)**: 사용자가 해당 제품 또는 서비스를 이용하며 느끼는 전반적인 경험. 감정, 만족도, 사용성 등이 포함됨



------------------------------------------------------------------------------------------------------------

### ✅ 문제 3

디자인 패턴 중 **클래스나 서로 상호작용하는 방법이나 책임 분배 방법**을  
정의하는 패턴으로, `Chain of Responsibility`, `Command`, `Iterator`, `Observer` 패턴 등이 있다.

**➤ 답: 행위 패턴 (Behavioral Pattern)**

---

### 📌 해설

- **행위 패턴(Behavioral Pattern)**은 객체 간의 **책임 분배**, **상호작용 방법**, **통신 패턴** 등을 정의하여  
  **동작(행위)**에 초점을 맞춘 디자인 패턴이다.
- 시스템 내 객체들 사이의 **효율적 협력**을 도와주며, **유연한 구조**를 갖도록 설계할 수 있다.

---

### 📌 주요 행위 패턴 예시

| 패턴 이름 | 설명 |
|-----------|------|
| **Chain of Responsibility** | 요청을 처리할 수 있는 객체를 체인 형태로 연결하여 순차적으로 전달 |
| **Command** | 요청을 객체로 캡슐화하여 사용자의 명령을 객체화 |
| **Iterator** | 컬렉션 내부 요소에 접근할 수 있도록 순차적으로 탐색하는 인터페이스 제공 |
| **Observer** | 한 객체의 상태 변화에 따라 연관된 객체들이 자동으로 업데이트되도록 구성 |

---

### 📌 참고: 디자인 패턴의 3가지 분류

1. **생성 패턴(Creational Pattern)**: 객체 생성 방식에 초점 (ex. Singleton, Factory Method 등)  
2. **구조 패턴(Structural Pattern)**: 클래스/객체들을 조합하여 더 큰 구조 형성 (ex. Adapter, Composite 등)  
3. **행위 패턴(Behavioral Pattern)**: 객체 간의 상호작용 및 책임 분배에 초점



------------------------------------------------------------------------------------------------------------
### ✅ 문제 4

트랜잭션의 특성 중 **원자성(Atomicity)**에 대해 설명하시오.

**➤ 답:**  
연산의 결과는 **모두 반영되거나 모두 반영되지 않아야 한다.**

---

### 📌 해설

- **원자성 (Atomicity)**은 트랜잭션의 ACID 특성 중 하나로,  
  트랜잭션 내의 모든 연산이 **하나의 단위로 처리**되어야 함을 의미한다.
- 중간 단계에서 일부 연산만 반영되고 나머지가 실패해서는 안 되며,  
  실패 시에는 **모든 연산이 취소(rollback)**되어야 한다.
- 즉, 트랜잭션은 **성공하면 전체 반영(commit), 실패하면 전부 취소(rollback)**되는 특성을 갖는다.

---

### 📌 ACID 네 가지 특성 요약

| 특성 | 설명 |
|------|------|
| **Atomicity (원자성)** | 모든 작업이 전부 수행되거나 전혀 수행되지 않아야 함 |
| **Consistency (일관성)** | 트랜잭션 수행 전과 후의 데이터가 항상 일관된 상태 유지 |
| **Isolation (독립성)** | 동시에 수행되는 트랜잭션들이 서로 영향을 미치지 않아야 함 |
| **Durability (영속성)** | 성공한 트랜잭션의 결과는 시스템 장애가 발생해도 보존됨 |



------------------------------------------------------------------------------------------------------------
### ✅ 문제 5

**부분 함수적 종속성**을 제거하여 **완전 함수 종속**을 만족하는 정규형이 무엇인지 쓰시오.

**➤ 답:**  
제2정규형 (2NF)

---

### 📌 해설

- **부분 함수적 종속(Partial Functional Dependency)**이란,  
  **기본 키의 일부분**에만 종속된 속성이 존재하는 것을 의미함.
- 이를 제거하고 **모든 속성이 기본 키 전체에 종속**되도록 만드는 것이 **제2정규형(2NF)**이다.

---

### 📌 제2정규형 (2NF)의 정의

- 릴레이션이 **제1정규형(1NF)**을 만족하고,  
- **모든 비(非)기본 속성이 기본 키에 완전 함수 종속**을 가질 때 → 제2정규형

---

### 📌 정규형 단계 요약

| 정규형 | 설명 |
|--------|------|
| **제1정규형 (1NF)** | 도메인이 원자값(atomic value)을 가져야 함 |
| **제2정규형 (2NF)** | 부분 함수적 종속 제거 (완전 함수 종속 만족) |
| **제3정규형 (3NF)** | 이행적 함수 종속 제거 |
| **BCNF** | 결정자가 후보키가 아니면 분해 |




------------------------------------------------------------------------------------------------------------

### ✅ 문제 6

다음에 설명하는 **대칭키 암호**를 쓰시오.

- NIST가 주최한 공모전에서 채택된 **Rijndael 알고리즘**을 가리킨다.  
- DES를 대신하여 **새로운 표준**이 되었다.  
- **블록 크기**는 128bit이고, **키 길이**는 128 / 192 / 256 bit이다.  
- **SPN 구조**이다.

**➤ 답: AES (Advanced Encryption Standard)**

---

### 📌 해설

- **AES**는 미국 NIST에서 2001년에 표준으로 채택한 **블록 암호 알고리즘**으로,  
  기존의 **DES**를 대체하기 위해 개발되었다.
- **Rijndael(레인달) 알고리즘**을 기반으로 하며, **SPN(Substitution-Permutation Network) 구조**를 사용한다.
- 고속, 보안성, 효율성에서 우수하여 다양한 분야에서 널리 사용된다.

---

### 📌 주요 블록 암호 알고리즘 정리

| 알고리즘 | 블록 크기 | 키 길이 | 라운드 수 | 구조 | 비고 |
|----------|------------|-----------|-------------|--------|------|
| **DES** | 64비트 | 56비트 | 16라운드 | Feistel | 구 표준 |
| **3DES** | 64비트 | 112/168비트 (2/3키) | 48라운드 | Feistel | DES 3회 적용 |
| **AES** | 128비트 | 128/192/256비트 | 10/12/14라운드 | SPN | NIST 표준 |
| **IDEA** | 64비트 | 128비트 | 8라운드 | Feistel + SPN | 스위스 개발 |
| **SEED** | 128비트 | 128비트 | 16라운드 | Feistel | 한국 개발 |
| **ARIA** | 128비트 | 128/192/256비트 | 12/14/16라운드 | SPN | 한국 개발 |
| **SKIPJACK** | 64비트 | 80비트 | 32라운드 | Feistel 변형 | NSA 개발 |
| **LEA** | 128비트 | 128/192/256비트 | 24/28/32라운드 | SPN | 한국 경량암호 |

---

### 📌 참고: 암호 알고리즘 분류 요약

#### 🔹 대칭키 암호
- **블록 암호**: AES, DES, 3DES, IDEA, SEED, ARIA 등
- **스트림 암호**: RC4, A5, LFSR 등

#### 🔹 공개키 암호
- **소인수 분해 기반**: RSA, Rabin
- **이산대수 기반**: Diffie-Hellman, DSA, ElGamal
- **타원 곡선 기반**: ECC

#### 🔹 단방향 해시 함수
- MD5, SHA(SHA-1, SHA-2, SHA-3), HAS-160 등


------------------------------------------------------------------------------------------------------------

문제 8) 하나의 트랜잭션이 데이터를 액세스하는 동안 
다른 트랜잭션이 그 데이터 항목을 액세스할수 없도록 하는 병행제어 기법이 무엇인지 쓰시오

답: 로킹 

병행제어
병행제어를 하지 않았을때의 문제점
- 갱신 분실
- 비완료 의존성
- 모순성
- 연쇄 복귀

병행제어 기법 
- 로킹
- 2단계 로킹
- 타임스탬프
- 낙관적 병행제어 
- 다중 버전 병행제어 

회복기법
- 로그 기반 회복 기법
- 검사점 회복 기법
- 그림자 페이징 회복 기법
- 미디어 회복 기법
- ARIES 회복 기법(분석, REDO, UNDO)

------------------------------------------------------------------------------------------------------------
### ✅ 문제 9

다음 (1), (2), (3)에 설명하는 알맞은 답안을 쓰시오.

(1): 모듈이 다수의 관련 기능을 가질 때, 모듈 내부의 기능 요소들이 그 기능을 **순차적으로 수행**할 경우  
(2): **동일한 입력과 출력을 사용하는 소작업들**이 모인 경우  
(3): 모듈 내부의 모든 기능 요소들이 **한 문제와 연관되어 수행**되는 경우

**➤ 답:**
- (1) 절차적 응집도
- (2) 교환적 응집도
- (3) 기능적 응집도

---

### 📌 해설: 응집도(Cohesion)

응집도는 모듈 내부 요소들이 **얼마나 밀접하게 관련되어 있는지를 나타내는 척도**로,  
응집도가 높을수록 **좋은 설계**로 간주됩니다.

| 응집도 종류 | 설명 | 수준 |
|-------------|------|------|
| **기능적 응집도** | 모듈이 **하나의 명확한 기능만 수행** | 🔼 가장 높음 |
| **순차적 응집도** | 출력이 다음 기능의 입력으로 **연쇄적으로 연결**됨 | |
| **교환적 응집도** | **같은 입력과 출력을 사용하는 작업**들이 함께 모여 있음 | |
| **절차적 응집도** | 관련 기능들을 **일정한 절차에 따라 수행** | |
| **논리적 응집도** | 유사한 기능을 수행하지만 **제어 흐름에 따라 분기** | 🔽 낮음 |
| **우연적 응집도** | 관련 없는 여러 기능이 **임의로 모여 있음** | 🔽 가장 낮음 |

---

### 📌 정답 정리

| 번호 | 설명 | 정답 (응집도 유형) |
|------|------|------------------|
| (1) | 순차적으로 수행되는 관련 기능 요소 | 절차적 응집도 |
| (2) | 동일한 입출력을 사용하는 작업 모음 | 교환적 응집도 |
| (3) | 하나의 문제 해결을 위한 구성 | 기능적 응집도 |

------------------------------------------------------------------------------------------------------------
### ✅ 문제 10

학생 테이블에서 **점수가 90점 이상인 학생의 과목 평가를 'A'로 수정**하는 SQL문을 완성하시오.

---

#### 📌 빈칸

(1) 학생  
(2)  
과목평가 = 'A'  
WHERE 점수 >= 90

---

**➤ 답:**
- (1) `UPDATE`
- (2) `SET`

---

### ✅ 전체 SQL문

```sql
UPDATE 학생
SET 과목평가 = 'A'
WHERE 점수 >= 90;
📌 해설
UPDATE: 테이블의 데이터를 수정할 때 사용하는 명령어

SET: 수정할 **열(Column)**과 새로운 값을 지정

WHERE: 조건에 맞는 행(Row)만 선택적으로 수정

✅ 예시 설명
예를 들어, 학생 테이블에 다음과 같은 데이터가 있을 경우:

학번	이름	점수	과목평가
2023001	김철수	92	B
2023002	이영희	85	C
2023003	박민수	90	B

위 SQL문을 실행하면 점수 ≥ 90인 김철수, 박민수의 과목평가가 'A'로 변경됩니다.
------------------------------------------------------------------------------------------------------------
### ✅ 문제 11

다음 **패킷 교환 방식**에 대한 설명으로 (1), (2)에 알맞은 용어를 쓰시오.

---

(1): 패킷을 전송하기 전에 **논리적인 연결**을 먼저 수행하여 패킷을 주고 받는다.  
(2): 각 전송 패킷을 **미리 정해진 경로 없이**, **독립적으로 처리**하여 교환하는 방식이다.

---

**➤ 답:**
- (1) 가상 회선 방식 (Virtual Circuit)
- (2) 데이터그램 방식 (Datagram)

---

### 📌 해설

#### 1️⃣ 가상 회선 방식 (Virtual Circuit)
- **통신을 시작하기 전에 논리적인 연결 경로를 설정**한 후에 데이터를 전송하는 방식
- 실제 회선을 설치하지는 않지만, **가상의 경로를 설정**해 패킷들이 해당 경로로 전송됨
- **모든 패킷이 동일한 경로**를 따라 전송되므로 순서 유지 보장
- 예: **ATM, X.25**

#### 2️⃣ 데이터그램 방식 (Datagram)
- **연결 설정 없이**, 각 패킷이 독립적으로 처리되어 전송되는 방식
- 각 패킷은 **자체적으로 목적지까지의 경로를 결정**하며, 서로 다른 경로로 전달될 수 있음
- 패킷 순서 보장 ❌, 속도 빠름, 유연함
- 예: **IP(Internet Protocol)**


---

### 📌 비교 요약

| 항목 | 가상 회선 방식 | 데이터그램 방식 |
|------|----------------|-----------------|
| 연결 설정 | 필요함 | 불필요 |
| 경로 | 고정된 경로 | 동적으로 결정됨 |
| 순서 보장 | O | X |
| 대표 예시 | X.25, ATM | IP, UDP |



------------------------------------------------------------------------------------------------------------

### ✅ 문제 12

학생정보와 학과 정보를 조인하여 결과값을 출력하는 SELECT문을 완성하시오.

```sql
SELECT * FROM 학생정보 T1 
JOIN 학과정보 T2 (1) T1.학과 = T2.(2)

➤ 답:

(1) ON

(2) 학과

✅ 완성된 SQL문
SELECT * FROM 학생정보 T1
JOIN 학과정보 T2 ON T1.학과 = T2.학과;

📌 해설
JOIN 구문에서 테이블 간의 연결 조건을 명시할 때는 ON 키워드를 사용한다.

T1.학과 = T2.학과는 학생정보 테이블과 학과정보 테이블을 학과 컬럼 기준으로 연결한다는 의미이다.

SELECT *는 조인된 모든 컬럼을 결과로 반환한다.

📌 추가 설명
JOIN의 기본 형태는 INNER JOIN이며, 양쪽 테이블에서 일치하는 데이터만 출력한다.

ON 절에는 조인 조건을 정확하게 명시해야 하며, 보통 키 컬럼을 사용한다.

------------------------------------------------------------------------------------------------------------

### ✅ 문제 13

<보기>에 해당하는 용어를 쓰시오.

- 특정 시스템 컴포넌트의 개발이 완료되지 않은 상황에서 필요한 시험을 진행하기 위해 생성된 더미 컴포넌트이다.  
- 하향식 통합 테스트에서 사용하는 임시 모듈이다.

**➤ 답:** 스텁 (Stub)

---

### 📌 해설

- **스텁(Stub)**은 상위 모듈에서 호출하는 하위 모듈이 아직 개발되지 않았거나 준비되지 않은 경우,  
  테스트를 위해 임시로 만든 **더미 모듈(가짜 모듈)**이다.
- 주로 **하향식(Top-down) 통합 테스트**에서 사용되며,  
  호출되는 하위 모듈의 기능을 단순화하여 구현한다.
- 스텁을 통해 상위 모듈의 동작을 검증할 수 있다.

---

### 📌 관련 개념

| 용어      | 설명                              |
|-----------|---------------------------------|
| **스텁**  | 하위 모듈을 대신하는 임시 모듈    |
| **드라이버** | 상위 모듈을 대신하는 임시 모듈 (주로 상향식 테스트에서 사용) |



------------------------------------------------------------------------------------------------------------
### ✅ 문제 14

화이트박스 테스트에서 수행하는 **구조적 커버리지**의 설명으로 알맞은 것을 쓰시오.

---

(1): 시험 대상의 전체 **구문** 중에 테스트에 의해 실행된 구문을 측정한다.  
(2): 시험 대상의 전체 **분기** 중 테스트에 의해 실행된 것을 측정한다.  
(3): 모든 **조건식의 TRUE, FALSE** 중 테스트에 의해 실행된 것을 측정한다.

---

**➤ 답:**  
- (1) 구문(문장) 커버리지  
- (2) 결정(분기) 커버리지  
- (3) 조건 커버리지

---

### 📌 코드 커버리지 종류

| 커버리지 종류         | 설명                                                                                  |
|-----------------------|---------------------------------------------------------------------------------------|
| **구문 커버리지**       | 코드 내 각 구문(문장)이 최소 한 번 이상 실행되었는지 측정                              |
| **조건 커버리지**       | 개별 조건식의 TRUE와 FALSE 값이 각각 실행되었는지 측정                                |
| **결정(분기) 커버리지** | 분기문(예: if, switch)의 모든 분기 경로가 실행되었는지 측정                           |
| **조건/결정 커버리지**   | 결정 포인트의 T/F 결과와 각 조건식의 T/F 결과 모두를 충족하는지 측정                  |
| **변경 조건/결정 커버리지** | 결정 포인트 내 개별 조건식이 최소 한 번씩 TRUE/FALSE가 되는지 검사                   |
| **다중 조건 커버리지**   | 가능한 모든 조건 조합이 100% 테스트되었는지 보장                                     |

---

### 📌 참고

- **화이트박스 테스트**에서는 코드의 내부 구조를 기반으로 테스트 케이스를 설계하여,  
  코드 실행 경로를 최대한 많이 커버하는 것이 목적이다.
- 커버리지 수준이 높을수록 테스트의 신뢰도가 올라가지만, 비용도 증가한다.


------------------------------------------------------------------------------------------------------------
### ✅ 문제 15

럼바우 객체지향 분석 기법의 설명이다. 해당 설명의 유형을 쓰시오.

---

(1): 자료 흐름도(DFD) 프로세스들의 **자료 흐름**을 중심으로 처리 과정을 표현  
(2): 상태 다이어그램, 시간 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 **동적인 행위**를 표현  
(3): 객체 다이어그램, 정보 모델링이라고도 하며, 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의, 가장 중요하며 선행되어야 함

---

**➤ 답:**  
- (1) 기능 모델링  
- (2) 동적 모델링  
- (3) 객체 모델링

---

### 📌 해설 및 객체지향 분석 방법론

- **럼바우(Rumbaugh) 방법**은 객체지향 분석 시, 세 가지 주요 모델을 사용하여 시스템을 다각도로 표현한다.

| 모델 유형     | 설명                                         | 대표 다이어그램     |
|--------------|----------------------------------------------|--------------------|
| **기능 모델링** | 시스템의 **기능 처리 과정**을 자료 흐름 중심으로 표현 | 자료 흐름도(DFD)     |
| **동적 모델링** | 시간의 흐름에 따른 **객체들의 상태 변화 및 동작 순서** 표현 | 상태 다이어그램      |
| **객체 모델링** | 시스템에서 필요한 **객체와 그 관계**를 정의하는 정보 모델링 | 객체 다이어그램      |

---

### 📌 관련 객체지향 분석 방법론

| 방법론         | 특징 및 주요 내용                                     |
|----------------|-----------------------------------------------------|
| **럼바우 방법**   | 기능, 동적, 객체 모델링의 삼중 모델 활용                  |
| **부치(Booch) 방법** | 미시적(세부)와 거시적(전체) 개발 프로세스 구분               |
| **제이콥슨(Jacobson)** | Use Case 중심의 분석 방법                                 |
| **코드 & 유어돈(Coad & Yourdon)** | ER 다이어그램 활용한 객체지향 분석                        |
| **위르프스-브록(Wirfs-Brock)** | 분석과 설계 구분 없이 통합적 접근                             |

---

필요하면 각 방법론별 특징과 다이어그램 설명도 자세히 정리해 드릴 수 있습니다!


------------------------------------------------------------------------------------------------------------

### ✅ 문제 16

클래스를 생성하지 않고 사용할 수 있는 메소드를 선언할 때 사용하는 명령어는 무엇인가?

아래 JAVA 소스코드에 들어갈 명령어를 쓰시오.

```java
public class ClassA {
    public static void main(String args[]){
        System.out.println(check(1));
    }
    
    () String check(int num){
        return num;
    }
}

➤ 답: static

✅ 수정된 코드 예시

public class ClassA {
    public static void main(String args[]){
        System.out.println(check(1));
    }
    
    public static String check(int num){
        return Integer.toString(num);
    }
}

📌 해설
static 키워드는 클래스의 인스턴스(객체)를 생성하지 않고도 호출할 수 있는 메소드나 변수를 선언할 때 사용한다.

main 메소드가 static이기 때문에, main 메소드 내에서 호출하는 메소드도 static이어야 한다.

반환 타입이 String이므로, return num;은 타입 불일치 오류 발생 가능성이 있어 Integer.toString(num)으로 변환하는 것이 맞다.

public 접근 제어자는 메소드 앞에 붙는 것이 일반적이다.

------------------------------------------------------------------------------------------------------------ 

### ✅ 문제 17

다음 Java 프로그램의 실행 결과를 쓰시오.

```java
public class Class01 {
    public static void main(String[] args) {
        Class01 c1 = new Class01();
        Class02 c2 = new Class02();
        System.out.println(c1.sum(3, 2) + c2.sum(3, 2));
    }
    
    int sum(int x, int y) {
        return x + y;
    }
}

class Class02 extends Class01 {
    int sum(int x, int y) {
        return x - y + super.sum(x, y);
    }
}

✅ 실행 결과
11

📌 코드 분석 및 해설
c1.sum(3, 2) 호출 시:

Class01의 sum 메서드가 호출되어 3 + 2 = 5를 반환함.

c2.sum(3, 2) 호출 시:

Class02의 sum 메서드가 호출됨.

계산 과정: 3 - 2 + super.sum(3, 2)

super.sum(3, 2)는 Class01의 sum 메서드로 3 + 2 = 5

결과: 3 - 2 + 5 = 6

최종 결과: 5 + 6 = 11
------------------------------------------------------------------------------------------------------------ 

### ✅ 문제 18

다음 C 프로그램의 실행 결과를 쓰시오.

```c
int main() {
    int array[3];
    int s = 0;
    *(array + 0) = 1;
    array[1] = *(array + 0) + 2;
    array[2] = *array + 3;
    for(int i = 0; i < 3; i++) {
        s = s + array[i];
    }
    printf("%d", s);
}

✅ 실행 결과
8

📌 코드 분석 및 해설
*(array + 0) = 1;
배열 array의 첫 번째 요소(array[0])에 1을 저장 → array[0] = 1

array[1] = *(array + 0) + 2;
array[1] = array[0] + 2 = 1 + 2 = 3

array[2] = *array + 3;
array[2] = array[0] + 3 = 1 + 3 = 4

배열 상태:
array[0] = 1
array[1] = 3
array[2] = 4

for문에서 s에 배열 모든 요소 합산:
s = 1 + 3 + 4 = 8

printf로 8 출력
------------------------------------------------------------------------------------------------------------ 

### ✅ 문제 19

다음 파이썬 프로그램의 실행 결과를 쓰시오.

```python
a = 100
result = 0
for i in range(1, 3):
    result = a >> i
result = result + 1
print(result)

✅ 실행 결과
26

📌 코드 분석 및 해설
a = 100

for i in range(1, 3): 반복문에서 i는 1과 2를 순서대로 가짐

반복 과정:

i = 1: result = a >> 1 → 100을 오른쪽으로 1비트 쉬프트
→ 100(10진수) = 1100100(2진수)
→ 오른쪽 1비트 쉬프트 → 0110010(2진수) = 50 (10진수)

i = 2: result = a >> 2 → 100을 오른쪽으로 2비트 쉬프트
→ 1100100(2진수) → 0011001(2진수) = 25 (10진수)

for 루프 종료 후 result는 25

result = result + 1 → 26

print(result) → 26 출력

------------------------------------------------------------------------------------------------------------ 

### ✅ 문제 20

다음 C 프로그램의 실행 결과를 쓰시오.

```c
int fp(int base, int exp) {
    int result = 1;
    for (int i = 0; i < exp; i++) {
        result = result * base;
    }
    return result;
}

int main() {
    int result;
    result = fp(2, 10);
    printf("%d", result);
    return 0;
}

✅ 실행 결과
1024

📌 코드 분석 및 해설
fp 함수는 거듭제곱 함수로,
base를 exp 횟수만큼 곱하여 base^exp를 계산한다.

fp(2, 10) 호출 시, 2를 10번 곱한 값 → 
210=024

2 10=1024

main 함수에서 printf를 통해 1024를 출력함.

------------------------------------------------------------------------------------------------------------

