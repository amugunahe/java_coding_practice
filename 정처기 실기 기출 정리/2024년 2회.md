\# 📘 2024년 2회 정보처리기사 실기 기출 정리


\## ✅ 문제 1


\*\*문제:\*\*  

시스템의 성능 향상, 개발 과정의 편의성 등을 위해 정규화된 데이터 모델을 분할, 통합, 추가하는 과정으로 의도적으로 정규화에 위배되는 행위이다. 무엇을 설명하는 것인지 쓰시오.


\*\*답:\*\*  

반정규화 (=역정규화, 비정규화)



## 📌 관련 개념 설명

### 🔹 반정규화(역정규화, 비정규화)

- **정의:** 정규화를 통해 생성된 여러 개의 테이블을 조인으로 연결할 때 성능 저하가 발생하거나 시스템 구현이 복잡해질 경우, 이를 해결하기 위해 **의도적으로 정규화된 구조를 깨고** 테이블을 **통합하거나 중복된 속성을 추가하는 행위**.
- **목적:** 시스템 성능 향상, 구현의 단순화, 응답시간 단축

### 🔹 반정규화의 주요 방법

- 테이블 **병합** 또는 **분할**
- 중복 속성 **추가**
- **파생 속성** 추가
- **중복 테이블** 생성 등

---
## 📌 관련 용어 정리 (개념 쉽게 정리 + 갓반인 예시)

| 용어            | 설명 | 갓반인 예시 |
|-----------------|------|-------------|
| **공유데이터**     | 여러 시스템에서 **같이** 쓰는 데이터 | "학생 정보"는 성적 관리 시스템이랑 출석 시스템이 **같이 씀** |
| **저장데이터**     | 실제로 **DB에 저장**되어 있는 데이터 | 학생 이름, 학번 같은 게 **테이블에 저장돼 있음** |
| **통합데이터**     | **중복 없이 깔끔하게** 정리된 데이터 | 학생이 여러 과목을 들어도 **이름은 한 번만 저장**됨 |
| **운영데이터**     | **실시간 업무**에 쓰이는 데이터 | 출석체크할 때 **바로 조회되는 데이터** |

---

## 📌 이상현상 (Anomalies)  
> 정규화를 안 하면 생기는 **데이터 꼬임 현상**

| 종류         | 설명 | 갓반인 예시 |
|--------------|------|-------------|
| **삽입 이상**   | **쓸데없는 정보도 같이 넣어야** 등록되는 현상 | "과목 정보를 넣고 싶은데 학생 정보도 **같이 넣어야 저장됨**" |
| **삭제 이상**   | 하나 지웠는데 **연쇄적으로 삭제되는** 현상 | "어떤 학생이 수강 취소했는데 과목 정보까지 **같이 사라짐**" |
| **갱신 이상**   | 똑같은 데이터가 여러 군데 있어서 **모두 고쳐야** 되는 현상 | "학생 전화번호가 여러 줄에 있어, 하나만 고치면 **불일치 생김**" |

---

## 📌 함수 종속성 (FD: Functional Dependency)  
> 어떤 속성이 다른 속성을 **결정짓는 관계**

| 개념                 | 설명 | 갓반인 예시 |
|----------------------|------|-------------|
| **완전 함수 종속**     | 기본키 **전체가 있어야** 값이 결정됨 | (학번 + 과목코드) → 성적, **둘 다 알아야 성적 나옴** |
| **부분 함수 종속**     | 기본키 중 **일부만 알아도** 값이 결정됨 → ❌ 제2정규형 위반 | 학번 → 학생이름, **학번만으로 이름 나오는 건 문제** |
| **이행적 함수 종속**   | A → B, B → C면 A → C처럼 **간접적으로 종속** → ❌ 제3정규형 위반 | 학번 → 과대표, 과대표 → 전화번호 → 결국 학번 → 전화번호 관계 **성립됨** |

---

🔥 전부 다 **정규화 안 하면 데이터가 꼬이고**,  
📊 정규화를 하면 **깔끔하고 유지보수 쉬움!**



---------------------------------------------------------------------------


\## ✅ 문제 2


\*\*문제:\*\*  

빈칸에 들어갈 네트워크 보안 프로토콜을 쓰시오

VPN을 통해 안전한 통신을 구현하기 위해 사용되는 이 프로토콜은  
네트워크 계층에서 동작하며, 데이터의 기밀성, 무결성, 그리고 인증을 제공한다.  
이 프로토콜은 AH(Authentication Header)와 ESP(Encapsulating Security Payload) 두 가지 하위 프로토콜을 포함하며,  
각각 데이터의 무결성과 인증, 그리고 데이터의 기밀성을 제공한다.  

또한 이 프로토콜은 터널 모드와 전송 모드를 지원하며,  
주로 IKE(Internet Key Exchange) 프로토콜과 함께 보안 연결을 설정한다.  
이 프로토콜의 이름은 \*\*(           )\*\* 이다.

\*\*답:\*\*  

IPsec (IP Security)

---


## 📌 관련 개념 설명 (쉽고 직관적으로 + 갓반인 예시 포함)

### 🔐 IPsec (Internet Protocol Security)

- **설명:**  
  인터넷에서 **안전하게 통신**하기 위해 IP 계층에서 동작하는 보안 프로토콜.  
  주로 **VPN 만들 때 필수로 사용됨.**

- **기능:**  
  - 🔒 **기밀성(confidentiality)** → **남이 못 보게 암호화**
  - 🧱 **무결성(integrity)** → **데이터가 중간에 바뀌지 않았는지 확인**
  - 🙋‍♂️ **인증(authentication)** → **누가 보냈는지 확인**

- **구성 요소:**  
  | 구성 요소 | 설명 | 갓반인 예시 |
  |-----------|------|-------------|
  | **AH (Authentication Header)** | 무결성과 송신자 인증만 제공, **암호화는 X** | "이 메시지가 **진짜 그 친구가 보낸 건 맞아**, 근데 **내용은 그냥 평문**" |
  | **ESP (Encapsulating Security Payload)** | 무결성 + 인증 + 암호화 **전부 제공** | "친구가 보냈고, **누가 보냈는지도 맞고**, **내용도 암호화돼 있어서 안 들킴**" |

- **동작 모드:**  
  | 모드 | 설명 | 갓반인 예시 |
  |------|------|-------------|
  | **터널 모드** | 전체 IP 패킷을 암호화해서 **터널처럼** 보호함 | "내가 친구한테 보낸 편지를 **봉투째로 밀봉해서 보냄**" |
  | **전송 모드** | 데이터 부분만 암호화 (IP 헤더는 그대로) | "편지는 암호화했지만 **누가 보냈는지는 봉투에 써 있음**" |

---

## 📌 기타 보안 프로토콜 요약 (간단 + 갓반인식 설명)

| 프로토콜 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **SSL/TLS** | 웹사이트랑 내 컴퓨터 사이 **암호화 통신** (HTTPS) | "온라인 쇼핑할 때 **카드 정보 안 털리는 이유**" |
| **SSH** | **원격으로 컴퓨터 접속할 때 안전하게** 연결함 | "학교 서버에 원격 접속해서 과제 제출할 때 **해커한테 안 털림**" |
| **PGP** | 이메일 내용을 **암호화**하고 **보낸 사람 확인** | "누가 보냈고, **내용도 못 보게 잠가 놓음**" |
| **Kerberos** | 클라이언트와 서버가 **서로 인증**하는 프로토콜 | "선생님이 출석부 들고 네 얼굴도 확인하고, **너도 선생님이 진짜 맞는지 확인함**" |
| **S/MIME** | 이메일의 **암호화 + 전자서명** 표준 | "이메일에 **서명 딱 박혀 있고**, **내용도 자물쇠 걸려 있음**" |

---

🔥 암호화 + 인증은 **함께 쓰면 완벽하고**,  
👀 "누가 보냈는지" + "내용을 바꾸지 않았는지" + "몰래 못 보게" 전부 챙기려면  
➡️ **ESP 같은 완전체 프로토콜**이 최고!



---------------------------------------------------------------------------


\## ✅ 문제 3


\*\*문제:\*\*  

다음 설명에 해당하는 응집도 유형을 보기에서 골라 쓰시오


모듈 내부의 각 기능들이 서로 연관성을 가지고 \*\*순차적으로 수행되는 응집도 유형\*\*을 말한다.  
하나의 작업이 끝나면 그 결과가 다음 작업의 입력으로 사용되며,  
이러한 과정이 연속적으로 이어지는 형태이다.  
이 응집도는 \*\*기능적 응집도보다는 낮지만 절차적 응집도보다는 높은\*\* 수준의 응집도를 가진다.


\*\*답:\*\*  

순차적 응집도


---
## 📌 관련 개념 설명: 응집도(Cohesion)

응집도란 **모듈 내부 구성 요소들이 얼마나 관련된 기능들로 구성되었는지를 나타내는 척도**야.  
응집도가 **높을수록 코드가 깔끔하고, 유지보수도 쉽고, 재사용도 쉬워진다.**

> 📌 한 마디로: **모듈 안에 있는 기능들이 얼마나 서로 관련 있냐?**

---

### 🔼 응집도 수준 (높은 응집도 → 낮은 응집도 순)

| 응집도 유형         | 설명 | 갓반인 예시 |
|----------------------|------|-------------|
| **기능적 응집도**     | 모듈이 하나의 **명확한 기능만** 수행함 <br>(가장 이상적) | "계산기 앱에서 딱 **'덧셈만'** 하는 함수" |
| **순차적 응집도**     | 앞 단계 결과가 다음 단계의 입력이 됨 | "이름 입력 → 이름 대문자로 변환 → 출력" |
| **통신적 응집도**     | 같은 입력/출력을 쓰는 기능끼리 묶음 | "학생 이름 받아서 **출석도 체크**하고 **성적도 조회**" |
| **절차적 응집도**     | 순서대로 돌아가긴 하는데, **데이터 연관은 없음** | "로그인 → 화면 출력 → 알림 보내기 (내용은 따로놀음)" |
| **시간적 응집도**     | **같은 시간에 동시에 실행**되는 기능들 | "앱 실행하자마자 **환경 설정, 알림 초기화** 같이 실행됨" |
| **논리적 응집도**     | 비슷한 기능이지만, **내부 선택 구조 있음** | "학생 메뉴에서 '조회', '입력', '수정'을 if문으로 구분" |
| **우연적 응집도**     | 그냥 이것저것 섞여 있음 (**최악**) | "과목조회 + 채팅기능 + 로그인 전부 한 함수에 넣음" |

---

## 📌 비교 포인트 요약

| 응집도 유형     | 주요 특징 | 갓반인식 해석 |
|----------------|-----------|---------------|
| **기능적**     | 하나의 목적, 딱 하나만 함 | "딱 덧셈만 해!" |
| **순차적**     | 앞 결과가 뒤 입력 | "A 결과가 B에 들어가서 C로 감" |
| **통신적**     | 같은 데이터로 여러 일 함 | "같은 학생 정보로 출석도 하고 성적도 봄" |
| **절차적**     | 순서대로지만 각자 따로 놈 | "로그인하고, 화면 출력하고... 연관은 없음" |
| **시간적**     | 특정 시간에 같이 실행됨 | "앱 켤 때 초기 세팅 몰아서 실행" |
| **논리적**     | 비슷한 기능 묶고 if/switch로 나눔 | "메뉴 여러 개 들어있고 분기 처리함" |
| **우연적**     | 그냥 아무 기능이나 때려박음 | "잡탕 코드, 절대 금지" |

---

✅ 핵심 요약:  
**기능적 응집도**가 가장 이상적인 구조고,  
**우연적 응집도**는 최악. **위로 갈수록 좋은 코드!**



---------------------------------------------------------------------------

\## ✅ 문제 4

\*\*문제:\*\*  

다음 설명을 듣고 빈칸에 들어갈 네트워크 전송 방식 두 가지를 각각 쓰시오

(1)은 \*\*연결 지향적\*\*으로, 데이터 전송 전에 먼저 \*\*경로를 설정한 후\*\* 모든 패킷이 동일한 경로를 통해 순차적으로 전달된다.  
이 방식은 \*\*연결이 설정된 후에야 데이터가 전송\*\*되며, 패킷이 \*\*순서대로 도착하는 것이 보장\*\*된다.  
(2)는 \*\*비연결 지향적\*\*으로, 경로를 미리 설정하지 않고 각 패킷이 \*\*독립적으로 전송\*\*되며, 패킷이 서로 다른 경로를 통해 전달될 수 있다.  
패킷이 목적지에 도착하는 \*\*순서가 보장되지 않으며\*\*, 각 패킷이 \*\*개별적으로 처리\*\*되는 방식이다.

\*\*답:\*\*  

(1) 가상회선 방식  
(2) 데이터그램 방식

## 📌 관련 개념 설명

### 🔹 데이터 교환 방식 개요
데이터 전송에는 두 가지 큰 방식이 있어:

- **회선 교환(Circuit Switching)**: 전화처럼 먼저 선(회선)을 연결하고, 그 위로 데이터가 흐름
- **축적 후 교환(Store and Forward)**: 데이터를 잠깐 저장했다가 보냄 → 여기서 **메시지 교환**과 **패킷 교환**으로 나뉘어

> 📌 갓반인 예시:  
> 회선 교환은 **통화 연결**이 먼저 되는 전화,  
> 패킷 교환은 **카톡 메시지**처럼 따로따로 보내는 느낌이야.

---

### 🔸 (1) 가상회선 방식 (Virtual Circuit)

- 💡 **연결형 방식**이야: 먼저 길부터 만들어놓고 나중에 데이터 보냄
- **모든 패킷이 같은 경로**로 감
- 순서대로 도착해서, **순서 보장**됨
- 처음 연결이 필요하니 **속도는 살짝 느릴 수도** 있어
- 📦 예시: ATM 통신망, X.25, 프레임 릴레이 등

> 👨‍🏫 갓반인식 설명:  
> "패킷들아, 줄 맞춰서 이 길로만 가자~ 중간에 길 바꾸면 안 돼!"

---

### 🔸 (2) 데이터그램 방식 (Datagram)

- 💡 **비연결형 방식**: 연결 없이 바로 데이터 보냄
- **각 패킷이 경로를 알아서 선택**해서 감
- 중간에 길이 달라질 수 있어서 **순서가 뒤죽박죽 도착할 수 있음**
- 속도는 빠르지만, 순서 정렬은 **수신 쪽에서 처리해야 함**
- 📦 예시: IP (인터넷 프로토콜), UDP 등

> 👨‍🏫 갓반인식 설명:  
> "야 니네 그냥 아무 길로 가! 어차피 도착은 하니까~ 근데 순서 섞일 수도 있음"

---

## 📌 보충 설명: 회선 교환 vs. 패킷 교환

| 구분       | 회선 교환                            | 패킷 교환 (가상회선 / 데이터그램)                       |
|------------|--------------------------------------|---------------------------------------------------------|
| **연결 설정** | 전송 전에 필수로 선 연결함                | 가상회선: 연결함<br>데이터그램: 연결 안 함              |
| **전송 경로** | 처음부터 끝까지 고정 경로 사용              | 가상회선: 고정<br>데이터그램: 패킷마다 경로 다를 수 있음 |
| **순서 보장** | 항상 보장 (줄 맞춰 감)                   | 가상회선: 보장<br>데이터그램: 순서 섞일 수 있음         |
| **전송 단위** | 연속된 비트 스트림                      | **패킷 단위** (작게 나눠서 보냄)                         |

> 👨‍🏫 갓반인식 요약:
> - 회선 교환: “통화 먼저 연결하고, 그다음 말해”  
> - 패킷 교환(가상회선): “길 정해놓고 조각조각 보냄”  
> - 패킷 교환(데이터그램): “조각조각 막 보냄, 경로랑 순서 신경 안 씀”

---

✅ **정리 한 줄 요약**  
- 회선 교환: **길 먼저 만들고 데이터 보냄**  
- 가상회선: **길은 만들지만, 데이터는 패킷 단위**  
- 데이터그램: **길도 필요 없고, 순서도 자유로움**


---------------------------------------------------------------------------

\## ✅ 문제 5


\*\*문제:\*\*  

객체의 내부 구조를 감추면서도 일관된 방식으로 그 내부에 포함된 요소들을 \*\*순차적으로 접근\*\*할 수 있게 하며,  
동시에 여러 종류의 컬렉션 (예: 배열, 리스트, 트리)에서도 \*\*동일한 접근 방식\*\*을 제공하여  
컬렉션의 구현과 상관없이 순회가 가능하도록 하는 디자인패턴은 무엇인지 보기에서 골라 쓰시오.

\*\*답:\*\*  

Iterator (이터레이터)

---

## 📌 관련 개념 설명

### 🔸 Iterator 패턴

- **정의:**  
  컬렉션(배열, 리스트, 트리 등)의 내부 구조를 **노출하지 않고**  
  그 내부 요소를 **순차적으로 접근**할 수 있도록 하는 디자인 패턴

- **목적:**  
  다양한 자료구조에서 **동일한 방식으로 접근(순회)** 가능하게 함

- **주요 특징:**
  - **컬렉션과 분리된 순회 기능** 제공
  - 내부 구조의 변경 없이 접근 가능
  - **단일 인터페이스**로 여러 자료구조 대응 가능

- **주요 메서드 (Java 기준):**
  - `hasNext()` : 다음 요소가 있는지 확인
  - `next()` : 다음 요소 반환

- **일상 비유:**  
  자판기에서 음료를 하나씩 순서대로 꺼내 마시는 것처럼, 어떤 구조든 내부 구조 모르고 버튼만 누르면 다음 항목이 나오는 것.

---

## 📌 객체지향 구성 요소

| 구성 요소         | 설명                              | 일상 비유 |
|------------------|-----------------------------------|------------|
| **클래스 (class)**   | 데이터를 추상화한 설계도               | 레시피 (요리법) |
| **객체 (object)**   | 클래스의 인스턴스                   | 실제로 만든 요리 |
| **속성 (attribute)**| 객체가 가진 데이터                   | 요리의 재료 (예: 토핑, 소스) |
| **메서드 (method)** | 객체가 수행하는 동작                  | 요리 방법 (예: 굽기, 끓이기) |
| **메시지 (message)**| 객체에게 행위를 요청하는 것 (메서드 호출) | 요리사에게 "피자 구워줘"라고 말하는 것 |

---

## 📌 객체지향의 주요 특징

- **캡슐화 (Encapsulation):**  
  데이터를 외부에서 직접 접근하지 못하게 숨기고, 메서드를 통해서만 접근하도록 함  
  → 약을 먹을 때 알약은 캡슐에 싸여 있어, 알약을 통째로 복용하지만 내부 성분은 모르듯이.

- **정보은닉 (Information Hiding):**  
  외부에 불필요한 내부 세부사항을 숨김  
  → 리모컨 버튼만 알면 TV를 켤 수 있고, 내부 회로는 몰라도 됨.

- **상속 (Inheritance):**  
  부모 클래스의 속성과 기능을 자식 클래스가 물려받음  
  → 자식이 부모의 유전자나 성격을 물려받는 것처럼.

- **다형성 (Polymorphism):**  
  하나의 메시지(메서드 호출)에 대해 **여러 형태로 응답**할 수 있음  
  → "밥 줘"라는 말에 강아지는 먹이를, 사람은 밥상을, 고양이는 캔을 떠올리는 것.

- **추상화 (Abstraction):**  
  복잡한 내용을 감추고 필요한 기능만 노출  
  → 운전자는 페달, 핸들만 조작하고 엔진 작동 방식은 몰라도 운전 가능함.


---

## 📌 객체지향 설계 원칙 (SOLID)

| 원칙 | 설명 | 비유 예시 |
|------|------|-----------|
| **SRP (단일 책임 원칙)** | 하나의 클래스는 하나의 책임만 가져야 함 | 📦 하나의 택배 박스에는 한 종류의 물건만 담는 게 정리하기 쉬움. 여러 물건 섞으면 관리 복잡해짐. |
| **OCP (개방-폐쇄 원칙)** | 확장에는 열려 있고, 수정에는 닫혀 있어야 함 | 🎮 게임에 새로운 맵 추가는 가능하지만, 기존 코드는 손대지 않아도 되게 설계함. |
| **LSP (리스코프 치환 원칙)** | 자식 클래스는 부모 클래스를 대체할 수 있어야 함 | 🧸 장난감 배터리를 일반 AA건전지로 바꿔도 문제없이 작동해야 함. 새 부품이 예전 부품 역할을 그대로 해야 해. |
| **ISP (인터페이스 분리 원칙)** | 하나의 일반 인터페이스보다 여러 개의 구체적 인터페이스가 낫다 | ☎️ 전화 앱에 통화, 문자, 주소록 기능이 다 있지만 사용자에게는 필요한 기능만 보이게 하는 게 낫다. |
| **DIP (의존성 역전 원칙)** | 구체적인 것보다 추상적인 것에 의존해야 함 | 🎭 배우는 대본(추상)에 따라 연기하지, 특정 상황에만 맞는 지문(구체)에만 의존하지 않아야 유연하게 연기 가능함. |

---------------------------------------------------------------------------

\## ✅ 문제 6



\*\*문제:\*\*  

다음 설명에 해당하는 암호화 알고리즘의 이름을 쓰시오



이 알고리즘은 미국 국립 표준기술연구소가 기존의 DES를 대체하기 위해 선정한 \*\*대칭 키 블록 암호화 알고리즘\*\*이다.  
128비트의 \*\*고정 블록 크기\*\*를 사용하며, 키 길이는 \*\*128, 192, 256 비트\*\*를 지원한다.  
\*\*보안성과 성능이 우수\*\*하며, 전 세계적으로 다양한 분야에서 널리 사용되고 있으며,  
\*\*무선 통신\*\*, \*\*금융 거래\*\*, \*\*저장 데이터의 암호화\*\* 등에서 \*\*표준\*\*으로 채택되고 있다.

\*\*답:\*\*  
AES (Advanced Encryption Standard)

---

## 📌 관련 개념 설명

### 🔐 AES (Advanced Encryption Standard)

- **암호 방식:**  
  블록 단위로 암호화하는 **대칭키 암호** 방식 (암호화와 복호화에 같은 키 사용)

- **왜 나왔냐면?**  
  옛날에 쓰던 DES가 **너무 약해서** 미국 NIST에서 2001년에 새로운 표준으로 AES를 지정함

- **키 길이와 보안 레벨:**  
  - 🔑 128비트: 빠르지만 기본적인 보안 수준  
  - 🔑 192비트, 256비트: 더 강력한 보안

- **블록 크기:** 128비트 고정  
- **라운드 수:**  
  - 128bit → 10라운드  
  - 192bit → 12라운드  
  - 256bit → 14라운드

- **암호 구조:**  
  SPN(Substitution-Permutation Network):  
  → 데이터를 여러 번 바꾸고 섞는 구조

> 👨‍🏫 갓반인 예시:  
> AES는 마치 데이터를 **잘게 잘라서(블록)**,  
> **여러 번 섞고 바꾸는 요리법** 같음.  
> 요리마다 🔑 비밀 레시피(키)가 있고,  
> 같은 레시피로만 다시 만들 수 있어야 해!  

---

## 📌 주요 블록 암호 알고리즘 비교

| 알고리즘     | 블록 크기 | 키 길이          | 라운드 수   | 구조        | 국가/특징            |
|--------------|-----------|------------------|-------------|-------------|-----------------------|
| **DES**      | 64비트    | 56비트           | 16라운드    | Feistel     | 🇺🇸 미국, 오래돼서 위험 |
| **3DES**     | 64비트    | 112/168비트      | 48라운드    | Feistel     | DES 3번 돌려서 강화   |
| **AES**      | 128비트   | 128/192/256비트  | 10/12/14    | SPN         | 🇺🇸 미국, 최신 표준     |
| **SEED**     | 128비트   | 128비트          | 16라운드    | Feistel     | 🇰🇷 한국 자체 알고리즘  |
| **ARIA**     | 128비트   | 128/192/256비트  | 12/14/16    | SPN         | 🇰🇷 한국, AES 대응용    |
| **LEA**      | 128비트   | 128/192/256비트  | 24/28/32    | SPN         | 🇰🇷 한국, 경량 디바이스용 |
| **IDEA**     | 64비트    | 128비트          | 8라운드     | Feistel+SPN | 🇨🇭 스위스, 유럽계 암호 |
| **Skipjack** | 64비트    | 80비트           | 32라운드    | Feistel 변형 | 🇺🇸 NSA 개발, 비공개성 논란 |

> 📌 갓반인 팁:  
> AES = 요즘 대세  
> DES = 구식  
> SEED/ARIA = 한국표  
> LEA = 가벼운 장비용 (IoT 같은 곳에 좋음)

---

## 📌 기타 암호 알고리즘 분류 요약

### ✅ 스트림 암호 (한 글자씩 암호화)

| 알고리즘 | 설명 |
|----------|------|
| **LFSR** | 비트 단위 예측 어려운 무작위 생성기 |
| **RC4**  | 웹에서 SSL 등에 쓰였지만 이제는 보안상 잘 안 씀 |
| **A5**   | GSM 통신 (구형 휴대폰 네트워크)에서 사용 |

> 👨‍🏫 갓반인식 설명:  
> 스트림 암호는 “**물 흐르듯 한 글자씩** 암호화”하는 거야.  
> RC4는 예전에 **와이파이 보안(WEP)**에 쓰였는데 요즘은 탈락!

---

### ✅ 공개키 암호 (비대칭키)

| 기반 이론   | 알고리즘 |
|-------------|----------|
| **소인수분해** | RSA, Rabin |
| **이산대수**   | Diffie-Hellman, DSA, ElGamal |
| **타원곡선**   | ECC (Elliptic Curve Cryptography) |

> 👨‍🏫 갓반인 예시:  
> RSA는 “큰 수 나누는 거 어려움”에 착안,  
> ECC는 “타원 위 점 계산이 어렵다”는 걸 활용한 암호임.  
> **둘 다 비대칭**, 즉 "🔓 공개키로 잠그고, 🔑 개인키로 푸는 구조"

---

### ✅ 단방향 암호 (해시 함수)

| 알고리즘     | 설명 |
|--------------|------|
| **MD5**      | 빠르지만 충돌 발생 가능 → 요즘은 잘 안 씀 |
| **SHA**      | 미국 표준, SHA-256이 가장 널리 쓰임 |
| **HAS-160**  | 한국에서 개발, KCDSA와 함께 사용됨 |

> 👨‍🏫 갓반인 요약:  
> 해시는 **“지문”처럼 한 방향으로만 가는 함수**  
> 원래 값은 못 찾고, 같은 값이 나오지 않게 설계됨

---

✅ **총정리 한 줄 요약**

- **AES**: 지금 표준 블록 암호, 빠르고 강력함  
- **스트림 암호**: 실시간성 통신에 적합  
- **공개키 암호**: 키를 나눠 쓰는 안전한 구조  
- **해시 함수**: 무결성 검사나 비밀번호 저장용으로 최적

> 💡 갓반인 암기팁:  
> "AES는 블록, RC4는 스트림, RSA는 공개키, SHA는 해시!"



---------------------------------------------------------------------------

\## ✅ 문제 7


\*\*문제:\*\*  

다음 설명에 해당하는 결합도 유형을 쓰시오


두 모듈 사이에서 \*\*하나의 모듈이 다른 모듈의 내부 논리 흐름을 제어\*\*해  
\*\*특정 제어 신호를 전달하는 결합도\*\* 유형을 말한다.  
이 결합도는 모듈 간의 독립성을 저하시켜 \*\*유지보수와 확장성에 부정적인 영향\*\*을 미칠 수 있다.  
일반적으로 이 결합도가 존재할 경우, 호출하는 모듈이 호출된 모듈의 \*\*내부 동작 방식까지 알고 있어야\*\* 하므로  
모듈 간에 \*\*강한 의존성\*\*이 발생한다.  
따라서 제어 신호가 변경되면 관련된 \*\*모든 모듈을 수정\*\*해야 하는 상황이 발생할 수 있다.



\*\*답:\*\*  
제어 결합도 (Control Coupling)

---
## 📌 관련 개념 설명: 결합도(Coupling)

**결합도**는 모듈 간 **의존성의 정도**를 나타냄.  
결합도가 **낮을수록** 모듈 간 **독립성이 높고**,  
**유지보수, 재사용, 테스트가 쉬움** → 좋은 소프트웨어 설계의 핵심 목표!

👉 **이상적인 구조:**  
- **낮은 결합도 + 높은 응집도**

---

### 🔽 결합도의 종류 (낮은 결합도 → 높은 결합도 순)

| 결합도 유형                 | 설명 |
|----------------------------|------|
| ✅ **자료 결합도 (Data Coupling)**     | - **단순 데이터 값(숫자, 문자 등)** 만 전달<br> - 예: `calcSum(5, 10)`<br> - 🔥 가장 이상적 |
| ⚠️ **스탬프 결합도 (Stamp Coupling)** | - **구조체/객체 통째로 전달**<br> - 필요한 데이터만 전달하지 않고 덩어리째 전달<br> - 예: `process(Student s)` |
| ⚠️ **제어 결합도 (Control Coupling)** | - **제어 플래그(논리값 등)**을 전달해 상대 모듈의 흐름 결정<br> - 예: `handle(true)` → 내부에서 if문 분기 발생 |
| ⚠️ **외부 결합도 (External Coupling)** | - **외부 시스템 자원(DB, 환경변수)**을 여러 모듈이 공유 사용<br> - 독립성 ↓, 테스트 어려움 |
| ❌ **공통 결합도 (Common Coupling)**   | - **전역 변수 공유**<br> - 여러 모듈이 같은 전역 변수에 의존 → 변경 시 전체 영향 |
| ❌❌ **내용 결합도 (Content Coupling)** | - **한 모듈이 다른 모듈 내부 직접 접근/수정**<br> - 예: 다른 모듈의 변수나 함수에 직접 접근<br> - 🔥 최악의 결합도 (무조건 피해야 함) |

---

## 📌 제어 결합도 예시 (Java)

```java
// orderType 값에 따라 다른 처리를 하도록 설계 → 제어 결합도 발생
void processOrder(int orderType) {
    if (orderType == 1) {
        // 배송 처리
    } else if (orderType == 2) {
        // 반품 처리
    }
}
## 👨‍🏫 갓반인식 설명

**제어 결합도**는 말이지...  
**"다른 모듈이 if문을 짜게 만드는 구조"**야.

예를 들어, A 모듈이 B 모듈한테  
“야, 이거 `true`면 이렇게 처리하고, `false`면 저렇게 해~”  
라고 알려주는 거지.  
**B는 그냥 판단만 하면 되는 애인데, 괜히 로직까지 떠안게 됨.**

> 🎯 **좋은 구조:**  
> "데이터만 넘기고 판단은 각자 알아서!"  
> → **"정보 전달만 하고, 판단은 각자 모듈이!"**

---

## 📌 갓반인 요약 정리

| 결합도 유형             | 한 줄 요약               | 추천도     |
|------------------------|--------------------------|------------|
| ✅ **자료 결합도**       | 값만 전달, 딱 필요한 만큼  | ✅ **최고** |
| ⚠️ **스탬프 결합도**     | 구조체 통째로 줌           | ⚠️ 조심     |
| ⚠️ **제어 결합도**       | 흐름 제어 정보 전달        | ⚠️ 조심     |
| ⚠️ **외부 결합도**       | 외부 자원 같이 씀          | ⚠️ 피해야 함 |
| ❌ **공통 결합도**       | 전역변수 나눠 씀           | ❌ 위험     |
| ❌❌ **내용 결합도**      | 남의 모듈에 직접 손댐      | ❌❌ **최악** |

---

## 🔥 갓반인 암기 팁

> **자료만 줘**  
> → **Stamp는 덩어리**  
> → **Control은 간섭**  
> → **외부랑 공유**  
> → **전역변수 쓰고**  
> → **내용 직접 해킹!**

👉 결합도는 **거리를 얼마나 둬야 이상적인 관계인가** 생각하면 됨.  
**자료 결합도는 딱 필요한 말만 하는 사이고,  
내용 결합도는 사생활까지 뒤지는 최악의 친구지.**

---------------------------------------------------------------------------

\## ✅ 문제 8

\*\*문제:\*\*  

다음은 프로세스가 준비 상태 큐에 도착한 시간과 프로세스를 처리하는데 필요한 실행시간을 보여준다.  
\*\*선점형 스케줄링 알고리즘인 SRT 알고리즘\*\*을 사용할 경우 프로세스들의 \*\*평균 대기시간을 구하시오\*\*.  
(단, 프로세스 간 문맥교환에 따른 오버헤드는 무시하며, 주어진 4개 프로세스 외에 처리할 다른 프로세스는 없다고 가정한다)


| 프로세스 | 도착시간 | 실행시간 |
|----------|----------|----------|
| P1       |    0     |    8     |
| P2       |    1     |    4     |
| P3       |    2     |    9     |
| P4       |    3     |    5     |



\*\*답:\*\*  

6.5

---


## 📌 해설: SRT (Shortest Remaining Time) 알고리즘

**SRT**는 👉 **SJF(Shortest Job First)**의 **선점형** 버전이야.  
즉, **실행 중인 프로세스보다 남은 실행 시간이 더 짧은 프로세스**가 도착하면  
**기존 프로세스를 멈추고 교체**하는 방식이야!

---

### 🔹 갓반인식 예시 설명

> 🤓 “P1이 실행 중인데, 갑자기 남은 시간이 더 짧은 P2가 왔네?  
> 👉 그럼 당장 멈추고 P2부터 처리하자!”  
> 이런 식으로 일 잘할 것 같은 애가 오면 바로 자리 바꾸는 거지.

---

### 🔹 스케줄링 순서 (예시)

도착/실행 시간 기반으로 각 프로세스가 언제 실행되고 교체되는지를 **타임라인**으로 보여줄 수 있어.  
(예시는 생략했지만, 필요 시 Gantt Chart 가능)

---

### 🔹 완료 시간 및 대기 시간 계산:

| 프로세스 | 도착시간 | 종료시간 | 실행시간 | 대기시간 계산                      | 대기시간 |
|----------|----------|----------|----------|------------------------------------|----------|
| **P1**   | 0        | 17       | 8        | 17 - 0 - 8                         | **9**    |
| **P2**   | 1        | 5        | 4        | 5 - 1 - 4                          | **0**    |
| **P3**   | 2        | 26       | 9        | 26 - 2 - 9                         | **15**   |
| **P4**   | 3        | 10       | 5        | 10 - 3 - 5                         | **2**    |

- 🧠 **총 대기시간 = 9 + 0 + 15 + 2 = 26**
- 📊 **평균 대기시간 = 26 ÷ 4 = 6.5**

---

## 📌 관련 개념 정리

### 🔹 스케줄링 알고리즘 분류

#### ✅ 선점형 스케줄링

| 알고리즘 | 설명 |
|----------|------|
| **Round Robin** | 타임퀀텀 기반, 일정 시간 지나면 다음 프로세스로 |
| **SRT**         | 남은 시간이 가장 짧은 프로세스가 선점 |
| **MLQ**         | 우선순위별로 큐를 나눠 관리 |
| **MLFQ**        | 작업 특성 따라 큐를 **이동**하며 스케줄링 |

#### ✅ 비선점형 스케줄링

| 알고리즘 | 설명 |
|----------|------|
| **FCFS**        | 도착 순서대로 처리 (First Come First Served) |
| **SJF**         | 실행 시간이 짧은 프로세스를 우선 |
| **HRN**         | 응답률 높은 것 우선 → Aging 적용으로 기아 방지 |
| **우선순위 기반** | 프로세스에 우선순위 부여해 높은 순 먼저 처리 |
| **기한부**      | 마감 기한 고려해 스케줄링 (실시간 시스템 등) |

---

## 📌 갓반인식 핵심 이슈들

- **기아 현상 (Starvation)**  
  👉 낮은 우선순위 프로세스가 계속 뒤로 밀려 **실행되지 못하는 상황**  
  🔥 발생 가능 알고리즘: **SJF, SRT, MLQ, 우선순위 스케줄링**

- **에이징 (Aging)**  
  👉 대기 시간이 길수록 우선순위를 **점점 높여주는 방식**  
  ✅ 해결책으로 사용됨 (예: **HRN, MLFQ** 등)

---

## 📌 페이지 교체 알고리즘 요약

| 알고리즘 | 설명 |
|----------|------|
| **FIFO** | 먼저 들어온 페이지부터 제거 (First In First Out) |
| **OPT**  | 미래를 예측해, **가장 오래 안 쓸 페이지 제거** (이론적 최적) |
| **LRU**  | 최근에 **가장 오래 안 쓴 페이지** 제거 (과거 기반) |
| **LFU**  | **사용 횟수 가장 적은 페이지** 제거 |
| **NUR**  | 최근 사용 여부 비트로 교체 판단 (하드웨어 기반 최적화) |
| **SCR**  | FIFO + Second Chance 부여해서 최근 사용 여부 체크 |

---

## 👊 갓반인 암기 꿀팁 정리

> 스케줄링이든 페이지 교체든,  
> **선점/비선점**, **미래 기반/과거 기반**을 먼저 파악하면 흐름이 보여!

- SRT = SJF + 선점  
- OPT = 미래 예측, LRU = 과거 참조  
- MLQ vs MLFQ 차이는 "큐 이동" 유무

---------------------------------------------------------------------------

## ✅ 문제 9

**문제:**  
다음 네트워크 구성도를 참고하여, **RIP**를 사용해 **라우터 A에서 라우터 F까지 가는 최적 경로**를 구하시오.  
각 라우터 간의 **연결 비용은 각 간선에 명시된 숫자**로 나타내며, **비용은 홉 수(hop count)**로 계산된다.

**답:**  
**A → D → C → F**  
즉, **ADCF**

---

## 📌 해설: RIP (Routing Information Protocol)

### 🔹 갓반인식 핵심 요약

> “RIP는 ‘몇 번 거치냐(=홉 수)’만 본다.  
> 실제 거리, 비용 그런 거 몰라.  
> 단순하게 **적게 거치는 경로가 최고**임!”

---

### 🔹 RIP의 특징

| 항목         | 내용 |
|--------------|------|
| 🧠 **라우팅 알고리즘** | 거리 벡터 (Distance Vector) |
| 📏 **Metric**           | 홉 수 (Hop Count) |
| 🚫 **최대 홉 수**       | 15 → 16은 "도달 불가"로 간주 |
| ✅ **경로 선택 기준**   | 홉 수가 가장 적은 경로 |

> 🔥 핵심: **A → D → C → F** 가 정답이면, 이유는 “홉 수 3으로 최소라서”임.  
> 비용 숫자가 아무리 작아도, RIP는 그딴 거 안 봄.

---

## 📌 문제 해석 꿀팁 (갓반인 설명)

1. 문제에 "연결 비용"이 숫자로 나온다 해도, **RIP는 전부 무시**
2. 오직 “몇 개의 라우터를 거치느냐”만 판단 기준임
3. 정답은 “거치는 라우터 수 = 홉 수”가 가장 작은 경로

---

### 🔹 예시 경로 비교

| 경로           | 홉 수 | 설명                        |
|----------------|-------|-----------------------------|
| A → B → E → F  | 3     | 중간 라우터 2개 거침        |
| **A → D → C → F** | **3**   | ✅ 정답 경로, RIP 기준 최소 홉 |
| A → D → F      | 2     | 연결 안 됐으면 탈락         |
| A → C → F      | 2     | 연결 상태에 따라 가능/불가  |

---

## 📌 RIP 한눈 정리

| 항목       | 설명 |
|------------|------|
| 🧪 동작 방식 | 이웃 라우터에게 라우팅 테이블을 **주기적 전파** |
| 📉 수렴 속도 | 느림 (루프 발생 가능) |
| 🧱 한계     | 최대 15홉까지만 가능 |
| 🛠️ 장점     | 단순, 설정 쉬움 |
| ⚠️ 단점     | 대규모 네트워크에 부적합, 정확성 낮음 |

---

## 📌 라우팅 프로토콜 분류 정리

| 분류     | 종류       | 프로토콜            | 특징 |
|----------|------------|---------------------|------|
| **정적** | Static     | 수동 설정           | 단순하지만 자동화 안됨 |
| **동적** | 내부 IGP   | **RIP** (거리 벡터) <br> **OSPF** (링크 상태) | RIP: 홉 수 기준 <br> OSPF: 링크 비용 기준 |
|          | 외부 EGP   | **BGP**              | 다른 AS 간 라우팅 (인터넷 전체에서 사용) |

---

## 🧠 갓반인 암기 팁

> RIP: "몇 칸 가는지만 봐!"  
> OSPF: "도로 상황(비용)까지 감안!"  
> BGP: "나라 간 외교!"  
> → RIP은 **단순 무식**, OSPF는 **똑똑한 도로 공무원**, BGP는 **국제 협상가** 느낌!





---------------------------------------------------------------------------

\## ✅ 문제 10



\*\*문제:\*\*  

다음 테이블의 \*\*카디널리티(행 개수)\*\*와 \*\*차수(열 개수)\*\*를 구하시오.



| 학번    | 이름 | 학년 | 학과         |
|--------|------|------|--------------|
| 181101 | KKK  | 1    | 컴퓨터공학과 |
| 171201 | hhh  | 2    | 전자공학과   |
| 171302 | xxx  | 3    | 컴퓨터공학과 |
| 161107 | yyy  | 3    | 건축공학과   |
| 151403 | qqq  | 4    | 전자공학과   |


\*\*답:\*\*  
\- \*\*카디널리티 (행 수):\*\* 5  
\- \*\*차수 (열 수):\*\* 4


## 📌 해설

| 용어                        | 정의                                      | 예시 (위 테이블 기준)         |
|-----------------------------|-------------------------------------------|-------------------------------|
| **카디널리티 (Cardinality)** | **튜플(Tuple)** 또는 **행(Row)**의 수       | 5행 → **카디널리티: 5**       |
| **차수 (Degree)**            | **속성(Attribute)** 또는 **열(Column)**의 수 | 4열 → **차수: 4**             |

---

### 🔹 릴레이션(Relation)의 구성 요소

| 용어                | 설명                        |
|---------------------|-----------------------------|
| **속성(Attribute)**  | 열(Column) 구성요소, 즉 테이블의 컬럼명들 |
| **튜플(Tuple)**      | 행(Row) 구성요소, 하나의 레코드          |
| **카디널리티**       | 튜플의 수 = 행(Row) 수                   |
| **차수**             | 속성의 수 = 열(Column) 수                |

---

### 🔹 데이터베이스 테이블의 예시 용어 매핑

- **속성(Attribute)** → `학번`, `이름`, `학년`, `학과` 등
- **튜플(Tuple)** → 각 학생의 데이터 한 줄

---

## 📌 요약

- **카디널리티(Cardinality)** = 행(Row) 수 = **5**
- **차수(Degree)** = 열(Column) 수 = **4**


---------------------------------------------------------------------------

\## ✅ 문제 11


\*\*문제:\*\*  

다음은 SQL을 이용한 데이터베이스 관리 작업에 관한 문제이다.  
빈칸에 들어갈 적절한 SQL 키워드를 쓰시오.

insert into 직원(직원번호, 성명, 나이, 연봉, 팀번호)

(1) (101, 'kim', 25, 3000, 2);
insert into 직원

(2) 직원번호, 성명, 나이, 연봉, 팀번호 from 신규직원 where 팀번호 = 2;
delete (3) 직원 where 직원번호 = 101;
update 직원 (4) 연봉 = 3500 where 성명 = 'lee';



답

(1) values
(2) select
(3) from
(4) set




## 📌 해설: INSERT, DELETE, UPDATE 문 쉽게 이해하기

👨‍🏫 **갓반인식 한 줄 정리**  
- INSERT는 "데이터 넣기",  
- DELETE는 "행 지우기",  
- UPDATE는 "값 바꾸기"  
➡ 각각에 맞는 키워드만 알면 끝!

---

## 📌 핵심 개념 요약

| SQL 명령어                | 설명                                | 갓반인 예시 |
|---------------------------|-------------------------------------|-------------|
| **INSERT INTO ... VALUES** | 직접 값을 넣을 때 사용                  | `INSERT INTO 직원 VALUES (101, 'kim', 25, 3000, 2);` |
| **INSERT INTO ... SELECT** | 다른 테이블에서 선택해서 데이터 넣기     | `INSERT INTO 직원 SELECT 직원번호, 성명, 나이, 연봉, 팀번호 FROM 신규직원 WHERE 팀번호 = 2;` |
| **DELETE FROM**            | 조건에 맞는 행을 삭제할 때 사용         | `DELETE FROM 직원 WHERE 직원번호 = 101;` |
| **UPDATE ... SET ... WHERE** | 테이블의 특정 컬럼 값을 수정할 때 사용 | `UPDATE 직원 SET 연봉 = 3500 WHERE 성명 = 'lee';` |

---

## 📌 갓반인식 설명

### ✅ INSERT 문
- `VALUES`: **직접 하나하나 값 때려박는 방식**
  > "직원(101, 'kim'...) 이런 애 넣고 싶어요!"  
- `SELECT`: **다른 테이블에서 복사 붙여넣기**
  > "신규직원 중 팀번호 2인 애들 전체 복붙!"

### ✅ DELETE 문
- `FROM`: **어디서 삭제할지** 지정
  > "직원 테이블에서 직원번호 101번 없애!"

### ✅ UPDATE 문
- `SET`: **무엇을 어떻게 바꿀지** 설정
  > "연봉을 3500으로 올려! (단, lee인 애만)"

---

## 📌 주의사항 (실수 방지 팁)

| 상황                  | 꼭 기억해야 할 점 |
|-----------------------|-------------------|
| INSERT 시             | `VALUES` or `SELECT` 중 하나만 사용해야 함 |
| DELETE 시             | `FROM`은 필수! (`DELETE 직원` ❌ → `DELETE FROM 직원` ✅) |
| UPDATE 시             | `SET`으로 수정 대상 명확히 지정해야 함 |

---

## 📌 갓반인 암기법

> `INSERT = VALUES or SELECT`  
> `DELETE = FROM 꼭 써라`  
> `UPDATE = SET 없으면 아무것도 안 바뀜`

---

🔥 **실무 팁**  
- `WHERE` 없이 `DELETE`나 `UPDATE` 하면 전부 날라감 ⚠️  
  ➤ `DELETE FROM 직원;` → 직원 전원 해고됨 😱  
  ➤ `UPDATE 직원 SET 연봉 = 0;` → 전원 최저시급 됨

🧠 그래서 항상 `WHERE` 조건 확인은 습관처럼!




---------------------------------------------------------------------------

# 🚀 문제 12) JAVA 코드의 출력 결과를 쓰시오


## 📌 문제 코드 (원본)
public class Main {
                                                                // 배열 비교 함수 정의
                                                                // 두 int 배열이 같은지 비교한다.
                                                                // x: 첫 번째 배열 (int[] 타입)
                                                                // y: 두 번째 배열 (int[] 타입)
    public static void check(int[] x, int[] y) {
                                                        // '==' 연산자로 배열을 비교하면, 배열의 '내용'을 비교하는 게 아니라
                                                        // 두 배열이 '메모리 상에서 완전히 같은 객체(동일한 주소)'인지 비교한다. (핵심!)
        if (x == y) {
            System.out.print("O");                           // 메모리 주소가 같으면 'O' 출력
        } else {
            System.out.print("X");                           // 메모리 주소가 다르면 'X' 출력
        }
    }

                                                        // 프로그램의 메인 진입점
    public static void main(String[] args) {
                                                      // 크기와 내용이 '같은' 세 개의 int 배열을 '새로' 생성한다.
                                                      // 자바에서 'new' 키워드는 항상 새로운 메모리 공간을 할당한다.
        int a[] = new int[] { 1, 2, 3, 4 };                 // 새로운 배열 객체 생성 (메모리 주소 1)
        int b[] = new int[] { 1, 2, 3, 4 };                 // 또 다른 새로운 배열 객체 생성 (메모리 주소 2)
        int c[] = new int[] { 1, 2, 3, 4 };               // 또 또 다른 새로운 배열 객체 생성 (메모리 주소 3)

                                      // check 함수를 세 번 호출하여 각 배열 쌍을 비교한다.
                                      // '==' 연산자는 배열의 내용이 같더라도 메모리 주소가 다르면 '다르다'고 판단한다.
        check(a, b);                     // a와 b는 내용이 같지만, 다른 메모리 주소를 가지고 있으므로 'X'
        check(b, c);                       // b와 c는 내용이 같지만, 다른 메모리 주소를 가지고 있으므로 'X'
        check(a, c);                         // a와 c는 내용이 같지만, 다른 메모리 주소를 가지고 있으므로 'X'
    }
}


✅ 출력 결과
XXX


---------------------------------------------------------------------------

## 🚀 문제 13) Python 문자열 부분 문자열 개수 세기 풀이

def fnc(str_main, p_sub):                               # 'str_main' 문자열에서 'p_sub' 부분 문자열이 몇 번 나오는지 세는 함수
                                                       # 파이썬 내장 함수 'str'과 겹치지 않게 변수명 변경 (관례상 좋음)
    cnt = 0                                            # 부분 문자열 발견 횟수를 저장할 카운트 초기화
    
                                                            # 'str_main' 문자열의 각 인덱스를 순회한다.
                                                            # 'p_sub'의 길이만큼 잘라낼 것이므로, 'str_main' 길이에서 'p_sub' 길이를 뺀 지점까지만 순회하면 된다.
                                                            # 예를 들어, "abc"에서 "bc"를 찾을 때, 'a' (인덱스 0)에서 "bc"를 자르고, 'b' (인덱스 1)에서 "bc"를 자르면 끝.
                                                            # 'c' (인덱스 2)부터 자르면 "c"만 남아서 "bc"랑 비교할 수 없다.
    for i in range(len(str_main) - len(p_sub) + 1):             # <-- 이 부분 중요! 끝까지 안 가도 됨
                                                              # 'str_main'에서 현재 인덱스 'i'부터 'p_sub'의 길이만큼 잘라낸다.
        tmp = str_main[i : i + len(p_sub)]
        
                                                              # 잘라낸 'tmp'가 찾으려는 부분 문자열 'p_sub'와 같으면 카운트를 1 늘린다.
        if tmp == p_sub:
            cnt += 1
            
    return cnt                                                               # 최종 카운트 반환

                                                                                    # 원본 문자열 정의
str_main = "abccabcabcca" # 변수명 'str' 대신 'str_main' 사용 (권장)

                                                                                    # 찾을 부분 문자열 정의
p1 = "ab" # 찾을 첫 번째 부분 문자열
p2 = "ca" # 찾을 두 번째 부분 문자열

                                                                                      # f-string을 사용하여 결과를 포맷팅하여 출력한다.
                                                                                      # fnc 함수를 호출하여 "ab"와 "ca"가 각각 몇 번 나오는지 계산하고, 그 결과를 문자열에 삽입한다.
print(f'ab{fnc(str_main, p1)}ca{fnc(str_main, p2)}')

---
## 🎯 최종 결과
> **정답:** `ab3ca3`

---------------------------------------------------------------------------

🚀 문제 14)  C언어 코드 출력 결과 풀이

#include <stdio.h>                                   // 표준 입출력 함수 (printf 등)를 사용하기 위해 필요한 헤더 파일

int main() {                             // C 프로그램의 메인 함수. 여기서부터 실행이 시작된다.
    int a = 11;                           // 정수형 변수 'a'를 선언하고 값 11로 초기화한다.
    int b = 19;                         // 정수형 변수 'b'를 선언하고 값 19로 초기화한다.

                                                    // 'switch' 문: 변수 'a'의 값에 따라 코드 실행 흐름을 분기한다.
    switch (a) {
        case 1:                                     // 'a'의 값이 1일 경우 이 코드 블록을 실행한다.
            b += 1;                                     // b = b + 1; (b는 19였으니 20이 된다.)
                                                      // 'break' 문이 없으므로, 다음 'case 11'로 실행이 이어진다 (fall-through).
        case 11:                                 // 'a'의 값이 11일 경우 이 코드 블록을 실행한다. (현재 'a'가 11이므로 여기서부터 실행 시작)
            b += 2;                                       // b = b + 2; (b는 19였으니 21이 된다.)
                                                    // 'break' 문이 없으므로, 다음 'default'로 실행이 이어진다 (fall-through).
        default:                             // 위에 정의된 어떤 'case'에도 해당하지 않을 경우 이 코드 블록을 실행한다.
                                               // 또는 'break' 없이 fall-through 된 경우에도 실행된다.
            b += 3;                                   // b = b + 3; (b는 21이었으니 24가 된다.)
            break;                                       // 'break' 문이 있으므로, 여기서 'switch' 문을 완전히 빠져나간다.
    }

                                                                      // 최종적으로 'a - b'의 계산 결과를 정수형으로 출력한다.
                                                                      // 'a'는 초기값 11, 'b'는 'switch' 문 실행 후 24가 되었다.
    printf("%d", a - b);                                                         // 11 - 24 = -13이 출력된다.
    
    return 0;                                                         // 프로그램이 성공적으로 종료되었음을 운영체제에 알린다.
}

✅ 최종 출력 결과
답: -13


---------------------------------------------------------

🚀 문제 15)  C언어 코드 출력 결과 풀이

#include <stdio.h> // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일

// 문자열 s의 내용을 문자열 d로 복사하는 함수
// char *d: 목적지 문자열 포인터 (복사될 곳)
// char *s: 원본 문자열 포인터 (복사할 내용이 있는 곳)
void func(char *d, char *s) {
    // 원본 문자열 s가 가리키는 문자가 널 문자('\0', 문자열의 끝을 의미)가 아닐 동안 반복한다.
    while (*s) {
        *d = *s; // s가 가리키는(현재 위치의) 문자를 d가 가리키는 곳으로 복사한다.
        d++;     // 목적지 포인터 d를 다음 메모리 위치로 이동시킨다. (다음 문자 복사를 위해)
        s++;     // 원본 포인터 s를 다음 메모리 위치로 이동시킨다. (다음 문자 읽기를 위해)
    }
    *d = '\0'; // 원본 문자열 복사가 끝나면, 목적지 문자열 d의 현재 위치에 널 문자('\0')를 추가한다.
               // 이는 복사된 문자열의 끝을 명확히 표시하여 다른 함수들이 문자열의 끝을 알 수 있게 한다.
}

int main() {
    char str1[] = "eraon";                         // 문자열 "eraon"을 저장하는 char 배열 str1을 선언하고 초기화한다.
                                                   // 이 배열은 'e', 'r', 'a', 'o', 'n', '\0' (널 문자) 총 6칸의 메모리를 차지한다.
                                                       // 즉, 배열의 크기는 6이다.
    char str2[50] = "c language";                     // 크기가 50인 char 배열 str2를 선언하고 "c language"로 초기화한다.
                                                     // "c language"는 10글자이고 널 문자 포함 11칸을 사용한다.
                                                               // 나머지 39칸은 비어있다 (혹은 널 문자로 채워져 있다).
    int sum = 0;                                           // 합계를 저장할 정수형 변수 sum을 0으로 초기화한다.

                                                                      // func 함수를 호출하여 str1의 내용을 str2로 복사한다.
                                                                      // func("c language"의 시작 주소, "eraon"의 시작 주소)
                                                                  // 이 호출 후 str2의 내용은 "eraon"으로 바뀐다.
                                                                  // str2: 'e', 'r', 'a', 'o', 'n', '\0', 'g', 'u', 'a', 'g', 'e', ..., '\0'
                                                              //(기존 "c language" 뒷부분은 덮어쓰지 않은 채 남아있을 수 있지만, 'eraon' 뒤의 '\0' 때문에 문자열은 'eraon'으로 인식됨)
     func(str2, str1);

                                                                    // str2 배열의 각 문자를 순회하며 인덱스를 sum에 더한다.
                                                                    // 널 문자('\0')를 만나기 전까지 반복한다.
    for (int i = 0; str2[i] != '\0'; i++) {
                                                                      // 현재 인덱스 'i'를 sum에 더한다.
                                                                      // str2의 내용은 "eraon"이므로, 널 문자는 5번째 인덱스 (str2[5])에 있다.
                                                                      // 따라서 루프는 i = 0, 1, 2, 3, 4 까지 실행된다.
        sum += i; 
                                                                            /*
                                                                            i = 0: sum = 0 + 0 = 0
                                                                            i = 1: sum = 0 + 1 = 1
                                                                            i = 2: sum = 1 + 2 = 3
                                                                            i = 3: sum = 3 + 3 = 6
                                                                            i = 4: sum = 6 + 4 = 10
                                                                            i = 5: str2[5]는 '\0'이므로 루프 종료
                                                                            */
    }

                                                                            // 최종 sum 값을 정수형으로 출력한다.
    printf("%d", sum); 
    
    return 0;                                                         // 프로그램이 성공적으로 종료되었음을 운영체제에 알린다.
}


✅ 최종 출력 결과
답: 10



------------------------------------------------------------

문제 16) 다음 c언어 코드의 출력 결과를 쓰시오


#include <stdio.h>                                 // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일

int main() {                                     // C 프로그램의 메인 함수. 여기서부터 실행이 시작된다.
                                                                  // 3x3 크기의 2차원 정수 배열을 선언하고 초기화한다.
                                                                  // C에서 다차원 배열은 메모리에 연속적으로 저장된다.
                                                                  // arr[0] = {1, 2, 3}
                                                                  // arr[1] = {4, 5, 6}
                                                                  // arr[2] = {7, 8, 9}
                                                                  // 메모리에는 1, 2, 3, 4, 5, 6, 7, 8, 9 순서로 연속해서 저장된다.
    int arr[3][3] = {1,2,3,4,5,6,7,8,9};

                                                            // 'darr'는 int* (정수 포인터)를 저장하는 크기 2짜리 배열이다.
                                                            // 즉, int 포인터들을 두 개 저장할 수 있는 배열이다.
                                                            // arr[1]은 arr 배열의 두 번째 행({4, 5, 6})의 첫 번째 요소 주소 (즉, 4의 주소)를 나타낸다.
                                                            // arr[2]는 arr 배열의 세 번째 행({7, 8, 9})의 첫 번째 요소 주소 (즉, 7의 주소)를 나타낸다.
    int *darr[2] = {arr[1], arr[2]};
                                                            // 따라서:
                                                            // darr[0]은 arr[1]의 시작 주소(4의 주소)를 가리킨다. (int* 타입)
                                                            // darr[1]은 arr[2]의 시작 주소(7의 주소)를 가리킨다. (int* 타입)
                                                        
                                                            // 계산된 세 개의 값을 더해서 출력한다.
                                                            // 각 항의 값을 분석해보자:

                                                      // 1. darr[1][1]
                                                      //    - darr[1]은 arr[2]의 시작 주소(7의 주소)를 가리킨다.
                                                      //    - darr[1][1]은 darr[1]이 가리키는 배열의 인덱스 1에 있는 값이다.
                                                      //      즉, arr[2]의 두 번째 요소인 8을 의미한다.
                                                      //      (arr[2][0]은 7, arr[2][1]은 8, arr[2][2]는 9)
                                                      //    - 결과: 8
                                                  
                                                      // 2. *(darr[1]+2)
                                                      //    - darr[1]은 arr[2]의 시작 주소(7의 주소)를 가리킨다.
                                                      //    - (darr[1]+2)는 darr[1]이 가리키는 주소로부터 int 크기만큼 2칸 떨어진 주소를 의미한다.
                                                      //      이는 arr[2]의 세 번째 요소인 9의 주소와 같다.
                                                      //      (7의 주소 + 1칸은 8의 주소, 7의 주소 + 2칸은 9의 주소)
                                                      //    - * 역참조 연산자를 사용하여 그 주소에 있는 값을 가져온다.
                                                      //    - 결과: 9
                                                  
                                                      // 3. **darr
                                                      //    - darr는 배열의 이름이므로, darr 자체는 darr[0]의 주소(int** 타입)를 의미한다.
                                                      //    - *darr는 darr[0]의 값, 즉 arr[1]의 시작 주소(4의 주소)를 의미한다.
                                                      //    - **darr는 (*darr)가 가리키는 주소에 있는 값을 가져온다.
                                                      //      즉, arr[1]의 첫 번째 요소인 4를 의미한다.
                                                      //    - 결과: 4
                                                  
                                                                  // 세 개의 값을 모두 더한다: 8 + 9 + 4
    printf("%d", darr[1][1] + *(darr[1]+2) + **darr);                 // 최종 출력: 21
    
    return 0;                                                   // 프로그램이 성공적으로 종료되었음을 운영체제에 알린다.
}

🧠 최종 출력 결과
답: 21

------------------------------------------------------------

### 📘 문제 17) Java 코드 실행 결과를 쓰시오

                                                                // 'Num'이라는 인터페이스 정의
                                                                // 인터페이스는 클래스가 구현해야 할 '규약' 또는 '청사진'을 정의한다.
interface Num {
                                                              // 정수 배열 'a'와 boolean 값 'odd'를 받아 정수를 반환하는 추상(abstract) 메서드 'sum' 선언.
                                                              // 이 메서드는 이 인터페이스를 구현하는 모든 클래스가 반드시 구현해야 한다.
    int sum(int[] a, boolean odd);
}

                                                                    // 'ODDNum' 클래스는 'Num' 인터페이스를 구현한다.
                                                                    // 이는 'ODDNum' 클래스가 'Num' 인터페이스에 선언된 모든 추상 메서드를 반드시 구현해야 함을 의미한다.
class ODDNum implements Num {
                                                                      // @Override 어노테이션은 이 메서드가 부모 클래스나 인터페이스의 메서드를 '재정의(override)'함을 명시한다.
                                                                      // 여기서는 'Num' 인터페이스의 'sum' 메서드를 구현한다.
    @Override
    public int sum(int[] a, boolean odd) {
        int result = 0; // 합계를 저장할 변수를 0으로 초기화한다.

                                                                          // 배열 'a'의 모든 요소를 반복한다.
        for (int i = 0; i < a.length; i++) {
                                                                                  // 핵심 조건문:
                                                                                  // 이 조건은 두 가지 경우 중 하나라도 참이면 블록 안의 코드를 실행한다.
                                                                                  // 1. (odd가 true 이고 현재 숫자(a[i])가 홀수) 인 경우
                                                                                  //    (odd && a[i] % 2 != 0)
                                                                                  //    - 'odd'가 true이면 홀수를 찾는다는 의미.
                                                                                  //    - 'a[i] % 2 != 0'은 'a[i]'가 홀수인지 판별 (나머지가 0이 아니면 홀수).
                                                                                  //
                                                                                  // 2. (odd가 false 이고 현재 숫자(a[i])가 짝수) 인 경우
                                                                                  //    (!odd && a[i] % 2 == 0)
                                                                                  //    - '!odd'가 true이면 (즉, odd가 false이면) 짝수를 찾는다는 의미.
                                                                                  //    - 'a[i] % 2 == 0'은 'a[i]'가 짝수인지 판별 (나머지가 0이면 짝수).
                                                                                  //
                                                                                  // 결국, 'odd'가 true면 홀수의 합을, 'odd'가 false면 짝수의 합을 구하는 로직이다.
            if ((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0)) {
                result += a[i];                                                     // 조건을 만족하는 숫자(a[i])를 result에 더한다.
            }
        }
        return result;                                                                 // 최종 합계 반환
    }
}

                                                                                                // 메인 실행 클래스
class Main {
    public static void main(String[] args) {
                                                                                            // 1부터 9까지의 정수 배열을 선언하고 초기화한다.
        int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};

                                                                                                  // ODDNum 클래스의 객체를 생성한다.
        ODDNum obj = new ODDNum();

                                                                                                    // obj.sum(a, true) 호출 결과와 obj.sum(a, false) 호출 결과를 콤마로 구분하여 출력한다.
                                                                                                    // 1. obj.sum(a, true): 배열 'a'에서 '홀수'만 골라 합산한다.
                                                                                                    //    홀수: 1, 3, 5, 7, 9
                                                                                                    //    합계: 1 + 3 + 5 + 7 + 9 = 25
                                                                                                    //
                                                                                                    // 2. obj.sum(a, false): 배열 'a'에서 '짝수'만 골라 합산한다.
                                                                                                    //    짝수: 2, 4, 6, 8
                                                                                                    //    합계: 2 + 4 + 6 + 8 = 20
        System.out.print(obj.sum(a, true) + "," + obj.sum(a, false));
    }
}

✅ 출력 결과
답: 25,20



------------------------------------------------------------
문제 18) java에 대해 출력값을 쓰시오

public class Main { // 클래스 이름은 Main으로 가정

    public static void main(String[] args) {
        String str = "abacabcd";                             // 입력 문자열. 길이: 8 (인덱스 0~7)
                                                            // 문자 등장 여부를 기록할 boolean 배열. 아스키 코드 값으로 인덱싱한다.
                                                            // 모든 요소는 기본값 false로 초기화된다.
        boolean[] ary = new boolean[256];

                                                                      // fn 함수를 호출하고 그 결과를 출력한다.
                                                                      // str.length()-1은 문자열의 마지막 인덱스(7)를 의미한다.
                                                                      // 이 코드는 문자열을 뒤에서부터 탐색한다.
        System.out.print(fn(str, str.length() - 1, ary));
    }

                                                                                // 재귀 함수: 문자열을 뒤에서부터 탐색하며 중복 없는 문자를 역순으로 조합한다.
                                                                                // str: 원본 문자열
                                                                                // index: 현재 탐색할 문자의 인덱스
                                                                                // ary: 문자의 등장 여부를 기록하는 boolean 배열
    public static String fn(String str, int index, boolean[] ary) {
                                                                    // 1. 재귀 호출 종료 조건: index가 0보다 작아지면 (모든 문자를 다 탐색했으면) 빈 문자열 반환
        if (index < 0) {
            return "";
        }

                                                                                              // 2. 현재 index에 해당하는 문자를 가져온다.
        char c = str.charAt(index);

                                                                                  // 3. 다음 문자를 재귀적으로 탐색하여 결과 문자열을 얻어온다.
                                                                                  // 예를 들어, fn("abacabcd", 7, ary) -> fn("abacabcd", 6, ary) -> ... -> fn("abacabcd", -1, ary)
                                                                                  // 이 'result' 변수에는 현재 문자 'c'보다 '앞'에 있던 (즉, 원래 문자열에서는 왼쪽에 있던) 문자들 중
                                                                                  // 중복 없는 문자열이 '역순'으로 담겨서 넘어온다.
        String result = fn(str, index - 1, ary);                                             // 재귀 호출!

                                                                                            // 4. 현재 문자 'c'가 이전에(즉, 이미 'result'에 포함된 문자들 중에서) 등장했는지 'ary' 배열로 확인한다.
                                                                                            // 'ary[c]'가 false이면 처음 등장한 문자! (현재 인덱스보다 뒤에 있는 문자열에선 아직 안 나옴)
        if (!ary[c]) {
            ary[c] = true;                                                                           // 처음 등장했으니 'true'로 표시해서 다음부터는 이 문자를 만나면 무시하게 한다.
            return c + result;                                                                 // 현재 문자 'c'를 'result' (이미 처리된 문자열) 앞에 붙여서 반환한다.
                                                                                             // 이 부분이 핵심! 재귀 호출이 풀리면서 문자가 역순으로 조합된다.
        }
                                                                                    // 5. 이미 등장한 문자라면 (ary[c]가 true), 현재 문자는 무시하고 'result'만 그대로 반환한다.
        return result;
    }
}

✅ 정답
답: dcba


------------------------------------------------------------

# ✅ 문제 19) C언어 구조체 포인터 코드 출력 결과

---
#include <stdio.h>                                     // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일
                                                    
                                                    // 'node'라는 이름의 구조체(structure)를 정의한다.
                                                    // 구조체는 서로 다른 데이터 타입의 변수들을 하나로 묶을 수 있게 해준다.
struct node {
    int n1;                                               // 'n1': 정수형 멤버. 이 노드의 데이터를 저장한다.
    struct node *n2;                                        // 'n2': 'struct node' 타입의 포인터 멤버.
                                                                  // 다음 'node' 구조체의 주소를 가리킨다.
                                                                  // 연결 리스트에서 다음 노드를 가리키는 역할을 한다.
};

int main() {
                                                                  // 1. 'struct node' 타입의 포인터 'head'를 NULL로 초기화한다.
                                                                  // 'head'는 연결 리스트의 첫 번째 노드를 가리키는 역할을 한다.
    struct node *head = NULL;

                                                                              // 2. 'struct node' 타입의 변수 'a', 'b', 'c'를 선언하고 초기값을 할당한다.
                                                                              // .n2 멤버는 명시적으로 초기화하지 않으면 0 (NULL)으로 초기화된다.
                                                                              // 구조체 변수는 메모리에 실제 공간을 할당받는다.
    struct node a = {10, 0};                                                     // 'a' 노드: n1 = 10, n2 = NULL
    struct node b = {20, 0};                                                     // 'b' 노드: n1 = 20, n2 = NULL
    struct node c = {30, 0};                                                 // 'c' 노드: n1 = 30, n2 = NULL

                                                                                      // 3. 포인터들을 연결하여 간단한 연결 리스트를 만든다.
                                                                                      // 이 과정으로 'a -> b -> c' 형태의 연결 리스트가 구성된다.
                                                                                  
                                                                                      // 'head' 포인터가 'a' 노드의 주소를 가리키게 한다.
                                                                                      // 이제 'head'는 리스트의 시작점이다.
    head = &a; // head ----> [a | NULL]
                                                                                      
                                                                                          // 'a' 노드의 n2 멤버가 'b' 노드의 주소를 가리키게 한다.
                                                                                          // 'a'와 'b'가 연결된다.
    a.n2 = &b; // head ----> [a | 주소_of_b] ----> [b | NULL]

                                                                                          // 'b' 노드의 n2 멤버가 'c' 노드의 주소를 가리키게 한다.
                                                                                          // 'b'와 'c'가 연결된다.
    b.n2 = &c; // head ----> [a | 주소_of_b] ----> [b | 주소_of_c] ----> [c | NULL]

                                                                                                      // 4. 특정 노드의 값을 출력한다.
                                                                                                      // '->' 연산자는 포인터가 가리키는 구조체의 멤버에 접근할 때 사용한다.
                                                                                                      // (head)는 'a' 노드를 가리킨다.
                                                                                                      // (head->n2)는 'a' 노드의 n2 멤버가 가리키는 노드, 즉 'b' 노드를 가리킨다.
                                                                                                      // (head->n2->n1)은 'b' 노드의 n1 멤버의 값, 즉 20을 의미한다.
    printf("%d", head->n2->n1);                                                                         // 최종적으로 20이 출력된다.

    return 0;                                                                                     // 프로그램이 성공적으로 종료되었음을 운영체제에 알린다.
}


✅ 출력 결과
답: 20

------------------------------------------------------------

문제 20) JAVA 코드 변환 

# ✅ 문제: Java 코드의 출력 결과 분석

---

## 📌 문제 코드

public class ExampleClass {
    public static void main(String[] args) {
        String input = "HELLOEXAMPLESENTENCE";                                 // 원본 입력 문자열

                                                                        // String.split("E") 메소드:
                                                                        // 이 메소드는 주어진 구분자("E")를 기준으로 문자열을 쪼개서 String 배열로 반환한다.
                                                                        // 중요한 점은 구분자 자체는 결과 배열에 포함되지 않고,
                                                                        // 만약 문자열의 시작이나 끝이 구분자로 시작하거나 끝나면 빈 문자열("")이 요소로 포함될 수 있다는 거다.
                                                                        // 그리고 연속된 구분자의 경우에도 빈 문자열이 포함될 수 있다.
        String[] output = input.split("E");                               // "E"를 기준으로 문자열을 나눈다.

                                                                              // input: "H E L L O E X A M P L E S E N T E N C E"
                                                                              //           ^   ^       ^       ^     ^
                                                                              // 각 'E'를 기준으로 쪼개지는 과정을 단계별로 보자:
                                                                              // 1. 첫 번째 'E' 앞에서 쪼개짐: "" (빈 문자열, 'H' 앞에 'E'가 없으니)
                                                                              // 2. 첫 번째 'E'와 두 번째 'E' 사이: "LLO"
                                                                              // 3. 두 번째 'E'와 세 번째 'E' 사이: "XAMPL"
                                                                              // 4. 세 번째 'E'와 네 번째 'E' 사이: "S"
                                                                              // 5. 네 번째 'E'와 다섯 번째 'E' 사이: "NTC"
                                                                              // 6. 다섯 번째 'E' 뒤에는 아무것도 없으니: "" (빈 문자열)

                                                                              // 따라서 output 배열의 최종 내용은 다음과 같다:
                                                                              // output[0] = ""  (첫 번째 'E' 앞)
                                                                              // output[1] = "LLO" (첫 번째 'E'와 두 번째 'E' 사이)
                                                                              // output[2] = "XAMPL" (두 번째 'E'와 세 번째 'E' 사이)
                                                                              // output[3] = "S"   (세 번째 'E'와 네 번째 'E' 사이)
                                                                              // output[4] = "NTC" (네 번째 'E'와 다섯 번째 'E' 사이)
                                                                              // output[5] = ""  (마지막 'E' 뒤)

                                                                              // 나눠진 배열의 4번째 요소(인덱스 3)를 출력한다.
        System.out.print(output[3]);
    }
}

✅ 최종 출력
답: S
