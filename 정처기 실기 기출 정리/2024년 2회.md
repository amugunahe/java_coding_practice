\# 📘 2024년 2회 정보처리기사 실기 기출 정리


\## ✅ 문제 1


\*\*문제:\*\*  

시스템의 성능 향상, 개발 과정의 편의성 등을 위해 정규화된 데이터 모델을 분할, 통합, 추가하는 과정으로 의도적으로 정규화에 위배되는 행위이다. 무엇을 설명하는 것인지 쓰시오.


\*\*답:\*\*  

반정규화 (=역정규화, 비정규화)



## 📌 관련 개념 설명

### 🔹 반정규화(역정규화, 비정규화)

- **정의:** 정규화를 통해 생성된 여러 개의 테이블을 조인으로 연결할 때 성능 저하가 발생하거나 시스템 구현이 복잡해질 경우, 이를 해결하기 위해 **의도적으로 정규화된 구조를 깨고** 테이블을 **통합하거나 중복된 속성을 추가하는 행위**.
- **목적:** 시스템 성능 향상, 구현의 단순화, 응답시간 단축

### 🔹 반정규화의 주요 방법

- 테이블 **병합** 또는 **분할**
- 중복 속성 **추가**
- **파생 속성** 추가
- **중복 테이블** 생성 등

---

## 📌 관련 용어 정리

| 용어            | 설명 |
|-----------------|------|
| **공유데이터**     | 여러 응용 시스템에서 공유하여 사용하는 데이터 |
| **저장데이터**     | 실제 DB에 저장되는 데이터 |
| **통합데이터**     | 데이터의 **중복을 최소화**하고 일관성을 유지하기 위해 통합된 구조의 데이터 |
| **운영데이터**     | 업무 처리를 위해 사용되는 데이터, 실시간으로 접근이 필요한 데이터 |

---

## 📌 이상현상 (Anomalies)

정규화되지 않은 테이블에서 발생하는 데이터 이상

| 종류         | 설명 |
|--------------|------|
| **삽입 이상**   | 불필요한 데이터를 함께 입력해야 삽입 가능한 현상 |
| **삭제 이상**   | 하나의 데이터 삭제 시 **연쇄적으로 관련 없는 데이터도 삭제**되는 현상 |
| **갱신 이상**   | 한 데이터를 갱신할 때 **중복된 모든 데이터**를 갱신해야 하는 현상 |

---

## 📌 함수 종속성(FD: Functional Dependency)

| 개념                 | 설명 |
|----------------------|------|
| **완전 함수 종속**     | 기본키의 **전체에 종속**되는 경우 |
| **부분 함수 종속**     | 기본키의 **일부에만 종속**되는 경우 (→ 제2정규형 위반) |
| **이행적 함수 종속**   | A → B, B → C 이면 A → C 와 같은 간접 종속 (→ 제3정규형 위반) |


---------------------------------------------------------------------------


\## ✅ 문제 2


\*\*문제:\*\*  

빈칸에 들어갈 네트워크 보안 프로토콜을 쓰시오

VPN을 통해 안전한 통신을 구현하기 위해 사용되는 이 프로토콜은  
네트워크 계층에서 동작하며, 데이터의 기밀성, 무결성, 그리고 인증을 제공한다.  
이 프로토콜은 AH(Authentication Header)와 ESP(Encapsulating Security Payload) 두 가지 하위 프로토콜을 포함하며,  
각각 데이터의 무결성과 인증, 그리고 데이터의 기밀성을 제공한다.  

또한 이 프로토콜은 터널 모드와 전송 모드를 지원하며,  
주로 IKE(Internet Key Exchange) 프로토콜과 함께 보안 연결을 설정한다.  
이 프로토콜의 이름은 \*\*(           )\*\* 이다.

\*\*답:\*\*  

IPsec (IP Security

---


## 📌 관련 개념 설명

### 🔐 IPsec (Internet Protocol Security)

- **설명:**  
  IP 계층에서 동작하는 네트워크 보안 프로토콜로,  
  **VPN 환경에서 안전한 통신**을 위해 사용됨.

- **기능:**  
  - 데이터의 **기밀성(confidentiality)**  
  - **무결성(integrity)**  
  - **인증(authentication)** 제공

- **구성 요소:**
  - **AH (Authentication Header)**  
    → 데이터의 무결성과 송신자 인증 제공 (기밀성은 제공하지 않음)
  - **ESP (Encapsulating Security Payload)**  
    → 데이터의 무결성, 인증, 기밀성 모두 제공

- **동작 모드:**
  - **터널 모드**: 전체 IP 패킷을 암호화하여 보안 터널 생성
  - **전송 모드**: IP 패킷의 페이로드만 암호화

---

## 📌 기타 보안 프로토콜 요약

| 프로토콜 | 설명 |
|----------|------|
| **SSL/TLS** | 웹 브라우저와 서버 간 암호화된 연결 제공 (HTTPS 통신에 사용됨) |
| **SSH** | 원격 컴퓨터에 안전하게 접속하여 명령 실행 |
| **PGP** | 이메일 데이터 암호화 및 디지털 서명 |
| **Kerberos** | 클라이언트와 서버 간의 **상호 인증**을 위한 네트워크 인증 프로토콜 |
| **S/MIME** | 이메일 메시지의 **암호화** 및 **디지털 서명**을 위한 표준 |


---------------------------------------------------------------------------


\## ✅ 문제 3


\*\*문제:\*\*  

다음 설명에 해당하는 응집도 유형을 보기에서 골라 쓰시오


모듈 내부의 각 기능들이 서로 연관성을 가지고 \*\*순차적으로 수행되는 응집도 유형\*\*을 말한다.  
하나의 작업이 끝나면 그 결과가 다음 작업의 입력으로 사용되며,  
이러한 과정이 연속적으로 이어지는 형태이다.  
이 응집도는 \*\*기능적 응집도보다는 낮지만 절차적 응집도보다는 높은\*\* 수준의 응집도를 가진다.


\*\*답:\*\*  

순차적 응집도


---
## 📌 관련 개념 설명: 응집도(Cohesion)

응집도란 **모듈 내부 구성요소 간의 기능적 관련성의 정도**를 의미하며,  
응집도가 높을수록 모듈의 독립성이 높고 재사용성이 증가함.

---

### 🔼 응집도 수준 (높은 응집도 → 낮은 응집도 순)

| 응집도 유형         | 설명 |
|----------------------|------|
| **기능적 응집도**     | 모듈이 하나의 명확한 기능만 수행 (가장 높은 응집도) |
| **순차적 응집도**     | **앞 단계 결과가 다음 단계의 입력**으로 사용됨. 작업이 순차적으로 수행됨 |
| **통신적 응집도**     | 동일한 입력이나 출력 데이터를 사용하는 기능들로 구성 |
| **절차적 응집도**     | 특정 절차에 따라 수행되지만, 데이터 연관성은 없음 |
| **시간적 응집도**     | 특정 시간에 함께 실행되는 기능들로 구성 (예: 초기화 작업) |
| **논리적 응집도**     | 비슷한 성격의 여러 기능을 하나의 모듈에 포함. 제어문으로 기능 선택 |
| **우연적 응집도**     | 아무런 관련 없이 기능들이 모듈에 나열됨 (가장 낮은 응집도) |

---

## 📌 비교 포인트

| 응집도 유형     | 주요 특징 |
|----------------|-----------|
| **기능적**     | 단일 목적, 하나의 기능만 수행 |
| **순차적**     | A → B → C 순서로 **출력이 다음 입력**이 됨 |
| **통신적**     | 같은 입력/출력을 공유 |
| **절차적**     | 순서는 있지만 출력입력 연관은 없음 |
| **시간적**     | 특정 시점 동시 수행 |
| **논리적**     | 유사한 작업을 묶되, 내부 선택 구조 포함 |
| **우연적**     | 관련 없는 기능 나열 |



---------------------------------------------------------------------------

\## ✅ 문제 4

\*\*문제:\*\*  

다음 설명을 듣고 빈칸에 들어갈 네트워크 전송 방식 두 가지를 각각 쓰시오

(1)은 \*\*연결 지향적\*\*으로, 데이터 전송 전에 먼저 \*\*경로를 설정한 후\*\* 모든 패킷이 동일한 경로를 통해 순차적으로 전달된다.  
이 방식은 \*\*연결이 설정된 후에야 데이터가 전송\*\*되며, 패킷이 \*\*순서대로 도착하는 것이 보장\*\*된다.  
(2)는 \*\*비연결 지향적\*\*으로, 경로를 미리 설정하지 않고 각 패킷이 \*\*독립적으로 전송\*\*되며, 패킷이 서로 다른 경로를 통해 전달될 수 있다.  
패킷이 목적지에 도착하는 \*\*순서가 보장되지 않으며\*\*, 각 패킷이 \*\*개별적으로 처리\*\*되는 방식이다.

\*\*답:\*\*  

(1) 가상회선 방식  
(2) 데이터그램 방식

---## 📌 관련 개념 설명

### 🔹 데이터 교환 방식 개요
데이터 전송을 위한 교환 방식은 **회선 교환**과 **축적 후 교환**(Store and Forward)으로 나뉘며,  
축적 후 교환은 다시 **메시지 교환**과 **패킷 교환**으로 구분됨.

---

### 🔸 (1) 가상회선 방식 (Virtual Circuit)

- **연결 지향형 방식**
- **데이터 전송 전에 경로 설정 필수**
- **모든 패킷이 동일한 경로**를 따라 전송됨
- 패킷이 **순서대로 도착**함
- 예: ATM, X.25


### 🔸 (2) 데이터그램 방식 (Datagram)

- **비연결형 방식**
- **패킷마다 경로를 독립적으로 선택**하여 전송
- 패킷이 **서로 다른 경로**를 통해 목적지에 도달할 수 있음
- **도착 순서 보장되지 않음**
- 예: IP 프로토콜

---

## 📌 보충 설명: 회선 교환 vs. 패킷 교환

| 구분       | 회선 교환      | 패킷 교환                                       |
|------------|----------------|--------------------------------------------------|
| 연결 설정   | 필요함         | 필요 없음 (데이터그램) / 있음 (가상회선)       |
| 전송 경로   | 고정           | 유동적                                           |
| 순서 보장   | 항상 보장      | 방식에 따라 다름                                 |
| 전송 단위   | 비트 스트림    | 패킷                                            |


---------------------------------------------------------------------------

\## ✅ 문제 5


\*\*문제:\*\*  

객체의 내부 구조를 감추면서도 일관된 방식으로 그 내부에 포함된 요소들을 \*\*순차적으로 접근\*\*할 수 있게 하며,  
동시에 여러 종류의 컬렉션 (예: 배열, 리스트, 트리)에서도 \*\*동일한 접근 방식\*\*을 제공하여  
컬렉션의 구현과 상관없이 순회가 가능하도록 하는 디자인패턴은 무엇인지 보기에서 골라 쓰시오.

\*\*답:\*\*  

Iterator (이터레이터)

---

## 📌 관련 개념 설명

### 🔸 Iterator 패턴

- **정의:**  
  컬렉션(배열, 리스트, 트리 등)의 내부 구조를 **노출하지 않고**  
  그 내부 요소를 **순차적으로 접근**할 수 있도록 하는 디자인 패턴

- **목적:**  
  다양한 자료구조에서 **동일한 방식으로 접근(순회)** 가능하게 함

- **주요 특징:**
  - **컬렉션과 분리된 순회 기능** 제공
  - 내부 구조의 변경 없이 접근 가능
  - **단일 인터페이스**로 여러 자료구조 대응 가능

- **주요 메서드 (Java 기준):**
  - `hasNext()` : 다음 요소가 있는지 확인
  - `next()` : 다음 요소 반환

- **일상 비유:**  
  자판기에서 음료를 하나씩 순서대로 꺼내 마시는 것처럼, 어떤 구조든 내부 구조 모르고 버튼만 누르면 다음 항목이 나오는 것.

---

## 📌 객체지향 구성 요소

| 구성 요소         | 설명                              | 일상 비유 |
|------------------|-----------------------------------|------------|
| **클래스 (class)**   | 데이터를 추상화한 설계도               | 레시피 (요리법) |
| **객체 (object)**   | 클래스의 인스턴스                   | 실제로 만든 요리 |
| **속성 (attribute)**| 객체가 가진 데이터                   | 요리의 재료 (예: 토핑, 소스) |
| **메서드 (method)** | 객체가 수행하는 동작                  | 요리 방법 (예: 굽기, 끓이기) |
| **메시지 (message)**| 객체에게 행위를 요청하는 것 (메서드 호출) | 요리사에게 "피자 구워줘"라고 말하는 것 |

---

## 📌 객체지향의 주요 특징

- **캡슐화 (Encapsulation):**  
  데이터를 외부에서 직접 접근하지 못하게 숨기고, 메서드를 통해서만 접근하도록 함  
  → 약을 먹을 때 알약은 캡슐에 싸여 있어, 알약을 통째로 복용하지만 내부 성분은 모르듯이.

- **정보은닉 (Information Hiding):**  
  외부에 불필요한 내부 세부사항을 숨김  
  → 리모컨 버튼만 알면 TV를 켤 수 있고, 내부 회로는 몰라도 됨.

- **상속 (Inheritance):**  
  부모 클래스의 속성과 기능을 자식 클래스가 물려받음  
  → 자식이 부모의 유전자나 성격을 물려받는 것처럼.

- **다형성 (Polymorphism):**  
  하나의 메시지(메서드 호출)에 대해 **여러 형태로 응답**할 수 있음  
  → "밥 줘"라는 말에 강아지는 먹이를, 사람은 밥상을, 고양이는 캔을 떠올리는 것.

- **추상화 (Abstraction):**  
  복잡한 내용을 감추고 필요한 기능만 노출  
  → 운전자는 페달, 핸들만 조작하고 엔진 작동 방식은 몰라도 운전 가능함.


---

## 📌 객체지향 설계 원칙 (SOLID)

| 원칙 | 설명 | 비유 예시 |
|------|------|-----------|
| **SRP (단일 책임 원칙)** | 하나의 클래스는 하나의 책임만 가져야 함 | 📦 하나의 택배 박스에는 한 종류의 물건만 담는 게 정리하기 쉬움. 여러 물건 섞으면 관리 복잡해짐. |
| **OCP (개방-폐쇄 원칙)** | 확장에는 열려 있고, 수정에는 닫혀 있어야 함 | 🎮 게임에 새로운 맵 추가는 가능하지만, 기존 코드는 손대지 않아도 되게 설계함. |
| **LSP (리스코프 치환 원칙)** | 자식 클래스는 부모 클래스를 대체할 수 있어야 함 | 🧸 장난감 배터리를 일반 AA건전지로 바꿔도 문제없이 작동해야 함. 새 부품이 예전 부품 역할을 그대로 해야 해. |
| **ISP (인터페이스 분리 원칙)** | 하나의 일반 인터페이스보다 여러 개의 구체적 인터페이스가 낫다 | ☎️ 전화 앱에 통화, 문자, 주소록 기능이 다 있지만 사용자에게는 필요한 기능만 보이게 하는 게 낫다. |
| **DIP (의존성 역전 원칙)** | 구체적인 것보다 추상적인 것에 의존해야 함 | 🎭 배우는 대본(추상)에 따라 연기하지, 특정 상황에만 맞는 지문(구체)에만 의존하지 않아야 유연하게 연기 가능함. |

---------------------------------------------------------------------------

\## ✅ 문제 6



\*\*문제:\*\*  

다음 설명에 해당하는 암호화 알고리즘의 이름을 쓰시오



이 알고리즘은 미국 국립 표준기술연구소가 기존의 DES를 대체하기 위해 선정한 \*\*대칭 키 블록 암호화 알고리즘\*\*이다.  
128비트의 \*\*고정 블록 크기\*\*를 사용하며, 키 길이는 \*\*128, 192, 256 비트\*\*를 지원한다.  
\*\*보안성과 성능이 우수\*\*하며, 전 세계적으로 다양한 분야에서 널리 사용되고 있으며,  
\*\*무선 통신\*\*, \*\*금융 거래\*\*, \*\*저장 데이터의 암호화\*\* 등에서 \*\*표준\*\*으로 채택되고 있다.

\*\*답:\*\*  
AES (Advanced Encryption Standard)

---

## 📌 관련 개념 설명

### 🔐 AES (Advanced Encryption Standard)

- **암호 방식:** 블록 암호 방식 (대칭 키)
- **개발 배경:** DES의 취약점을 보완하고, 고속/고보안성을 위해 미국 NIST에서 표준으로 채택 (2001년)
- **키 길이:** 128, 192, 256 비트 지원
- **블록 크기:** 128비트 고정
- **라운드 수:**  
  - 128비트 키 → 10 라운드  
  - 192비트 키 → 12 라운드  
  - 256비트 키 → 14 라운드
- **구조:** SPN(Substitution Permutation Network) 구조 사용
- **특징:** 빠른 처리 속도와 강력한 보안성, 하드웨어/소프트웨어 모두 적합

---

## 📌 주요 블록 암호 알고리즘 비교

| 알고리즘       | 블록 크기 | 키 길이          | 라운드 수    | 구조        | 국가/특징   |
|---------------|-----------|------------------|-------------|-------------|------------|
| **DES**        | 64비트    | 56비트           | 16라운드    | Feistel     | 미국, 구표준 |
| **3DES**       | 64비트    | 112/168비트      | 48라운드    | Feistel     | DES 강화    |
| **AES**        | 128비트   | 128/192/256비트  | 10/12/14    | SPN         | 미국, 표준  |
| **SEED**       | 128비트   | 128비트          | 16라운드    | Feistel     | 한국        |
| **ARIA**       | 128비트   | 128/192/256비트  | 12/14/16    | SPN         | 한국        |
| **LEA**        | 128비트   | 128/192/256비트  | 24/28/32    | SPN         | 한국, 경량  |
| **IDEA**       | 64비트    | 128비트          | 8라운드     | Feistel+SPN | 스위스      |
| **Skipjack**   | 64비트    | 80비트           | 32라운드    | Feistel 변형 | 미국 NSA   |

---

## 📌 기타 암호 알고리즘 분류 요약

### ✅ 스트림 암호

| 알고리즘 | 설명                    |
|----------|-------------------------|
| **LFSR** | 선형 피드백 시프트 레지스터 기반 |
| **RC4**  | 인터넷 보안 프로토콜에 사용         |
| **A5**   | GSM 이동통신에서 사용               |

### ✅ 공개키 암호 (비대칭키)

| 기반 이론   | 알고리즘                     |
|-------------|------------------------------|
| 소인수분해  | RSA, Rabin                   |
| 이산대수    | Diffie-Hellman, DSA, ElGamal |
| 타원곡선    | ECC (Elliptic Curve Cryptography) |

### ✅ 단방향 암호 (해시 함수)

| 알고리즘 | 설명               |
|----------|--------------------|
| **MD5**  | 빠르지만 취약점 존재 |
| **SHA**  | 미국 NIST 개발, 보안성 강화 |
| **HAS-160** | 한국 개발, KCDSA에서 사용 |


---------------------------------------------------------------------------

\## ✅ 문제 7


\*\*문제:\*\*  

다음 설명에 해당하는 결합도 유형을 쓰시오


두 모듈 사이에서 \*\*하나의 모듈이 다른 모듈의 내부 논리 흐름을 제어\*\*해  
\*\*특정 제어 신호를 전달하는 결합도\*\* 유형을 말한다.  
이 결합도는 모듈 간의 독립성을 저하시켜 \*\*유지보수와 확장성에 부정적인 영향\*\*을 미칠 수 있다.  
일반적으로 이 결합도가 존재할 경우, 호출하는 모듈이 호출된 모듈의 \*\*내부 동작 방식까지 알고 있어야\*\* 하므로  
모듈 간에 \*\*강한 의존성\*\*이 발생한다.  
따라서 제어 신호가 변경되면 관련된 \*\*모든 모듈을 수정\*\*해야 하는 상황이 발생할 수 있다.



\*\*답:\*\*  
제어 결합도 (Control Coupling)

---
## 📌 관련 개념 설명: 결합도(Coupling)

**결합도**란 모듈 간의 **의존성(연결 강도)**을 의미하며,  
결합도가 낮을수록 모듈 간 독립성이 높아지고 유지보수가 쉬워짐.  
이상적인 설계에서는 **낮은 결합도, 높은 응집도**가 바람직함.

### 🔽 결합도의 종류 (낮은 결합도 → 높은 결합도 순)

| 결합도 유형               | 설명                                           |
|--------------------------|------------------------------------------------|
| **자료 결합도 (Data Coupling)**     | **단순한 값**을 인자로 전달 (가장 바람직함)            |
| **스탬프 결합도 (Stamp Coupling)** | 배열, 구조체 등 **자료구조 전체**를 인자로 전달           |
| **제어 결합도 (Control Coupling)** | **제어 신호(논리값, 플래그)**를 전달하여 상대 모듈의 실행 흐름 제어 |
| **외부 결합도 (External Coupling)** | 두 모듈이 외부 시스템 자원(환경변수, DB 등)을 함께 사용    |
| **공통 결합도 (Common Coupling)**   | **전역 변수**를 여러 모듈이 공유하여 사용                  |
| **내용 결합도 (Content Coupling)** | **한 모듈이 다른 모듈의 내부를 직접 접근하거나 수정** (가장 나쁨) |

---

## 📌 제어 결합도 예시 (Java)

```java
void processOrder(int orderType) {
    if (orderType == 1) {
        // 배송처리
    } else if (orderType == 2) {
        // 반품처리
    }
}

---------------------------------------------------------------------------

\## ✅ 문제 8

\*\*문제:\*\*  

다음은 프로세스가 준비 상태 큐에 도착한 시간과 프로세스를 처리하는데 필요한 실행시간을 보여준다.  
\*\*선점형 스케줄링 알고리즘인 SRT 알고리즘\*\*을 사용할 경우 프로세스들의 \*\*평균 대기시간을 구하시오\*\*.  
(단, 프로세스 간 문맥교환에 따른 오버헤드는 무시하며, 주어진 4개 프로세스 외에 처리할 다른 프로세스는 없다고 가정한다)


| 프로세스 | 도착시간 | 실행시간 |
|----------|----------|----------|
| P1       |    0     |    8     |
| P2       |    1     |    4     |
| P3       |    2     |    9     |
| P4       |    3     |    5     |



\*\*답:\*\*  

6.5

---


\## 📌 해설: SRT (Shortest Remaining Time) 알고리즘

SRT는 \*\*SJF(Shortest Job First)\*\*의 선점형 방식이다.  
실행 중인 프로세스보다 \*\*남은 시간이 더 짧은 프로세스가 도착\*\*하면, 현재 실행을 \*\*선점하고 교체\*\*한다.


\### 🔹 스케줄링 순서:


\### 🔹 완료 시간 및 대기 시간 계산:

| 프로세스 | 도착시간 | 종료시간 | 실행시간 | 대기시간 |
|----------|----------|----------|----------|----------|
| P1       |    0     |   17     |    8     | 17 - 0 - 8 = \*\*9\*\* |
| P2       |    1     |    5     |    4     | 5 - 1 - 4 = \*\*0\*\* |
| P3       |    2     |   26     |    9     | 26 - 2 - 9 = \*\*15\*\* |
| P4       |    3     |   10     |    5     | 10 - 3 - 5 = \*\*2\*\* |



\*\*총 대기시간 = 9 + 0 + 15 + 2 = 26\*\*  

\*\*평균 대기시간 = 26 ÷ 4 = 6.5\*\*

---

\## 📌 관련 개념 정리

\### 🔹 스케줄링 알고리즘 분류



\#### ✅ 선점형

\- \*\*Round Robin\*\*: 타임퀀텀 기반 시분할
\- \*\*SRT (Shortest Remaining Time)\*\*: 남은 시간이 가장 짧은 프로세스를 우선
\- \*\*MLQ (Multi-Level Queue)\*\*: 우선순위별 여러 큐
\- \*\*MLFQ (Multi-Level Feedback Queue)\*\*: 동적으로 큐 이동



\#### ✅ 비선점형

\- \*\*FCFS\*\*: 도착 순서
\- \*\*SJF\*\*: 짧은 작업 먼저
\- \*\*HRN\*\*: 응답률 높은 것 우선
\- \*\*우선순위 스케줄링\*\*
\- \*\*기한부(Deadline-based)\*\*

---

\## 📌 스케줄링 관련 문제

\- \*\*기아 현상(Starvation)\*\*: SJF, 우선순위, SRT, MLQ에서 낮은 우선순위 작업이 무한정 대기할 수 있음
\- \*\*에이징(Aging)\*\*: 대기 시간이 증가할수록 우선순위를 올려 \*\*기아 현상 방지\*\*

&nbsp; - 적용: HRN, MLFQ 등



---


\## 📌 페이지 교체 알고리즘 요약


| 알고리즘 | 설명 |
|----------|------|
| \*\*FIFO\*\* | 먼저 들어온 페이지를 먼저 교체 |
| \*\*OPT\*\*  | 앞으로 가장 오랫동안 사용되지 않을 페이지 교체 (이론적 최적) |
| \*\*LRU\*\*  | 가장 오래 사용하지 않은 페이지 교체 |
| \*\*LFU\*\*  | 사용 빈도가 가장 낮은 페이지 교체 |
| \*\*NUR\*\*  | 최근 사용 여부 비트 기반 교체 |
| \*\*SCR (Second Chance)\*\* | FIFO + 한 번의 기회 부여 |



---------------------------------------------------------------------------

## ✅ 문제 9

**문제:**  
다음 네트워크 구성도를 참고하여, **RIP**를 사용해 **라우터 A에서 라우터 F까지 가는 최적 경로**를 구하시오.  
각 라우터 간의 **연결 비용은 각 간선에 명시된 숫자**로 나타내며, **비용은 홉 수(hop count)**로 계산된다.

**답:**  
**A → D → C → F**  
즉, **ADCF**

---

## 📌 해설

### 🔹 RIP (Routing Information Protocol)의 특성

- **라우팅 알고리즘:** 거리 벡터(Distance Vector)
- **비용(metric):** **홉 수 (hop count)**  
  - 한 라우터를 거칠 때마다 비용 1 증가
- **최대 홉 수 제한:** 15  
  - 16은 도달 불가능을 의미 (루프 방지용)
- **경로 선택 기준:** **가장 적은 홉 수를 가지는 경로 선택**

---

### 🔹 문제 조건 해석

- 실제 비용이 숫자로 주어졌지만, **RIP는 실제 연결 비용이 아닌 홉 수만 고려**하므로  
  ➤ **A에서 F까지 거치는 라우터 수가 최소가 되는 경로**를 찾는 것이 목적임

---

### 🔹 가능한 경로 (예시)

1. A → B → E → F (3 hops)  
2. A → D → C → F (**3 hops, 정답 경로**)  
3. A → D → F (2 hops) ← 단, **직접 연결이 없으면 불가**  
4. A → C → F (2 hops) ← 마찬가지로 연결 유무 확인 필요

※ 문제 조건상, **ADCF 경로가 연결된 최단 홉 수 경로**로 제시되었으므로  
→ **ADCF**가 **RIP 기준의 최적 경로**가 됨.

---

## 📌 관련 개념 정리

### 🔹 라우팅 프로토콜 분류

| 분류       | 유형           | 프로토콜                | 특징                             |
|------------|----------------|-------------------------|----------------------------------|
| **정적**   | Static Routing | 수동 설정               | 단순하지만 확장성 낮음           |
| **동적**   | 내부 IGP       | **RIP** (거리 벡터)      <br>**OSPF** (링크 상태) | RIP: 홉 수 기준 <br> OSPF: 링크 비용 기준 |
|            | 외부 EGP       | **BGP**                 | 자율 시스템(AS) 간 경로 설정     |

---

### 🔹 RIP 요약

- **프로토콜:** RIP (Routing Information Protocol)
- **동작 방식:** 거리 벡터 기반, 주기적으로 이웃에게 라우팅 정보 전파
- **Metric:** 홉 수
- **장점:** 구성 간단
- **단점:** 느린 수렴 속도, 루프 발생 가능성, 15홉 제한

---

## 📌 참고

- RIP은 간단하지만 대규모 네트워크에는 부적합
- OSPF는 RIP보다 정밀하고 효율적이지만 복잡함
- BGP는 인터넷 전체에서 사용하는 외부 라우팅 프로토콜




---------------------------------------------------------------------------

\## ✅ 문제 10



\*\*문제:\*\*  

다음 테이블의 \*\*카디널리티(행 개수)\*\*와 \*\*차수(열 개수)\*\*를 구하시오.



| 학번    | 이름 | 학년 | 학과         |
|--------|------|------|--------------|
| 181101 | KKK  | 1    | 컴퓨터공학과 |
| 171201 | hhh  | 2    | 전자공학과   |
| 171302 | xxx  | 3    | 컴퓨터공학과 |
| 161107 | yyy  | 3    | 건축공학과   |
| 151403 | qqq  | 4    | 전자공학과   |


\*\*답:\*\*  
\- \*\*카디널리티 (행 수):\*\* 5  
\- \*\*차수 (열 수):\*\* 4


## 📌 해설

| 용어                        | 정의                                      | 예시 (위 테이블 기준)         |
|-----------------------------|-------------------------------------------|-------------------------------|
| **카디널리티 (Cardinality)** | **튜플(Tuple)** 또는 **행(Row)**의 수       | 5행 → **카디널리티: 5**       |
| **차수 (Degree)**            | **속성(Attribute)** 또는 **열(Column)**의 수 | 4열 → **차수: 4**             |

---

### 🔹 릴레이션(Relation)의 구성 요소

| 용어                | 설명                        |
|---------------------|-----------------------------|
| **속성(Attribute)**  | 열(Column) 구성요소, 즉 테이블의 컬럼명들 |
| **튜플(Tuple)**      | 행(Row) 구성요소, 하나의 레코드          |
| **카디널리티**       | 튜플의 수 = 행(Row) 수                   |
| **차수**             | 속성의 수 = 열(Column) 수                |

---

### 🔹 데이터베이스 테이블의 예시 용어 매핑

- **속성(Attribute)** → `학번`, `이름`, `학년`, `학과` 등
- **튜플(Tuple)** → 각 학생의 데이터 한 줄

---

## 📌 요약

- **카디널리티(Cardinality)** = 행(Row) 수 = **5**
- **차수(Degree)** = 열(Column) 수 = **4**


---------------------------------------------------------------------------

\## ✅ 문제 11


\*\*문제:\*\*  

다음은 SQL을 이용한 데이터베이스 관리 작업에 관한 문제이다.  
빈칸에 들어갈 적절한 SQL 키워드를 쓰시오.

insert into 직원(직원번호, 성명, 나이, 연봉, 팀번호)

(1) (101, 'kim', 25, 3000, 2);
insert into 직원

(2) 직원번호, 성명, 나이, 연봉, 팀번호 from 신규직원 where 팀번호 = 2;
delete (3) 직원 where 직원번호 = 101;
update 직원 (4) 연봉 = 3500 where 성명 = 'lee';



답

(1) values
(2) select
(3) from
(4) set




## 📌 해설

- **INSERT 문**  
  - `values` : 구체적인 값을 명시할 때 사용  
  - `select` : 다른 테이블에서 값을 선택하여 삽입할 때 사용

- **DELETE 문**  
  - `from` : 삭제할 테이블을 지정할 때 사용

- **UPDATE 문**  
  - `set` : 수정할 컬럼과 값을 지정할 때 사용

---

## 📌 관련 개념

| SQL 명령어               | 설명                            | 예시                                                                                         |
|--------------------------|--------------------------------|----------------------------------------------------------------------------------------------|
| **INSERT INTO ... VALUES** | 특정 값을 테이블에 삽입          | `insert into 직원 values (101, 'kim', 25, 3000, 2);`                                         |
| **INSERT INTO ... SELECT** | 다른 테이블에서 데이터를 선택해 삽입 | `insert into 직원 select 직원번호, 성명, 나이, 연봉, 팀번호 from 신규직원 where 팀번호 = 2;` |
| **DELETE FROM**            | 테이블에서 조건에 맞는 행 삭제   | `delete from 직원 where 직원번호 = 101;`                                                     |
| **UPDATE ... SET ... WHERE** | 테이블의 데이터를 수정          | `update 직원 set 연봉 = 3500 where 성명 = 'lee';`                                            |

---

## 📌 주의사항

- DELETE 구문에서 `from` 키워드는 필수임.
- UPDATE 구문에서 수정할 컬럼과 값을 지정하려면 반드시 `set` 사용.
- INSERT 구문에서 `values` 또는 `select` 중 상황에 맞는 키워드를 사용해야 함.


---------------------------------------------------------------------------

# 🚀 문제 12) JAVA 코드의 출력 결과를 쓰시오


## 📌 문제 코드 (원본)
public class Main {
                                                                                    
                                                                                        // 두 int 배열이 같은지 비교하는 함수
                                                                                        //  x: 첫 번째 배열
                                                                                        //  y: 두 번째 배열
    public static void check(int[] x, int[] y) {
                                                                                            // x와 y가 같은지를 비교한다. (핵심!)
        if (x == y)
            System.out.print("O"); // 같으면 'O' 출력
        else
            System.out.print("X"); // 다르면 'X' 출력
    }

    public static void main(String[] args) {
                                                                                                            // 크기와 내용이 같은 세 개의 int 배열을 생성한다.
        int a[] = new int[] { 1, 2, 3, 4 };
        int b[] = new int[] { 1, 2, 3, 4 };
        int c[] = new int[] { 1, 2, 3, 4 };

                                                                                                        // check 함수를 세 번 호출하여 각 배열 쌍을 비교한다.
        check(a, b);
        check(b, c);
        check(a, c);
    }
}


✅ 출력 결과
XXX



📌 설명 (== 연산자가 배열을 비교하는 방식이 핵심!)
야, 이 코드는 Java에서 배열을 == 연산자로 비교할 때 어떤 일이 일어나는지 아는 게 존나 중요해. ==는 배열의 **내용(값)**을 비교하는 게 아니라, 두 배열이 메모리상에서 같은 위치(참조값, 주소)를 가리키는지 비교한다.

1. 배열 a, b, c의 생성
main 함수에서 a, b, c 세 개의 배열을 만들지?

int a[] = new int[] { 1, 2, 3, 4 };
int b[] = new int[] { 1, 2, 3, 4 };
int c[] = new int[] { 1, 2, 3, 4 };

여기서 중요한 건 new int[]를 세 번 썼다는 거야. new 키워드를 쓸 때마다 메모리의 다른 공간에 새로운 배열 객체가 만들어져.
즉, a, b, c는 모두 내용은 {1, 2, 3, 4}로 같지만, 메모리상에서는 서로 다른 세 개의 독립적인 배열 객체를 가리키고 있는 거야. 각자의 주소가 다르다는 거지.

2. check 함수의 비교 과정
check 함수는 두 배열의 참조(주소)를 ==로 비교해.

check(a, b); 호출:

a가 가리키는 배열의 주소와 b가 가리키는 배열의 주소를 비교한다.

a와 b는 new로 각각 만들어졌으므로 서로 다른 주소를 가지고 있지?

따라서 a == b는 false가 된다.

System.out.print("X"); → X 출력.

check(b, c); 호출:

b가 가리키는 배열의 주소와 c가 가리키는 배열의 주소를 비교한다.

b와 c도 각각 new로 만들어졌으므로 서로 다른 주소를 가지고 있지?

따라서 b == c는 false가 된다.

System.out.print("X"); → X 출력.

check(a, c); 호출:

a가 가리키는 배열의 주소와 c가 가리키는 배열의 주소를 비교한다.
a와 c 역시 각각 new로 만들어졌으므로 서로 다른 주소를 가지고 있지?

따라서 a == c는 false가 된다.
System.out.print("X"); → X 출력.

3. 최종 출력
모든 check 호출이 끝난 후 화면에 출력된 문자들을 합치면:
XXX

---------------------------------------------------------------------------

## 🚀 문제 13) Python 문자열 부분 문자열 개수 세기 풀이

def fnc(str, p):                                                         # 'str' 문자열에서 'p' 부분 문자열이 몇 번 나오는지 세는 함수
    cnt = 0                                                                     # 카운트 초기화
    for i in range(len(str)):                                                     # 'str'의 각 인덱스를 순회
                                                                                    # 'str'에서 현재 인덱스 'i'부터 'p'의 길이만큼 잘라낸다.
        tmp = str[i:i+len(p)]
                                                                                        # 잘라낸 'tmp'가 'p'와 같으면 카운트를 1 늘린다.
        if tmp == p:
            cnt += 1
    return cnt                                                                                 # 최종 카운트 반환

str = "abccabcabcca"                                                                                 # 원본 문자열
p1 = "ab"                                                                                             # 찾을 첫 번째 부분 문자열
p2 = "ca"                                                                                             # 찾을 두 번째 부분 문자열

# f-string을 사용하여 결과를 포맷팅하여 출력한다.
print(f'ab{fnc(str,p1)}ca{fnc(str,p2)}')

---
## 🎯 최종 결과
> **정답:** `ab3ca3`


📌 설명 (fnc 함수가 각 패턴을 몇 번 찾는지 세는 게 핵심!)
야, 이 코드는 fnc 함수가 주어진 문자열(str) 안에서 특정 부분 문자열(p)이 겹치지 않게 나타나는 횟수를 세는 방식이야. main 코드에서는 이 fnc 함수를 두 번 호출해서 그 결과를 조합해 출력한다.

1. fnc("abccabcabcca", "ab") 호출 분석
원본 문자열: "abccabcabcca"
찾을 패턴: "ab" (len(p)는 2)
fnc 함수는 i를 0부터 시작해서 문자열 끝까지 돌면서 2글자씩 잘라낸 다음 "ab"와 비교해.

i = 0: str[0:2]는 "ab". 일치! cnt는 1.
i = 1: str[1:3]는 "bc". 불일치.
i = 2: str[2:4]는 "cc". 불일치.
i = 3: str[3:5]는 "ca". 불일치.
i = 4: str[4:6]는 "ab". 일치! cnt는 2.
i = 5: str[5:7]는 "bc". 불일치.
i = 6: str[6:8]는 "ca". 불일치.
i = 7: str[7:9]는 "ab". 일치! cnt는 3.
i = 8: str[8:10]는 "bc". 불일치.
i = 9: str[9:11]는 "cc". 불일치.
i = 10: str[10:12]는 "ca". 불일치. (여기서 i+len(p)가 문자열 길이를 넘어가면 파이썬은 자동으로 가능한 범위까지만 잘라줌. "ca"만 잘려 나옴)

fnc("abccabcabcca", "ab")의 결과는 **3**이다.

2. fnc("abccabcabcca", "ca") 호출 분석
원본 문자열: "abccabcabcca"
찾을 패턴: "ca" (len(p)는 2)

fnc 함수는 i를 0부터 시작해서 문자열 끝까지 돌면서 2글자씩 잘라낸 다음 "ca"와 비교해.

i = 0: "ab". 불일치.
i = 1: "bc". 불일치.
i = 2: "cc". 불일치.
i = 3: "ca". 일치! cnt는 1.
i = 4: "ab". 불일치.
i = 5: "bc". 불일치.
i = 6: "ca". 일치! cnt는 2.
i = 7: "ab". 불일치.
i = 8: "bc". 불일치.
i = 9: "cc". 불일치.
i = 10: "ca". 일치! cnt는 3.

fnc("abccabcabcca", "ca")의 결과는 **3**이다.

3. 최종 출력
print(f'ab{fnc(str,p1)}ca{fnc(str,p2)}')는 f-string으로 문자열을 조합한다.
fnc(str,p1)이 3이고, fnc(str,p2)도 3이니까
print(f'ab{3}ca{3}')이 되는 거지.

최종 출력은 **ab3ca3**이 된다.


---------------------------------------------------------------------------

🚀 문제 14)  C언어 코드 출력 결과 풀이


#include <stdio.h>                                                     // printf 함수를 위해 필요

int main() {
    int a = 11;                             // 정수형 변수 'a'를 11로 초기화
    int b = 19;                                                     // 정수형 변수 'b'를 19로 초기화

    switch (a) {                                             // 변수 'a'의 값에 따라 분기한다.
        case 1:                                                                                            // 'a'가 1일 경우 실행
            b += 1;
        case 11:                                                               // 'a'가 11일 경우 실행
            b += 2;
        default:                                           // 위 모든 case에 해당하지 않을 경우 실행 (혹은 fall-through 시 실행)
            b += 3;
            break;                                                 // switch 문을 여기서 빠져나간다.
    }

    printf("%d", a - b);                                             // 최종적으로 'a - b'의 결과를 출력한다.
    return 0;
}

✅ 최종 출력 결과
답: -13


📌 설명 (switch문의 break 없으면 줄줄이 실행되는 게 핵심!)
야, 이 코드는 C언어 switch 문에서 break 키워드가 없을 때 어떻게 동작하는지 (이걸 fall-through 현상이라고 한다!) 아는 게 존나 중요해.
break가 없으면 맞는 case를 찾은 다음에도 아래 case나 default를 계속 실행한다.

1. switch (a) 실행 과정
int a = 11; 이니까, switch (a)는 switch (11)과 같아.

그럼 case 11: 이 부분이 실행되겠지?

case 11: 부터 실행:
b += 2; : b는 19였으니까 19 + 2 = 21이 돼. (현재 b = 21)

case 11: 뒤에 break;가 없지?
그래서 바로 아래에 있는 default: 부분으로 실행이 넘어간다. (이게 바로 fall-through!)

default: 실행:
b += 3; : b는 21이었으니까 21 + 3 = 24가 돼. (현재 b = 24)
break; : 여기서 switch 문을 최종적으로 빠져나간다.

2. 최종 출력 (printf("%d", a - b);)
switch 문이 끝났을 때 a는 여전히 11이고, b는 24가 됐어.
printf("%d", a - b);는 11 - 24를 계산하라는 뜻이야.

11 - 24 = -13

따라서 최종 출력은 **-13**이 된다.


---------------------------------------------------------

🚀 문제 15)  C언어 코드 출력 결과 풀이

#include <stdio.h>                                                                                 // printf 함수를 위해 필요

                                                                                                // 문자열 s의 내용을 문자열 d로 복사하는 함수
                                                                                                // d: 목적지 문자열 포인터
                                                                                                // s: 원본 문자열 포인터
void func(char *d, char *s){
   while (*s) {                                                                                 // s가 가리키는 문자가 널 문자('\0')가 아닐 동안 반복
     *d = *s;                                                                                   // s가 가리키는 문자를 d가 가리키는 곳으로 복사
     d++;                                                                                       // d 포인터를 다음 위치로 이동
     s++;                                                                                        // s 포인터를 다음 위치로 이동
   }
   *d = '\0';                                                                 // 원본 문자열 복사가 끝나면 목적지 문자열 끝에 널 문자 추가 (문자열의 끝 표시)
}

int main() {
   char str1[] = "eraon";                                                             // 문자열 "eraon" (널 문자 포함 6칸)
   char str2[50] = "c language";                                                     // 크기 50의 문자열 배열에 "c language" 초기화
   int sum = 0;                                                                             // 합계를 저장할 변수

   func(str2, str1);                                                                     // func 함수를 호출하여 str1의 내용을 str2로 복사한다.

                                                                                           // str2 배열의 각 문자를 순회하며 인덱스를 sum에 더한다.
                                                                                           // 널 문자('\0')를 만나기 전까지 반복
   for (int i = 0; str2[i] != '\0'; i++) {
     sum += i; // 현재 인덱스 'i'를 sum에 더한다.
   }

   printf("%d", sum);                                                                                     // 최종 sum 값을 출력한다.
   return 0;
}


✅ 최종 출력 결과
답: 10

📌 설명 (func 함수가 str2를 어떻게 바꾸는지 아는 게 핵심!)
야, 이 코드는 두 가지 핵심이 있어.

func 함수가 str1의 내용을 str2로 어떻게 복사하는지.

for 루프에서 복사된 str2의 문자들을 순회하면서 인덱스 i를 sum에 어떻게 더하는지.

1. func(str2, str1) 호출 후 str2의 변화
str1은 "eraon"이야.

str2는 원래 "c language"였어.

func 함수가 호출되면, while (*s) 루프가 돌면서 str1의 문자들을 str2의 시작 위치부터 하나씩 복사해.

*d = *s; : str2에 str1의 문자를 복사

d++; s++; : 다음 문자로 이동

이 과정을 거치면:

str2[0]에 e
str2[1]에 r
str2[2]에 a
str2[3]에 o
str2[4]에 n

이렇게 복사가 끝나면, str1의 끝에 있는 널 문자(\0)를 만날 거야. while (*s) 조건이 false가 돼서 루프가 멈추고, *d = '\0'; 이 부분이 실행돼.
str2[5]에 \0 (널 문자)가 들어간다.
그래서 func 함수 호출 후 str2는 "eraon\0" 이렇게 돼. (원래 c language였던 부분은 덮어씌워지고, 나머지는 그대로 남아있지만 널 문자 때문에 보이지 않아.)



2. for 루프에서 sum 계산
이제 main 함수의 for 루프가 str2를 순회하면서 sum을 계산한다.
for (int i = 0; str2[i] != '\0'; i++) 이 조건은 str2 배열의 문자들이 널 문자(\0)가 아닐 때까지 반복하라는 뜻이야.

i = 0: str2[0]은 'e' (\0 아님). sum += 0; → sum = 0.
i = 1: str2[1]은 'r' (\0 아님). sum += 1; → sum = 0 + 1 = 1.
i = 2: str2[2]은 'a' (\0 아님). sum += 2; → sum = 1 + 2 = 3.
i = 3: str2[3]은 'o' (\0 아님). sum += 3; → sum = 3 + 3 = 6.
i = 4: str2[4]은 'n' (\0 아님). sum += 4; → sum = 6 + 4 = 10.
i = 5: str2[5]은 '\0'이다. 루프 조건(str2[i] != '\0')이 false가 되므로 루프 종료.

3. 최종 출력
printf("%d", sum);를 실행하면, 최종 sum 값인 **10**이 화면에 출력된다.


------------------------------------------------------------

문제 16) 다음 c언어 코드의 출력 결과를 쓰시오


#include <stdio.h>

int main() {
                                                                                                // 3x3 크기의 2차원 정수 배열을 선언하고 초기화한다.
                                                                                                // 메모리에는 1, 2, 3, 4, 5, 6, 7, 8, 9 순서로 연속해서 저장된다.
    int arr[3][3] = {1,2,3,4,5,6,7,8,9};

                                                                                                // 'darr'는 int* (정수 포인터)를 저장하는 크기 2짜리 배열이다.
                                                                                                // darr[0]은 arr[1]의 첫 번째 요소 주소를 가리킨다. (즉, {4, 5, 6} 배열의 시작 주소)
                                                                                                // darr[1]은 arr[2]의 첫 번째 요소 주소를 가리킨다. (즉, {7, 8, 9} 배열의 시작 주소)
    int *darr[2] = {arr[1], arr[2]};

                                                                                                        // 계산된 세 개의 값을 더해서 출력한다.
    printf("%d", darr[1][1] + *(darr[1]+2) + **darr);
    return 0;
}

🧠 최종 출력 결과
답: 21



📌 설명 (포인터 배열과 2차원 배열의 관계를 이해하는 게 핵심!)
야, 이 코드는 C언어에서 2차원 배열이 메모리에 어떻게 저장되는지랑 포인터 배열을 이용해서 어떻게 2차원 배열의 특정 요소에 접근하는지 묻는 문제야. 각 부분이 뭘 가리키는지 정확하게 짚고 넘어가자.

1. arr 배열과 darr 포인터 배열의 구성
arr[3][3] 배열:

arr[0]은 {1, 2, 3}을 가리켜.
arr[1]은 {4, 5, 6}을 가리켜.
arr[2]은 {7, 8, 9}를 가리켜.

메모리에는 1, 2, 3, 4, 5, 6, 7, 8, 9 순서로 쭉 저장되어 있어.

darr[2] 포인터 배열:
int *darr[2] = {arr[1], arr[2]};
darr[0]: arr[1]의 시작 주소를 가리켜. (즉, arr[1][0]인 4의 주소)
darr[1]: arr[2]의 시작 주소를 가리켜. (즉, arr[2][0]인 7의 주소)

2. printf 문 안의 각 항목 계산
이제 printf("%d", darr[1][1] + *(darr[1]+2) + **darr); 이 부분을 하나씩 뜯어보자.

darr[1][1]:
darr[1]은 arr[2]의 시작 주소를 가리키지?
그럼 darr[1][1]은 arr[2] 배열의 두 번째 요소 (인덱스 1)를 의미해.

arr[2]는 {7, 8, 9}니까, arr[2][1]은 8이다.
darr[1][1]의 값은 8이다.

*(darr[1]+2):

darr[1]은 역시 arr[2]의 시작 주소를 가리켜.
darr[1]+2는 arr[2]의 시작 주소에서 int 타입 크기만큼 두 번 이동한 주소야. 이건 arr[2][2]의 주소와 같아.

*(darr[1]+2)는 그 주소에 있는 값을 가져오라는 뜻이지.

arr[2]는 {7, 8, 9}니까, arr[2][2]는 9이다.
*(darr[1]+2)의 값은 9이다.

**darr:
darr는 darr 배열의 시작 주소 (즉, darr[0]의 주소)를 가리키는 포인터 배열의 이름이야.

*darr는 darr[0]의 값을 가져오라는 뜻이야. darr[0]은 arr[1]의 시작 주소({4, 5, 6}의 시작 주소)를 가지고 있지.

그럼 **darr는 *(*darr)와 같으니까, arr[1]의 시작 주소(arr[1][0])에 있는 값을 가져오라는 뜻이 돼.

arr[1]은 {4, 5, 6}이니까, arr[1][0]은 4이다.

**darr의 값은 4이다.


3. 최종 계산 및 출력
이제 계산된 세 값을 모두 더하면 돼.

8 + 9 + 4 = 21

------------------------------------------------------------

### 📘 문제 17) Java 코드 실행 결과를 쓰시오

interface Num {                                                                 // 'Num'이라는 인터페이스 정의
                                                                                    // 정수 배열 'a'와 boolean 값 'odd'를 받아 정수를 반환하는 sum 메서드
    int sum(int[] a, boolean odd);
}

class ODDNum implements Num {                                                     // 'ODDNum' 클래스는 'Num' 인터페이스를 구현한다.
    @Override                                                                     // 인터페이스의 sum 메서드를 구현 (오버라이드)
    public int sum(int[] a, boolean odd) {
        int result = 0;                                                                 // 합계를 저장할 변수 초기화
        for (int i = 0; i < a.length; i++) {                                             // 배열 'a'의 모든 요소를 반복
                                                                                            // 핵심 조건:
                                                                                            // (odd가 true이고 현재 숫자가 홀수) 또는
                                                                                            // (odd가 false이고 현재 숫자가 짝수)일 경우
            if ((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))
                result += a[i];                                                             // 조건을 만족하는 숫자를 result에 더한다.
        }
        return result;                                                                                     // 최종 합계 반환
    }
}

class Main {
    public static void main(String[] args) {
        int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};                                                             // 1부터 9까지의 정수 배열
        ODDNum obj = new ODDNum();                                                                     // ODDNum 클래스의 객체 생성
                                                                                                // obj.sum(a, true) 결과와 obj.sum(a, false) 결과를 콤마로 구분하여 출력한다.
        System.out.print(obj.sum(a, true) + "," + obj.sum(a, false));
    }
}

✅ 출력 결과
답: 25,20


🔍 실행 과정 분석
📌 설명 (sum 메서드의 odd 매개변수가 핵심!)
야, 이 코드는 ODDNum 클래스의 sum 메서드가 odd라는 boolean 값에 따라 홀수만 더할지 짝수만 더할지 결정하는 게 핵심이야. 
main 함수에서 이 sum 메서드를 두 번 호출해서 그 결과를 합쳐서 출력한다.

1. obj.sum(a, true) 호출 분석
배열 a: {1, 2, 3, 4, 5, 6, 7, 8, 9}

odd 매개변수: true

sum 메서드 안의 조건 (odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0)을 보자.

odd가 true니까 (true && a[i] % 2 != 0) 이 부분이 활성화돼.
즉, a[i] % 2 != 0 (숫자가 홀수)일 때만 result에 더해라는 뜻이야.

배열 a에서 홀수인 숫자들을 찾아서 더하면:
1 + 3 + 5 + 7 + 9 = 25
따라서 obj.sum(a, true)의 결과는 **25**다.

2. obj.sum(a, false) 호출 분석
배열 a: {1, 2, 3, 4, 5, 6, 7, 8, 9}

odd 매개변수: false

sum 메서드 안의 조건 (odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0)을 다시 보자.
odd가 false니까 (!false && a[i] % 2 == 0) 즉, (true && a[i] % 2 == 0) 이 부분이 활성화돼.
즉, a[i] % 2 == 0 (숫자가 짝수)일 때만 result에 더해라는 뜻이야.

배열 a에서 짝수인 숫자들을 찾아서 더하면:
2 + 4 + 6 + 8 = 20

따라서 obj.sum(a, false)의 결과는 **20**이다.


3. 최종 출력
System.out.print(obj.sum(a, true) + "," + obj.sum(a, false));
두 결과를 콤마(,)로 이어서 출력하니까:

25,20

이렇게 최종 출력이 된다.

------------------------------------------------------------
문제 18) java에 대해 출력값을 쓰시오

public class Main { // 클래스 이름은 Main으로 가정
    public static void main(String [] args){
        String str = "abacabcd";                                                                                 // 입력 문자열
        boolean[] ary = new boolean[256];                                             // 문자 등장 여부를 기록할 boolean 배열 (아스키 코드 값으로 인덱싱)
                                                                                            // fn 함수를 호출하고 그 결과를 출력한다.
                                                                                            // str.length()-1은 문자열의 마지막 인덱스를 의미한다. (8글자면 인덱스 7)
        System.out.print(fn(str, str.length()-1, ary));
    }

                                                                                            // 재귀 함수: 문자열을 뒤에서부터 탐색하며 중복 없는 문자를 역순으로 조합한다.
    public static String fn(String str, int index, boolean[] ary){
                                                                                        // 1. 재귀 호출 종료 조건: index가 0보다 작아지면 빈 문자열 반환 (더 이상 탐색할 문자가 없음)
        if (index < 0) return "";

                                                                                                        // 2. 현재 index에 해당하는 문자를 가져온다.
        char c = str.charAt(index);

                                                                                                        // 3. 다음 문자를 재귀적으로 탐색하여 결과 문자열을 얻어온다.
                                                                                                        //    (예: "d" 탐색 시 -> "c" 탐색 -> "b" 탐색 ... "a" 탐색 후 빈 문자열 반환)
        String result = fn(str, index - 1, ary); // 재귀 호출!
                                                                                                
                                                                                                        // 4. 현재 문자 'c'가 이전에 등장했는지 'ary' 배열로 확인한다.
                                                                                                        //    'ary[c]'가 false이면 처음 등장한 문자!
        if (!ary[c]) {
            ary[c] = true; // 처음 등장했으니 'true'로 표시해서 다음부터는 무시하게 한다.
            return c + result; // 현재 문자 'c'를 'result' 앞에 붙여서 반환한다.
        }
                                                                                                            // 5. 이미 등장한 문자라면, 현재 문자는 무시하고 'result'만 그대로 반환한다.
        return result;
    }
}


✅ 정답
답: dcba

📌 설명 (재귀 함수가 어떻게 호출되고 문자열이 조합되는지 추적!)
야, 이 코드는 재귀 함수(fn)가 문자열을 뒤에서부터 거꾸로 탐색하면서, 아직 등장하지 않은 문자들만 골라서 역순으로 새로운 문자열을 만드는 거야.
 boolean 배열 ary가 어떤 문자가 이미 처리되었는지 기억하는 역할을 한다.

1. fn 함수 호출 흐름과 ary 배열의 변화
main 함수에서 fn("abacabcd", 7, ary)를 호출하는 것부터 시작해. (str.length()-1은 8-1=7)
ary 배열은 모든 값이 false로 초기화되어 있어.

각 index 별로 어떤 일이 일어나는지 보자:
fn("abacabcd", 7, ary) 호출 (문자 'd')
c는 'd'
result = fn("abacabcd", 6, ary) 호출 → (아래로 내려감)
ary['d']는 false? YES! (ary['d']를 true로 바꾼다)
return 'd' + result

결과 누적: d

fn("abacabcd", 6, ary) 호출 (문자 'c')
c는 'c'
result = fn("abacabcd", 5, ary) 호출 → (아래로 내려감)
ary['c']는 false? YES! (ary['c']를 true로 바꾼다)
return 'c' + result

결과 누적: c

fn("abacabcd", 5, ary) 호출 (문자 'b')
c는 'b'
result = fn("abacabcd", 4, ary) 호출 → (아래로 내려감)
ary['b']는 false? YES! (ary['b']를 true로 바꾼다)
return 'b' + result

결과 누적: b

fn("abacabcd", 4, ary) 호출 (문자 'a')
c는 'a'
result = fn("abacabcd", 3, ary) 호출 → (아래로 내려감)
ary['a']는 false? YES! (ary['a']를 true로 바꾼다)
return 'a' + result

결과 누적: a

fn("abacabcd", 3, ary) 호출 (문자 'c')
c는 'c'
result = fn("abacabcd", 2, ary) 호출 → (아래로 내려감)
ary['c']는 false? NO! (ary['c']는 이미 true다)
return result (그냥 result만 반환, 'c'는 무시)
fn("abacabcd", 2, ary) 호출 (문자 'a')

c는 'a'

result = fn("abacabcd", 1, ary) 호출 → (아래로 내려감)
ary['a']는 false? NO! (ary['a']는 이미 true다)
return result (그냥 result만 반환, 'a'는 무시)
fn("abacabcd", 1, ary) 호출 (문자 'b')

c는 'b'

result = fn("abacabcd", 0, ary) 호출 → (아래로 내려감)
ary['b']는 false? NO! (ary['b']는 이미 true다)
return result (그냥 result만 반환, 'b'는 무시)
fn("abacabcd", 0, ary) 호출 (문자 'a')

c는 'a'

result = fn("abacabcd", -1, ary) 호출 → (아래로 내려감)
ary['a']는 false? NO! (ary['a']는 이미 true`다)
return result (그냥 result만 반환, 'a'는 무시)
fn("abacabcd", -1, ary) 호출 (종료 조건)
index < 0 이므로 return "" (빈 문자열 반환)
이 빈 문자열이 위로 쭉쭉 전달된다.

2. 반환 값 조합 (콜 스택 역순)
이제 재귀 호출이 끝나고 반환 값들이 어떻게 합쳐지는지 위로 올라가 보자.

fn(str, 0, ary)가 받은 result는 ""였다. ary['a']가 true이므로 result 그대로 반환. → ""
fn(str, 1, ary)가 받은 result는 ""였다. ary['b']가 true이므로 result 그대로 반환. → ""
fn(str, 2, ary)가 받은 result는 ""였다. ary['a']가 true이므로 result 그대로 반환. → ""
fn(str, 3, ary)가 받은 result는 ""였다. ary['c']가 true이므로 result 그대로 반환. → ""

fn(str, 4, ary)가 받은 result는 ""였다. ary['a']가 false였으므로 'a' + result 반환. → "a"
fn(str, 5, ary)가 받은 result는 "a"였다. ary['b']가 false였으므로 'b' + result 반환. → "ba"
fn(str, 6, ary)가 받은 result는 "ba"였다. ary['c']가 false였으므로 'c' + result 반환. → "cba"
fn(str, 7, ary)가 받은 result는 "cba"였다. ary['d']가 false였으므로 'd' + result 반환. → "dcba"

최종적으로 main 함수에서 System.out.print로 출력되는 값은 **dcba**가 된다.
------------------------------------------------------------

# ✅ 문제 19) C언어 구조체 포인터 코드 출력 결과

---
#include <stdio.h>                                                                         // printf 함수를 위해 필요

                                                                                            // 'node'라는 이름의 구조체를 정의한다.
                                                                                                //  - int n1: 정수형 멤버
                                                                                                //  - struct node *n2: 다음 'node' 구조체를 가리키는 포인터 멤버
struct node {
    int n1;
    struct node *n2;
};

int main() {
                                                                                                    // 1. 'node' 타입의 포인터 'head'를 NULL로 초기화
    struct node *head = NULL;
                                                                                                        // 2. 'node' 타입의 변수 'a', 'b', 'c'를 선언하고 초기값을 할당
                                                                                                        //    n2 멤버는 모두 0 (NULL)으로 초기화된다.
    struct node a = {10, 0};
    struct node b = {20, 0};
    struct node c = {30, 0};

                                                                                                                        // 3. 포인터들을 연결하여 간단한 연결 리스트를 만든다.
    head = &a;                                                                                                           // head가 'a'의 주소를 가리키게 한다.
    a.n2 = &b;                                                                                                           // 'a'의 n2 멤버가 'b'의 주소를 가리키게 한다.
    b.n2 = &c;                                                                                                           // 'b'의 n2 멤버가 'c'의 주소를 가리키게 한다.

                                                                                                                            // 4. 특정 노드의 값을 출력한다.
    printf("%d", head->n2->n1);
}


✅ 출력 결과
답: 20

🔍 구조도 분석
📌 설명 (구조체 포인터를 따라가며 값을 찾는 게 핵심!)
야, 이 코드는 C언어에서 구조체랑 포인터가 어떻게 연결돼서 간단한 연결 리스트처럼 동작하는지 보여주는 거야.
head->n2->n1 이 부분이 뭘 의미하는지 그림 그리듯이 따라가면 존나 쉽다.

1. 노드들의 초기 상태와 연결
main 함수에서 a, b, c 세 개의 node 구조체가 만들어지고, 각각 n1 멤버에 값이 들어가. n2 멤버는 모두 NULL (0)로 초기화돼.

a: n1 = 10, n2 = NULL
b: n1 = 20, n2 = NULL
c: n1 = 30, n2 = NULL

그리고 나서 포인터들이 이렇게 연결돼:

head = &a;
head는 a 노드를 가리킨다.

a.n2 = &b;
a 노드의 n2는 b 노드를 가리킨다.

b.n2 = &c;
b 노드의 n2는 c 노드를 가리킨다.

이걸 그림으로 그리면 이렇게 된다:
head ─▶ a (n1=10) ─▶ b (n1=20) ─▶ c (n1=30)


2. printf("%d", head->n2->n1); 분석
이제 printf 문 안의 head->n2->n1이 무슨 값을 가져오는지 단계별로 따라가 보자.

head:
head는 위에서 봤듯이 a 노드를 가리키고 있지?

head->n2:
head가 가리키는 a 노드의 n2 멤버에 접근하는 거야.

a.n2는 b 노드를 가리키도록 설정했잖아?

그러니까 head->n2는 b 노드를 가리킨다.

head->n2->n1:

이제 head->n2가 가리키는 b 노드의 n1 멤버에 접근하는 거야.

b 노드의 n1 값은 20이지?
그래서 head->n2->n1의 최종 값은 **20**이 된다.


3. 최종 출력
printf("%d", 20); 가 실행되니까, **20**이 화면에 출력돼.
------------------------------------------------------------

문제 20) JAVA 코드 변환 

# ✅ 문제: Java 코드의 출력 결과 분석

---

## 📌 문제 코드

public class ExampleClass {
    public static void main(String[] args) {
        String input = "HELLOEXAMPLESENTENCE";
        String[] output = input.split("E");                                         // "E"를 기준으로 문자열을 나눈다.
        System.out.print(output[3]);                                                 // 나눠진 배열의 4번째 요소(인덱스 3)를 출력한다.
    }
}

✅ 최종 출력
답: S

🔍 코드 설명

📌 설명 (split()으로 문자열이 어떻게 쪼개지는지 추적하는 게 핵심!)
야, 이 코드는 Java의 String.split() 메서드가 특정 문자를 기준으로 문자열을 어떻게 쪼개서 배열로 만드는지 아는 게 존나 중요해.
split()은 구분자(여기서는 "E")를 기준으로 문자열을 자르고, 그 구분자는 결과 배열에 포함되지 않아.

1. input.split("E") 실행 과정
원본 문자열: HELLOEXAMPLESENTENCE

구분자: "E"
자, 이제 "E"를 기준으로 문자열을 하나씩 쪼개면서 output 배열이 어떻게 만들어지는지 보자.
HELLOEXAMPLESENTENCE

첫 번째 "E" 앞: H
output[0] = "H"

두 번째 "E" 앞: LLO
output[1] = "LLO"

세 번째 "E" 앞: XAMPL
output[2] = "XAMPL"

네 번째 "E" 앞: S
output[3] = "S"

다섯 번째 "E" 앞: NT
output[4] = "NT"

여섯 번째 "E" 앞: NC
output[5] = "NC"

마지막 "E" 뒤: 아무것도 없지? 이럴 땐 빈 문자열("")이 된다.
output[6] = ""

그래서 output 배열은 최종적으로 이렇게 돼:
output = {"H", "LLO", "XAMPL", "S", "NT", "NC", ""}


2. System.out.print(output[3]); 실행
output 배열에서 인덱스 3에 해당하는 요소를 출력하라고 했지?

output[0]은 "H"
output[1]은 "LLO"
output[2]는 "XAMPL"
output[3]은 바로 **"S"**다.

그래서 최종 출력은 **S**가 된다.

