\# 📘 2024년 2회 정보처리기사 실기 기출 정리



\## ✅ 문제 1


\*\*문제:\*\*  

시스템의 성능 향상, 개발 과정의 편의성 등을 위해 정규화된 데이터 모델을 분할, 통합, 추가하는 과정으로 의도적으로 정규화에 위배되는 행위이다. 무엇을 설명하는 것인지 쓰시오.


\*\*답:\*\*  

반정규화 (=역정규화, 비정규화)



\## 📌 관련 개념 설명



\### 🔹 반정규화(역정규화, 비정규화)

\- \*\*정의:\*\* 정규화를 통해 생성된 여러 개의 테이블을 조인으로 연결할 때 성능 저하가 발생하거나 시스템 구현이 복잡해질 경우, 이를 해결하기 위해 \*\*의도적으로 정규화된 구조를 깨고\*\* 테이블을 \*\*통합하거나 중복된 속성을 추가하는 행위\*\*.

\- \*\*목적:\*\* 시스템 성능 향상, 구현의 단순화, 응답시간 단축



\### 🔹 반정규화의 주요 방법

\- 테이블 \*\*병합\*\* 또는 \*\*분할\*\*
\- 중복 속성 \*\*추가\*\*
\- \*\*파생 속성\*\* 추가
\- \*\*중복 테이블\*\* 생성 등




\## 📌 관련 용어 정리


| 용어          | 설명 |

|---------------|------|

| \*\*공유데이터\*\* | 여러 응용 시스템에서 공유하여 사용하는 데이터 |

| \*\*저장데이터\*\* | 실제 DB에 저장되는 데이터 |

| \*\*통합데이터\*\* | 데이터의 \*\*중복을 최소화\*\*하고 일관성을 유지하기 위해 통합된 구조의 데이터 |

| \*\*운영데이터\*\* | 업무 처리를 위해 사용되는 데이터, 실시간으로 접근이 필요한 데이터 |



---



\## 📌 이상현상 (Anomalies)

정규화되지 않은 테이블에서 발생하는 데이터 이상



| 종류       | 설명 |

|------------|------|

| \*\*삽입 이상\*\* | 불필요한 데이터를 함께 입력해야 삽입 가능한 현상 |

| \*\*삭제 이상\*\* | 하나의 데이터 삭제 시 \*\*연쇄적으로 관련 없는 데이터도 삭제\*\*되는 현상 |

| \*\*갱신 이상\*\* | 한 데이터를 갱신할 때 \*\*중복된 모든 데이터\*\*를 갱신해야 하는 현상 |



---



\## 📌 함수 종속성(FD: Functional Dependency)



| 개념               | 설명 |

|--------------------|------|

| \*\*완전 함수 종속\*\* | 기본키의 \*\*전체에 종속\*\*되는 경우 |

| \*\*부분 함수 종속\*\* | 기본키의 \*\*일부에만 종속\*\*되는 경우 (→ 제2정규형 위반) |

| \*\*이행적 함수 종속\*\* | A → B, B → C 이면 A → C 와 같은 간접 종속 (→ 제3정규형 위반) |



---------------------------------------------------------------------------



\## ✅ 문제 2



\*\*문제:\*\*  

빈칸에 들어갈 네트워크 보안 프로토콜을 쓰시오



VPN을 통해 안전한 통신을 구현하기 위해 사용되는 이 프로토콜은  

네트워크 계층에서 동작하며, 데이터의 기밀성, 무결성, 그리고 인증을 제공한다.  

이 프로토콜은 AH(Authentication Header)와 ESP(Encapsulating Security Payload) 두 가지 하위 프로토콜을 포함하며,  

각각 데이터의 무결성과 인증, 그리고 데이터의 기밀성을 제공한다.  

또한 이 프로토콜은 터널 모드와 전송 모드를 지원하며,  

주로 IKE(Internet Key Exchange) 프로토콜과 함께 보안 연결을 설정한다.  

이 프로토콜의 이름은 \*\*(           )\*\* 이다.



\*\*답:\*\*  

IPsec (IP Security)



---



\## 📌 관련 개념 설명



\### 🔐 IPsec (Internet Protocol Security)

\- \*\*설명:\*\*  

&nbsp; IP 계층에서 동작하는 네트워크 보안 프로토콜로,  

&nbsp; \*\*VPN 환경에서 안전한 통신\*\*을 위해 사용됨.


\- \*\*기능:\*\*  

&nbsp; - 데이터의 \*\*기밀성(confidentiality)\*\*  
&nbsp; - \*\*무결성(integrity)\*\*  
&nbsp; - \*\*인증(authentication)\*\* 제공


\- \*\*구성 요소:\*\*

&nbsp; - \*\*AH (Authentication Header)\*\*  
&nbsp;   → 데이터의 무결성과 송신자 인증 제공 (기밀성은 제공하지 않음)
&nbsp; - \*\*ESP (Encapsulating Security Payload)\*\*  
&nbsp;   → 데이터의 무결성, 인증, 기밀성 모두 제공


\- \*\*동작 모드:\*\*

&nbsp; - \*\*터널 모드\*\*: 전체 IP 패킷을 암호화하여 보안 터널 생성
&nbsp; - \*\*전송 모드\*\*: IP 패킷의 페이로드만 암호화


\## 📌 기타 보안 프로토콜 요약



| 프로토콜 | 설명 |

|----------|------|

| \*\*SSL/TLS\*\* | 웹 브라우저와 서버 간 암호화된 연결 제공 (HTTPS 통신에 사용됨) |

| \*\*SSH\*\* | 원격 컴퓨터에 안전하게 접속하여 명령 실행 |

| \*\*PGP\*\* | 이메일 데이터 암호화 및 디지털 서명 |

| \*\*Kerberos\*\* | 클라이언트와 서버 간의 \*\*상호 인증\*\*을 위한 네트워크 인증 프로토콜 |

| \*\*S/MIME\*\* | 이메일 메시지의 \*\*암호화\*\* 및 \*\*디지털 서명\*\*을 위한 표준 |



---------------------------------------------------------------------------


\## ✅ 문제 3



\*\*문제:\*\*  

다음 설명에 해당하는 응집도 유형을 보기에서 골라 쓰시오



모듈 내부의 각 기능들이 서로 연관성을 가지고 \*\*순차적으로 수행되는 응집도 유형\*\*을 말한다.  

하나의 작업이 끝나면 그 결과가 다음 작업의 입력으로 사용되며,  

이러한 과정이 연속적으로 이어지는 형태이다.  

이 응집도는 \*\*기능적 응집도보다는 낮지만 절차적 응집도보다는 높은\*\* 수준의 응집도를 가진다.



\*\*답:\*\*  

순차적 응집도



---



\## 📌 관련 개념 설명: 응집도(Cohesion)



응집도란 \*\*모듈 내부 구성요소 간의 기능적 관련성의 정도\*\*를 의미하며,  

응집도가 높을수록 모듈의 독립성이 높고 재사용성이 증가함.



\### 🔼 응집도 수준 (높은 응집도 → 낮은 응집도 순)



| 응집도 유형         | 설명 |

|----------------------|------|

| \*\*기능적 응집도\*\*     | 모듈이 하나의 명확한 기능만 수행 (가장 높은 응집도) |

| \*\*순차적 응집도\*\*     | \*\*앞 단계 결과가 다음 단계의 입력\*\*으로 사용됨. 작업이 순차적으로 수행됨 |

| \*\*통신적 응집도\*\*     | 동일한 입력이나 출력 데이터를 사용하는 기능들로 구성 |

| \*\*절차적 응집도\*\*     | 특정 절차에 따라 수행되지만, 데이터 연관성은 없음 |

| \*\*시간적 응집도\*\*     | 특정 시간에 함께 실행되는 기능들로 구성 (예: 초기화 작업) |

| \*\*논리적 응집도\*\*     | 비슷한 성격의 여러 기능을 하나의 모듈에 포함. 제어문으로 기능 선택 |

| \*\*우연적 응집도\*\*     | 아무런 관련 없이 기능들이 모듈에 나열됨 (가장 낮은 응집도) |




\## 📌 비교 포인트



| 응집도 유형     | 주요 특징 |

|----------------|-----------|

| \*\*기능적\*\*     | 단일 목적, 하나의 기능만 수행 |

| \*\*순차적\*\*     | A → B → C 순서로 \*\*출력이 다음 입력\*\*이 됨 |

| \*\*통신적\*\*     | 같은 입력/출력을 공유 |

| \*\*절차적\*\*     | 순서는 있지만 출력입력 연관은 없음 |

| \*\*시간적\*\*     | 특정 시점 동시 수행 |

| \*\*논리적\*\*     | 유사한 작업을 묶되, 내부 선택 구조 포함 |

| \*\*우연적\*\*     | 관련 없는 기능 나열 |



---------------------------------------------------------------------------

\## ✅ 문제 4



\*\*문제:\*\*  

다음 설명을 듣고 빈칸에 들어갈 네트워크 전송 방식 두 가지를 각각 쓰시오



(1)은 \*\*연결 지향적\*\*으로, 데이터 전송 전에 먼저 \*\*경로를 설정한 후\*\* 모든 패킷이 동일한 경로를 통해 순차적으로 전달된다.  

이 방식은 \*\*연결이 설정된 후에야 데이터가 전송\*\*되며, 패킷이 \*\*순서대로 도착하는 것이 보장\*\*된다.  

(2)는 \*\*비연결 지향적\*\*으로, 경로를 미리 설정하지 않고 각 패킷이 \*\*독립적으로 전송\*\*되며, 패킷이 서로 다른 경로를 통해 전달될 수 있다.  

패킷이 목적지에 도착하는 \*\*순서가 보장되지 않으며\*\*, 각 패킷이 \*\*개별적으로 처리\*\*되는 방식이다.



\*\*답:\*\*  

(1) 가상회선 방식  

(2) 데이터그램 방식



---



\## 📌 관련 개념 설명



\### 🔹 데이터 교환 방식 개요



데이터 전송을 위한 교환 방식은 \*\*회선 교환\*\*과 \*\*축적 후 교환\*\*(Store and Forward)으로 나뉘며,  

축적 후 교환은 다시 \*\*메시지 교환\*\*과 \*\*패킷 교환\*\*으로 구분됨.





---



\### 🔸 (1) 가상회선 방식 (Virtual Circuit)



\- \*\*연결 지향형 방식\*\*

\- \*\*데이터 전송 전에 경로 설정 필수\*\*

\- \*\*모든 패킷이 동일한 경로\*\*를 따라 전송됨

\- 패킷이 \*\*순서대로 도착\*\*함

\- 예: ATM, X.25



\### 🔸 (2) 데이터그램 방식 (Datagram)



\- \*\*비연결형 방식\*\*

\- \*\*패킷마다 경로를 독립적으로 선택\*\*하여 전송

\- 패킷이 \*\*서로 다른 경로\*\*를 통해 목적지에 도달할 수 있음

\- \*\*도착 순서 보장되지 않음\*\*

\- 예: IP 프로토콜



---



\## 📌 보충 설명: 회선 교환 vs. 패킷 교환



| 구분 | 회선 교환 | 패킷 교환 |

|------|-----------|------------|

| 연결 설정 | 필요함 | 필요 없음 (데이터그램) / 있음 (가상회선) |

| 전송 경로 | 고정 | 유동적 |

| 순서 보장 | 항상 보장 | 방식에 따라 다름 |

| 전송 단위 | 비트 스트림 | 패킷 |



---------------------------------------------------------------------------



\## ✅ 문제 5



\*\*문제:\*\*  

객체의 내부 구조를 감추면서도 일관된 방식으로 그 내부에 포함된 요소들을 \*\*순차적으로 접근\*\*할 수 있게 하며,  

동시에 여러 종류의 컬렉션 (예: 배열, 리스트, 트리)에서도 \*\*동일한 접근 방식\*\*을 제공하여  

컬렉션의 구현과 상관없이 순회가 가능하도록 하는 디자인패턴은 무엇인지 보기에서 골라 쓰시오.



\*\*답:\*\*  

Iterator (이터레이터)



---



\## 📌 관련 개념 설명



\### 🔸 Iterator 패턴



\- \*\*정의:\*\*  

&nbsp; 컬렉션(배열, 리스트, 트리 등)의 내부 구조를 \*\*노출하지 않고\*\*  

&nbsp; 그 내부 요소를 \*\*순차적으로 접근\*\*할 수 있도록 하는 디자인 패턴



\- \*\*목적:\*\*  

&nbsp; 다양한 자료구조에서 \*\*동일한 방식으로 접근(순회)\*\* 가능하게 함



\- \*\*주요 특징:\*\*

&nbsp; - \*\*컬렉션과 분리된 순회 기능\*\* 제공

&nbsp; - 내부 구조의 변경 없이 접근 가능

&nbsp; - \*\*단일 인터페이스\*\*로 여러 자료구조 대응 가능



\- \*\*주요 메서드 (Java 기준):\*\*

&nbsp; - `hasNext()` : 다음 요소가 있는지 확인

&nbsp; - `next()` : 다음 요소 반환



---



\## 📌 객체지향 구성 요소



| 구성 요소        | 설명 |

|------------------|------|

| \*\*클래스 (class)\*\* | 데이터를 추상화한 설계도 |

| \*\*객체 (object)\*\* | 클래스의 인스턴스 |

| \*\*속성 (attribute)\*\* | 객체가 가진 데이터 |

| \*\*메서드 (method)\*\* | 객체가 수행하는 동작 |

| \*\*메시지 (message)\*\* | 객체에게 행위를 요청하는 것 (메서드 호출 등) |



---



\## 📌 객체지향의 주요 특징



\- \*\*캡슐화(Encapsulation):\*\*  

&nbsp; 데이터를 외부에서 직접 접근하지 못하게 숨기고, 메서드를 통해서만 접근하도록 함



\- \*\*정보은닉(Information Hiding):\*\*  

&nbsp; 외부에 불필요한 내부 세부사항을 숨김



\- \*\*상속(Inheritance):\*\*  

&nbsp; 부모 클래스의 속성과 기능을 자식 클래스가 물려받음



\- \*\*다형성(Polymorphism):\*\*  

&nbsp; 하나의 메시지(메서드 호출)에 대해 \*\*여러 형태로 응답\*\*할 수 있음



\- \*\*추상화(Abstraction):\*\*  

&nbsp; 복잡한 내용을 감추고 필요한 기능만 노출



---



\## 📌 객체지향 설계 원칙 (SOLID)



| 원칙                         | 설명 |

|------------------------------|------|

| \*\*SRP (단일 책임 원칙)\*\*         | 하나의 클래스는 하나의 책임만 가져야 함 |

| \*\*OCP (개방-폐쇄 원칙)\*\*         | 확장에는 열려 있고, 수정에는 닫혀 있어야 함 |

| \*\*LSP (리스코프 치환 원칙)\*\*     | 자식 클래스는 부모 클래스를 대체할 수 있어야 함 |

| \*\*ISP (인터페이스 분리 원칙)\*\*   | 하나의 일반 인터페이스보다 여러 개의 구체적 인터페이스가 낫다 |

| \*\*DIP (의존성 역전 원칙)\*\*       | 구체적인 것보다 추상적인 것에 의존해야 함 |



---------------------------------------------------------------------------

\## ✅ 문제 6



\*\*문제:\*\*  

다음 설명에 해당하는 암호화 알고리즘의 이름을 쓰시오



이 알고리즘은 미국 국립 표준기술연구소가 기존의 DES를 대체하기 위해 선정한 \*\*대칭 키 블록 암호화 알고리즘\*\*이다.  

128비트의 \*\*고정 블록 크기\*\*를 사용하며, 키 길이는 \*\*128, 192, 256 비트\*\*를 지원한다.  

\*\*보안성과 성능이 우수\*\*하며, 전 세계적으로 다양한 분야에서 널리 사용되고 있으며,  

\*\*무선 통신\*\*, \*\*금융 거래\*\*, \*\*저장 데이터의 암호화\*\* 등에서 \*\*표준\*\*으로 채택되고 있다.



\*\*답:\*\*  

AES (Advanced Encryption Standard)



---



\## 📌 관련 개념 설명



\### 🔐 AES (Advanced Encryption Standard)



\- \*\*암호 방식:\*\* 블록 암호 방식 (대칭 키)

\- \*\*개발 배경:\*\* DES의 취약점을 보완하고, 고속/고보안성을 위해 미국 NIST에서 표준으로 채택 (2001년)

\- \*\*키 길이:\*\* 128, 192, 256 비트 지원

\- \*\*블록 크기:\*\* 128비트 고정

\- \*\*라운드 수:\*\* 

&nbsp; - 128비트 키 → 10 라운드  

&nbsp; - 192비트 키 → 12 라운드  

&nbsp; - 256비트 키 → 14 라운드

\- \*\*구조:\*\* SPN(Substitution Permutation Network) 구조 사용

\- \*\*특징:\*\* 빠른 처리 속도와 강력한 보안성, 하드웨어/소프트웨어 모두 적합



---



\## 📌 주요 블록 암호 알고리즘 비교



| 알고리즘   | 블록 크기 | 키 길이         | 라운드 수   | 구조        | 국가/특징 |

|------------|-----------|------------------|-------------|-------------|------------|

| \*\*DES\*\*    | 64비트    | 56비트           | 16라운드    | Feistel     | 미국, 구표준 |

| \*\*3DES\*\*   | 64비트    | 112/168비트      | 48라운드    | Feistel     | DES 강화 |

| \*\*AES\*\*    | 128비트   | 128/192/256비트  | 10/12/14    | SPN         | 미국, 표준 |

| \*\*SEED\*\*   | 128비트   | 128비트          | 16라운드    | Feistel     | 한국 |

| \*\*ARIA\*\*   | 128비트   | 128/192/256비트  | 12/14/16    | SPN         | 한국 |

| \*\*LEA\*\*    | 128비트   | 128/192/256비트  | 24/28/32    | SPN         | 한국, 경량 |

| \*\*IDEA\*\*   | 64비트    | 128비트          | 8라운드     | Feistel+SPN | 스위스 |

| \*\*Skipjack\*\* | 64비트 | 80비트           | 32라운드    | Feistel 변형 | 미국 NSA |



---



\## 📌 기타 암호 알고리즘 분류 요약



\### ✅ 스트림 암호

| 알고리즘 | 설명 |

|----------|------|

| \*\*LFSR\*\* | 선형 피드백 시프트 레지스터 기반 |

| \*\*RC4\*\*  | 인터넷 보안 프로토콜에 사용 |

| \*\*A5\*\*   | GSM 이동통신에서 사용 |



\### ✅ 공개키 암호 (비대칭키)

| 기반 이론 | 알고리즘 |

|-----------|----------|

| 소인수분해 | RSA, Rabin |

| 이산대수 | Diffie-Hellman, DSA, ElGamal |

| 타원곡선 | ECC (Elliptic Curve Cryptography) |



\### ✅ 단방향 암호 (해시 함수)

| 알고리즘 | 설명 |

|----------|------|

| \*\*MD5\*\* | 빠르지만 취약점 존재 |

| \*\*SHA\*\* | 미국 NIST 개발, 보안성 강화 |

| \*\*HAS-160\*\* | 한국 개발, KCDSA에서 사용 |



---------------------------------------------------------------------------



\## ✅ 문제 7



\*\*문제:\*\*  

다음 설명에 해당하는 결합도 유형을 쓰시오



두 모듈 사이에서 \*\*하나의 모듈이 다른 모듈의 내부 논리 흐름을 제어\*\*해  

\*\*특정 제어 신호를 전달하는 결합도\*\* 유형을 말한다.  

이 결합도는 모듈 간의 독립성을 저하시켜 \*\*유지보수와 확장성에 부정적인 영향\*\*을 미칠 수 있다.  

일반적으로 이 결합도가 존재할 경우, 호출하는 모듈이 호출된 모듈의 \*\*내부 동작 방식까지 알고 있어야\*\* 하므로  

모듈 간에 \*\*강한 의존성\*\*이 발생한다.  

따라서 제어 신호가 변경되면 관련된 \*\*모든 모듈을 수정\*\*해야 하는 상황이 발생할 수 있다.



\*\*답:\*\*  

제어 결합도 (Control Coupling)



---



\## 📌 관련 개념 설명: 결합도(Coupling)



\*\*결합도\*\*란 모듈 간의 \*\*의존성(연결 강도)\*\*을 의미하며,  

결합도가 낮을수록 모듈 간 독립성이 높아지고 유지보수가 쉬워짐.  

이상적인 설계에서는 \*\*낮은 결합도, 높은 응집도\*\*가 바람직함.



\### 🔽 결합도의 종류 (낮은 결합도 → 높은 결합도 순)



| 결합도 유형             | 설명 |

|--------------------------|------|

| \*\*자료 결합도 (Data Coupling)\*\* | \*\*단순한 값\*\*을 인자로 전달 (가장 바람직함) |

| \*\*스탬프 결합도 (Stamp Coupling)\*\* | 배열, 구조체 등 \*\*자료구조 전체\*\*를 인자로 전달 |

| \*\*제어 결합도 (Control Coupling)\*\* | \*\*제어 신호(논리값, 플래그)\*\*를 전달하여 상대 모듈의 실행 흐름 제어 |

| \*\*외부 결합도 (External Coupling)\*\* | 두 모듈이 외부 시스템 자원(환경변수, DB 등)을 함께 사용 |

| \*\*공통 결합도 (Common Coupling)\*\* | \*\*전역 변수\*\*를 여러 모듈이 공유하여 사용 |

| \*\*내용 결합도 (Content Coupling)\*\* | \*\*한 모듈이 다른 모듈의 내부를 직접 접근하거나 수정\*\* (가장 나쁨) |



---



\## 📌 제어 결합도 예시



```java

void processOrder(int orderType) {

&nbsp;   if (orderType == 1) {

&nbsp;       // 배송처리

&nbsp;   } else if (orderType == 2) {

&nbsp;       // 반품처리

&nbsp;   }

}

---------------------------------------------------------------------------

\## ✅ 문제 8



\*\*문제:\*\*  

다음은 프로세스가 준비 상태 큐에 도착한 시간과 프로세스를 처리하는데 필요한 실행시간을 보여준다.  

\*\*선점형 스케줄링 알고리즘인 SRT 알고리즘\*\*을 사용할 경우 프로세스들의 \*\*평균 대기시간을 구하시오\*\*.  

(단, 프로세스 간 문맥교환에 따른 오버헤드는 무시하며, 주어진 4개 프로세스 외에 처리할 다른 프로세스는 없다고 가정한다)



| 프로세스 | 도착시간 | 실행시간 |

|----------|----------|----------|

| P1       |    0     |    8     |

| P2       |    1     |    4     |

| P3       |    2     |    9     |

| P4       |    3     |    5     |



\*\*답:\*\*  

6.5



---



\## 📌 해설: SRT (Shortest Remaining Time) 알고리즘



SRT는 \*\*SJF(Shortest Job First)\*\*의 선점형 방식이다.  

실행 중인 프로세스보다 \*\*남은 시간이 더 짧은 프로세스가 도착\*\*하면, 현재 실행을 \*\*선점하고 교체\*\*한다.



\### 🔹 스케줄링 순서:





\### 🔹 완료 시간 및 대기 시간 계산:



| 프로세스 | 도착시간 | 종료시간 | 실행시간 | 대기시간 |

|----------|----------|----------|----------|----------|

| P1       |    0     |   17     |    8     | 17 - 0 - 8 = \*\*9\*\* |

| P2       |    1     |    5     |    4     | 5 - 1 - 4 = \*\*0\*\* |

| P3       |    2     |   26     |    9     | 26 - 2 - 9 = \*\*15\*\* |

| P4       |    3     |   10     |    5     | 10 - 3 - 5 = \*\*2\*\* |



\*\*총 대기시간 = 9 + 0 + 15 + 2 = 26\*\*  

\*\*평균 대기시간 = 26 ÷ 4 = 6.5\*\*



---



\## 📌 관련 개념 정리



\### 🔹 스케줄링 알고리즘 분류



\#### ✅ 선점형

\- \*\*Round Robin\*\*: 타임퀀텀 기반 시분할

\- \*\*SRT (Shortest Remaining Time)\*\*: 남은 시간이 가장 짧은 프로세스를 우선

\- \*\*MLQ (Multi-Level Queue)\*\*: 우선순위별 여러 큐

\- \*\*MLFQ (Multi-Level Feedback Queue)\*\*: 동적으로 큐 이동



\#### ✅ 비선점형

\- \*\*FCFS\*\*: 도착 순서

\- \*\*SJF\*\*: 짧은 작업 먼저

\- \*\*HRN\*\*: 응답률 높은 것 우선

\- \*\*우선순위 스케줄링\*\*

\- \*\*기한부(Deadline-based)\*\*



---



\## 📌 스케줄링 관련 문제



\- \*\*기아 현상(Starvation)\*\*: SJF, 우선순위, SRT, MLQ에서 낮은 우선순위 작업이 무한정 대기할 수 있음

\- \*\*에이징(Aging)\*\*: 대기 시간이 증가할수록 우선순위를 올려 \*\*기아 현상 방지\*\*

&nbsp; - 적용: HRN, MLFQ 등



---



\## 📌 페이지 교체 알고리즘 요약



| 알고리즘 | 설명 |

|----------|------|

| \*\*FIFO\*\* | 먼저 들어온 페이지를 먼저 교체 |

| \*\*OPT\*\*  | 앞으로 가장 오랫동안 사용되지 않을 페이지 교체 (이론적 최적) |

| \*\*LRU\*\*  | 가장 오래 사용하지 않은 페이지 교체 |

| \*\*LFU\*\*  | 사용 빈도가 가장 낮은 페이지 교체 |

| \*\*NUR\*\*  | 최근 사용 여부 비트 기반 교체 |

| \*\*SCR (Second Chance)\*\* | FIFO + 한 번의 기회 부여 |



---------------------------------------------------------------------------



\## ✅ 문제 9



\*\*문제:\*\*  

다음 네트워크 구성도를 참고하여, \*\*RIP\*\*를 사용해 \*\*라우터 A에서 라우터 F까지 가는 최적 경로\*\*를 구하시오.  

각 라우터 간의 \*\*연결 비용은 각 간선에 명시된 숫자\*\*로 나타내며, \*\*비용은 홉 수(hop count)\*\*로 계산된다.



\*\*답:\*\*  

\*\*A → D → C → F\*\*  

즉, \*\*ADCF\*\*



---



\## 📌 해설



\### 🔹 RIP (Routing Information Protocol)의 특성



\- \*\*라우팅 알고리즘:\*\* 거리 벡터(Distance Vector)

\- \*\*비용(metric):\*\* \*\*홉 수 (hop count)\*\*  

&nbsp; - 한 라우터를 거칠 때마다 비용 1 증가

\- \*\*최대 홉 수 제한:\*\* 15  

&nbsp; - 16은 도달 불가능을 의미 (루프 방지용)

\- \*\*경로 선택 기준:\*\* \*\*가장 적은 홉 수를 가지는 경로 선택\*\*



\### 🔹 문제 조건 해석



\- 실제 비용이 숫자로 주어졌지만, \*\*RIP는 실제 연결 비용이 아닌 홉 수만 고려\*\*하므로,  

&nbsp; \*\*A에서 F까지 거치는 라우터 수가 최소가 되는 경로\*\*를 찾는 것이 목적임.



\### 🔹 가능한 경로 (예시):



1\. A → B → E → F (3 hops)

2\. A → D → C → F (\*\*3 hops, 정답 경로\*\*)

3\. A → D → F (2 hops) ← 단, \*\*직접 연결이 없으면 불가\*\*

4\. A → C → F (2 hops) ← 마찬가지로 연결 유무 확인 필요



※ 문제 조건상, \*\*ADCF 경로가 연결된 최단 홉 수 경로\*\*로 제시되었으므로  

\*\*ADCF\*\*가 \*\*RIP 기준의 최적 경로\*\*가 됨.



---



\## 📌 관련 개념 정리



\### 🔹 라우팅 프로토콜 분류



| 분류     | 유형         | 프로토콜 | 특징 |

|----------|--------------|----------|------|

| \*\*정적\*\* | Static Routing | 수동 설정 | 단순하지만 확장성 낮음 |

| \*\*동적\*\* | 내부 IGP     | \*\*RIP\*\* (거리 벡터)<br>\*\*OSPF\*\* (링크 상태) | RIP: 홉 수 기준<br>OSPF: 링크 비용 기준 |

|          | 외부 EGP     | \*\*BGP\*\* | 자율 시스템(AS) 간 경로 설정 |



\### 🔹 RIP 요약



\- \*\*프로토콜:\*\* RIP (Routing Information Protocol)

\- \*\*동작 방식:\*\* 거리 벡터 기반, 주기적으로 이웃에게 라우팅 정보 전파

\- \*\*Metric:\*\* 홉 수

\- \*\*장점:\*\* 구성 간단

\- \*\*단점:\*\* 느린 수렴 속도, 루프 발생 가능성, 15홉 제한



---



\## 📌 참고



\- RIP은 간단하지만 대규모 네트워크에는 부적합

\- OSPF는 RIP보다 정밀하고 효율적이지만 복잡함

\- BGP는 인터넷 전체에서 사용하는 외부 라우팅 프로토콜



---------------------------------------------------------------------------

\## ✅ 문제 10



\*\*문제:\*\*  

다음 테이블의 \*\*카디널리티(행 개수)\*\*와 \*\*차수(열 개수)\*\*를 구하시오.



| 학번    | 이름 | 학년 | 학과         |

|--------|------|------|--------------|

| 181101 | KKK  | 1    | 컴퓨터공학과 |

| 171201 | hhh  | 2    | 전자공학과   |

| 171302 | xxx  | 3    | 컴퓨터공학과 |

| 161107 | yyy  | 3    | 건축공학과   |

| 151403 | qqq  | 4    | 전자공학과   |



\*\*답:\*\*  

\- \*\*카디널리티 (행 수):\*\* 5  

\- \*\*차수 (열 수):\*\* 4



---



\## 📌 해설



| 용어       | 정의                                     | 예시 (위 테이블 기준)   |

|------------|------------------------------------------|--------------------------|

| \*\*카디널리티 (Cardinality)\*\* | \*\*튜플(Tuple)\*\* 또는 \*\*행(Row)\*\*의 수               | 5행 → \*\*카디널리티: 5\*\* |

| \*\*차수 (Degree)\*\*           | \*\*속성(Attribute)\*\* 또는 \*\*열(Column)\*\*의 수         | 4열 → \*\*차수: 4\*\*       |





\### 🔹 릴레이션(Relation)의 구성 요소



| 용어             | 설명 |

|------------------|------|

| \*\*속성(Attribute)\*\* | 열(Column) 구성요소, 즉 테이블의 컬럼명들 |

| \*\*튜플(Tuple)\*\*     | 행(Row) 구성요소, 하나의 레코드 |

| \*\*카디널리티\*\*       | 튜플의 수 = 행(Row) 수 |

| \*\*차수\*\*           | 속성의 수 = 열(Column) 수 |



\### 🔹 데이터베이스 테이블의 예시 용어 매핑



\- \*\*속성(Attribute)\*\* → `학번`, `이름`, `학년`, `학과` 등

\- \*\*튜플(Tuple)\*\* → 각 학생의 데이터 한 줄



\## 📌 요약



\- \*\*카디널리티(Cardinality)\*\* = 행(Row) 수 = \*\*5\*\*

\- \*\*차수(Degree)\*\* = 열(Column) 수 = \*\*4\*\*



---------------------------------------------------------------------------

\## ✅ 문제 11



\*\*문제:\*\*  

다음은 SQL을 이용한 데이터베이스 관리 작업에 관한 문제이다.  

빈칸에 들어갈 적절한 SQL 키워드를 쓰시오.



```sql

insert into 직원(직원번호, 성명, 나이, 연봉, 팀번호)

(1) (101, 'kim', 25, 3000, 2);

insert into 직원

(2) 직원번호, 성명, 나이, 연봉, 팀번호 from 신규직원 where 팀번호 = 2;

delete (3) 직원 where 직원번호 = 101;

update 직원 (4) 연봉 = 3500 where 성명 = 'lee';



답

(1) values
(2) select
(3) from
(4) set




\## 📌 해설



\- \*\*INSERT 문\*\*  

&nbsp; - `values` : 구체적인 값을 명시할 때 사용  

&nbsp; - `select` : 다른 테이블에서 값을 선택하여 삽입할 때 사용



\- \*\*DELETE 문\*\*  

&nbsp; - `from` : 삭제할 테이블을 지정할 때 사용



\- \*\*UPDATE 문\*\*  

&nbsp; - `set` : 수정할 컬럼과 값을 지정할 때 사용



\## 📌 관련 개념


| SQL 명령어 | 설명                                            | 예시                                                      |

|------------|-------------------------------------------------|-----------------------------------------------------------|

| \*\*INSERT INTO ... VALUES\*\* | 특정 값을 테이블에 삽입                            | `insert into 직원 values (101, 'kim', 25, 3000, 2);`       |

| \*\*INSERT INTO ... SELECT\*\* | 다른 테이블에서 데이터를 선택해 삽입               | `insert into 직원 select 직원번호, 성명, 나이, 연봉, 팀번호 from 신규직원 where 팀번호 = 2;` |

| \*\*DELETE FROM\*\*             | 테이블에서 조건에 맞는 행 삭제                       | `delete from 직원 where 직원번호 = 101;`                   |

| \*\*UPDATE ... SET ... WHERE\*\* | 테이블의 데이터를 수정                                | `update 직원 set 연봉 = 3500 where 성명 = 'lee';`          |






\## 📌 주의사항

\- DELETE 구문에서 `from` 키워드는 필수임.

\- UPDATE 구문에서 수정할 컬럼과 값을 지정하려면 반드시 `set` 사용.

\- INSERT 구문에서 `values` 또는 `select` 중 상황에 맞는 키워드를 사용해야 함.



---------------------------------------------------------------------------

# 🚀 문제 12) JAVA 코드의 출력 결과를 쓰시오


## 📌 문제 코드 (원본)

```java
public class Main {

    public static void check(int[] x, int[] y) {
        if (x == y)
            System.out.print("O");
        else
            System.out.print("X");
    }

    public static void main(String[] args) {
        int a[] = new int[] { 1, 2, 3, 4 };
        int b[] = new int[] { 1, 2, 3, 4 };
        int c[] = new int[] { 1, 2, 3, 4 };

        check(a, b);
        check(b, c);
        check(a, c);
    }
}


✅ 출력 결과
XXX
🔍 해설
== 연산자는 값(value) 비교가 아니라, 참조(reference, 주소) 비교를 합니다.

int[] a = new int[]{1,2,3,4}; 와 같이 new를 사용하면, 항상 새로운 배열 객체가 생성되어 각각 다른 주소를 갖습니다.

즉,

a == b → ❌

b == c → ❌

a == c → ❌

→ 따라서 모두 false 가 되어, check()는 세 번 모두 "X" 를 출력합니다.


답: XXX

---------------------------------------------------------------------------

## 🚀 문제 13) Python 문자열 부분 문자열 개수 세기 풀이

아래 Python 코드를 실행했을 때 출력 결과를 구하시오.

```python
def fnc(str, p):
    cnt = 0
    for i in range(len(str)):
        tmp = str[i:i+len(p)]
        if tmp == p:
            cnt += 1
    return cnt

str = "abccabcabcca"
p1 = "ab"
p2 = "ca"

print(f'ab{fnc(str,p1)}ca{fnc(str,p2)}')
```

---

## ✅ 함수 설명

- `fnc(str, p)` 함수는 문자열 `str` 안에 부분 문자열 `p`가 **몇 번 등장하는지** 세는 함수
- i를 기준으로 `len(p)`만큼 슬라이싱해서 `p`와 일치하면 카운트

---

## 🔎 실행 흐름

### ① fnc("abccabcabcca", "ab") 호출

문자열: `abccabcabcca`  
패턴: `"ab"`

i별 슬라이싱 결과:

| i | tmp      | 일치 여부 |
|---|----------|-----------|
| 0 | "ab"     | ✅        |
| 1 | "bc"     | ✗        |
| 2 | "cc"     | ✗        |
| 3 | "ca"     | ✗        |
| 4 | "ab"     | ✅        |
| 5 | "bc"     | ✗        |
| 6 | "ca"     | ✗        |
| 7 | "ab"     | ✅        |
| 8 | "bc"     | ✗        |
| 9 | "cc"     | ✗        |
| 10| "ca"     | ✗        |

→ **총 3번 등장**

---

### ② fnc("abccabcabcca", "ca") 호출

문자열: `abccabcabcca`  
패턴: `"ca"`

i별 슬라이싱 결과:

| i | tmp      | 일치 여부 |
|---|----------|-----------|
| 0 | "ab"     | ✗        |
| 1 | "bc"     | ✗        |
| 2 | "cc"     | ✗        |
| 3 | "ca"     | ✅        |
| 4 | "ab"     | ✗        |
| 5 | "bc"     | ✗        |
| 6 | "ca"     | ✅        |
| 7 | "ab"     | ✗        |
| 8 | "bc"     | ✗        |
| 9 | "cc"     | ✗        |
| 10| "ca"     | ✅        |

→ **총 3번 등장**

---

## ✅ 최종 출력

```python
print(f'ab{fnc(str,p1)}ca{fnc(str,p2)}')
```

→ `ab3ca3`

---

## 🎯 최종 결과

> **정답:** `ab3ca3`


---------------------------------------------------------------------------

🚀 문제 14)  C언어 코드 출력 결과 풀이


#include <stdio.h>

int main() {
    int a = 11;
    int b = 19;

    switch (a) {
        case 1:
            b += 1;
        case 11:
            b += 2;
        default:
            b += 3;
            break;
    }

    printf("%d", a - b);
    return 0;
}

✅ 핵심 포인트
a = 11이므로 switch(a)에서 case 11:부터 실행됨

break;가 없으면 아래로 계속 실행됨 (fall-through 현상)


🔢 실행 순서
case 11: → b += 2; → b = 19 + 2 = 21

default: → b += 3; → b = 21 + 3 = 24

break; → switch 종료


✅ 출력 부분
printf("%d", a - b);
a = 11, b = 24
→ 11 - 24 = -13

✅ 최종 출력 결과

답: -13


---------------------------------------------------------

🚀 문제 15)  C언어 코드 출력 결과 풀이

#include <stdio.h>

void func(char *d, char *s){
   while (*s) {
     *d = *s;
     d++;
     s++;
   }
   *d = '\0';
}

int main() {
   char str1[] = "eraon";
   char str2[50] = "c language";
   int sum = 0;

   func(str2, str1);

   for (int i = 0; str2[i] != '\0'; i++) {
      sum += i;
   }

   printf("%d", sum);
   return 0;


✅ 주요 동작 정리
char str1[] = "eraon";
char str2[50] = "c language";
func(str2, str1); 호출되면 str1의 내용을 str2에 복사함.

즉, str2는 "eraon"으로 변경됨.

str2 = "eraon"

🔢 for 루프에서 sum 계산
str2[i] != '\0' 조건에서, i는 0부터 4까지 반복됨 ('e', 'r', 'a', 'o', 'n')

i 값의 합: 0 + 1 + 2 + 3 + 4 = 10


✅ 최종 출력 결과
답: 10

------------------------------------------------------------

문제 16) 다음 c언어 코드의 출력 결과를 쓰시오


#include <stdio.h>

int main() {
    int arr[3][3] = {1,2,3,4,5,6,7,8,9};
    int *darr[2] = {arr[1], arr[2]};

    printf("%d", darr[1][1] + *(darr[1]+2) + **darr);
    return 0;
}

🔢 배열 값 구성
arr[3][3] = {
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};

🧩 darr 포인터 배열
int *darr[2] = {arr[1], arr[2]};
darr[0] = arr[1] = {4, 5, 6}

darr[1] = arr[2] = {7, 8, 9}


🔎 계산
darr[1][1]      → darr[1] = arr[2] → arr[2][1] = 8  
*(darr[1] + 2)  → darr[1] = arr[2] → *(arr[2] + 2) = arr[2][2] = 9  
**darr          → darr[0] = arr[1] → *arr[1] = arr[1][0] = 4

✅ 최종 계산
8 + 9 + 4 = 21

🧠 최종 출력 결과
답: 21

------------------------------------------------------------

### 📘 문제 17) Java 코드 실행 결과를 쓰시오

```java
interface Num {
    int sum(int[] a, boolean odd);
}

class ODDNum implements Num {
    public int sum(int[] a, boolean odd) {
        int result = 0;
        for (int i = 0; i < a.length; i++) {
            if ((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))
                result += a[i];
        }
        return result;
    }
}

class Main {
    public static void main(String[] args) {
        int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        ODDNum obj = new ODDNum();
        System.out.print(obj.sum(a, true) + "," + obj.sum(a, false));
    }
}

🔍 실행 과정 분석
🔸 배열 a
int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};

🔸 obj.sum(a, true)
odd == true: 홀수만 더함

홀수: 1, 3, 5, 7, 9

합계: 1 + 3 + 5 + 7 + 9 = 25

🔸 obj.sum(a, false)
odd == false: 짝수만 더함

짝수: 2, 4, 6, 8

합계: 2 + 4 + 6 + 8 = 20


✅ 출력 결과
답: 25,20

------------------------------------------------------------
문제 18) java에 대해 출력값을 쓰시오

# ✅ Java 재귀 문제 정리 (중복 없는 문자 역순 출력)

```java
public static void main(String [] args){
    String str = "abacabcd";
    boolean[] ary = new boolean[256];
    System.out.print(fn(str, str.length()-1, ary));
}

public static String fn(String str, int index, boolean[] ary){
    if (index < 0) return "";
    char c = str.charAt(index);
    String result = fn(str, index - 1, ary);
    if (!ary[c]) {
        ary[c] = true;
        return c + result;
    }
    return result;
}

🔍 핵심 로직 설명
항목	설명
🔄 탐색 방향	index = str.length() - 1 → 0 (즉, 뒤에서 앞으로)
🔤 문자 조건	ary[c] == false → 아직 등장하지 않은 문자만 처리
📌 반환 방식	return c + result; → 새 문자를 앞에 붙임
🔁 누적 구조	뒤에서 처음 등장한 문자부터 앞쪽에 계속 누적됨

🧪 예제 분석: "abacabcd"
🔸 인덱스별 처리 흐름
인덱스	문자	이미 나왔나?	추가 여부	결과 누적
7	d	❌ 아니요	✅ 추가	d
6	c	❌ 아니요	✅ 추가	c + d → cd
5	b	❌ 아니요	✅ 추가	b + cd → bcd
4	a	❌ 아니요	✅ 추가	a + bcd → abcd
3	c	✅ 예	❌ 무시	abcd 유지
2	a	✅ 예	❌ 무시	abcd 유지
1	b	✅ 예	❌ 무시	abcd 유지
0	a	✅ 예	❌ 무시	abcd 유지

🔚 결과
return c + result이기 때문에 문자열이 역순으로 쌓임

따라서 출력은: dcba

✅ 정답
답: dcba
------------------------------------------------------------

# ✅ 문제 19) C언어 구조체 포인터 코드 출력 결과

---

## 📌 문제 코드

```c
#include <stdio.h>

struct node {
    int n1;
    struct node *n2;
};

int main() {
    struct node *head = NULL;
    struct node a = {10, 0};
    struct node b = {20, 0};
    struct node c = {30, 0};

    head = &a;
    a.n2 = &b;
    b.n2 = &c;

    printf("%d", head->n2->n1);
}


🔍 구조도 분석

head ─▶ a (n1=10) ─▶ b (n1=20) ─▶ c (n1=30)
head는 a를 가리킴 (head = &a)

a.n2 = &b → a는 b를 가리킴

b.n2 = &c → b는 c를 가리킴


🔧 실행 흐름 분석
printf("%d", head->n2->n1);
head → a

head->n2 → a.n2 → &b

head->n2->n1 → b.n1 → 20

✅ 출력 결과
답: 20
------------------------------------------------------------

문제 20) JAVA 코드 변환 

# ✅ 문제: Java 코드의 출력 결과 분석

---

## 📌 문제 코드

```java
public class ExampleClass {
    public static void main(String[] args) {
        String input = "HELLOEXAMPLESENTENCE";
        String[] output = input.split("E");
        System.out.print(output[3]);
    }
}

🔍 코드 설명
String input = "HELLOEXAMPLESENTENCE";

문자열 HELLOEXAMPLESENTENCE를 선언

input.split("E")

대문자 "E"를 기준으로 문자열을 나눔

결과 배열은 "E"를 기준으로 분리되고 "E"는 제외됨

📐 문자열 분해 과정
원래 문자열: HELLOEXAMPLESENTENCE

"E" 기준 분할 결과:
1. "H"            (HELLO → H + 'E' + LLO)
2. "LLO"          (HELLO → H + E + "LLO")
3. "XAMPL"        (EXAMPLE → split 후 'E' 제외)
4. "S"            (SENTENCE 중 "E" 앞까지)
5. "NT"           (두 번째 "E" 뒤부터 다음 "E"까지)
6. "NC"           (다음 "E"까지)
7. ""             (마지막 "E" 뒤에 아무 것도 없음)
→ output = ["H", "LLO", "XAMPL", "S", "NT", "NC", ""]

🧮 출력 결과
System.out.print(output[3]);  // "S"

✅ 최종 출력
답: S







