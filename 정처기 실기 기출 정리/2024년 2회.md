\# 📘 2020년 1회 정보처리기사 실기 기출 정리



---



\## ✅ 문제 1



\*\*문제:\*\*  

시스템의 성능 향상, 개발 과정의 편의성 등을 위해 정규화된 데이터 모델을 분할, 통합, 추가하는 과정으로 의도적으로 정규화에 위배되는 행위이다. 무엇을 설명하는 것인지 쓰시오.



\*\*답:\*\*  

반정규화 (=역정규화, 비정규화)



---



\## 📌 관련 개념 설명



\### 🔹 반정규화(역정규화, 비정규화)

\- \*\*정의:\*\* 정규화를 통해 생성된 여러 개의 테이블을 조인으로 연결할 때 성능 저하가 발생하거나 시스템 구현이 복잡해질 경우, 이를 해결하기 위해 \*\*의도적으로 정규화된 구조를 깨고\*\* 테이블을 \*\*통합하거나 중복된 속성을 추가하는 행위\*\*.

\- \*\*목적:\*\* 시스템 성능 향상, 구현의 단순화, 응답시간 단축



\### 🔹 반정규화의 주요 방법

\- 테이블 \*\*병합\*\* 또는 \*\*분할\*\*

\- 중복 속성 \*\*추가\*\*

\- \*\*파생 속성\*\* 추가

\- \*\*중복 테이블\*\* 생성 등



---



\## 📌 관련 용어 정리



| 용어          | 설명 |

|---------------|------|

| \*\*공유데이터\*\* | 여러 응용 시스템에서 공유하여 사용하는 데이터 |

| \*\*저장데이터\*\* | 실제 DB에 저장되는 데이터 |

| \*\*통합데이터\*\* | 데이터의 \*\*중복을 최소화\*\*하고 일관성을 유지하기 위해 통합된 구조의 데이터 |

| \*\*운영데이터\*\* | 업무 처리를 위해 사용되는 데이터, 실시간으로 접근이 필요한 데이터 |



---



\## 📌 이상현상 (Anomalies)

정규화되지 않은 테이블에서 발생하는 데이터 이상



| 종류       | 설명 |

|------------|------|

| \*\*삽입 이상\*\* | 불필요한 데이터를 함께 입력해야 삽입 가능한 현상 |

| \*\*삭제 이상\*\* | 하나의 데이터 삭제 시 \*\*연쇄적으로 관련 없는 데이터도 삭제\*\*되는 현상 |

| \*\*갱신 이상\*\* | 한 데이터를 갱신할 때 \*\*중복된 모든 데이터\*\*를 갱신해야 하는 현상 |



---



\## 📌 함수 종속성(FD: Functional Dependency)



| 개념               | 설명 |

|--------------------|------|

| \*\*완전 함수 종속\*\* | 기본키의 \*\*전체에 종속\*\*되는 경우 |

| \*\*부분 함수 종속\*\* | 기본키의 \*\*일부에만 종속\*\*되는 경우 (→ 제2정규형 위반) |

| \*\*이행적 함수 종속\*\* | A → B, B → C 이면 A → C 와 같은 간접 종속 (→ 제3정규형 위반) |



---------------------------------------------------------------------------



\## ✅ 문제 2



\*\*문제:\*\*  

빈칸에 들어갈 네트워크 보안 프로토콜을 쓰시오



VPN을 통해 안전한 통신을 구현하기 위해 사용되는 이 프로토콜은  

네트워크 계층에서 동작하며, 데이터의 기밀성, 무결성, 그리고 인증을 제공한다.  

이 프로토콜은 AH(Authentication Header)와 ESP(Encapsulating Security Payload) 두 가지 하위 프로토콜을 포함하며,  

각각 데이터의 무결성과 인증, 그리고 데이터의 기밀성을 제공한다.  

또한 이 프로토콜은 터널 모드와 전송 모드를 지원하며,  

주로 IKE(Internet Key Exchange) 프로토콜과 함께 보안 연결을 설정한다.  

이 프로토콜의 이름은 \*\*(           )\*\* 이다.



\*\*답:\*\*  

IPsec (IP Security)



---



\## 📌 관련 개념 설명



\### 🔐 IPsec (Internet Protocol Security)

\- \*\*설명:\*\*  

&nbsp; IP 계층에서 동작하는 네트워크 보안 프로토콜로,  

&nbsp; \*\*VPN 환경에서 안전한 통신\*\*을 위해 사용됨.

\- \*\*기능:\*\*  

&nbsp; - 데이터의 \*\*기밀성(confidentiality)\*\*  

&nbsp; - \*\*무결성(integrity)\*\*  

&nbsp; - \*\*인증(authentication)\*\* 제공

\- \*\*구성 요소:\*\*

&nbsp; - \*\*AH (Authentication Header)\*\*  

&nbsp;   → 데이터의 무결성과 송신자 인증 제공 (기밀성은 제공하지 않음)

&nbsp; - \*\*ESP (Encapsulating Security Payload)\*\*  

&nbsp;   → 데이터의 무결성, 인증, 기밀성 모두 제공

\- \*\*동작 모드:\*\*

&nbsp; - \*\*터널 모드\*\*: 전체 IP 패킷을 암호화하여 보안 터널 생성

&nbsp; - \*\*전송 모드\*\*: IP 패킷의 페이로드만 암호화



---



\## 📌 기타 보안 프로토콜 요약



| 프로토콜 | 설명 |

|----------|------|

| \*\*SSL/TLS\*\* | 웹 브라우저와 서버 간 암호화된 연결 제공 (HTTPS 통신에 사용됨) |

| \*\*SSH\*\* | 원격 컴퓨터에 안전하게 접속하여 명령 실행 |

| \*\*PGP\*\* | 이메일 데이터 암호화 및 디지털 서명 |

| \*\*Kerberos\*\* | 클라이언트와 서버 간의 \*\*상호 인증\*\*을 위한 네트워크 인증 프로토콜 |

| \*\*S/MIME\*\* | 이메일 메시지의 \*\*암호화\*\* 및 \*\*디지털 서명\*\*을 위한 표준 |



---------------------------------------------------------------------------



\## ✅ 문제 3



\*\*문제:\*\*  

다음 설명에 해당하는 응집도 유형을 보기에서 골라 쓰시오



모듈 내부의 각 기능들이 서로 연관성을 가지고 \*\*순차적으로 수행되는 응집도 유형\*\*을 말한다.  

하나의 작업이 끝나면 그 결과가 다음 작업의 입력으로 사용되며,  

이러한 과정이 연속적으로 이어지는 형태이다.  

이 응집도는 \*\*기능적 응집도보다는 낮지만 절차적 응집도보다는 높은\*\* 수준의 응집도를 가진다.



\*\*답:\*\*  

순차적 응집도



---



\## 📌 관련 개념 설명: 응집도(Cohesion)



응집도란 \*\*모듈 내부 구성요소 간의 기능적 관련성의 정도\*\*를 의미하며,  

응집도가 높을수록 모듈의 독립성이 높고 재사용성이 증가함.



\### 🔼 응집도 수준 (높은 응집도 → 낮은 응집도 순)



| 응집도 유형         | 설명 |

|----------------------|------|

| \*\*기능적 응집도\*\*     | 모듈이 하나의 명확한 기능만 수행 (가장 높은 응집도) |

| \*\*순차적 응집도\*\*     | \*\*앞 단계 결과가 다음 단계의 입력\*\*으로 사용됨. 작업이 순차적으로 수행됨 |

| \*\*통신적 응집도\*\*     | 동일한 입력이나 출력 데이터를 사용하는 기능들로 구성 |

| \*\*절차적 응집도\*\*     | 특정 절차에 따라 수행되지만, 데이터 연관성은 없음 |

| \*\*시간적 응집도\*\*     | 특정 시간에 함께 실행되는 기능들로 구성 (예: 초기화 작업) |

| \*\*논리적 응집도\*\*     | 비슷한 성격의 여러 기능을 하나의 모듈에 포함. 제어문으로 기능 선택 |

| \*\*우연적 응집도\*\*     | 아무런 관련 없이 기능들이 모듈에 나열됨 (가장 낮은 응집도) |



---



\## 📌 비교 포인트



| 응집도 유형     | 주요 특징 |

|----------------|-----------|

| \*\*기능적\*\*     | 단일 목적, 하나의 기능만 수행 |

| \*\*순차적\*\*     | A → B → C 순서로 \*\*출력이 다음 입력\*\*이 됨 |

| \*\*통신적\*\*     | 같은 입력/출력을 공유 |

| \*\*절차적\*\*     | 순서는 있지만 출력입력 연관은 없음 |

| \*\*시간적\*\*     | 특정 시점 동시 수행 |

| \*\*논리적\*\*     | 유사한 작업을 묶되, 내부 선택 구조 포함 |

| \*\*우연적\*\*     | 관련 없는 기능 나열 |



---------------------------------------------------------------------------

\## ✅ 문제 4



\*\*문제:\*\*  

다음 설명을 듣고 빈칸에 들어갈 네트워크 전송 방식 두 가지를 각각 쓰시오



(1)은 \*\*연결 지향적\*\*으로, 데이터 전송 전에 먼저 \*\*경로를 설정한 후\*\* 모든 패킷이 동일한 경로를 통해 순차적으로 전달된다.  

이 방식은 \*\*연결이 설정된 후에야 데이터가 전송\*\*되며, 패킷이 \*\*순서대로 도착하는 것이 보장\*\*된다.  

(2)는 \*\*비연결 지향적\*\*으로, 경로를 미리 설정하지 않고 각 패킷이 \*\*독립적으로 전송\*\*되며, 패킷이 서로 다른 경로를 통해 전달될 수 있다.  

패킷이 목적지에 도착하는 \*\*순서가 보장되지 않으며\*\*, 각 패킷이 \*\*개별적으로 처리\*\*되는 방식이다.



\*\*답:\*\*  

(1) 가상회선 방식  

(2) 데이터그램 방식



---



\## 📌 관련 개념 설명



\### 🔹 데이터 교환 방식 개요



데이터 전송을 위한 교환 방식은 \*\*회선 교환\*\*과 \*\*축적 후 교환\*\*(Store and Forward)으로 나뉘며,  

축적 후 교환은 다시 \*\*메시지 교환\*\*과 \*\*패킷 교환\*\*으로 구분됨.





---



\### 🔸 (1) 가상회선 방식 (Virtual Circuit)



\- \*\*연결 지향형 방식\*\*

\- \*\*데이터 전송 전에 경로 설정 필수\*\*

\- \*\*모든 패킷이 동일한 경로\*\*를 따라 전송됨

\- 패킷이 \*\*순서대로 도착\*\*함

\- 예: ATM, X.25



\### 🔸 (2) 데이터그램 방식 (Datagram)



\- \*\*비연결형 방식\*\*

\- \*\*패킷마다 경로를 독립적으로 선택\*\*하여 전송

\- 패킷이 \*\*서로 다른 경로\*\*를 통해 목적지에 도달할 수 있음

\- \*\*도착 순서 보장되지 않음\*\*

\- 예: IP 프로토콜



---



\## 📌 보충 설명: 회선 교환 vs. 패킷 교환



| 구분 | 회선 교환 | 패킷 교환 |

|------|-----------|------------|

| 연결 설정 | 필요함 | 필요 없음 (데이터그램) / 있음 (가상회선) |

| 전송 경로 | 고정 | 유동적 |

| 순서 보장 | 항상 보장 | 방식에 따라 다름 |

| 전송 단위 | 비트 스트림 | 패킷 |



---------------------------------------------------------------------------



\## ✅ 문제 5



\*\*문제:\*\*  

객체의 내부 구조를 감추면서도 일관된 방식으로 그 내부에 포함된 요소들을 \*\*순차적으로 접근\*\*할 수 있게 하며,  

동시에 여러 종류의 컬렉션 (예: 배열, 리스트, 트리)에서도 \*\*동일한 접근 방식\*\*을 제공하여  

컬렉션의 구현과 상관없이 순회가 가능하도록 하는 디자인패턴은 무엇인지 보기에서 골라 쓰시오.



\*\*답:\*\*  

Iterator (이터레이터)



---



\## 📌 관련 개념 설명



\### 🔸 Iterator 패턴



\- \*\*정의:\*\*  

&nbsp; 컬렉션(배열, 리스트, 트리 등)의 내부 구조를 \*\*노출하지 않고\*\*  

&nbsp; 그 내부 요소를 \*\*순차적으로 접근\*\*할 수 있도록 하는 디자인 패턴



\- \*\*목적:\*\*  

&nbsp; 다양한 자료구조에서 \*\*동일한 방식으로 접근(순회)\*\* 가능하게 함



\- \*\*주요 특징:\*\*

&nbsp; - \*\*컬렉션과 분리된 순회 기능\*\* 제공

&nbsp; - 내부 구조의 변경 없이 접근 가능

&nbsp; - \*\*단일 인터페이스\*\*로 여러 자료구조 대응 가능



\- \*\*주요 메서드 (Java 기준):\*\*

&nbsp; - `hasNext()` : 다음 요소가 있는지 확인

&nbsp; - `next()` : 다음 요소 반환



---



\## 📌 객체지향 구성 요소



| 구성 요소        | 설명 |

|------------------|------|

| \*\*클래스 (class)\*\* | 데이터를 추상화한 설계도 |

| \*\*객체 (object)\*\* | 클래스의 인스턴스 |

| \*\*속성 (attribute)\*\* | 객체가 가진 데이터 |

| \*\*메서드 (method)\*\* | 객체가 수행하는 동작 |

| \*\*메시지 (message)\*\* | 객체에게 행위를 요청하는 것 (메서드 호출 등) |



---



\## 📌 객체지향의 주요 특징



\- \*\*캡슐화(Encapsulation):\*\*  

&nbsp; 데이터를 외부에서 직접 접근하지 못하게 숨기고, 메서드를 통해서만 접근하도록 함



\- \*\*정보은닉(Information Hiding):\*\*  

&nbsp; 외부에 불필요한 내부 세부사항을 숨김



\- \*\*상속(Inheritance):\*\*  

&nbsp; 부모 클래스의 속성과 기능을 자식 클래스가 물려받음



\- \*\*다형성(Polymorphism):\*\*  

&nbsp; 하나의 메시지(메서드 호출)에 대해 \*\*여러 형태로 응답\*\*할 수 있음



\- \*\*추상화(Abstraction):\*\*  

&nbsp; 복잡한 내용을 감추고 필요한 기능만 노출



---



\## 📌 객체지향 설계 원칙 (SOLID)



| 원칙                         | 설명 |

|------------------------------|------|

| \*\*SRP (단일 책임 원칙)\*\*         | 하나의 클래스는 하나의 책임만 가져야 함 |

| \*\*OCP (개방-폐쇄 원칙)\*\*         | 확장에는 열려 있고, 수정에는 닫혀 있어야 함 |

| \*\*LSP (리스코프 치환 원칙)\*\*     | 자식 클래스는 부모 클래스를 대체할 수 있어야 함 |

| \*\*ISP (인터페이스 분리 원칙)\*\*   | 하나의 일반 인터페이스보다 여러 개의 구체적 인터페이스가 낫다 |

| \*\*DIP (의존성 역전 원칙)\*\*       | 구체적인 것보다 추상적인 것에 의존해야 함 |



---------------------------------------------------------------------------

\## ✅ 문제 6



\*\*문제:\*\*  

다음 설명에 해당하는 암호화 알고리즘의 이름을 쓰시오



이 알고리즘은 미국 국립 표준기술연구소가 기존의 DES를 대체하기 위해 선정한 \*\*대칭 키 블록 암호화 알고리즘\*\*이다.  

128비트의 \*\*고정 블록 크기\*\*를 사용하며, 키 길이는 \*\*128, 192, 256 비트\*\*를 지원한다.  

\*\*보안성과 성능이 우수\*\*하며, 전 세계적으로 다양한 분야에서 널리 사용되고 있으며,  

\*\*무선 통신\*\*, \*\*금융 거래\*\*, \*\*저장 데이터의 암호화\*\* 등에서 \*\*표준\*\*으로 채택되고 있다.



\*\*답:\*\*  

AES (Advanced Encryption Standard)



---



\## 📌 관련 개념 설명



\### 🔐 AES (Advanced Encryption Standard)



\- \*\*암호 방식:\*\* 블록 암호 방식 (대칭 키)

\- \*\*개발 배경:\*\* DES의 취약점을 보완하고, 고속/고보안성을 위해 미국 NIST에서 표준으로 채택 (2001년)

\- \*\*키 길이:\*\* 128, 192, 256 비트 지원

\- \*\*블록 크기:\*\* 128비트 고정

\- \*\*라운드 수:\*\* 

&nbsp; - 128비트 키 → 10 라운드  

&nbsp; - 192비트 키 → 12 라운드  

&nbsp; - 256비트 키 → 14 라운드

\- \*\*구조:\*\* SPN(Substitution Permutation Network) 구조 사용

\- \*\*특징:\*\* 빠른 처리 속도와 강력한 보안성, 하드웨어/소프트웨어 모두 적합



---



\## 📌 주요 블록 암호 알고리즘 비교



| 알고리즘   | 블록 크기 | 키 길이         | 라운드 수   | 구조        | 국가/특징 |

|------------|-----------|------------------|-------------|-------------|------------|

| \*\*DES\*\*    | 64비트    | 56비트           | 16라운드    | Feistel     | 미국, 구표준 |

| \*\*3DES\*\*   | 64비트    | 112/168비트      | 48라운드    | Feistel     | DES 강화 |

| \*\*AES\*\*    | 128비트   | 128/192/256비트  | 10/12/14    | SPN         | 미국, 표준 |

| \*\*SEED\*\*   | 128비트   | 128비트          | 16라운드    | Feistel     | 한국 |

| \*\*ARIA\*\*   | 128비트   | 128/192/256비트  | 12/14/16    | SPN         | 한국 |

| \*\*LEA\*\*    | 128비트   | 128/192/256비트  | 24/28/32    | SPN         | 한국, 경량 |

| \*\*IDEA\*\*   | 64비트    | 128비트          | 8라운드     | Feistel+SPN | 스위스 |

| \*\*Skipjack\*\* | 64비트 | 80비트           | 32라운드    | Feistel 변형 | 미국 NSA |



---



\## 📌 기타 암호 알고리즘 분류 요약



\### ✅ 스트림 암호

| 알고리즘 | 설명 |

|----------|------|

| \*\*LFSR\*\* | 선형 피드백 시프트 레지스터 기반 |

| \*\*RC4\*\*  | 인터넷 보안 프로토콜에 사용 |

| \*\*A5\*\*   | GSM 이동통신에서 사용 |



\### ✅ 공개키 암호 (비대칭키)

| 기반 이론 | 알고리즘 |

|-----------|----------|

| 소인수분해 | RSA, Rabin |

| 이산대수 | Diffie-Hellman, DSA, ElGamal |

| 타원곡선 | ECC (Elliptic Curve Cryptography) |



\### ✅ 단방향 암호 (해시 함수)

| 알고리즘 | 설명 |

|----------|------|

| \*\*MD5\*\* | 빠르지만 취약점 존재 |

| \*\*SHA\*\* | 미국 NIST 개발, 보안성 강화 |

| \*\*HAS-160\*\* | 한국 개발, KCDSA에서 사용 |



---------------------------------------------------------------------------



\## ✅ 문제 7



\*\*문제:\*\*  

다음 설명에 해당하는 결합도 유형을 쓰시오



두 모듈 사이에서 \*\*하나의 모듈이 다른 모듈의 내부 논리 흐름을 제어\*\*해  

\*\*특정 제어 신호를 전달하는 결합도\*\* 유형을 말한다.  

이 결합도는 모듈 간의 독립성을 저하시켜 \*\*유지보수와 확장성에 부정적인 영향\*\*을 미칠 수 있다.  

일반적으로 이 결합도가 존재할 경우, 호출하는 모듈이 호출된 모듈의 \*\*내부 동작 방식까지 알고 있어야\*\* 하므로  

모듈 간에 \*\*강한 의존성\*\*이 발생한다.  

따라서 제어 신호가 변경되면 관련된 \*\*모든 모듈을 수정\*\*해야 하는 상황이 발생할 수 있다.



\*\*답:\*\*  

제어 결합도 (Control Coupling)



---



\## 📌 관련 개념 설명: 결합도(Coupling)



\*\*결합도\*\*란 모듈 간의 \*\*의존성(연결 강도)\*\*을 의미하며,  

결합도가 낮을수록 모듈 간 독립성이 높아지고 유지보수가 쉬워짐.  

이상적인 설계에서는 \*\*낮은 결합도, 높은 응집도\*\*가 바람직함.



\### 🔽 결합도의 종류 (낮은 결합도 → 높은 결합도 순)



| 결합도 유형             | 설명 |

|--------------------------|------|

| \*\*자료 결합도 (Data Coupling)\*\* | \*\*단순한 값\*\*을 인자로 전달 (가장 바람직함) |

| \*\*스탬프 결합도 (Stamp Coupling)\*\* | 배열, 구조체 등 \*\*자료구조 전체\*\*를 인자로 전달 |

| \*\*제어 결합도 (Control Coupling)\*\* | \*\*제어 신호(논리값, 플래그)\*\*를 전달하여 상대 모듈의 실행 흐름 제어 |

| \*\*외부 결합도 (External Coupling)\*\* | 두 모듈이 외부 시스템 자원(환경변수, DB 등)을 함께 사용 |

| \*\*공통 결합도 (Common Coupling)\*\* | \*\*전역 변수\*\*를 여러 모듈이 공유하여 사용 |

| \*\*내용 결합도 (Content Coupling)\*\* | \*\*한 모듈이 다른 모듈의 내부를 직접 접근하거나 수정\*\* (가장 나쁨) |



---



\## 📌 제어 결합도 예시



```java

void processOrder(int orderType) {

&nbsp;   if (orderType == 1) {

&nbsp;       // 배송처리

&nbsp;   } else if (orderType == 2) {

&nbsp;       // 반품처리

&nbsp;   }

}

---------------------------------------------------------------------------

\## ✅ 문제 8



\*\*문제:\*\*  

다음은 프로세스가 준비 상태 큐에 도착한 시간과 프로세스를 처리하는데 필요한 실행시간을 보여준다.  

\*\*선점형 스케줄링 알고리즘인 SRT 알고리즘\*\*을 사용할 경우 프로세스들의 \*\*평균 대기시간을 구하시오\*\*.  

(단, 프로세스 간 문맥교환에 따른 오버헤드는 무시하며, 주어진 4개 프로세스 외에 처리할 다른 프로세스는 없다고 가정한다)



| 프로세스 | 도착시간 | 실행시간 |

|----------|----------|----------|

| P1       |    0     |    8     |

| P2       |    1     |    4     |

| P3       |    2     |    9     |

| P4       |    3     |    5     |



\*\*답:\*\*  

6.5



---



\## 📌 해설: SRT (Shortest Remaining Time) 알고리즘



SRT는 \*\*SJF(Shortest Job First)\*\*의 선점형 방식이다.  

실행 중인 프로세스보다 \*\*남은 시간이 더 짧은 프로세스가 도착\*\*하면, 현재 실행을 \*\*선점하고 교체\*\*한다.



\### 🔹 스케줄링 순서:





\### 🔹 완료 시간 및 대기 시간 계산:



| 프로세스 | 도착시간 | 종료시간 | 실행시간 | 대기시간 |

|----------|----------|----------|----------|----------|

| P1       |    0     |   17     |    8     | 17 - 0 - 8 = \*\*9\*\* |

| P2       |    1     |    5     |    4     | 5 - 1 - 4 = \*\*0\*\* |

| P3       |    2     |   26     |    9     | 26 - 2 - 9 = \*\*15\*\* |

| P4       |    3     |   10     |    5     | 10 - 3 - 5 = \*\*2\*\* |



\*\*총 대기시간 = 9 + 0 + 15 + 2 = 26\*\*  

\*\*평균 대기시간 = 26 ÷ 4 = 6.5\*\*



---



\## 📌 관련 개념 정리



\### 🔹 스케줄링 알고리즘 분류



\#### ✅ 선점형

\- \*\*Round Robin\*\*: 타임퀀텀 기반 시분할

\- \*\*SRT (Shortest Remaining Time)\*\*: 남은 시간이 가장 짧은 프로세스를 우선

\- \*\*MLQ (Multi-Level Queue)\*\*: 우선순위별 여러 큐

\- \*\*MLFQ (Multi-Level Feedback Queue)\*\*: 동적으로 큐 이동



\#### ✅ 비선점형

\- \*\*FCFS\*\*: 도착 순서

\- \*\*SJF\*\*: 짧은 작업 먼저

\- \*\*HRN\*\*: 응답률 높은 것 우선

\- \*\*우선순위 스케줄링\*\*

\- \*\*기한부(Deadline-based)\*\*



---



\## 📌 스케줄링 관련 문제



\- \*\*기아 현상(Starvation)\*\*: SJF, 우선순위, SRT, MLQ에서 낮은 우선순위 작업이 무한정 대기할 수 있음

\- \*\*에이징(Aging)\*\*: 대기 시간이 증가할수록 우선순위를 올려 \*\*기아 현상 방지\*\*

&nbsp; - 적용: HRN, MLFQ 등



---



\## 📌 페이지 교체 알고리즘 요약



| 알고리즘 | 설명 |

|----------|------|

| \*\*FIFO\*\* | 먼저 들어온 페이지를 먼저 교체 |

| \*\*OPT\*\*  | 앞으로 가장 오랫동안 사용되지 않을 페이지 교체 (이론적 최적) |

| \*\*LRU\*\*  | 가장 오래 사용하지 않은 페이지 교체 |

| \*\*LFU\*\*  | 사용 빈도가 가장 낮은 페이지 교체 |

| \*\*NUR\*\*  | 최근 사용 여부 비트 기반 교체 |

| \*\*SCR (Second Chance)\*\* | FIFO + 한 번의 기회 부여 |



---------------------------------------------------------------------------



\## ✅ 문제 9



\*\*문제:\*\*  

다음 네트워크 구성도를 참고하여, \*\*RIP\*\*를 사용해 \*\*라우터 A에서 라우터 F까지 가는 최적 경로\*\*를 구하시오.  

각 라우터 간의 \*\*연결 비용은 각 간선에 명시된 숫자\*\*로 나타내며, \*\*비용은 홉 수(hop count)\*\*로 계산된다.



\*\*답:\*\*  

\*\*A → D → C → F\*\*  

즉, \*\*ADCF\*\*



---



\## 📌 해설



\### 🔹 RIP (Routing Information Protocol)의 특성



\- \*\*라우팅 알고리즘:\*\* 거리 벡터(Distance Vector)

\- \*\*비용(metric):\*\* \*\*홉 수 (hop count)\*\*  

&nbsp; - 한 라우터를 거칠 때마다 비용 1 증가

\- \*\*최대 홉 수 제한:\*\* 15  

&nbsp; - 16은 도달 불가능을 의미 (루프 방지용)

\- \*\*경로 선택 기준:\*\* \*\*가장 적은 홉 수를 가지는 경로 선택\*\*



\### 🔹 문제 조건 해석



\- 실제 비용이 숫자로 주어졌지만, \*\*RIP는 실제 연결 비용이 아닌 홉 수만 고려\*\*하므로,  

&nbsp; \*\*A에서 F까지 거치는 라우터 수가 최소가 되는 경로\*\*를 찾는 것이 목적임.



\### 🔹 가능한 경로 (예시):



1\. A → B → E → F (3 hops)

2\. A → D → C → F (\*\*3 hops, 정답 경로\*\*)

3\. A → D → F (2 hops) ← 단, \*\*직접 연결이 없으면 불가\*\*

4\. A → C → F (2 hops) ← 마찬가지로 연결 유무 확인 필요



※ 문제 조건상, \*\*ADCF 경로가 연결된 최단 홉 수 경로\*\*로 제시되었으므로  

\*\*ADCF\*\*가 \*\*RIP 기준의 최적 경로\*\*가 됨.



---



\## 📌 관련 개념 정리



\### 🔹 라우팅 프로토콜 분류



| 분류     | 유형         | 프로토콜 | 특징 |

|----------|--------------|----------|------|

| \*\*정적\*\* | Static Routing | 수동 설정 | 단순하지만 확장성 낮음 |

| \*\*동적\*\* | 내부 IGP     | \*\*RIP\*\* (거리 벡터)<br>\*\*OSPF\*\* (링크 상태) | RIP: 홉 수 기준<br>OSPF: 링크 비용 기준 |

|          | 외부 EGP     | \*\*BGP\*\* | 자율 시스템(AS) 간 경로 설정 |



\### 🔹 RIP 요약



\- \*\*프로토콜:\*\* RIP (Routing Information Protocol)

\- \*\*동작 방식:\*\* 거리 벡터 기반, 주기적으로 이웃에게 라우팅 정보 전파

\- \*\*Metric:\*\* 홉 수

\- \*\*장점:\*\* 구성 간단

\- \*\*단점:\*\* 느린 수렴 속도, 루프 발생 가능성, 15홉 제한



---



\## 📌 참고



\- RIP은 간단하지만 대규모 네트워크에는 부적합

\- OSPF는 RIP보다 정밀하고 효율적이지만 복잡함

\- BGP는 인터넷 전체에서 사용하는 외부 라우팅 프로토콜



---------------------------------------------------------------------------

\## ✅ 문제 10



\*\*문제:\*\*  

다음 테이블의 \*\*카디널리티(행 개수)\*\*와 \*\*차수(열 개수)\*\*를 구하시오.



| 학번    | 이름 | 학년 | 학과         |

|--------|------|------|--------------|

| 181101 | KKK  | 1    | 컴퓨터공학과 |

| 171201 | hhh  | 2    | 전자공학과   |

| 171302 | xxx  | 3    | 컴퓨터공학과 |

| 161107 | yyy  | 3    | 건축공학과   |

| 151403 | qqq  | 4    | 전자공학과   |



\*\*답:\*\*  

\- \*\*카디널리티 (행 수):\*\* 5  

\- \*\*차수 (열 수):\*\* 4



---



\## 📌 해설



| 용어       | 정의                                     | 예시 (위 테이블 기준)   |

|------------|------------------------------------------|--------------------------|

| \*\*카디널리티 (Cardinality)\*\* | \*\*튜플(Tuple)\*\* 또는 \*\*행(Row)\*\*의 수               | 5행 → \*\*카디널리티: 5\*\* |

| \*\*차수 (Degree)\*\*           | \*\*속성(Attribute)\*\* 또는 \*\*열(Column)\*\*의 수         | 4열 → \*\*차수: 4\*\*       |



---



\## 📌 관련 개념 정리



\### 🔹 릴레이션(Relation)의 구성 요소



| 용어             | 설명 |

|------------------|------|

| \*\*속성(Attribute)\*\* | 열(Column) 구성요소, 즉 테이블의 컬럼명들 |

| \*\*튜플(Tuple)\*\*     | 행(Row) 구성요소, 하나의 레코드 |

| \*\*카디널리티\*\*       | 튜플의 수 = 행(Row) 수 |

| \*\*차수\*\*           | 속성의 수 = 열(Column) 수 |



\### 🔹 데이터베이스 테이블의 예시 용어 매핑



\- \*\*속성(Attribute)\*\* → `학번`, `이름`, `학년`, `학과` 등

\- \*\*튜플(Tuple)\*\* → 각 학생의 데이터 한 줄



---



\## 📌 요약



\- \*\*카디널리티(Cardinality)\*\* = 행(Row) 수 = \*\*5\*\*

\- \*\*차수(Degree)\*\* = 열(Column) 수 = \*\*4\*\*



---------------------------------------------------------------------------

\## ✅ 문제 11



\*\*문제:\*\*  

다음은 SQL을 이용한 데이터베이스 관리 작업에 관한 문제이다.  

빈칸에 들어갈 적절한 SQL 키워드를 쓰시오.



```sql

insert into 직원(직원번호, 성명, 나이, 연봉, 팀번호)

(1) (101, 'kim', 25, 3000, 2);



insert into 직원

(2) 직원번호, 성명, 나이, 연봉, 팀번호 from 신규직원 where 팀번호 = 2;



delete (3) 직원 where 직원번호 = 101;



update 직원 (4) 연봉 = 3500 where 성명 = 'lee';



답

(1) values



(2) select



(3) from



(4) set









\## 📌 해설



\- \*\*INSERT 문\*\*  

&nbsp; - `values` : 구체적인 값을 명시할 때 사용  

&nbsp; - `select` : 다른 테이블에서 값을 선택하여 삽입할 때 사용



\- \*\*DELETE 문\*\*  

&nbsp; - `from` : 삭제할 테이블을 지정할 때 사용



\- \*\*UPDATE 문\*\*  

&nbsp; - `set` : 수정할 컬럼과 값을 지정할 때 사용



---



\## 📌 관련 개념



| SQL 명령어 | 설명                                            | 예시                                                      |

|------------|-------------------------------------------------|-----------------------------------------------------------|

| \*\*INSERT INTO ... VALUES\*\* | 특정 값을 테이블에 삽입                            | `insert into 직원 values (101, 'kim', 25, 3000, 2);`       |

| \*\*INSERT INTO ... SELECT\*\* | 다른 테이블에서 데이터를 선택해 삽입               | `insert into 직원 select 직원번호, 성명, 나이, 연봉, 팀번호 from 신규직원 where 팀번호 = 2;` |

| \*\*DELETE FROM\*\*             | 테이블에서 조건에 맞는 행 삭제                       | `delete from 직원 where 직원번호 = 101;`                   |

| \*\*UPDATE ... SET ... WHERE\*\* | 테이블의 데이터를 수정                                | `update 직원 set 연봉 = 3500 where 성명 = 'lee';`          |



---



\## 📌 주의사항



\- DELETE 구문에서 `from` 키워드는 필수임.

\- UPDATE 구문에서 수정할 컬럼과 값을 지정하려면 반드시 `set` 사용.

\- INSERT 구문에서 `values` 또는 `select` 중 상황에 맞는 키워드를 사용해야 함.



---------------------------------------------------------------------------



🚀 문제 12) JAVA코드의 출력 결과를 쓰시오 



📌 문제 코드 (원본)

public class Main {

&nbsp;   public static void check(int\[] x, int\[] y) {

&nbsp;       if (x == y)

&nbsp;           System.out.print("O");

&nbsp;       else

&nbsp;           System.out.print("X");

&nbsp;   }



&nbsp;   public static void main(String\[] args) {

&nbsp;       int a\[] = new int\[] { 1, 2, 3, 4 };

&nbsp;       int b\[] = new int\[] { 1, 2, 3, 4 };

&nbsp;       int c\[] = new int\[] { 1, 2, 3, 4 };



&nbsp;       check(a, b);

&nbsp;       check(b, c);

&nbsp;       check(a, c);

&nbsp;   }

}



🧠 핵심 개념 파악 (이거 모르면 개털린다!)

자바에서 배열(Array)은 객체다, 이 새끼야! 그리고 new int\[] { ... } 이렇게 배열을 만들면, 메모리에 새로운 공간이 할당되고 그 공간의 \*\*주소값(참조값)\*\*이 변수에 저장된다.



여기서 존나 중요한 건, == 연산자는 배열이나 다른 객체들을 비교할 때 실제 배열 안에 있는 값들을 비교하는 게 아니라, 그냥 그 배열이 저장된 메모리 '주소'가 같은지 다른지만 확인한다는 거다.



그러니까 new int\[]를 세 번 했으면, 각각 다른 메모리 주소에 세 개의 배열이 생성된다는 말이다. 아무리 내용물이 똑같아도 주소가 다르면 ==는 false를 뱉는다!



🔍 코드 실행 과정 족쳐보기

int a\[] = new int\[] {1, 2, 3, 4};



메모리에 {1, 2, 3, 4}를 담는 새로운 공간이 생기고, a는 그 공간의 주소를 가리킨다. (예: 주소\_A)



int b\[] = new int\[] {1, 2, 3, 4};



메모리에 {1, 2, 3, 4}를 담는 또 다른 새로운 공간이 생기고, b는 그 공간의 주소를 가리킨다. (예: 주소\_B)



주소\_A와 주소\_B는 서로 다르다. 내용물은 같지만 주소는 다르다는 걸 명심해라!



int c\[] = new int\[] {1, 2, 3, 4};



메모리에 {1, 2, 3, 4}를 담는 또또 다른 새로운 공간이 생기고, c는 그 공간의 주소를 가리킨다. (예: 주소\_C)



주소\_A, 주소\_B, 주소\_C 모두 서로 다른 주소다.



이제 check 메소드 호출 순서대로 따져보자.



check(a, b);



x는 a의 주소 (주소\_A), y는 b의 주소 (주소\_B)를 받는다.



if (x == y)는 주소\_A == 주소\_B와 같다.



주소\_A와 주소\_B는 다르므로 조건은 false다.



결과: X 출력



check(b, c);



x는 b의 주소 (주소\_B), y는 c의 주소 (주소\_C)를 받는다.



if (x == y)는 주소\_B == 주소\_C와 같다.



주소\_B와 주소\_C는 다르므로 조건은 false다.



결과: X 출력



check(a, c);



x는 a의 주소 (주소\_A), y는 c의 주소 (주소\_C)를 받는다.



if (x == y)는 주소\_A == 주소\_C와 같다.



주소\_A와 주소\_C는 다르므로 조건은 false다.



결과: X 출력



📝 최종 결과 (정답)

위 실행 과정을 보면 알겠지만, 모든 비교가 false를 반환한다.



따라서 프로그램의 최종 출력은 다음과 같다:



답: XXX

---------------------------------------------------------------------------

🚀문제 13) Python 문자열 부분 문자열 개수 세기 풀이

📌 문제 코드 (원본)

def fnc(str,p):

&nbsp;   cnt = 0;

&nbsp;   for i in range(len(str)):

&nbsp;       tmp = str\[i:i+len(p)]

&nbsp;       if tmp == p:

&nbsp;           cnt += 1

&nbsp;   return cnt



str = "abccabcabcca"

p1 = "ab"

p2 = "ca"



print(f'ab{fnc(str,p1)}ca{fnc(str,p2)}')



🧠 핵심 개념 파악 (이거 모르면 개털린다!)

fnc(str, p) 함수:



주어진 문자열 str 안에서 p라는 부분 문자열이 몇 번 나타나는지 세어서 반환하는 함수다.



cnt = 0: 카운트를 저장할 변수를 0으로 초기화한다.



for i in range(len(str)): str 문자열의 길이만큼 반복한다. i는 0부터 str 길이-1까지 변한다.



tmp = str\[i:i+len(p)]: 여기가 존나 중요하다! str에서 i번째 인덱스부터 p의 길이만큼 잘라낸다. 이걸 문자열 슬라이싱이라고 한다.



예를 들어, str이 "abcde"이고 p가 "ab" (길이 2)라면:



i=0: str\[0:0+2] -> str\[0:2] -> "ab"



i=1: str\[1:1+2] -> str\[1:3] -> "bc"



i=2: str\[2:2+2] -> str\[2:4] -> "cd"



이런 식으로 한 글자씩 밀면서 p와 같은 길이의 부분 문자열을 만들어서 비교한다.



만약 i+len(p)가 len(str)을 넘어가도 파이썬은 에러를 내지 않고 그냥 문자열의 끝까지 자른다. (존나 똑똑함)



if tmp == p: 잘라낸 tmp가 p와 똑같으면 (cnt를 1 증가시킨다.



return cnt: 최종 카운트 값을 반환한다.



f-string (Formatted String Literals):



print(f'ab{fnc(str,p1)}ca{fnc(str,p2)}') 이 부분이다.



문자열 앞에 f를 붙이면, 중괄호 {} 안에 파이썬 변수나 함수 호출 등을 직접 넣어서 문자열을 만들 수 있다. 존나 편하다.



여기서는 fnc(str,p1)의 결과와 fnc(str,p2)의 결과를 문자열 안에 박아 넣는다는 말이다.



🔍 코드 실행 과정 족쳐보기

원본 문자열: str = "abccabcabcca"



1\. fnc(str, p1) 계산:

p1 = "ab" (길이 2)



i = 0: str\[0:2] = "ab" -> "ab" == "ab" (True) -> cnt = 1



i = 1: str\[1:3] = "bc" -> "bc" == "ab" (False)



i = 2: str\[2:4] = "cc" -> "cc" == "ab" (False)



i = 3: str\[3:5] = "ca" -> "ca" == "ab" (False)



i = 4: str\[4:6] = "ab" -> "ab" == "ab" (True) -> cnt = 2



i = 5: str\[5:7] = "bc" -> "bc" == "ab" (False)



i = 6: str\[6:8] = "ca" -> "ca" == "ab" (False)



i = 7: str\[7:9] = "ab" -> "ab" == "ab" (True) -> cnt = 3



i = 8: str\[8:10] = "bc" -> "bc" == "ab" (False)



i = 9: str\[9:11] = "cc" -> "cc" == "ab" (False)



i = 10: str\[10:12] = "ca" -> "ca" == "ab" (False)



fnc(str, p1)의 결과는 3이다.



2\. fnc(str, p2) 계산:

p2 = "ca" (길이 2)



i = 0: str\[0:2] = "ab" -> "ab" == "ca" (False)



i = 1: str\[1:3] = "bc" -> "bc" == "ca" (False)



i = 2: str\[2:4] = "cc" -> "cc" == "ca" (False)



i = 3: str\[3:5] = "ca" -> "ca" == "ca" (True) -> cnt = 1



i = 4: str\[4:6] = "ab" -> "ab" == "ca" (False)



i = 5: str\[5:7] = "bc" -> "bc" == "ca" (False)



i = 6: str\[6:8] = "ca" -> "ca" == "ca" (True) -> cnt = 2



i = 7: str\[7:9] = "ab" -> "ab" == "ca" (False)



i = 8: str\[8:10] = "bc" -> "bc" == "ca" (False)



i = 9: str\[9:11] = "cc" -> "cc" == "ca" (False)



i = 10: str\[10:12] = "ca" -> "ca" == "ca" (True) -> cnt = 3



fnc(str, p2)의 결과는 3이다.



3\. 최종 print문 실행:

print(f'ab{fnc(str,p1)}ca{fnc(str,p2)}')

-> print(f'ab{3}ca{3}')

-> print('ab3ca3')





답: ab3ca3

---------------------------------------------------------------------------

🚀 문제 14)  C언어 코드 출력 결과 풀이



📌 문제 코드 (원본)



\#include <stdio.h> // printf 함수를 쓰려면 이거 필수다



int main(){

&nbsp;   int a = 11;

&nbsp;   int b = 19;



&nbsp;   switch(a){

&nbsp;       case 1:

&nbsp;           b+=1;

&nbsp;       case 11:

&nbsp;           b+=2;

&nbsp;       default:

&nbsp;           b+= 3;

&nbsp;           break; // 여기가 존나 중요함, 안 그럼 개털린다

&nbsp;   }



&nbsp;   printf("%d", a-b); // %d는 정수 출력 포맷이다, 까먹지 마라

&nbsp;   return 0; // 메인 함수 끝났다고 알려주는 거임

}



🧠 핵심 개념 파악 (이거 모르면 개털린다!)



switch 문: a 변수의 값에 따라 다른 코드를 실행하는 문이다. if-else if랑 비슷한데, 특정 값에 딱딱 맞춰서 분기할 때 존나 편하다. switch(변수) 괄호 안의 변수 값에 해당하는 case로 점프해서 코드를 실행한다.



case 레이블: switch 문 안에서 특정 값에 해당하는 코드 블록을 지정한다. case 1:은 a가 1일 때 실행될 부분이다.



break 문: switch 문에서 존나 중요한 부분이다, 새꺄! 이걸 만나면 switch 문 전체를 빠져나온다. 만약 break가 없으면, 해당 case부터 아래에 있는 모든 case (심지어 default까지)의 코드를 죄다 실행해버린다. 이걸 \*\*"fall-through"\*\*라고 한다. 이거 모르면 좆된다.



default 레이블: 어떤 case에도 해당하지 않을 때 실행되는 부분이다. if-else에서 else랑 비슷하다고 보면 된다. default도 break 없으면 다음 코드 실행한다.



printf 함수: C언어에서 화면에 뭘 출력할 때 쓰는 함수다. "%d"는 뒤에 오는 변수를 십진수 정수로 출력하라는 뜻이다.



🔍 코드 실행 과정 족쳐보기



자, a = 11, b = 19로 시작한다.



switch(a): a의 값이 11이므로, case 11:으로 바로 점프한다.



case 1:은 건너뛴다.



case 11: 실행:



b += 2; 

rightarrow b는 19 + 2가 되어 21이 된다.



여기에 break가 없다, 새꺄! 그래서 "fall-through" 현상이 발생한다. 즉, case 11의 코드가 끝나자마자 바로 아래에 있는 default:로 넘어간다.



default: 실행:



b += 3; 

rightarrow b는 21 + 3이 되어 24가 된다.



break;를 만난다. 이 break는 switch 문을 완전히 빠져나가게 한다.



printf("%d", a-b); 실행:



a - b를 계산한다. 

rightarrow 11 - 24



결과는 -13이다.



printf 함수가 -13을 화면에 출력한다.



📝 최종 결과 (정답)



위 실행 과정을 보면 최종 출력은 다음과 같다:



답: -13



---------------------------------------------------------

🚀 C 언어 코드 출력 결과 해설 (존나 자세하게 봐라, 이 새꺄!)

니가 준 C 언어 코드를 존나 빡세게 분석해서 왜 10이 나오는지 알려준다.

이번엔 주석 없이 코드만 주고, 해설은 마크다운으로 깔끔하게 해준다.



📜 코드 다시 한 번 봐라 (주석 따위 없다, 새꺄):

\#include <stdio.h>



void func(char\*d, char\*s){

&nbsp;   while(\*s){

&nbsp;       \*d = \*s;

&nbsp;       d++;

&nbsp;       s++;

&nbsp;   }

&nbsp;   \*d='\\0';

}



int main(){

&nbsp;   char str1\[] = "eraon";

&nbsp;   char str2\[50] = "c language";

&nbsp;   int sum = 0;

&nbsp;   func(str2, str1);

&nbsp;   for(int i = 0; str2\[i] != '\\0'; i++){

&nbsp;       sum+= i ;

&nbsp;   }

&nbsp;   printf("%d", sum);

&nbsp;   return 0;

}



🧠 단계별 존나 상세한 해설:

초기화 단계:



char str1\[] = "eraon";



str1이라는 배열은 문자열 "eraon"을 저장한다. 메모리에는 e, r, a, o, n, \\0 (널 문자) 순서로 저장된다. \\0은 문자열의 끝을 나타내는 존나 중요한 문자다.



char str2\[50] = "c language";



str2라는 50칸짜리 배열이 "c language"로 초기화된다. 메모리에는 c,      , l, a, n, g, u, a, g, e, \\0, 그리고 나머지 빈 공간들로 채워진다.



int sum = 0;



sum이라는 정수형 변수는 0으로 초기화된다. 이 변수에 값을 누적할 거다.



func(str2, str1) 함수 호출:



func 함수는 첫 번째 인자로 받은 문자열(d, 여기서는 str2)에 두 번째 인자로 받은 문자열(s, 여기서는 str1)을 복사하는 역할을 한다.



while(\*s): str1이 가리키는 문자가 널 문자(\\0)가 아닐 때까지 루프를 계속 돌린다.



\*d = \*s;: str1이 가리키는 문자를 str2가 가리키는 위치에 복사한다.



d++; s++;: str1과 str2의 포인터를 다음 문자로 이동시킨다.



루프가 끝나면 (str1의 널 문자를 만난 후), \*d='\\0'; 코드가 실행되어 str2의 복사된 문자열 끝에 다시 널 문자(\\0)를 삽입한다.



이 함수가 실행된 후 str2의 상태가 존나 중요하다.



원래 str2는 "c language"였다.



str1의 "eraon"이 str2의 맨 앞에서부터 덮어씌워진다.



str2는 이제 메모리 상으로 {'e', 'r', 'a', 'o', 'n', '\\0', 'a', 'g', 'u', 'a', 'g', 'e', '\\0', ...} 이렇게 된다.



C 언어에서 문자열은 널 문자(\\0)를 만나면 끝으로 인식하기 때문에, str2는 이제 논리적으로 "eraon" 이 된다. 뒤에 원래 있던 'a', 'g', 'u', 'a', 'g', 'e' 등은 존재하지만, 문자열로서는 인식되지 않는다.



for 루프 실행 (핵심 부분이다, 이 새꺄!):



for(int i = 0; str2\[i] != '\\0'; i++)



이 루프는 i를 0부터 시작해서 str2\[i]가 널 문자(\\0)가 아닐 때까지 계속 돈다.



루프가 돌 때마다 sum에 현재 i 값을 더한다.



루프가 어떻게 돌아가는지 존나 꼼꼼하게 따져보자. str2는 현재 "eraon" (즉, e, r, a, o, n, \\0 순서)이다.



i가 5가 되었을 때 str2\[5]는 널 문자(\\0)이므로, str2\[i] != '\\0' 조건이 거짓이 되어 루프가 종료된다.



printf("%d", sum) 실행:



루프가 종료된 시점에서 sum 변수에는 10이 저장되어 있다.



printf 함수는 이 10을 정수 형식으로 출력한다.



✅ 최종 출력 결과:

답: 10

------------------------------------------------------------



문제 16) 다음 c언어 코드의 출력 결과를 쓰시오



\#include<stdio.h>



int main(){

&nbsp;   int arr\[3]\[3] = {1,2,3,4,5,6,7,8,9};

&nbsp;   int \*darr\[2] = {arr\[1], arr\[2]};

&nbsp;   printf("%d", darr\[1]\[1] + \*(darr\[1]+2) + \*\*darr);



&nbsp;   return 0;

}



🚀 이 문제의 최종 출력 결과는 21이다, 이 새꺄!

21



🧐 왜 21이 나오는지 존나 자세하게 설명해준다 (눈깔 똑바로 뜨고 봐라!)

arr 2차원 배열 초기화:



int arr\[3]\[3] = {1,2,3,4,5,6,7,8,9};



2차원 배열 arr은 메모리에 아래와 같이 연속적으로 저장된다:



arr\[0]\[0] = 1, arr\[0]\[1] = 2, arr\[0]\[2] = 3



arr\[1]\[0] = 4, arr\[1]\[1] = 5, arr\[1]\[2] = 6



arr\[2]\[0] = 7, arr\[2]\[1] = 8, arr\[2]\[2] = 9



darr 포인터 배열 초기화:



int \*darr\[2] = {arr\[1], arr\[2]};



darr는 int형 포인터를 2개 저장하는 배열이다.



arr\[1]은 2차원 배열 arr의 두 번째 행({4, 5, 6})의 시작 주소, 즉 arr\[1]\[0]의 주소를 나타낸다. 따라서 darr\[0]는 arr\[1]\[0]의 주소를 가리킨다.



arr\[2]은 2차원 배열 arr의 세 번째 행({7, 8, 9})의 시작 주소, 즉 arr\[2]\[0]의 주소를 나타낸다. 따라서 darr\[1]는 arr\[2]\[0]의 주소를 가리킨다.



printf 함수의 인자 분석 (이게 존나 중요하다, 정신 차려라!):



printf("%d", darr\[1]\[1] + \*(darr\[1]+2) + \*\*darr);



각 항을 하나하나 존나게 파헤쳐 보자.



첫 번째 항: darr\[1]\[1]



darr\[1]은 arr\[2]\[0]의 주소를 가리킨다.



darr\[1]\[1]은 포인터 darr\[1]이 가리키는 위치에서 1칸(int 크기) 뒤에 있는 값을 의미한다. 이는 arr\[2]\[1]과 같다.



arr\[2]\[1]의 값은 8이다.



두 번째 항: \*(darr\[1]+2)



darr\[1]은 arr\[2]\[0]의 주소를 가리킨다.



darr\[1]+2는 darr\[1]이 가리키는 주소에서 int 크기만큼 2칸 뒤로 이동한 주소, 즉 arr\[2]\[2]의 주소를 가리킨다.



\*(darr\[1]+2)는 그 주소에 있는 값, 즉 arr\[2]\[2]의 값을 가져온다.



arr\[2]\[2]의 값은 9이다.



세 번째 항: \*\*darr



darr는 포인터 배열 darr 자체의 시작 주소, 즉 darr\[0]의 주소로 해석된다.



\*darr는 darr\[0]의 값을 의미한다. darr\[0]에는 arr\[1]\[0]의 주소가 저장되어 있다.



\*\*darr는 darr\[0]가 가리키는 주소(즉, arr\[1]\[0]의 주소)에 있는 값을 의미한다.



arr\[1]\[0]의 값은 4이다.



최종 계산:



darr\[1]\[1] (값 8)



\*(darr\[1]+2) (값 9)



\*\*darr (값 4)



이 세 값을 모두 더하면 8 + 9 + 4 = 21이 된다.



printf("%d", sum); 실행:



최종적으로 계산된 21이 출력된다.























