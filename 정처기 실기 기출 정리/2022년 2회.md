## ✅ 문제 1) 다음 괄호에 들어갈 용어를 쓰시오

- 관계데이터 모델의 제안자인 코드(E.F. Codd)가 수학의 predicate calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안하였다.  
- **(  )**은 관계 데이터의 연산을 표현하는 방법으로 원하는 정보를 정의할 때 계산 수식을 사용  
- **(  )**은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성  

**답: 관계해석**

---

### 🔍 해설:

- **관계해석(Relational Calculus)**  
  : *수학의 술어 논리(predicate calculus)에 기반하여*, 원하는 정보가 무엇인지 **선언적으로** 기술하는 방식이다.  
  - **비절차적 언어**: 정보를 얻기 위한 *"어떻게(how)"*가 아니라 *"무엇(what)"*을 기술  
  - 사용 예: 튜플 관계해석(TRC), 도메인 관계해석(DRC)

- 반면, **관계대수(Relational Algebra)**는 원하는 데이터를 얻기 위해 수행할 작업을 **절차적으로** 기술하는 연산자들의 집합이다.

---

### 📌 관련 개념 설명

#### 🔸 관계대수(Relational Algebra)
- **절차적 언어**: 데이터를 얻기 위해 어떤 연산을 어떤 순서로 수행할지 명시  
- 주요 연산자:
  - `σ` (시그마): **선택(Select)** → 조건에 맞는 튜플만 선택  
  - `π` (파이): **투영(Project)** → 지정된 속성만 추출  
  - `⨝` (보타이): **조인(Join)** → 두 릴레이션을 조건에 따라 결합  
  - `÷` (디비전): **나누기(Division)** → 특정 조건을 만족하는 튜플 추출

#### 🔸 관계해석(Relational Calculus)
- **비절차적 언어**: 어떤 데이터가 필요한지를 명시, 절차는 시스템이 결정  
- 형태:
  - **튜플 관계해석 (TRC)**: `t ∈ R ∧ t[A] = "X"` 와 같은 형태
  - **도메인 관계해석 (DRC)**: `∃x∃y (R(x, y) ∧ x = "a")`

---

### 🧪 관계대수 예시 (참고용)

#### 예시 릴레이션 R

| A  | B  |
|----|----|
| a1 | b1 |
| a1 | b2 |
| a1 | b3 |
| a2 | b1 |
| a2 | b3 |

#### 예시 릴레이션 S1

| B  |
|----|
| b1 |

#### 예시 릴레이션 S2

| B  |
|----|
| b1 |
| b2 |

위 릴레이션을 활용하여 `관계대수` 연산(예: Division, Join 등)에 적용 가능


------------------------------------------------------------------------------------------------------

## ✅ 문제 2) 다음 1~2에 해당하는 암호화 알고리즘 용어를 쓰시오

(1)은 1990년 스위스에서 만들어진 PES를 개량하여 만들어진 블록 암호 알고리즘으로  
키 길이가 128bit, 블록 길이가 64bit이다.  
Feistel 방식과 SPN 중간 형태 구조이다.

(2)은 국가 안보국(NSA)에서 개발한 알고리즘으로  
64비트의 입출력, 80비트의 키, 32라운드를 가진다.  
주로 전화기와 같은 음성을 암호화하는 데 사용된다고 한다.

---

**답:**  
(1) **IDEA**  
(2) **SKIPJACK**

---

### 🔍 해설:

#### (1) IDEA (International Data Encryption Algorithm)
- 1990년 스위스에서 개발된 **PES(Proposal Encryption Standard)**의 개량형  
- **128비트 키**, **64비트 블록 크기**  
- **Feistel 구조**와 **SPN 구조**의 혼합 형태  
- 고속 처리와 보안성 때문에 과거 PGP(Pretty Good Privacy) 등에서 사용됨

#### (2) SKIPJACK
- **NSA(미국 국가안보국)**에서 개발  
- **64비트 입력**, **80비트 키**, **32 라운드**  
- **블록 암호 방식**  
- **Clipper chip**에 사용되었으며, **음성 통신 암호화** 목적이 강함

---

### 📌 관련 개념 설명

#### 🔸 블록 암호 알고리즘
- 입력 데이터를 일정한 크기(블록)로 나누어 암호화  
- 예시:
  - **DES** (Data Encryption Standard): 56bit 키, 64bit 블록
  - **3DES**: DES를 3번 적용
  - **AES**: 128/192/256bit 키, 128bit 블록
  - **IDEA**
  - **SKIPJACK**
  - **SEED** (한국 개발, 128bit 키)
  - **ARIA**, **LEA** 등

#### 🔸 스트림 암호 알고리즘
- 데이터를 1비트 혹은 1바이트 단위로 실시간 암호화  
- 예시:
  - **RC4**
  - **A5** (GSM 음성 암호화)
  - **LFSR** (선형 피드백 시프트 레지스터 기반)

#### 🔸 공개키 암호화 알고리즘
- 서로 다른 공개키와 비밀키를 사용하는 **비대칭 키 방식**
- 기반 수학 문제:
  - **소인수분해 문제**: RSA
  - **이산대수 문제**: ElGamal, DSA
  - **타원곡선 문제**: ECC

#### 🔸 단방향 암호 알고리즘 (해시 함수)
- 입력 → 고정된 길이의 해시값으로 변환, 역변환 불가능
- 예시:
  - **MD5**
  - **SHA-1**, **SHA-2**
  - **HAS-160** (한국 개발)


------------------------------------------------------------------------------------------------------

## ✅ 문제 3) 다음에 설명하는 용어를 영문 약어로 적으시오

인터넷 등 통신 사업자의 공중 네트워크에 암호화 기술을 이용하여  
사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션

**답: VPN**

---

### 🔍 해설:

- **VPN (Virtual Private Network)**  
  : 공중 네트워크(예: 인터넷)를 통해 **암호화된 터널**을 만들어  
  마치 자신의 전용망처럼 안전하게 통신할 수 있도록 해주는 기술.  
  - **보안성**, **프라이버시 보호**, **원격 접속** 등에 사용  
  - 인터넷 상에서 안전하게 내부 네트워크에 접근하는 데 사용됨

---

### 📌 관련 개념 설명: 주요 보안 솔루션 정리

| 분류 | 용어 | 설명 |
|------|------|------|
| 네트워크 보호 | **방화벽** | 네트워크 간 전송 데이터를 필터링하여 침입 차단 |
| 웹 보호 | **웹 방화벽 (WAF)** | 웹 서버 공격(SQL Injection 등)을 방어 |
| 침입 탐지 | **IDS (Intrusion Detection System)** | 이상/오용을 **탐지**하는 시스템 (알림만 수행) |
| 침입 차단 | **IPS (Intrusion Prevention System)** | IDS 기능 + **차단** 기능 수행 |
| 정보 유출 방지 | **DLP (Data Loss Prevention)** | 내부 정보가 외부로 유출되지 않도록 감시 및 차단 |
| 접근 제어 | **NAC (Network Access Control)** | MAC 주소 기반으로 네트워크 접근을 제어 |
| 로그 관리 | **ESM (Enterprise Security Management)** | 로그, 이벤트를 **통합** 관리하는 시스템 |
| 로그/행위 분석 | **SIEM (Security Information and Event Management)** | 대규모 보안 이벤트를 장시간 **심층 분석** |
| 자동 대응 | **SOAR (Security Orchestration, Automation and Response)** | 보안 이벤트에 **자동 대응**하고 조치 |
| 격리 실행 | **SANDBOX** | 의심 파일/코드를 **가상 환경에서 격리 실행** |
| 금융 이상 감지 | **FDS (Fraud Detection System)** | 금융 거래에서 **비정상적 행위 탐지 및 차단** |
| 중계 서버 | **PROXY SERVER** | 클라이언트를 대신해 요청 중계, IP 숨기기, 캐시 제공 |

---



------------------------------------------------------------------------------------------------------
## ✅ 문제 4) 아래 설명에서 1~4에 해당하는 용어를 적으시오

네트워크 집합을 몇 개의 그룹으로 나누었을 때  
**동일 그룹 내에서 라우팅 정보를 교환할 때 사용하는 라우팅 프로토콜**을 (1)이라고 하고,  
**다른 그룹과 라우팅 정보를 교환하는 프로토콜**을 (2)라고 한다.  
(1)의 대표적인 프로토콜은 **RIP**와 (3)가 있고  
(2)의 대표적인 프로토콜은 (4)이다.

---

**답:**  
(1) **IGP**  
(2) **EGP**  
(3) **OSPF**  
(4) **BGP**

---

### 🔍 해설:

#### (1) **IGP (Interior Gateway Protocol)**  
- 내부 게이트웨이 프로토콜  
- **자율 시스템(AS) 내**에서 사용하는 라우팅 프로토콜  
- 빠른 수렴성과 내부 네트워크 최적화를 목표로 함  
- 예: **RIP**, **OSPF**, **IS-IS**, **EIGRP**

#### (2) **EGP (Exterior Gateway Protocol)**  
- 외부 게이트웨이 프로토콜  
- 서로 다른 **자율 시스템(AS)** 간 라우팅 정보 교환  
- 규모가 큰 인터넷 백본 환경에서 사용됨  
- 예: **BGP**가 유일하게 실사용되는 EGP

#### (3) **OSPF (Open Shortest Path First)**  
- 링크 상태 라우팅 프로토콜  
- IGP에 속하며, RIP보다 더 빠르고 효율적인 라우팅 제공  
- **Dijkstra 알고리즘** 기반

#### (4) **BGP (Border Gateway Protocol)**  
- EGP에 속하는 **유일한** 라우팅 프로토콜  
- 인터넷의 **핵심 라우팅 프로토콜**로, AS 간 경로 정보를 교환  
- 정책 기반 라우팅, 경로 벡터 방식을 사용

---

### 📌 라우팅 프로토콜 분류 요약

| 분류 | 약어 | 설명 | 대표 프로토콜 |
|------|------|------|----------------|
| 내부 라우팅 | **IGP** | 동일 자율 시스템 내 라우팅 | RIP, OSPF, IS-IS, EIGRP |
| 외부 라우팅 | **EGP** | 다른 자율 시스템 간 라우팅 | BGP |




------------------------------------------------------------------------------------------------------

## ✅ 문제 5) 아래 1~2에서 설명하는 테스트 종류를 쓰시오

(1)은 개발자의 통제하에 사용자가 **개발 환경에서 수행하는 테스트**이다.  
내부에서 진행하는 **자체 검사**로 실제 사용 환경에서 동작시키며 관련자만 참여한다.

(2)는 개발된 소프트웨어를 사용자가 **실제 운영환경에서 수행하는 테스트**이다.  
(1) 수행 이후 **정식으로 출시하기 전**, 사용자에게 테스트를 하도록 한다.

---

**답:**  
(1) **알파 테스트 (Alpha Test)**  
(2) **베타 테스트 (Beta Test)**

---

### 🔍 해설:

#### (1) 알파 테스트 (Alpha Test)
- **개발 환경에서**, **개발자 또는 내부 인력**에 의해 수행  
- 기능의 완성도를 검증하고 주요 결함을 조기에 발견하기 위함  
- **테스트 대상**: 사내 직원, QA 팀 등  
- 실 사용자의 피드백을 받기 전 단계의 테스트

#### (2) 베타 테스트 (Beta Test)
- **운영 환경에서**, **실제 사용자**가 참여  
- 출시 직전 사용자 피드백을 반영해 최종 보완  
- 실 사용자의 다양한 환경에서의 테스트가 가능  
- 제품의 사용성, 안정성 등을 최종 확인

---

### 📌 관련 개념 정리

| 테스트 종류 | 환경 | 수행 주체 | 목적 |
|-------------|------|-----------|------|
| **알파 테스트** | 개발 환경 | 개발자, 내부 인력 | 기능 및 품질 확인, 초기 결함 검출 |
| **베타 테스트** | 실제 운영 환경 | 일반 사용자 | 사용자 피드백 수집, 실사용 안정성 검증 |


------------------------------------------------------------------------------------------------------

## ✅ 문제 6) 변경 또는 수정된 코드에 대하여 새로운 결함 발견 여부를 평가하는 테스트는 무엇인지 보기에서 찾아 쓰시오

---

**답: 회귀 테스트 (Regression Test)**

---

### 🔍 해설:

- **회귀 테스트(Regression Test)**  
  : 소프트웨어의 일부가 **변경되거나 수정된 후**,  
    해당 변경이 **기존 기능에 영향을 미치지 않았는지** 확인하기 위한 테스트  
  - 주로 **기존 기능의 오류 유무**를 점검  
  - 자동화 테스트 도구와 함께 사용되는 경우가 많음  
  - 자주 반복되는 테스트이므로 자동화가 적합함

---

### 📌 애플리케이션 테스트 유형 정리

#### 🔸 테스트 목적 분류

| 목적 | 설명 |
|-------|------|
| **회복 테스트** | 고의로 실패를 유도해 복구 능력 평가 |
| **안전 테스트** | 보안 취약점 및 결함 점검 |
| **강도 테스트** | 과부하, 스트레스 테스트 |
| **성능 테스트** | 반응속도, 처리량, 자원 사용량 등 평가 |
| **구조 테스트** | 코드의 복잡도, 흐름 평가 |
| **회귀 테스트** | **변경 코드로 인한 영향도 검증** |
| **병행 테스트** | 변경 전후 시스템을 비교 |
| **A/B 테스트** | 기존 대비 효과 비교 실험 |
| **스모크 테스트** | 최소한의 기능 동작 여부 점검 (빌드 검증 테스트) |

---

### 🔸 기타 분류 기준

| 기준 | 유형 | 설명 |
|------|------|------|
| **프로그램 실행 여부** | 정적 / 동적 테스트 | 실행하지 않고 분석 / 실행하면서 검사 |
| **테스트 기법** | 화이트박스 / 블랙박스 테스트 | 코드 구조 기반 / 요구사항 기반 |
| **테스트 시각** | 검증 / 확인 테스트 | 요구사항 일치 여부 / 개발 결과의 정확성 평가 |
| **테스트 기반** | 명세 기반 / 구조 기반 / 경험 기반 테스트 | 설계 명세, 코드 구조, 경험에 의존한 테스트 |
------------------------------------------------------------------------------------------------------

## ✅ 문제 7) 다음 주어진 구조에서 C의 FAN IN과 FAN OUT을 구하시오

        A
      / | \
    B   C   D
   /|   |\   |\
  E |   F G  J I
     \       |
       H     I

---

**답:**  
- **FAN IN**: 1  
- **FAN OUT**: 2  

---

### 🔍 해설:

#### 🔸 FAN IN
- **정의**: 특정 모듈(C)을 호출하거나 사용하는 **다른 모듈의 개수**
- 여기서 C를 호출하는 상위 모듈은 **A 1개**  
→ **FAN IN = 1**

#### 🔸 FAN OUT
- **정의**: 특정 모듈(C)이 호출하거나 사용하는 **하위 모듈의 개수**
- C는 **F, G** 두 개의 하위 모듈을 호출  
→ **FAN OUT = 2**

---

### 📌 관련 개념 정리

#### ✅ 응집도(Cohesion) — 모듈 내부 구성 요소 간의 관련성
| 응집도 종류 | 설명 |
|-------------|------|
| **기능적 응집도** | 모든 기능이 하나의 목적을 위해 수행됨 (가장 이상적) |
| **순차적 응집도** | 출력이 다음 작업의 입력으로 사용됨 |
| **통신적 응집도** | 동일한 입출력을 사용하여 관련 기능 수행 |
| **절차적 응집도** | 절차적으로 수행되나 서로 밀접한 관련은 없음 |
| **시간적 응집도** | 같은 시간에 실행되는 작업 묶음 |
| **논리적 응집도** | 유사 기능들을 하나의 모듈로 묶음 |
| **우연적 응집도** | 관련 없는 기능들을 임의로 묶음 (가장 낮은 응집도) |

#### ✅ 결합도(Coupling) — 모듈 간의 의존도
| 결합도 종류 | 설명 |
|-------------|------|
| **자료 결합도** | 값(데이터)만을 주고받음 (가장 이상적) |
| **스탬프 결합도** | 배열, 구조체 등 복합자료 전달 |
| **제어 결합도** | 제어 정보를 인자로 전달 |
| **외부 결합도** | 외부 선언 변수 참조 |
| **공통 결합도** | 전역 변수 사용 |
| **내용 결합도** | 다른 모듈 내부 내용을 직접 참조 (가장 나쁜 결합도) |

---

### ✅ 정리 요약

- **FAN IN**: 자신을 호출하는 **상위 모듈 수**  
- **FAN OUT**: 자신이 호출하는 **하위 모듈 수**  

→ 본 구조도에서 **C**는 A로부터 호출되고, **F와 G**를 호출하므로  
→ **FAN IN = 1**, **FAN OUT = 2**

------------------------------------------------------------------------------------------------------

## ✅ 문제 8) 아래 1~3에서 해당하는 용어를 쓰시오

(1)는 W3(World Wide Web) 상에서 정보를 주고받을 수 있는 **프로토콜**이다.  
GET, POST 방식을 이용하여 문서를 주고받는데,  
이 문서 내에서 다른 문서의 **링크 정보**가 들어가는데  
이런 링크 정보를 만들 수 있는 것이 (2)이다.  

이런 (2)를 만들 수 있는 **마크업 언어**가 (3)이다.

---

**답:**  
(1) **HTTP**  
(2) **Hypertext**  
(3) **HTML**

---

### 🔍 해설:

#### (1) **HTTP (HyperText Transfer Protocol)**  
- 웹에서 데이터를 주고받기 위한 **표준 통신 프로토콜**  
- 클라이언트(브라우저)와 서버 간의 요청(Request)과 응답(Response)을 처리  
- 주요 메서드:
  - **GET**: 데이터 요청  
  - **POST**: 데이터 전송  
  - **PUT**, **DELETE** 등

#### (2) **Hypertext (하이퍼텍스트)**  
- 문서 내에 다른 문서나 위치로 **연결(링크)**할 수 있는 텍스트  
- 사용자 클릭을 통해 다른 문서나 리소스로 이동 가능  
- 대표 예: `<a href="...">링크</a>` 같은 HTML 링크

#### (3) **HTML (HyperText Markup Language)**  
- 하이퍼텍스트를 포함한 문서를 작성하는 **표준 마크업 언어**  
- 웹페이지의 **구조(문단, 제목, 표, 링크 등)**를 정의  
- 웹 문서의 뼈대를 설계하는 데 사용됨

---

### 📌 관련 개념 요약

| 항목 | 내용 |
|------|------|
| **HTTP** | 웹 상의 데이터 전송을 위한 통신 규약 |
| **Hypertext** | 문서 간 연결 기능을 가진 텍스트 |
| **HTML** | 웹 문서를 구조화하기 위한 마크업 언어 |


------------------------------------------------------------------------------------------------------
## ✅ 문제 9) 객체지향 설계 원칙 중 아래에 설명하는 용어를 보기에서 찾아 쓰시오

자신이 **사용하지 않는 인터페이스는 구현하지 말아야** 하고,  
자신이 사용하지 않는 인터페이스 때문에 **영향을 받아서는 안 된다.**  
그러므로 **인터페이스를 작게 나누어** 만들어야 한다.

---

**답: 인터페이스 분리 원칙 (ISP)**

---

### 🔍 해설:

- **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**  
  : 클라이언트는 자신이 **사용하지 않는 메서드에 의존하지 않아야** 한다는 원칙  
  - **비대한 인터페이스**는 **작고 구체적인 인터페이스**로 분리  
  - 인터페이스가 너무 크면, 변경 시 불필요한 영향(변화 전파)이 발생  
  - SOLID 원칙 중 **유연하고 유지보수하기 쉬운 설계**를 위한 핵심 원칙

---

### 📌 객체지향 설계 원칙 (SOLID 원칙)

| 원칙 | 약어 | 설명 |
|------|------|------|
| **단일 책임 원칙** | SRP | 하나의 클래스는 하나의 책임만 가져야 함 |
| **개방-폐쇄 원칙** | OCP | 확장에는 열려 있고, 수정에는 닫혀 있어야 함 |
| **리스코프 치환 원칙** | LSP | 자식 클래스는 부모 클래스를 대체할 수 있어야 함 |
| **인터페이스 분리 원칙** | ISP | 클라이언트가 사용하지 않는 인터페이스에 의존하지 않도록 인터페이스 분리 |
| **의존성 역전 원칙** | DIP | 구체적인 클래스보다 **추상화(인터페이스)**에 의존해야 함 |

---

### ✅ 예시로 이해하기 (ISP)

```java
// 위반 예시: 너무 많은 기능을 하나의 인터페이스에 몰아둠
interface Worker {
    void work();
    void eat(); // 일을 하지 않는 로봇도 구현해야만 함 (불필요)
}

// ISP 적용: 인터페이스 분리
interface Workable {
    void work();
}
interface Eatable {
    void eat();
}


------------------------------------------------------------------------------------------------------
## ✅ 문제 10) IP 주소가 192.168.100.132이고 서브넷 마스크가 255.255.255.192인 경우 1~2에 해당하는 값을 고르시오

---

**답:**  
(1) **128**  
(2) **62**

---

### 🔍 해설:

#### 🔸 IP 주소: 192.168.100.132  
→ 클래스 C 주소 (사설 IP)

#### 🔸 서브넷 마스크: 255.255.255.192  
→ 192는 11000000(2)  
→ 즉, **26비트가 네트워크 주소** (CIDR: /26)

→ 8비트 중 2비트만 호스트 비트로 사용 (32 - 26 = 6 비트)

---

#### (1) 네트워크 주소 계산

- 서브넷 마스크: 255.255.255.**192** → 마지막 바이트 기준: **2^6 = 64** 단위로 나뉨
- 192.168.100.132가 속한 범위:
  - 0~63 → X
  - 64~127 → X
  - 128~191 → ✅ 해당됨

→ **네트워크 주소 = 192.168.100.128**

---

#### (2) 사용 가능한 호스트 주소 수

- 남은 비트 수 = 6 → 총 주소 수: 2^6 = 64개  
- 이 중에서:
  - **네트워크 주소 1개**
  - **브로드캐스트 주소 1개** 제외

→ **사용 가능한 IP 주소 수 = 64 - 2 = 62개**

---

### 📌 요약

| 항목 | 값 |
|------|-----|
| 네트워크 주소 | **192.168.100.128** |
| 사용 가능한 호스트 수 | **62개** |
| 브로드캐스트 주소 | 192.168.100.191 |
| IP 범위 | 192.168.100.129 ~ 192.168.100.190 |



------------------------------------------------------------------------------------------------------
## ✅ 문제 11) 다음 직원 릴레이션에서 다음 관계대수식을 실행한 결과를 1~5에 쓰시오

### 🔸 직원 릴레이션

| NAME | TTL   |  
|------|--------|  
| LEE  | 부장   |  
| KIM  | 대리   |  
| SONG | 차장   |  
| PARK | 과장   |  

---

### 🔸 관계대수식: `π TTL(직원)`

---

**답 (결과):**

TTL
부장
대리
차장
과장


---

### 🔍 해설:

#### 🔸 `π` (파이) 연산: **Projection 연산**
- 릴레이션에서 **특정 속성(열)만 추출**하는 연산  
- **중복 제거**된 튜플만 반환 (관계형 모델의 특징)

#### 🔸 `π TTL(직원)`의 의미:
- `직원` 릴레이션에서 **TTL 속성(직급)**만 선택  
- 중복된 값이 없으므로 그대로 모두 출력됨

→ 결과는 "직급"만 출력되며 다음과 같음:

| TTL   |  
|--------|  
| 부장   |  
| 대리   |  
| 차장   |  
| 과장   |  

---

### 📌 관계대수 연산 요약

| 연산 기호 | 이름 | 설명 |
|----------|------|------|
| `σ`(시그마) | Selection (선택) | 조건에 맞는 행(튜플)을 선택 |
| `π`(파이)   | Projection (투영) | 지정한 열(속성)만 선택 |
| `⋈`(보타이) | Join (조인) | 두 릴레이션을 조건에 따라 결합 |
| `/`        | Division (나누기) | 관련 있는 부분 릴레이션 추출 |
------------------------------------------------------------------------------------------------------

## ✅ 문제 12) 상품 테이블에서 B 제조사 전체 제품의 단가보다 **더 큰 단가**를 가진 제품을 모두 출력하는 SQL 문을 완성하시오

---

### 🔸 주어진 테이블 예시

| 제품번호 | 단가  | 제조사 |
|----------|-------|--------|
| 100      | 1000  | A      |
| 200      | 1500  | B      |
| 300      | 3000  | C      |
| 400      | 900   | D      |
| 500      | 2000  | B      |
| 600      | 1000  | C      |

---

### 🔸 SQL 문:

```sql
SELECT * FROM 상품
WHERE 단가 > ALL (
  SELECT 단가 FROM 상품 
  WHERE 제조사 = 'B'
);
정답: ALL
🔍 해설:
조건: B 제조사의 모든 제품 단가보다 큰 제품을 찾는 것

B 제조사 제품 단가: 1500, 2000

이보다 모든 값보다 큰 단가 → > ALL 사용

즉, 단가 > 2000인 제품만 선택

→ 조건을 만족하는 제품은:

제품번호	단가	제조사
300	3000	C

📌 SQL 비교 연산자 요약
연산자	설명
> ANY	서브쿼리 결과 중 하나라도 작으면 참
> ALL	서브쿼리 결과 모두보다 커야 참
IN	서브쿼리 결과 목록에 포함되면 참
EXISTS	서브쿼리 결과가 존재하면 참
= ANY 또는 IN	둘은 동일 의미 (부분 포함)

✅ 최종 결과:
sql
복사
편집
SELECT * FROM 상품
WHERE 단가 > ALL (
  SELECT 단가 FROM 상품 
  WHERE 제조사 = 'B'
);
→ 출력되는 제품: 제품번호 300, 단가 3000
------------------------------------------------------------------------------------------------------
## ✅ 문제 13) 다음 릴레이션 데이터는 다음과 같이 저장되어 있다.  
아래 SQL을 수행했을 때 결과를 쓰시오.

---

### 🔸 릴레이션 데이터 (TABLE)

| IDX | COL1 | COL2 |
|-----|------|------|
| 1   | 2    | NULL |
| 2   | 3    | 6    |
| 3   | 5    | 5    |
| 4   | 6    | 3    |
| 5   | NULL | 3    |

---

### 🔸 SQL 문

```sql
SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);
🔍 해설
✅ 조건 해석:
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5)

→ 조건을 만족하는 행:

IDX 1: COL1 = 2 → ✅

IDX 2: COL1 = 3 → ✅

IDX 3: COL2 = 5 → ✅

IDX 4: COL2 = 3 → ✅

IDX 5: COL2 = 3 → ✅

→ 총 5개 행이 조건을 만족함

✅ COUNT(COL2)는?
COUNT(COL2)는 NULL 제외
→ 조건을 만족한 5개 중 COL2가 NULL이 아닌 행만 카운트

IDX	COL2
1	NULL ❌ (제외)
2	6 ✅
3	5 ✅
4	3 ✅
5	3 ✅

→ 총 4개 행이 COL2에 NULL이 아님

✅ 정답: 4
sql
복사
편집
SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);
-- 결과: 4
📌 참고: COUNT(컬럼) vs COUNT(*)
함수	의미	NULL 포함 여부
COUNT(*)	전체 행 개수	✅ 포함
COUNT(컬럼)	해당 컬럼이 NULL이 아닌 행만 카운트	❌ 제외

------------------------------------------------------------------------------------------------------
## ✅ 문제 14) 다음은 함수적 종속에 해당하는 설명이다. 1~3에 해당하는 용어를 보기에서 찾아 쓰시오.

- 함수적 종속관계에서 종속자가 **기본키 전체에 종속**되며,  
  기본키가 여러 속성으로 구성되어 있을 경우  
  **기본키의 모든 속성이 포함된** 경우를 **(1)** 이라고 한다.

- 기본키가 여러 속성으로 구성되어 있을 경우,  
  기본키를 구성하는 속성 중 **일부에만 종속**되는 경우를 **(2)** 라고 한다.

- `X → Y`, `Y → Z` 종속 관계가 있을 경우,  
  `X → Z` 가 성립되는 경우를 **(3)** 라고 한다.

---

**답:**
- (1) **FULL** (완전 함수 종속)
- (2) **PARTIAL** (부분 함수 종속)
- (3) **TRANSITIVE** (이행적 함수 종속)

---

### 🔍 해설

#### (1) **FULL FUNCTIONAL DEPENDENCY (완전 함수 종속)**  
- 기본키의 **전체 속성에 의존**하는 경우  
- 예: (A, B) → C  
  - C는 A나 B 중 일부가 아니라, **A와 B 둘 다 있어야만** 결정됨

#### (2) **PARTIAL FUNCTIONAL DEPENDENCY (부분 함수 종속)**  
- 기본키 중 일부 속성에만 의존  
- 예: (A, B) → C 이고 A → C 도 성립한다면, 이는 **부분 함수 종속**  
  - 정규화 과정에서 **2NF로 올리기 위해 제거 대상**

#### (3) **TRANSITIVE FUNCTIONAL DEPENDENCY (이행적 함수 종속)**  
- A → B, B → C 이면 A → C가 되는 종속성  
- 이 때 C는 A의 **기본키가 아닌 속성**일 경우 문제가 됨  
  - **3NF 정규화** 시 제거 대상

---

### 📌 함수적 종속 요약 정리

| 용어 | 설명 | 정규화 대상 |
|------|------|-------------|
| **완전 함수 종속** | 기본키 전체에 종속됨 | ✅ 유지 |
| **부분 함수 종속** | 기본키 일부에만 종속됨 | ❌ 2NF에서 제거 |
| **이행적 함수 종속** | 기본키 아닌 속성을 통해 종속됨 | ❌ 3NF에서 제거 |


------------------------------------------------------------------------------------------------------
## ✅ 문제 15) 다음 C언어 프로그램의 출력 결과를 쓰시오

```c
#include <stdio.h>

struct st {
    int x, y;
};

int main() {
    struct st dt[2];
    for(int i = 0; i < 2; i++) {
        dt[i].x = i;
        dt[i].y = i + 1;
    }
    printf("%d", dt[0].x + dt[1].y);
}
✅ 답: 2
🔍 해설:
🔸 구조체 배열 선언
c
복사
편집
struct st dt[2];
→ 구조체 st를 요소로 하는 배열 dt를 선언
→ dt[0], dt[1] 총 두 개의 구조체 인스턴스가 생성됨

🔸 for문 동작
c
복사
편집
for(int i = 0; i < 2; i++) {
    dt[i].x = i;
    dt[i].y = i + 1;
}
i	dt[i].x	dt[i].y
0	0	1
1	1	2

🔸 출력 구문
c
복사
편집
printf("%d", dt[0].x + dt[1].y);
→ dt[0].x = 0, dt[1].y = 2
→ 0 + 2 = 2

✅ 최종 출력 결과: 2
plaintext
복사
편집
2
------------------------------------------------------------------------------------------------------
## ✅ 문제 16) 다음 C언어 프로그램의 출력 결과를 쓰시오

```c
#include <stdio.h>

int func(char *p) {
    int cnt = 0;
    while (*p != '\0') {
        cnt++;
        p++;
    }
    return cnt;
}

int main() {
    char *p1 = "2022";
    char *p2 = "202210";
    int i = func(p1);
    int j = func(p2);
    printf("%d", i + j);
    return 0;
}
✅ 답: 10
🔍 해설:
함수 func는 문자열 길이를 구하는 함수이다. (NULL 문자까지 문자 수 세기)

문자열 "2022"의 길이: 4

문자열 "202210"의 길이: 6

i = func(p1) = 4

j = func(p2) = 6

출력: i + j = 4 + 6 = 10

주의사항
코드 내 while(*p! = '\0')는 오타입니다.
→ 올바른 표현: while (*p != '\0')

최종 출력
plaintext
복사
편집
10
------------------------------------------------------------------------------------------------------

## ✅ 문제 17) 다음 C언어 프로그램의 출력 결과를 쓰시오

```c
#include <stdio.h>
int main() {
    int a[4] = {0, 2, 4, 8};
    int b[3];
    int *p;
    int sum = 0;

    for(int i = 1; i < 4; i++) {
        p = a + i;
        b[i - 1] = *p - a[i - 1];
        sum += b[i - 1] + a[i];
    }
    printf("%d", sum);
}
✅ 답: 22
🔍 해설:
i	p = a + i	*p	a[i-1]	b[i-1] = *p - a[i-1]	a[i]	sum += b[i-1] + a[i]	sum 누적값
1	a + 1	2	a[0]=0	2 - 0 = 2	2	2 + 2 = 4	4
2	a + 2	4	a[1]=2	4 - 2 = 2	4	2 + 4 = 6	4 + 6 = 10
3	a + 3	8	a[2]=4	8 - 4 = 4	8	4 + 8 = 12	10 + 12=22

sum 변수는 for문에서 계속 누적

최종 출력은 22

✅ 최종 출력:
plaintext
복사
편집
22
------------------------------------------------------------------------------------------------------

## ✅ 문제 18) 다음 Java 프로그램의 출력 결과를 쓰시오

```java
public static void main(String[] args){
    int i = 3;
    int sum = 0;
    switch(i){
        case 0: sum++;
        case 1: sum += 3;
        case 2: sum -= 10;
        case 3: sum = 0;
        case 4: sum += 3;
        case 5: sum -= 10;
        default: sum--;
    }
    System.out.println(sum);
}
✅ 답: -8
🔍 해설:
switch 문에서 i = 3이므로 case 3부터 실행 시작

break 문이 없으므로 아래 case들과 default까지 모두 실행됨

실행 구간	연산 내용	sum 값 변화
case 3	sum = 0	0
case 4	sum += 3	3
case 5	sum -= 10	-7
default	sum--	-8

실행 순서
sum = 0 (case 3)

sum = 0 + 3 = 3 (case 4)

sum = 3 - 10 = -7 (case 5)

sum = -7 - 1 = -8 (default)

최종 출력
plaintext
복사
편집
-8
------------------------------------------------------------------------------------------------------

## ✅ 문제 19) 다음 Java 프로그램의 출력 결과를 쓰시오

```java
class Cal {
    int a;
    Cal(int a) {
        this.a = a;
    }
    int func() {
        int b = 1;
        for (int i = 1; i < a; i++)
            b = a * i + b;
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Cal obj = new Cal(3);
        obj.a = 5;
        int b = obj.func();
        System.out.println(obj.a + b);
    }
}
✅ 답: 61
🔍 해설:
객체 생성 시 obj.a = 3 으로 초기화되나,
이후 obj.a = 5로 값이 변경됨

func() 호출 시 a = 5

func() 실행 과정 (a = 5):
java
복사
편집
int b = 1;
for (int i = 1; i < 5; i++) {
    b = 5 * i + b;
}
return a + b;  // return 5 + b;
i	계산식	b 값 변화
1	b = 5*1 + 1 = 6	6
2	b = 5*2 + 6 = 16	16
3	b = 5*3 + 16=31	31
4	b = 5*4 + 31=51	51

func() 반환값: a + b = 5 + 51 = 56

최종 출력
java
복사
편집
System.out.println(obj.a + b);  // 5 + 56 = 61
✅ 출력 결과: 61
plaintext
복사
편집
61

------------------------------------------------------------------------------------------------------
## ✅ 문제 20) 다음 파이썬 코드에서 출력되는 결과를 작성하시오

```python
str1 = "REMEMBER NOVEMBER"
str2 = str[:3] + str1[12:6]
str = "R AND %s" % "STR"
print(str2 + st3)
문제점 및 가정
코드에 변수 이름 오타가 있습니다.

str이라는 내장함수 이름을 변수로 사용했습니다 (권장하지 않음).

str2 = str[:3] + str1[12:6] 에서 str1[12:6]은 빈 문자열('')을 반환합니다 (슬라이싱 범위가 역순).

print(str2 + st3) 에서 st3 변수가 정의되어 있지 않습니다.
아마 str3의 오타로 추정됩니다.

수정된 코드 (의도 파악 후 추정)
python
복사
편집
str1 = "REMEMBER NOVEMBER"
str2 = str1[:8]  # 'REMEMBER' (인덱스 0~7)
str3 = " AND %s" % "STR"
print(str2 + str3)
결과
nginx
복사
편집
REMEMBER AND STR
🔍 해설
str1[:8] → 'REMEMBER'

" AND %s" % "STR" → " AND STR"

두 문자열을 합쳐서 "REMEMBER AND STR" 출력

결론
문제에서 의도한 출력은 아래와 같습니다.

nginx
복사
편집
REMEMBER AND STR





