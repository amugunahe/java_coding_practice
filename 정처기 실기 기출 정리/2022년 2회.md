## ✅ 문제 1) 다음 괄호에 들어갈 용어를 쓰시오

- 관계데이터 모델의 제안자인 코드(E.F. Codd)가 수학의 predicate calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안하였다.  
- **(  )**은 관계 데이터의 연산을 표현하는 방법으로 원하는 정보를 정의할 때 계산 수식을 사용  
- **(  )**은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성  

**답: 관계해석**

---
### 🔍 해설: 관계해석(Relational Calculus)과 관계대수(Relational Algebra) 쉽게 이해하기 – 갓반인도 척척!

---

## 1️⃣ 관계해석(Relational Calculus)

- 수학의 술어 논리(predicate calculus)에 기반한 **비절차적 언어**  
- **무엇(what)을 원하는지 선언**만 할 뿐, 어떻게 처리할지는 신경 쓰지 않음  
- 예) 튜플 관계해석(TRC), 도메인 관계해석(DRC)  
- 쉽게 말해, “어떤 데이터가 필요한지”만 말하는 방식

---

## 2️⃣ 관계대수(Relational Algebra)

- 데이터를 얻기 위한 **절차적 언어**  
- “어떤 연산을 어떤 순서로 수행할지” 명확히 기술함  
- 주요 연산자:  
  - `σ` (시그마): 조건에 맞는 튜플 선택(Select)  
  - `π` (파이): 특정 속성만 추출(Project)  
  - `⨝` (보타이): 두 릴레이션 결합(Join)  
  - `÷` (디비전): 특정 조건 만족하는 튜플 추출(Division)  
- 쉽게 말해, “데이터를 어떻게 꺼낼지 절차대로 설명”하는 방식

---

## 📌 관계해석과 관계대수 정리

| 구분           | 관계해석(Relational Calculus)       | 관계대수(Relational Algebra)           |
|----------------|------------------------------------|---------------------------------------|
| 언어 유형      | 비절차적 (What)                    | 절차적 (How)                          |
| 기술 방식      | 원하는 데이터의 조건 명시           | 수행할 연산과 순서 명시                |
| 예             | 튜플 관계해석(TRC), 도메인 관계해석(DRC) | 선택, 투영, 조인, 나누기 연산 등       |

---

## 🧪 관계대수 예시 (참고)

### 릴레이션 R

| A  | B  |
|----|----|
| a1 | b1 |
| a1 | b2 |
| a1 | b3 |
| a2 | b1 |
| a2 | b3 |

### 릴레이션 S1

| B  |
|----|
| b1 |

### 릴레이션 S2

| B  |
|----|
| b1 |
| b2 |

- 이 릴레이션들을 가지고  
- 관계대수 연산(예: Division, Join 등)을 수행해 원하는 결과를 얻을 수 있음

---

## 🧠 쉽게 이해하기 예시

- 관계해석 = “나는 b1과 a1이 포함된 데이터가 필요해!” (무엇을 원하는지 선언)  
- 관계대수 = “먼저 R에서 a1을 찾아, b값을 꺼내고, S1과 비교해서…” (어떻게 가져올지 절차적 설명)

---

> 관계해석과 관계대수는 데이터베이스에서 원하는 데이터를 표현하는 서로 다른 두 방법임!



------------------------------------------------------------------------------------------------------

## ✅ 문제 2) 다음 1~2에 해당하는 암호화 알고리즘 용어를 쓰시오

(1)은 1990년 스위스에서 만들어진 PES를 개량하여 만들어진 블록 암호 알고리즘으로  
키 길이가 128bit, 블록 길이가 64bit이다.  
Feistel 방식과 SPN 중간 형태 구조이다.

(2)은 국가 안보국(NSA)에서 개발한 알고리즘으로  
64비트의 입출력, 80비트의 키, 32라운드를 가진다.  
주로 전화기와 같은 음성을 암호화하는 데 사용된다고 한다.

---

**답:**  
(1) **IDEA**  
(2) **SKIPJACK**

---

### 🔍 해설:

#### (1) IDEA (International Data Encryption Algorithm)
- 1990년 스위스에서 개발된 **PES(Proposal Encryption Standard)** 개량형  
- **128비트 키**, **64비트 블록 크기**  
- **Feistel 구조**와 **SPN 구조** 혼합  
- 고속 처리와 높은 보안성 덕분에 과거 PGP(Pretty Good Privacy) 등에서 사용됨  

#### (2) SKIPJACK
- 미국 **NSA(국가안보국)**에서 개발  
- **64비트 입력**, **80비트 키**, **32 라운드**  
- **블록 암호 방식**  
- Clipper chip에 사용, 주로 **음성 통신 암호화** 목적  

---

### 📌 관련 개념 설명

#### 🔸 블록 암호 알고리즘
- 데이터를 일정 크기(블록) 단위로 나눠 암호화하는 방식  
- 주요 예시:  
  - **DES**: 56비트 키, 64비트 블록  
  - **3DES**: DES를 3번 연속 적용  
  - **AES**: 128/192/256비트 키, 128비트 블록  
  - **IDEA, SKIPJACK, SEED(한국 개발), ARIA, LEA** 등  

#### 🔸 스트림 암호 알고리즘
- 데이터를 1비트 또는 1바이트 단위로 실시간 암호화  
- 주요 예시:  
  - **RC4**  
  - **A5** (GSM 음성 암호화)  
  - **LFSR** (선형 피드백 시프트 레지스터 기반)  

#### 🔸 공개키 암호화 알고리즘
- 서로 다른 공개키와 비밀키를 사용하는 **비대칭 키 방식**  
- 기반 수학 문제에 따라 분류:  
  - **소인수분해 문제** → RSA  
  - **이산대수 문제** → ElGamal, DSA  
  - **타원곡선 문제** → ECC  

#### 🔸 단방향 암호 알고리즘 (해시 함수)
- 입력값을 고정 길이 해시값으로 변환, 역산 불가능  
- 주요 예시:  
  - **MD5**  
  - **SHA-1, SHA-2**  
  - **HAS-160** (한국 개발)  

---

### 🧠 쉽게 이해하기 갓반인 예시

- IDEA: 128비트 열쇠로 64비트 문을 단단히 잠그는 열쇠 시스템  
- SKIPJACK: NSA가 만든 비밀 통화용 자물쇠  
- 블록 암호는 문을 여러 칸으로 나눠 한 칸씩 잠그는 느낌  
- 스트림 암호는 문이 하나씩 지나갈 때마다 계속 잠그는 느낌  
- 공개키 암호는 편지함 열쇠 두 개(공개키+비밀키)를 써서 안전하게 메시지 교환  
- 단방향 암호는 메시지를 넣으면 고정된 길이 코드가 나오고, 거꾸로는 못 푸는 마법!



------------------------------------------------------------------------------------------------------

## ✅ 문제 3) 다음에 설명하는 용어를 영문 약어로 적으시오

인터넷 등 통신 사업자의 공중 네트워크에 암호화 기술을 이용하여  
사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션

**답: VPN**

---

### 🔍 해설:

- **VPN (Virtual Private Network)**  
  인터넷 같은 공중 네트워크를 통해 **암호화된 터널**을 만들어  
  마치 자신의 전용망처럼 안전하게 데이터를 주고받는 기술  
  - **보안 강화**, **프라이버시 보호**, **원격 접속**에 주로 사용  
  - 외부에서도 안전하게 회사 내부 네트워크 접속 가능  

---

### 📌 주요 보안 솔루션 한눈에 정리

| 분류           | 용어                              | 설명                                                        |
|----------------|----------------------------------|-------------------------------------------------------------|
| 네트워크 보호  | **방화벽 (Firewall)**            | 네트워크 간 데이터 흐름을 필터링해 침입 차단                   |
| 웹 보호        | **웹 방화벽 (WAF)**              | 웹 서버 공격(SQL Injection 등) 방어                          |
| 침입 탐지      | **IDS (Intrusion Detection System)** | 이상행위나 공격 탐지, 단순 알림 역할                          |
| 침입 차단      | **IPS (Intrusion Prevention System)** | IDS 기능 + 공격 차단 기능 포함                                |
| 정보 유출 방지 | **DLP (Data Loss Prevention)**  | 내부 정보가 외부로 새어나가지 않도록 감시 및 차단             |
| 접근 제어      | **NAC (Network Access Control)**| MAC 주소 기반으로 네트워크 접근 권한 제어                      |
| 로그 관리      | **ESM (Enterprise Security Management)** | 로그와 이벤트 통합 관리                                      |
| 로그/행위 분석 | **SIEM (Security Information and Event Management)** | 대규모 보안 이벤트를 장기간 심층 분석                         |
| 자동 대응      | **SOAR (Security Orchestration, Automation and Response)** | 보안 이벤트에 자동으로 대응하고 조치                          |
| 격리 실행      | **SANDBOX**                      | 의심스러운 파일/코드를 가상 환경에서 격리 실행                |
| 금융 이상 감지 | **FDS (Fraud Detection System)**| 금융 거래에서 이상 거래 탐지 및 차단                           |
| 중계 서버      | **PROXY SERVER**                 | 클라이언트를 대신해 요청 중계, IP 숨기기, 캐시 제공            |

---

### 🧠 쉽게 이해하는 갓반인 예시

- VPN: 인터넷 속에 내 전용 비밀 터널 만들어서 안전하게 회사 네트워크 접속  
- 방화벽: 집 문 지키는 경비원, 이상한 사람 못 들어오게 막음  
- WAF: 웹사이트 앞에 설치된 경비, 웹 공격 막음  
- IDS: 침입 시도 발견해서 알려주는 감시 카메라  
- IPS: 침입 시도 발견하고 바로 문 잠그는 자동 경비  
- DLP: 회사 비밀 문서가 밖으로 새는 거 감시하고 막음  
- NAC: 들어오는 사람 신분증 검사해서 출입 허가  
- SIEM/ESM: 보안 사건을 모아 분석하는 보안 상황실  
- SOAR: 침입 발생 시 자동으로 대응하는 로봇 경비  
- SANDBOX: 위험한 파일을 안전한 방에 가둬서 테스트  
- FDS: 카드 도용 같은 이상 거래 즉시 탐지  
- PROXY SERVER: 내가 대신 인터넷 요청해주고 신분 숨겨줌


---



------------------------------------------------------------------------------------------------------
## ✅ 문제 4) 아래 설명에서 1~4에 해당하는 용어를 적으시오

네트워크 집합을 몇 개의 그룹으로 나누었을 때  
**동일 그룹 내에서 라우팅 정보를 교환할 때 사용하는 라우팅 프로토콜**을 (1)이라고 하고,  
**다른 그룹과 라우팅 정보를 교환하는 프로토콜**을 (2)라고 한다.  
(1)의 대표적인 프로토콜은 **RIP**와 (3)가 있고  
(2)의 대표적인 프로토콜은 (4)이다.

---

**답:**  
(1) **IGP**  
(2) **EGP**  
(3) **OSPF**  
(4) **BGP**

---

### 🔍 해설:

#### (1) **IGP (Interior Gateway Protocol)**
- 내부 게이트웨이 프로토콜  
- 같은 **자율 시스템(AS)** 내부에서 라우팅 정보 교환  
- 빠른 수렴성과 네트워크 효율성 중점  
- 대표 프로토콜: **RIP**, **OSPF**, **IS-IS**, **EIGRP**

#### (2) **EGP (Exterior Gateway Protocol)**
- 외부 게이트웨이 프로토콜  
- 서로 다른 **자율 시스템(AS)** 간 라우팅 정보 교환  
- 인터넷 백본에서 사용되는 대규모 라우팅  
- 대표 프로토콜: **BGP** (유일한 실사용 EGP)

#### (3) **OSPF (Open Shortest Path First)**
- IGP에 속하는 **링크 상태 라우팅 프로토콜**  
- RIP보다 빠르고 효율적  
- **Dijkstra 알고리즘** 기반으로 최단 경로 계산

#### (4) **BGP (Border Gateway Protocol)**
- EGP에 속하는 **유일한 라우팅 프로토콜**  
- 인터넷의 핵심 라우팅 프로토콜  
- AS 간 경로 정보 교환, 정책 기반 라우팅, 경로 벡터 방식 사용

---

### 📌 라우팅 프로토콜 분류 한눈에 보기

| 분류       | 약어 | 설명                        | 대표 프로토콜            |
|------------|------|-----------------------------|-------------------------|
| 내부 라우팅 | IGP  | 같은 AS 내부 라우팅         | RIP, OSPF, IS-IS, EIGRP |
| 외부 라우팅 | EGP  | 다른 AS 간 라우팅           | BGP                     |

---

### 🧠 갓반인 예시

- IGP는 우리 회사 건물 내부에서 길 찾기  
- EGP는 여러 회사가 연결된 큰 도시에서 길 찾기  
- OSPF는 사내 최단 경로를 빠르고 정확히 찾는 고급 내비게이션  
- BGP는 인터넷 전체를 연결하는 슈퍼 내비게이션





------------------------------------------------------------------------------------------------------

## ✅ 문제 5) 아래 1~2에서 설명하는 테스트 종류를 쓰시오

(1)은 개발자의 통제하에 사용자가 **개발 환경에서 수행하는 테스트**이다.  
내부에서 진행하는 **자체 검사**로 실제 사용 환경에서 동작시키며 관련자만 참여한다.

(2)는 개발된 소프트웨어를 사용자가 **실제 운영환경에서 수행하는 테스트**이다.  
(1) 수행 이후 **정식으로 출시하기 전**, 사용자에게 테스트를 하도록 한다.

---

**답:**  
(1) **알파 테스트 (Alpha Test)**  
(2) **베타 테스트 (Beta Test)**

---

### 🔍 해설:

#### (1) 알파 테스트 (Alpha Test)
- **개발 환경에서** 내부 인력이 직접 수행  
- 기능 완성도 점검과 주요 결함 조기 발견 목적  
- 테스트 대상: 사내 직원, QA 팀 등  
- 실사용자 피드백 받기 전 마지막 점검 단계

#### (2) 베타 테스트 (Beta Test)
- **운영 환경에서** 실제 사용자가 참여  
- 출시 직전 다양한 사용자 환경에서 문제점 발견 및 보완  
- 사용자 경험, 안정성, 호환성 최종 확인

---

### 📌 관련 개념 정리

| 테스트 종류   | 환경         | 수행 주체          | 목적                       |
|--------------|--------------|--------------------|----------------------------|
| **알파 테스트** | 개발 환경    | 개발자, 내부 인력  | 기능 검증, 초기 결함 발견  |
| **베타 테스트** | 운영 환경    | 일반 사용자        | 사용자 피드백 수집 및 안정성 검증 |

---

### 🧠 갓반인 예시

- 알파 테스트: 우리 회사 직원들이 먼저 제품 써보고 문제점 찾기  
- 베타 테스트: 출시 전 실제 고객들이 써보고 의견 주는 단계



------------------------------------------------------------------------------------------------------

## ✅ 문제 6) 변경 또는 수정된 코드에 대하여 새로운 결함 발견 여부를 평가하는 테스트는 무엇인지 보기에서 찾아 쓰시오

---

**답: 회귀 테스트 (Regression Test)**

---

### 🔍 해설:

- **회귀 테스트 (Regression Test)**  
  : 소프트웨어를 수정하거나 기능을 변경한 후,  
  기존 기능이 문제없이 잘 작동하는지 확인하는 테스트  
  - 변경된 부분 때문에 다른 기능이 망가지지 않았는지 점검  
  - 자동화 도구와 함께 자주 반복 수행하는 게 효과적

---

### 📌 애플리케이션 테스트 유형 정리

#### 🔸 테스트 목적 분류

| 목적         | 설명                                |
|--------------|-----------------------------------|
| **회복 테스트** | 실패 상황을 일부러 만들어 복구 능력 평가   |
| **안전 테스트** | 보안 취약점 및 위험 요소 점검             |
| **강도 테스트** | 시스템에 과부하를 줘 안정성 평가           |
| **성능 테스트** | 처리 속도, 자원 사용량, 응답 시간 측정      |
| **구조 테스트** | 코드 복잡도, 분기 흐름 등을 분석            |
| **회귀 테스트** | 변경 후 기존 기능 정상 작동 여부 점검        |
| **병행 테스트** | 변경 전후 시스템 결과 비교                   |
| **A/B 테스트**  | 두 버전 중 사용자 반응 비교                  |
| **스모크 테스트** | 빌드 후 핵심 기능 최소 동작 여부 빠르게 확인  |

---

#### 🔸 기타 분류 기준

| 기준           | 유형               | 설명                              |
|----------------|--------------------|---------------------------------|
| **프로그램 실행 여부** | 정적 테스트 / 동적 테스트  | 실행 없이 분석 / 실제 실행하며 검사    |
| **테스트 기법**       | 화이트박스 / 블랙박스    | 코드 내부 구조 기반 / 입출력만 기반    |
| **테스트 시각**       | 검증 테스트 / 확인 테스트 | 요구사항 충족 여부 검사 / 실제 작동 확인 |
| **테스트 기반**       | 명세 기반 / 구조 기반 / 경험 기반 | 설계 명세 / 코드 구조 / 테스터 경험 활용 |

---

### 🧠 갓반인 예시

- 코드 고친 후 기존 기능 다 망가졌나? 확인하는 게 회귀 테스트  
- 새로 만든 기능만 테스트하는 게 아니고, 바뀐 영향 다 체크하는 것임!

------------------------------------------------------------------------------------------------------

## ✅ 문제 7) 다음 주어진 구조에서 C의 FAN IN과 FAN OUT을 구하시오

        A
      / | \
    B   C   D
   /|   |\   |\
  E |   F G  J I
     \       |
       H     I

---

**답:**  
- **FAN IN**: 1  
- **FAN OUT**: 2  

---

### 🔍 해설:

#### 🔸 FAN IN
- **정의**: 특정 모듈(C)을 호출하거나 사용하는 **다른 모듈의 개수**  
- 예) C를 호출하는 상위 모듈이 A 1개라면  
→ **FAN IN = 1**

#### 🔸 FAN OUT
- **정의**: 특정 모듈(C)이 호출하거나 사용하는 **하위 모듈의 개수**  
- 예) C가 F, G 두 개의 하위 모듈을 호출한다면  
→ **FAN OUT = 2**

---

### 📌 관련 개념 정리

#### ✅ 응집도(Cohesion) — 모듈 내부 구성 요소 간 관련성 정도

| 응집도 종류      | 설명                                      |
|-----------------|-----------------------------------------|
| **기능적 응집도**  | 모든 기능이 하나의 목적을 위해 수행됨 (최고 수준) |
| **순차적 응집도**  | 출력이 다음 작업의 입력으로 사용됨             |
| **통신적 응집도**  | 동일 입출력을 사용해 관련 기능 수행              |
| **절차적 응집도**  | 절차적으로 수행되나 관련성은 낮음                |
| **시간적 응집도**  | 같은 시간에 실행되는 작업들을 묶음                |
| **논리적 응집도**  | 비슷한 기능들을 하나로 묶음                      |
| **우연적 응집도**  | 관련 없는 기능들을 억지로 묶음 (최악 수준)        |

#### ✅ 결합도(Coupling) — 모듈 간 의존성 정도

| 결합도 종류      | 설명                                          |
|-----------------|---------------------------------------------|
| **자료 결합도**   | 데이터만 주고받음 (최고 수준)                     |
| **스탬프 결합도** | 배열, 구조체 등 복합 자료 전달                      |
| **제어 결합도**   | 제어 정보를 인자로 전달                            |
| **외부 결합도**   | 외부 선언 변수 참조                               |
| **공통 결합도**   | 전역 변수 사용                                   |
| **내용 결합도**   | 다른 모듈 내부 내용을 직접 참조 (최악 수준)           |

---

### ✅ 정리 요약

- **FAN IN** = 자신을 호출하는 **상위 모듈 수**  
- **FAN OUT** = 자신이 호출하는 **하위 모듈 수**  

예) 모듈 C는 A에게 호출되고, F와 G를 호출하므로  
→ **FAN IN = 1**, **FAN OUT = 2**

---

### 🧠 갓반인 예시

- A가 C에게 전화해서 일 시키면 C의 FAN IN은 1  
- C가 F, G에게 전화 걸어서 일 시키면 FAN OUT은 2  
- 적당한 응집도와 낮은 결합도가 좋은 모듈 설계 비결!


------------------------------------------------------------------------------------------------------

## ✅ 문제 8) 아래 1~3에서 해당하는 용어를 쓰시오

(1)는 W3(World Wide Web) 상에서 정보를 주고받을 수 있는 **프로토콜**이다.  
GET, POST 방식을 이용하여 문서를 주고받는데,  
이 문서 내에서 다른 문서의 **링크 정보**가 들어가는데  
이런 링크 정보를 만들 수 있는 것이 (2)이다.  

이런 (2)를 만들 수 있는 **마크업 언어**가 (3)이다.

---

**답:**  
(1) **HTTP**  
(2) **Hypertext**  
(3) **HTML**

---

### 🔍 해설:

#### (1) **HTTP (HyperText Transfer Protocol)**
- 웹에서 데이터를 주고받기 위한 **표준 통신 프로토콜**  
- 클라이언트(브라우저)와 서버 간 요청(Request)과 응답(Response)을 주고받음  
- 주요 메서드:  
  - **GET**: 서버에서 데이터 요청  
  - **POST**: 서버로 데이터 전송  
  - **PUT**, **DELETE** 등 다양한 작업 지원

#### (2) **Hypertext (하이퍼텍스트)**
- 문서 안에서 다른 문서나 위치로 연결되는 **링크가 포함된 텍스트**  
- 사용자가 클릭하면 다른 문서나 웹페이지로 이동 가능  
- 예: `<a href="주소">링크 텍스트</a>` 같은 HTML 링크

#### (3) **HTML (HyperText Markup Language)**
- 하이퍼텍스트 문서를 작성하는 **표준 마크업 언어**  
- 웹페이지의 구조(제목, 문단, 표, 링크 등)를 정의함  
- 웹 문서의 뼈대를 만드는 언어

---

### 📌 관련 개념 요약

| 항목        | 설명                           |
|-------------|------------------------------|
| **HTTP**    | 웹에서 데이터 주고받는 통신 규약       |
| **Hypertext** | 문서 간 연결을 가능하게 하는 텍스트     |
| **HTML**    | 웹 문서 구조를 만드는 마크업 언어      |

---

### 🧠 갓반인 예시

- 웹사이트에 접속하면, 브라우저가 HTTP로 서버에 "이 페이지 주세요(GET)" 요청  
- 페이지 안의 링크(하이퍼텍스트)를 클릭하면 다른 문서로 이동  
- HTML은 그 페이지가 어떻게 생겼는지, 어디에 뭐가 있는지 알려주는 설계도 같은 역할!



------------------------------------------------------------------------------------------------------
## ✅ 문제 9) 객체지향 설계 원칙 중 아래에 설명하는 용어를 보기에서 찾아 쓰시오

자신이 **사용하지 않는 인터페이스는 구현하지 말아야** 하고,  
자신이 사용하지 않는 인터페이스 때문에 **영향을 받아서는 안 된다.**  
그러므로 **인터페이스를 작게 나누어** 만들어야 한다.

---

**답: 인터페이스 분리 원칙 (ISP)**

---

### 🔍 해설:

- **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**  
  : 클라이언트는 자신이 **사용하지 않는 메서드에 의존하지 않아야** 한다는 원칙  
  - **비대한 인터페이스**는 **작고 구체적인 인터페이스**로 분리  
  - 인터페이스가 너무 크면, 변경 시 불필요한 영향(변화 전파)이 발생  
  - SOLID 원칙 중 **유연하고 유지보수하기 쉬운 설계**를 위한 핵심 원칙

---

### 🔍 해설:

- **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**  
  : 클라이언트는 자신이 **사용하지 않는 메서드에 의존하지 않아야** 한다는 원칙  
  - 너무 크고 복잡한 인터페이스를 **작고 구체적인 인터페이스**로 나눔  
  - 큰 인터페이스 하나가 여러 기능을 담으면, 변경 시 불필요한 영향이 커짐  
  - SOLID 원칙 중 유지보수와 유연성을 높이는 핵심 설계 원칙  

---

### 📌 객체지향 설계 원칙 (SOLID 원칙) + 예시

| 원칙             | 약어 | 설명                                   | 예시 |
|------------------|------|--------------------------------------|------|
| **단일 책임 원칙**     | SRP  | 하나의 클래스는 하나의 책임만 가져야 함        | `자동차` 클래스가 엔진 제어, 연비 계산, 음악 재생까지 모두 처리하면 복잡함 → 엔진 제어 클래스, 미디어 클래스 등으로 분리 |
| **개방-폐쇄 원칙**     | OCP  | 확장에는 열려 있고, 수정에는 닫혀 있어야 함      | 새로운 결제 방식 추가 시 기존 코드를 바꾸지 않고 새 클래스를 추가해 처리 가능 |
| **리스코프 치환 원칙**   | LSP  | 자식 클래스는 부모 클래스를 대체할 수 있어야 함    | `사각형` 클래스 부모, `정사각형` 클래스 자식일 때, 정사각형이 사각형 기능을 완전히 대체 가능해야 함 |
| **인터페이스 분리 원칙** | ISP  | 클라이언트가 사용하지 않는 인터페이스에 의존하지 않도록 분리 | `동물` 인터페이스가 걷기, 날기, 수영하기 포함 시, `개`는 걷기만 구현하도록 걷기 인터페이스만 받게 분리 |
| **의존성 역전 원칙**    | DIP  | 구체적 클래스보다 추상화(인터페이스)에 의존해야 함 | 고양이를 직접 의존하지 말고 `동물` 인터페이스에 의존 → 나중에 강아지로 바꿔도 코드 수정 최소화 |

---

### 🧠 한눈에 갓반인 정리

- SRP: 한 클래스가 한 가지 일만 제대로 하도록!  
- OCP: 기능은 새로 만들고, 기존 건 건드리지 마!  
- LSP: 자식은 부모 역할을 완벽히 대체할 수 있어야 해!  
- ISP: 필요한 인터페이스만 쓸 수 있게 쪼개!  
- DIP: 구체적 코드 말고, 추상화(인터페이스)에 의존해!


---

### ✅ 예시로 이해하기 (ISP)

```java
// 위반 예시: 너무 많은 기능을 하나의 인터페이스에 몰아둠
interface Worker {
    void work();
    void eat(); // 일을 하지 않는 로봇도 구현해야만 함 (불필요)
}

// ISP 적용: 인터페이스 분리
interface Workable {
    void work();
}
interface Eatable {
    void eat();
}


------------------------------------------------------------------------------------------------------
## ✅ 문제 10) IP 주소가 192.168.100.132이고 서브넷 마스크가 255.255.255.192인 경우 1~2에 해당하는 값을 고르시오

---

**답:**  
(1) **128**  
(2) **62**

---

💻 IP 주소랑 서브넷 마스크, 이거 뭐 별거 아니었어!  
🔍 딱 까놓고 보자, 네가 준 정보!

---

### IP 주소: 192.168.100.132  
- 클래스 C 주소고, 사설 IP야.  
- 집이나 회사에서 쓰는 그 IP 맞아.

### 서브넷 마스크: 255.255.255.192  
- 여기서 **192**가 핵심!  
- 192를 이진수로 바꾸면 `11000000`, 앞에 1이 두 개 붙어있지? → 즉, 네트워크 주소로 26비트 쓴다는 뜻이야  
- 그래서 CIDR로는 **/26**이라고 표현해  
- 전체 32비트 중 26비트는 네트워크용, 나머지 6비트가 호스트용이야. 쉬워~

---

### (1) 네트워크 주소 계산법  
- 서브넷 마스크가 255.255.255.192니까, 마지막 옥텟에서 **64 단위로 구간 나눠** (왜냐면 256 - 192 = 64니까)  
- 구간은 이렇게 나눠:  
  - 0 ~ 63  
  - 64 ~ 127  
  - 128 ~ 191 ← 여기 132가 딱 들어가겠지?  
  - 192 ~ 255  
- 네가 준 IP 192.168.100.132는 **128 ~ 191 구간에 속해**  
- 그래서 네트워크 주소는 그 구간 시작인 **192.168.100.128**이 되는 거야  
- 개쉽지?

---

### (2) 사용 가능한 호스트 주소 수  
- 호스트 비트가 6비트니까 → 2^6 = 64개 주소 가능  
- 근데 네트워크 주소 1개랑 브로드캐스트 주소 1개는 컴퓨터가 못 써 → 64 - 2 = 62개가 실제로 쓸 수 있는 주소야

---

### 📌 정리 쭉!

| 항목             | 값                          |
|------------------|-----------------------------|
| 네트워크 주소      | **192.168.100.128**          |
| 사용 가능한 호스트 수 | **62개**                     |
| 브로드캐스트 주소   | **192.168.100.191**          |
| IP 범위 (사용 가능) | 192.168.100.129 ~ 192.168.100.190 |

---

**갓반인 꿀팁!**  
서브넷 마스크 255.255.255.192는 한 네트워크 구간에 IP 64개씩 묶는다고 보면 돼.  
192.168.100.132는 그중 128~191 구간에 딱 들어가서, 네트워크 주소는 192.168.100.128!  
그리고 쓸 수 있는 IP는 네트워크랑 브로드캐스트 빼고 62개!  
이렇게 구간 나누면 네트워크 관리가 훨씬 편해진다니까~  





------------------------------------------------------------------------------------------------------
## ✅ 문제 11) 다음 직원 릴레이션에서 다음 관계대수식을 실행한 결과를 1~5에 쓰시오

### 🔸 직원 릴레이션

| NAME | TTL   |  
|------|--------|  
| LEE  | 부장   |  
| KIM  | 대리   |  
| SONG | 차장   |  
| PARK | 과장   |  

---

### 🔸 관계대수식: `π TTL(직원)`

---

**답 (결과):**

TTL
부장
대리
차장
과장


---

### 🔍 해설:

#### 🔸 `π` (파이) 연산: **Projection 연산**  
- 릴레이션에서 **특정 속성(열)만 쏙 뽑아내는** 연산이야  
- 중복된 값은 딱 한 번만 보여줘 (관계형 데이터베이스 특징)  

#### 🔸 `π TTL(직원)`의 의미:  
- `직원` 테이블에서 **TTL(직급)** 열만 선택하는 것  
- 중복된 직급은 하나로 줄여서 결과에 나타남  

→ 결과는 "직급"만 쫙 나오는 테이블로 이렇게 돼:

| TTL   |  
|-------|  
| 부장   |  
| 대리   |  
| 차장   |  
| 과장   |  

---

### 📌 관계대수 연산 한눈에

| 기호    | 이름          | 설명                                  | 갓반인 예시                          |
|---------|---------------|-------------------------------------|------------------------------------|
| `σ`     | Selection (선택)  | 조건에 맞는 행(레코드)만 골라내기          | 부서가 '영업'인 직원만 골라내기          |
| `π`     | Projection (투영) | 필요한 열(속성)만 쏙 빼내기               | 직원 테이블에서 '직급'만 뽑기            |
| `⋈`     | Join (조인)     | 두 테이블을 조건에 맞게 합치기               | 직원 테이블과 부서 테이블을 부서코드로 합치기 |
| `/`     | Division (나누기) | 특정 조건에 딱 맞는 부분 집합 추출하기          | '모든 프로젝트에 참여한 직원' 찾기           |

---

**갓반인 꿀팁!**  
- `σ`는 내가 원하는 조건만 골라내는 필터기  
- `π`는 필요한 컬럼만 딱 뽑아주는 마술사  
- `⋈`는 두 테이블 합체! 조건 딱 맞게 연결  
- `/`는 특정 조건을 완벽히 만족하는 친구들만 쏙쏙 뽑아내는 셀렉트 박스!


------------------------------------------------------------------------------------------------------

## ✅ 문제 12) 상품 테이블에서 B 제조사 전체 제품의 단가보다 **더 큰 단가**를 가진 제품을 모두 출력하는 SQL 문을 완성하시오

---

### 🔸 주어진 테이블 예시

| 제품번호 | 단가  | 제조사 |
|----------|-------|--------|
| 100      | 1000  | A      |
| 200      | 1500  | B      |
| 300      | 3000  | C      |
| 400      | 900   | D      |
| 500      | 2000  | B      |
| 600      | 1000  | C      |

---

### 🔸 SQL 문:

```sql
SELECT * FROM 상품
WHERE 단가 > ALL (
  SELECT 단가 FROM 상품 
  WHERE 제조사 = 'B'
);
정답: ALL
🔍 해설:
조건: B 제조사의 모든 제품 단가보다 큰 제품을 찾는 것

B 제조사 제품 단가: 1500, 2000

이보다 모든 값보다 큰 단가 → > ALL 사용

즉, 단가 > 2000인 제품만 선택

→ 조건을 만족하는 제품은:

제품번호	단가	제조사
300	3000	C

📌 SQL 비교 연산자 요약
연산자	설명
> ANY	서브쿼리 결과 중 하나라도 작으면 참
> ALL	서브쿼리 결과 모두보다 커야 참
IN	서브쿼리 결과 목록에 포함되면 참
EXISTS	서브쿼리 결과가 존재하면 참
= ANY 또는 IN	둘은 동일 의미 (부분 포함)

✅ 최종 결과:

SELECT * FROM 상품
WHERE 단가 > ALL (
  SELECT 단가 FROM 상품 
  WHERE 제조사 = 'B'
);
→ 출력되는 제품: 제품번호 300, 단가 3000


갓반인 꿀팁

> ALL 은 "서브쿼리 결과 전부보다 커야 한다"는 뜻!

> ANY 는 "서브쿼리 결과 중 하나라도 작으면 된다"는 뜻!

조건에 딱 맞는 제품 골라낼 때 요긴하게 써봐!
------------------------------------------------------------------------------------------------------
## ✅ 문제 13) 다음 릴레이션 데이터는 다음과 같이 저장되어 있다.  
아래 SQL을 수행했을 때 결과를 쓰시오.

---

### 🔸 릴레이션 데이터 (TABLE)

| IDX | COL1 | COL2 |
|-----|------|------|
| 1   | 2    | NULL |
| 2   | 3    | 6    |
| 3   | 5    | 5    |
| 4   | 6    | 3    |
| 5   | NULL | 3    |

---

### 🔸 SQL 문

```sql
SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);


🔍 해설
✅ 조건 해석:
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5)

→ 조건을 만족하는 행:

IDX 1: COL1 = 2 → ✅

IDX 2: COL1 = 3 → ✅

IDX 3: COL2 = 5 → ✅

IDX 4: COL2 = 3 → ✅

IDX 5: COL2 = 3 → ✅

→ 총 5개 행이 조건을 만족함

✅ COUNT(COL2)는?
COUNT(COL2)는 NULL 제외
→ 조건을 만족한 5개 중 COL2가 NULL이 아닌 행만 카운트

IDX	COL2
1	NULL ❌ (제외)
2	6 ✅
3	5 ✅
4	3 ✅
5	3 ✅

→ 총 4개 행이 COL2에 NULL이 아님

✅ 정답: 4
SELECT COUNT(COL2)
FROM TABLE
WHERE COL1 IN (2, 3) OR COL2 IN (3, 5);
-- 결과: 4
📌 참고: COUNT(컬럼) vs COUNT(*)
함수	의미	NULL 포함 여부
COUNT(*)	전체 행 개수	✅ 포함
COUNT(컬럼)	해당 컬럼이 NULL이 아닌 행만 카운트	❌ 제외

------------------------------------------------------------------------------------------------------
## ✅ 문제 14) 다음은 함수적 종속에 해당하는 설명이다. 1~3에 해당하는 용어를 보기에서 찾아 쓰시오.

- 함수적 종속관계에서 종속자가 **기본키 전체에 종속**되며,  
  기본키가 여러 속성으로 구성되어 있을 경우  
  **기본키의 모든 속성이 포함된** 경우를 **(1)** 이라고 한다.

- 기본키가 여러 속성으로 구성되어 있을 경우,  
  기본키를 구성하는 속성 중 **일부에만 종속**되는 경우를 **(2)** 라고 한다.

- `X → Y`, `Y → Z` 종속 관계가 있을 경우,  
  `X → Z` 가 성립되는 경우를 **(3)** 라고 한다.

---

**답:**
- (1) **FULL** (완전 함수 종속)
- (2) **PARTIAL** (부분 함수 종속)
- (3) **TRANSITIVE** (이행적 함수 종속)

---

### 🔍 해설

#### (1) **FULL FUNCTIONAL DEPENDENCY (완전 함수 종속)**  
- 기본키의 **전체 속성에 의존**하는 경우  
- 예: (A, B) → C  
  - C는 A나 B 중 일부가 아니라, **A와 B 둘 다 있어야만** 결정됨

#### (2) **PARTIAL FUNCTIONAL DEPENDENCY (부분 함수 종속)**  
- 기본키 중 일부 속성에만 의존  
- 예: (A, B) → C 이고 A → C 도 성립한다면, 이는 **부분 함수 종속**  
  - 정규화 과정에서 **2NF로 올리기 위해 제거 대상**

#### (3) **TRANSITIVE FUNCTIONAL DEPENDENCY (이행적 함수 종속)**  
- A → B, B → C 이면 A → C가 되는 종속성  
- 이 때 C는 A의 **기본키가 아닌 속성**일 경우 문제가 됨  
  - **3NF 정규화** 시 제거 대상

---

### 📌 함수적 종속 요약 정리

| 용어 | 설명 | 정규화 대상 |
|------|------|-------------|
| **완전 함수 종속** | 기본키 전체에 종속됨 | ✅ 유지 |
| **부분 함수 종속** | 기본키 일부에만 종속됨 | ❌ 2NF에서 제거 |
| **이행적 함수 종속** | 기본키 아닌 속성을 통해 종속됨 | ❌ 3NF에서 제거 |


------------------------------------------------------------------------------------------------------
## ✅ 문제 15) 다음 C언어 프로그램의 출력 결과를 쓰시오

```c
#include <stdio.h>

struct st {
    int x, y;
};

int main() {
    struct st dt[2];
    for(int i = 0; i < 2; i++) {
        dt[i].x = i;
        dt[i].y = i + 1;
    }
    printf("%d", dt[0].x + dt[1].y);
}

✅ 답: 2


🔍 해설:
🔸 구조체 배열 선언
struct st dt[2];
→ 구조체 st를 요소로 하는 배열 dt를 선언
→ dt[0], dt[1] 총 두 개의 구조체 인스턴스가 생성됨

🔸 for문 동작
for(int i = 0; i < 2; i++) {
    dt[i].x = i;
    dt[i].y = i + 1;
}
i	dt[i].x	dt[i].y
0	0	1
1	1	2

🔸 출력 구문
printf("%d", dt[0].x + dt[1].y);
→ dt[0].x = 0, dt[1].y = 2
→ 0 + 2 = 2

✅ 최종 출력 결과: 2
2
------------------------------------------------------------------------------------------------------
## ✅ 문제 16) 다음 C언어 프로그램의 출력 결과를 쓰시오

```c
#include <stdio.h>

int func(char *p) {
    int cnt = 0;
    while (*p != '\0') {
        cnt++;
        p++;
    }
    return cnt;
}

int main() {
    char *p1 = "2022";
    char *p2 = "202210";
    int i = func(p1);
    int j = func(p2);
    printf("%d", i + j);
    return 0;
}


✅ 답: 10
🔍 해설:
함수 func는 문자열 길이를 구하는 함수이다. (NULL 문자까지 문자 수 세기)

문자열 "2022"의 길이: 4

문자열 "202210"의 길이: 6

i = func(p1) = 4

j = func(p2) = 6

출력: i + j = 4 + 6 = 10

주의사항
코드 내 while(*p! = '\0')는 오타입니다.
→ 올바른 표현: while (*p != '\0')

최종 출력
10
------------------------------------------------------------------------------------------------------

## ✅ 문제 17) 다음 C언어 프로그램의 출력 결과를 쓰시오

```c
#include <stdio.h>
int main() {
    int a[4] = {0, 2, 4, 8};
    int b[3];
    int *p;
    int sum = 0;

    for(int i = 1; i < 4; i++) {
        p = a + i;
        b[i - 1] = *p - a[i - 1];
        sum += b[i - 1] + a[i];
    }
    printf("%d", sum);
}

✅ 답: 22
🔍 해설:
| i | p       | *p | a[i-1] | b[i-1] = *p - a[i-1] | a[i] | b[i-1] + a[i] | sum 누적값 |
|---|---------|----|--------|----------------------|------|----------------|-------------|
| 1 | a + 1   | 2  | 0      | 2                    | 2    | 2 + 2 = 4      | 4           |
| 2 | a + 2   | 4  | 2      | 2                    | 4    | 2 + 4 = 6      | 10          |
| 3 | a + 3   | 8  | 4      | 4                    | 8    | 4 + 8 = 12     | 22          |


sum 변수는 for문에서 계속 누적

최종 출력은 22

✅ 최종 출력:
22
------------------------------------------------------------------------------------------------------

## ✅ 문제 18) 다음 Java 프로그램의 출력 결과를 쓰시오

```java
public static void main(String[] args){
    int i = 3;
    int sum = 0;
    switch(i){
        case 0: sum++;
        case 1: sum += 3;
        case 2: sum -= 10;
        case 3: sum = 0;
        case 4: sum += 3;
        case 5: sum -= 10;
        default: sum--;
    }
    System.out.println(sum);
}

✅ 답: -8

🔍 해설:
switch 문에서 i = 3이므로 case 3부터 실행 시작

break 문이 없으므로 아래 case들과 default까지 모두 실행됨

실행 구간	연산 내용	sum 값 변화
case 3	sum = 0	0
case 4	sum += 3	3
case 5	sum -= 10	-7
default	sum--	-8

실행 순서
sum = 0 (case 3)

sum = 0 + 3 = 3 (case 4)

sum = 3 - 10 = -7 (case 5)

sum = -7 - 1 = -8 (default)
------------------------------------------------------------------------------------------------------

## ✅ 문제 19) 다음 Java 프로그램의 출력 결과를 쓰시오

```java
class Cal {
    int a;
    Cal(int a) {
        this.a = a;
    }
    int func() {
        int b = 1;
        for (int i = 1; i < a; i++)
            b = a * i + b;
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Cal obj = new Cal(3);
        obj.a = 5;
        int b = obj.func();
        System.out.println(obj.a + b);
    }
}

✅ 답: 61


🔍 해설:
객체 생성 시 obj.a = 3 으로 초기화되나,
이후 obj.a = 5로 값이 변경됨

func() 호출 시 a = 5

func() 실행 과정 (a = 5):

int b = 1;
for (int i = 1; i < 5; i++) {
    b = 5 * i + b;
}

return a + b;  // return 5 + b;
i	계산식	b 값 변화
1	b = 5*1 + 1 = 6	6
2	b = 5*2 + 6 = 16	16
3	b = 5*3 + 16=31	31
4	b = 5*4 + 31=51	51

func() 반환값: a + b = 5 + 51 = 56

최종 출력
System.out.println(obj.a + b);  // 5 + 56 = 61

✅ 출력 결과: 61


------------------------------------------------------------------------------------------------------
## ✅ 문제 20) 다음 파이썬 코드에서 출력되는 결과를 작성하시오

str1 = "REMEMBERNOVEMBER" # 원본 문자열
str2 = str1[:3] + str1[12:16] # 여기서 중요한 계산이 들어감
str3 = "RAND%s" % "STR" # 또 다른 문자열 만드는 부분
print(str2 + str3) # 최종 출력

✅ 최종 결론:
REMBERRANDSTR

🔍 각 줄마다 무슨 일이 벌어지는지 차근차근 보자!

```python
str1 = "REMEMBERNOVEMBER"
str1 변수에 "REMEMBERNOVEMBER"라는 문자열 전체를 저장하는 거야.

쉽게 말해, str1 = "REMEMBERNOVEMBER" 이렇게 문자열을 통째로 넣은 거지.

str2 = str1[:3] + str1[12:16]
str2가 만들어지는데, str1의 두 부분을 잘라서 더하는 거야.

str1[:3]은 str1에서 0번 인덱스부터 2번 인덱스까지(처음부터 3번째 문자까지) 잘라내는 것!

"REMEMBERNOVEMBER" 중에서 "REM"이 뽑혀 나와.

str1[12:16]은 str1에서 12번 인덱스부터 15번 인덱스까지(12번째 문자부터 16번째 문자 바로 앞까지) 잘라내는 것!

"REMEMBERNOVEMBER"에서 인덱스 12~15는 "BER"야 (12:'B', 13:'E', 14:'R', 15:'')

그래서 str2는 "REM" + "BER" 가 되어,

최종적으로 **"REMBER"**가 되는 거야.

str3 = "RAND%s" % "STR"
문자열 포맷팅 문법!

"RAND%s" 안의 %s는 문자열을 넣을 자리 표시자야.

뒤에 "STR"을 넣으라고 해서,

str3는 "RANDSTR" 가 돼.

print(str2 + str3)
마지막으로 str2와 str3를 더해서 출력하는 거야.

"REMBER" + "RANDSTR" → "REMBERRANDSTR" 가 출력돼.

✅ 최종 결론:
REMBERRANDSTR

