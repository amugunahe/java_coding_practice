## 📘 정보처리기사 실기 - RAID 관련 문제 정리

### 문제 1)
다음 설명에 맞는 RAID 단계를 쓰시오.

- 두개 이상의 하드디스크를 병렬로 연결해, 하나의 하드디스크처럼 이용하는 기술이다  
- 스트라이프 방식으로 구현한다.  
- 데이터가 분산되어 저장하기 때문에 하나의 하드디스크에 문제가 생기면 다른 디스크까지 사용이 불가능해진다.

**답: RAID 0**

---

### 📌 RAID 형태 요약

- **RAID-0 (스트라이핑)**  
  데이터를 여러 디스크에 쪼개서 저장 → 속도 엄청 빠름  
  단, 복구 기능 없음 → 디스크 하나만 고장 나도 데이터 다 날아감

- **RAID-1 (미러링)**  
  데이터를 똑같이 두 개 디스크에 복제 저장 → 안정성 최고  
  디스크 하나 고장 나도 다른 디스크에서 복구 가능

- **RAID-2**  
  해밍코드(Hamming Code) 사용해서 오류 정정 → 이론적이고 실제 사용 거의 없음

- **RAID-3**  
  바이트 단위 스트라이핑 + 한 디스크에 패리티 정보 저장 → 오류 검출/복구 가능

- **RAID-4**  
  블록 단위 스트라이핑 + 한 디스크에 패리티 정보 저장 → RAID-3 개선판

- **RAID-5**  
  데이터와 패리티 정보를 모든 디스크에 분산 저장 → 패리티 병목 현상 해결  
  가장 널리 쓰이는 방식, 성능과 안정성 균형 최고

- **RAID-6**  
  RAID-5에서 패리티 정보를 두 개 저장 → 2개 디스크가 동시에 고장 나도 복구 가능

---

쉽게 말하면,  
- RAID-0은 빠르지만 위험함  
- RAID-1은 느리지만 안전함  
- RAID-5가 그 둘을 잘 조합한 인기 만점  
- RAID-6는 RAID-5보다 더 안전함  


 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 트랜잭션 회복 기법 관련 문제 정리

### 문제 2)
다음은 로그 기반 회복 기법에서 사용되는 명령어이다.  
해당하는 항목을 보기에서 찾아 적으시오.

1. 트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 **재실행하여 복구**를 수행한다.  
2. 트랜잭션 로그를 이용하여 오류와 관련된 내용을 **취소하여 복구**를 수행한다.

**답:**
- 1) REDO  
- 2) UNDO

---
### 📌 관련 개념 정리

#### ✅ 트랜잭션 회복 기법
- **UNDO**: 실패한 트랜잭션 작업을 취소해 이전 상태로 되돌림  
- **REDO**: 성공한 트랜잭션 결과를 다시 실행해 복구

---

#### ✅ 트랜잭션의 4대 특성 (ACID)

| 특성명            | 설명                                         |
|-------------------|----------------------------------------------|
| **원자성 (Atomicity)**  | 작업은 전부 수행되거나 전혀 수행되지 않아야 함           |
| **일관성 (Consistency)** | 트랜잭션 전후 데이터가 항상 일관된 상태를 유지해야 함      |
| **격리성 (Isolation)**  | 동시에 실행되는 트랜잭션끼리 서로 간섭하지 않도록 보장       |
| **영속성 (Durability)**  | 완료된 트랜잭션 결과는 영구적으로 저장되어야 함            |

---

쉽게 말해,  
트랜잭션은 ‘모두 아니면 전혀’ 원칙을 지키면서,  
항상 데이터가 꼬이지 않고,  
서로 간섭 없이 안전하게 작동하며,  
끝난 작업 결과는 영원히 남는다는 뜻임.

 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 데이터베이스 이상현상

### 문제 3)
데이터베이스의 이상현상 중 **삭제이상**에 대해 간략히 서술하시오.

**답:**  
한 튜플을 삭제할 때 **연쇄 삭제 현상**으로 인해 **원하지 않는 정보 손실**이 발생하는 현상

---

### 📌 관련 개념 설명

#### ✅ 이상현상(Anomaly)이란?  
테이블에 중복이나 종속성 문제로 데이터 무결성이 깨지는 비정상적인 현상.  
주로 정규화를 안 했을 때 발생함.

---

#### ✅ 이상현상의 종류

| 이상현상           | 설명                                                      |
|--------------------|-----------------------------------------------------------|
| **삽입이상 (Insertion Anomaly)** | 필요한 정보 말고도 불필요한 정보까지 같이 입력해야 하는 경우          |
| **삭제이상 (Deletion Anomaly)** | 하나의 정보를 삭제하려다 원하지 않는 다른 정보까지 같이 삭제되는 경우   |
| **갱신이상 (Update Anomaly)**  | 중복된 정보가 여러 곳에 있어 일부만 수정하면 데이터 불일치가 생기는 경우 |

---

#### ✅ 삭제이상 예시

| 학생이름 | 학번 | 강의명   |
|----------|------|----------|
| 홍길동   | 1001 | DB개론   |
| 김영희   | 1002 | DB개론   |
| 이철수   | 1003 |          |

- 만약 **이철수** 학생 정보만 삭제했는데,  
- 강의명이 함께 사라진다면?  
- 강의 정보가 통째로 날아가버리는 문제 → **삭제이상**

---

정리하면,  
이상현상은 데이터가 꼬이고 깨지는 문제이고,  
정규화를 통해 이를 예방하는 게 핵심임!



 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 네트워크 보안 프로토콜

### 문제 4)
아래 임시 키 무결성 프로토콜의 영문 약어를 쓰시오.

> 임시 키 무결성 프로토콜은 IEEE 802.11의 무선 네트워킹 표준으로 사용되는 보안 프로토콜이다.  
> 임시 키 무결성 프로토콜은 IEEE 802.11i의 작업 그룹과 와이파이 얼라이언스에서 WEP를  
> 하드웨어 교체 없이 대체하기 위해 고안되었다.

**답: TKIP**

---

### 📌 관련 개념 설명

#### ✅ TKIP (Temporal Key Integrity Protocol)

- TKIP는 WEP의 취약점을 보완하기 위해 만든 무선 보안 프로토콜  
- IEEE 802.11i 표준의 일부이며, WPA의 핵심 기술  
- 기존 WEP 장비에 물리적 교체 없이 보안 강화 가능  
- 주요 기능:  
  - **패킷마다 다른 키 사용 (Per-packet key mixing)**  
  - **메시지 무결성 검사 코드 (MIC) 적용**  
  - **재전송 공격 방지**

---

#### ✅ WPA와 WPA2 차이

| 항목       | WPA (Wi-Fi Protected Access) | WPA2               |
|------------|-------------------------------|--------------------|
| 암호화 방식 | TKIP                          | AES                |
| 보안 수준   | WEP보다 강하지만 WPA2보단 약함 | 훨씬 강력한 보안 제공 |
| 표준       | IEEE 802.11i (부분 적용)       | IEEE 802.11i (완전 적용) |

---

쉽게 말해,  
TKIP는 WEP의 구멍을 메꾸고, WPA는 TKIP 기반, WPA2는 AES 기반으로 더 튼튼한 보안 체계임!

 -------------------------------------------------------------------------------------------------------

### 문제 5) 아래 설명하는 내용을 영문 약자로 쓰시오

> 특별한 하드웨어 없이 인간의 자연스러운 움직임을 인식하여 정보를 제공한다.

**답: NUI (Natural User Interface)**

---

### UI 설계 원칙

| 원칙   | 설명                                                          |
|--------|---------------------------------------------------------------|
| **직관성** | 화면의 버튼, 항목, 입력란 등을 누구나 쉽게 이해하고 사용할 수 있도록 한다.   |
| **유효성** | 사용자의 목적을 정확히 달성할 수 있도록 유용하고 효과적이어야 한다.         |
| **학습성** | 사용자가 쉽게 배우고 익힐 수 있어야 한다.                                   |
| **유연성** | 사용자의 요구를 최대한 수용하면서 오류를 최소화해야 한다.                   |

---

쉽게 말해,  
NUI는 손짓, 얼굴 인식 등 자연스러운 행동으로 기기를 다루는 UI 방식이고,  
좋은 UI 설계는 누구나 편하게 쓰고 쉽게 배울 수 있게 만드는 것임!



 -------------------------------------------------------------------------------------------------------

## 📘 정보처리기사 실기 - 소스코드 분석 도구 및 테스트 유형 분류

### 문제 6)
다음 소스코드 분석 도구에 대한 설명으로 알맞은 답을 보기에서 찾아 작성하시오

1. 소스코드의 **실행 없이**, 코드의 **의미를 분석하여 결함을 찾아내는** 코드분석 기법  
2. 소스코드를 **실행하여 프로그램의 동작이나 결과를 확인**하고, **메모리 누수, 스레드 결함** 등을 분석하는 기법

**답:**  
1) STATIC  
2) DYNAMIC

---
### 📌 애플리케이션 테스트 유형 분류

#### 1. 프로그램 실행 여부에 따른 분류

| 구분                | 설명                                                          |
|---------------------|---------------------------------------------------------------|
| **정적 테스트**      | 프로그램을 **실행하지 않고** 문서나 코드 리뷰로 결함을 찾음 (ex. 코드리뷰, 정적분석 도구) |
| **동적 테스트**      | 프로그램을 **실제로 실행**해 동작을 확인하고 오류를 찾음 (ex. 단위 테스트, 통합 테스트) |

---

#### 2. 테스트 기법에 따른 분류

| 구분                | 설명                                                  |
|---------------------|-------------------------------------------------------|
| **화이트박스 테스트** | 내부 코드 구조를 알고 테스트하는 방식                  |
| **블랙박스 테스트**   | 내부 구조 모른 채 입력과 출력으로만 테스트하는 방식      |

---

#### 3. 테스트 시각에 따른 분류

| 구분                | 설명                                               |
|---------------------|----------------------------------------------------|
| **검증 테스트**      | 제품이 요구사항을 **정확히 충족하는지** 검사           |
| **확인 테스트**      | 사용자의 요구에 맞게 **잘 동작하는지** 확인           |

---

#### 기타 테스트 목적별 분류

| 테스트 목적          | 설명                                                      |
|---------------------|-----------------------------------------------------------|
| **회복 테스트**      | 고의로 실패를 유도해 시스템 복구 능력을 평가                  |
| **안전 테스트**      | 시스템 보안 취약점 점검                                    |
| **강도 테스트**      | 과도한 부하를 줘 시스템 안정성 평가                        |
| **성능 테스트**      | 응답시간, 처리량, 자원 사용량 측정                          |
| **구조 테스트**      | 코드 복잡도, 분기 구조 분석                                |
| **회귀 테스트**      | 수정 후 기존 기능에 문제 없는지 확인                        |
| **병행 테스트**      | 변경 시스템과 기존 시스템을 동일 입력으로 비교               |
| **A/B 테스트**       | 두 버전 중 어떤 게 더 나은지 사용자 반응 비교                 |
| **스모크 테스트**    | 빌드 후 핵심 기능들이 작동하는지 빠르게 확인                  |

---

#### 테스트 기반 분류

| 분류                | 설명                                               |
|---------------------|----------------------------------------------------|
| **명세 기반 테스트** | 요구사항 명세서에 따라 테스트 (= 블랙박스 테스트)     |
| **구조 기반 테스트** | 코드 구조를 기반으로 테스트 (= 화이트박스 테스트)     |
| **경험 기반 테스트** | 테스터의 경험과 직관으로 수행하는 테스트              |

---

**쉽게 말해**  
- 정적은 실행 없이 검사, 동적은 직접 실행하며 확인  
- 화이트박스는 내부 들여다보고, 블랙박스는 겉만 보고 판단  
- 검증은 요구사항 맞는지, 확인은 사용자 입장에서 잘 되는지  
- 회복, 안전, 성능 등 목적에 따라 다양한 테스트가 있음  
- 명세, 코드, 경험 세 가지 관점으로 테스트가 나뉨  


 -------------------------------------------------------------------------------------------------------


### 문제 7)
아래에 설명하는 테스트 도구를 쓰시오.

- 자바 프로그래밍 언어용 **유닛 테스트 프레임워크**  
- 테스트 결과는 **TEST 클래스**로 개발자에게 테스트 방법 및 클래스의 **HISTORY**를 공유 가능  
- **어노테이션**으로 간결하게 지원

**답: JUNIT**

---

### 📌 관련 개념 설명

### 📌 JUnit 한눈에 정리

- **JUnit**  
  자바용 단위 테스트 프레임워크로, 작성한 코드가 제대로 동작하는지 자동으로 검사해줌.  
  어노테이션(@Test 등)으로 테스트 쉽게 만들고, 반복 실행 가능해서 자동화에 딱임.

---

| 어노테이션    | 역할                              |
|---------------|----------------------------------|
| `@Test`       | 테스트할 메서드 표시              |
| `@BeforeEach` | 각 테스트 실행 전 준비 작업 수행 |
| `@AfterEach`  | 각 테스트 후 정리 작업 수행      |
| `@BeforeAll`  | 모든 테스트 시작 전에 딱 한 번 수행 (static) |
| `@AfterAll`   | 모든 테스트 끝나고 딱 한 번 수행 (static) |
| `@Disabled`   | 해당 테스트 실행 안 함            |

---

#### ✅ JUnit 사용 예시 (Java)

```java
import org.junit.jupiter.api.*;

public class CalculatorTest {

    Calculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new Calculator();
    }

    @Test
    void testAdd() {
        Assertions.assertEquals(5, calculator.add(2, 3));
    }

    @AfterEach
    void tearDown() {
        calculator = null;
    }
}

✅ JUnit 장점
코드 품질 향상과 유지보수 편리

리팩토링 시 기능 오류 빠르게 발견

CI/CD 환경에서 자동화 테스트에 필수적

 -------------------------------------------------------------------------------------------------------
### 문제 8) 블랙박스 테스트 기법 3가지 고르기


1. EQUIVALENCE PARTITIONING  
2. BOUNDARY VALUE ANALYSIS  
3. BASE PATH TEST  
4. LOOP TEST  
5. DECISION COVERAGE  
6. CAUSE-EFFECT GRAPH

답: 1, 2, 6

---

### 블랙박스 테스트 기법 쉽게 이해하기

1. **동등분할기법 (Equivalence Partitioning)**  
   - 입력값을 비슷한 그룹(동등 클래스)으로 나누고, 각 그룹에서 대표값만 테스트하는 방법  
   - 예: 나이를 0~17, 18~59, 60~120으로 나누고 각 구간 대표값만 검사  

2. **경계값 분석 (Boundary Value Analysis)**  
   - 오류가 자주 발생하는 입력값의 경계(최소, 최대, 그 바로 위/아래)를 집중 테스트  
   - 예: 입력 범위 1~100일 때 1, 2, 99, 100을 주로 검사  

6. **원인-효과 그래프 검사 (Cause-Effect Graphing)**  
   - 입력 조건(원인)과 결과(효과) 관계를 그래프로 그려서, 중요한 테스트 케이스를 뽑는 방법  
   - 복잡한 조건을 체계적으로 분석해 효율적인 테스트 케이스 설계 가능  

---

### 참고: 화이트박스 테스트 기법은 아님!

- BASE PATH TEST  
- LOOP TEST  
- DECISION COVERAGE  

이들은 내부 구조를 분석하는 화이트박스 테스트 기법임!

---

**딱 정리하면:**  
블랙박스 테스트는 ‘속은 안보고 결과만 보고’ 테스트하는 기법!  
입력값을 그룹으로 나누고, 경계값을 집중 공략하고, 조건과 결과를 논리적으로 분석해서 좋은 테스트 케이스를 만드는 방법들임.



 -------------------------------------------------------------------------------------------------------

### 문제 9) 설명에 대한 영어 약자 쓰기

**답:** ISMS

---

### 해설 및 추가 설명

- **ISMS (Information Security Management System)**  
  기업이 중요한 정보를 안전하게 지키려고 만든 체계적인 관리 시스템이야.  
  여기엔 보안 정책, 책임자 지정, 자산 관리, 접근 통제, 사고 대응 같은 보안 절차가 포함돼.  
- **ISMS 인증**은 제3자 기관이 이 시스템이 국제 표준(예: ISO/IEC 27001)을 잘 지키는지 평가해서 주는 인증이야.  
- 인증을 받으면 회사가 정보 보호를 제대로 하고 있다는 걸 객관적으로 증명하는 거라 신뢰도가 팍 올라감.

---

### 관련 용어 한눈에 보기

| 약어    | 설명                                  |
|---------|-------------------------------------|
| **PIMS**   | 개인정보 보호에 집중한 관리체계 인증  |
| **ISMS-P** | ISMS랑 PIMS 합친, 정보보호+개인정보 보호 인증 |
| **ITSEC**  | 유럽에서 만든 정보보안 평가 기준      |
| **TCSEC**  | 미국 국방부 기준 컴퓨터 보안 평가      |
| **CC**     | 전 세계적으로 쓰이는 정보보안 제품 평가 |

---

### 짧고 굵은 정리

ISMS 인증 = 회사가 정보보호 체계 잘 만들고 운영하는지 공식 인증받는 것 →  
정보보안 믿을 만 하다 인정받는 셈임.

 -------------------------------------------------------------------------------------------------------
문제 10) 다음은 데이터베이스 키에 대한 설명이다. 빈칸에 들어갈 내용을 알맞게 쓰시오

1. 슈퍼키는 (1)의 속성을 갖는다.  
2. 후보키는 (1)과 (2)의 속성을 갖는다.

답:  
1) 유일성  
2) 최소성

---
### 해설: 슈퍼키 vs 후보키 쉽게 이해하기

- **슈퍼키 (Super Key)**  
  - 테이블에서 한 행(row)을 딱 하나만 가리킬 수 있는 속성들의 묶음  
  - 예: 학생 테이블에서 (학번), (이름, 전화번호), (학번, 이름) 모두 슈퍼키가 될 수 있음  
  - 중요한 건 **유일성(중복 없음)**이 꼭 지켜져야 함  

- **후보키 (Candidate Key)**  
  - 슈퍼키 중에서 **딱 필요한 최소한의 속성만 남긴 것**  
  - 즉, 하나라도 빼면 유일성을 잃어버리는 그런 키  
  - 예: (학번)은 후보키가 될 수 있는데, (학번, 이름)에서 이름 빼도 충분히 구분 가능하니 (학번, 이름)은 후보키 아님  
  - 후보키는 유일성 + **최소성**을 모두 만족  

- **쉽게 정리하면**  
  슈퍼키 = 유일성 있는 모든 키 후보  
  후보키 = 슈퍼키 중에서 쓸데없는 거 뺀 핵심 키  

- 후보키 중 하나를 골라 기본키(primary key)로 지정한다!




 -------------------------------------------------------------------------------------------------------

문제 11) 다음에서 설명하는 공격유형을 쓰시오

이 공격은 APT 공격에서 주로 쓰이는 공격이며, 타겟이 자주 들어가는 홈페이지를 파악했다가,  
그 홈페이지의 취약점을 통해 악성코드를 심어 사용자가 모르게  
해당 악성코드를 다운받게 하고, 다운로드 된 악성코드를 통해 공격하는 방식을 취한다.  

답: WATERING HOLE

---

### 워터링 홀(Watering Hole) 공격 쉽게 이해하기

- 공격자가 목표(예: 특정 회사 직원)가 자주 방문하는 **믿을 만한 웹사이트**를 골라  
- 그 사이트에 몰래 **악성코드**를 심는다  
- 피해자는 자신이 평소 다니던 사이트에서 감염되고, 공격자는 내부 정보 훔치거나 네트워크 침투 가능  

---

### 핵심 특징  
- **은밀함**: 사용자도 모르게 감염돼서 발견하기 어렵다  
- **표적 공격**: 특정 조직이나 사람만 노린다  
- **복합 공격**: 최신 취약점(제로데이) 활용해 방어 우회  

---

### 대응 방법  
- 자주 가는 사이트 보안 철저히 하기  
- 웹 방화벽(WAF) 설치  
- 사용자 보안 교육 강화  
- 최신 보안 업데이트 꾸준히 적용  


 -------------------------------------------------------------------------------------------------------

문제 12) 다음 V모델에서 테스트 단계에 대한 설명으로 괄호 안에 들어갈 내용을 쓰시오

요구사항분석 (4)
↓ 		    ↑
기능명세 분석 (3)
↓ 		    ↑
설계		     (2)
↓ 		     ↑
개발 		    (1)

답:  
1) 단위 테스트  
2) 통합 테스트  
3) 시스템 테스트  
4) 인수 테스트

---

#### V모델(Verification and Validation Model) 쉽게 정리

- V모델은 소프트웨어 개발 각 단계와 테스트 단계를 쌍으로 연결한 방식  
- 개발하면서 바로바로 대응하는 테스트를 해서 문제를 빨리 찾고 고침  

---

### 각 단계와 대응 테스트

| 개발 단계          | 대응 테스트             | 설명                                   |
|--------------------|------------------------|--------------------------------------|
| 요구사항 분석       | 인수 테스트 (Acceptance Test) | 실제 사용자 입장에서 요구사항 충족 확인 |
| 기능 명세 분석      | 시스템 테스트 (System Test)     | 전체 시스템이 명세대로 동작하는지 검사  |
| 설계 단계          | 통합 테스트 (Integration Test) | 여러 모듈 연결 후 인터페이스 확인      |
| 구현 단계          | 단위 테스트 (Unit Test)         | 각 모듈별 기능이 제대로 동작하는지 점검  |

---

### 핵심  
- 개발 단계가 내려갈수록 테스트도 구체적이고 작아짐  
- 테스트 단계는 개발 단계의 결과물이 제대로 됐는지 검증하는 것  
- 문제를 초기에 잡아내고 수정하기 좋아서 품질 관리에 최고임  


 -------------------------------------------------------------------------------------------------------
문제 13) 다음 SQL 결과에 알맞는 쿼리를 작성하시오

| NAME | SCORE |
|------|-------|
| LEE  | 95    |
| KIM  | 90    |
| SONG | 60    |

```sql
SELECT NAME, SCORE FROM 성적 (1) BY (2) (3)

답:

ORDER

SCORE

DESC

해설
ORDER BY 절은 결과를 특정 컬럼을 기준으로 정렬할 때 사용
(1) BY (2) (3)은 각각 ORDER BY SCORE DESC로 채워져야 함
SCORE 컬럼 기준으로 내림차순 정렬(DESC)하여 점수가 높은 순서대로 출력됨
 -------------------------------------------------------------------------------------------------------
### 문제 14) 파이썬 리스트 함수 선택

1. 요소를 확장해주는 역할을 하며, 모든 항목을 하나씩 리스트에 추가  
2. 리스트 내부 요소를 꺼내면서 삭제 후 반환  
3. 리스트 내부 요소의 순서를 뒤집음

---

### 답  
1) `extend`  
2) `pop`  
3) `reverse`

---

### 해설  
- `extend`: 리스트에 다른 리스트나 반복 가능한 객체의 모든 요소를 하나씩 쭉 추가함  
- `pop`: 리스트에서 마지막 요소(기본)나 지정한 인덱스 요소를 꺼내고 삭제한 뒤 그 값을 반환  
- `reverse`: 리스트 내 요소들의 순서를 완전 뒤집음  

---

**예시**

```python
lst = [1, 2, 3]
lst.extend([4, 5])   # lst -> [1, 2, 3, 4, 5]

val = lst.pop()      # val=5, lst -> [1, 2, 3, 4]

lst.reverse()        # lst -> [4, 3, 2, 1]


 -------------------------------------------------------------------------------------------------------
문제 15) 다음 파이썬 코드에서 출력되는 결과를 작성하시오

def func1(num1, num2=2):                       # 'func1'이라는 함수를 정의했다.
                                               # num1: 필수 매개변수 (값을 꼭 넘겨줘야 함)
                                                 # num2=2: 기본 매개변수. num2에 값이 안 넘어오면 기본적으로 2를 사용한다.
    print('a=', num1, 'b=', num2)                   # 'a=' 다음에 num1 값, 'b=' 다음에 num2 값을 출력한다.

func1(20)                                             # 'func1' 함수를 호출하면서 'num1'에만 20을 넘겨줬다.
                                                        # 'num2'는 값을 넘겨주지 않았으므로, 기본값인 2가 사용된다.
                                                            # 따라서 'num1'은 20, 'num2'는 2가 된다.
✅최종 결과
a= 20 b= 2 

 -------------------------------------------------------------------------------------------------------
문제 16) 다음 java 코드 중 밑줄에 들어갈 알맞은 코드를 작성하시오.

class Car implements Runnable {                   // (1) Car 클래스가 Runnable 인터페이스를 구현(implements)했다.
                                                       // Runnable 인터페이스는 run() 메소드를 포함하고 있어서,
                                                 // Car 클래스는 run() 메소드를 반드시 구현해야 한다.
                                                   // (근데 여기 코드에는 run()이 없네? 그럼 컴파일 에러 나는데,
                                                     // 일단 문제 의도는 빈칸 채우기니까 Car가 맞다고 보자.
                                                         // 실제 코드라면 run() 메소드를 추가해야 함.)
    int a;
    public void fun(){
        System.out.println("func call");
    }
                                                  // 여기에 public void run() { /* 스레드가 실행할 코드 */ } 가 있어야 정상 작동함
}

public class Main {
    public static void main (String [] args){
                                                                              // (2) Thread 객체를 생성할 때, Runnable 인터페이스를 구현한 객체를 인자로 넘겨줘야 한다.
                                                                              //     Car 클래스가 Runnable을 구현했으니, 'new Car()'를 여기에 넣는 거지.
        Thread t1 = new Thread(new Car());
        t1.start();                                           // (3) 스레드를 시작한다. 이러면 위에 있는 Car 클래스의 run() 메소드가 호출됨.
                                                        //     (만약 Car에 run() 메소드가 없으면 실행이 제대로 안 되거나 에러 남.)
    }
}

✅최종 결과
Car

이 코드는 자바에서 **멀티스레딩(Multithreading)**을 구현하는 방법 중 하나인 Runnable 인터페이스를 사용하는 방식이야.
Thread 객체를 만들 때 Runnable을 구현한 클래스의 인스턴스를 넘겨줘야 하거든.

```java
class Car implements Runnable { // (1) Car 클래스가 Runnable 인터페이스를 구현(implements)했다.
                               // Runnable 인터페이스는 run() 메소드를 포함하고 있어서,
                               // Car 클래스는 run() 메소드를 반드시 구현해야 한다.
                               // (근데 여기 코드에는 run()이 없네? 그럼 컴파일 에러 나는데,
                               // 일단 문제 의도는 빈칸 채우기니까 Car가 맞다고 보자.
                               // 실제 코드라면 run() 메소드를 추가해야 함.)
    int a;
    public void fun(){
        System.out.println("func call");
    }
    // 여기에 public void run() { /* 스레드가 실행할 코드 */ } 가 있어야 정상 작동함
}

public class Main {
    public static void main (String [] args){
                      // (2) Thread 객체를 생성할 때, Runnable 인터페이스를 구현한 객체를 인자로 넘겨줘야 한다.
                        //     Car 클래스가 Runnable을 구현했으니, 'new Car()'를 여기에 넣는 거지.
        Thread t1 = new Thread(new Car());
        t1.start();                     // (3) 스레드를 시작한다. 이러면 위에 있는 Car 클래스의 run() 메소드가 호출됨.
                                    //     (만약 Car에 run() 메소드가 없으면 실행이 제대로 안 되거나 에러 남.)
    }
}


왜 Car가 들어가야 하냐고?
자바에서 스레드를 만들고 실행하는 방법은 크게 두 가지야:

Thread 클래스를 **상속(extends)**받는 방법

Runnable **인터페이스를 구현(implements)**하는 방법

지금 문제 코드를 보면 class Car implements Runnable이라고 되어 있잖아? 즉, Car 클래스는 Runnable 인터페이스를 구현한 클래스라는 거지.

Thread 객체를 생성할 때, new Thread() 괄호 안에 Runnable 타입의 객체를 넣어줄 수 있어.
new ______() 이 빈칸에는 바로 Runnable을 구현한 클래스인 Car의 객체가 들어가야 하는 거다.

그래서 new Car()를 넣으면, Thread t1은 Car 클래스에 정의된 (원래는 있어야 할) run() 메소드를 실행할 준비가 되는 거지.

참고: 이 코드대로라면 Car 클래스에 public void run() 메소드가 없어서 컴파일 에러가 난다.
 Runnable 인터페이스를 구현하려면 run() 메소드를 반드시 오버라이딩해야 하거든. 이건 문제의 함정일 수도 있고, 아니면 그냥 빈칸 채우는 의도만 가진 문제일 수도 있음.
 -------------------------------------------------------------------------------------------------------

문제 17) 다음 java 프로그램의 결과를 쓰시오

class A {
    int a;                       // 'a'라는 정수형 멤버 변수
    int b;                       // 'b'라는 정수형 멤버 변수
}

public class Main {
    static void func1(A a){                     // func1 메소드: A 타입 객체의 참조값을 받아서 그 객체의 'a' 멤버에 10을 곱한다.
        a.a *= 10;
    }
    static void func2(A a){                           // func2 메소드: A 타입 객체의 참조값을 받아서 그 객체의 'a' 멤버에 'b' 멤버를 더한다.
        a.a += a.b;
    }

    public static void main(String[] args) {
        A a = new A();                                   // (1) 'A' 클래스의 새로운 객체를 만들고, 그 객체를 가리키는 참조 변수 'a'를 선언한다.
                                                       //    초기에는 a.a와 a.b 모두 기본값인 0으로 초기화된다.

        a.a = 100;                                     // (2) 객체 'a'의 멤버 변수 'a.a'에 100을 할당한다.
                                                             //    현재 객체 상태: {a=100, b=0}

        func1(a);                                          // (3) func1 메소드를 호출하면서 객체 'a'의 참조값을 넘겨준다.
                                                             //    func1 안에서 a.a *= 10; 이 실행되므로, 원본 객체 'a'의 'a.a' 값도 바뀐다.
                                                             //    a.a = 100 * 10 = 1000이 된다.
                                                             //    현재 객체 상태: {a=1000, b=0}

        a.b = a.a;                                           // (4) 객체 'a'의 멤버 변수 'a.b'에 현재 'a.a'의 값(1000)을 할당한다.
                                                                 //    현재 객체 상태: {a=1000, b=1000}

        func2(a);                                                // (5) func2 메소드를 호출하면서 객체 'a'의 참조값을 넘겨준다.
                                                                   //    func2 안에서 a.a += a.b; 이 실행되므로, 원본 객체 'a'의 'a.a' 값도 바뀐다.
                                                                   //    a.a = a.a (1000) + a.b (1000) = 2000이 된다.
                                                                   //    현재 객체 상태: {a=2000, b=1000}

        System.out.println(a.a);                                     // (6) 최종적으로 객체 'a'의 멤버 변수 'a.a' 값을 출력한다.
    }
}

✅최종 결과
2000



 -------------------------------------------------------------------------------------------------------

문제 18) 다음 c언어 프로그램의 출력결과를 쓰시오.  
(단 입력값은 5가 들어왔다고 가정한다.)

```c
#include<stdio.h>                     // 표준 입출력 함수를 사용하기 위한 헤더 파일

                                          // func 함수: 재귀적으로 숫자를 계산한다.
int func(int i){
    if(i <= 1) return 1;                 // (1) 기저 조건(Base Case): i가 1 이하(1 또는 0 또는 음수)이면 1을 반환하고 재귀 호출을 멈춘다.
    return i * func(i-2);                 // (2) 재귀 호출: 현재 i 값에 'i-2'를 인자로 func 함수를 다시 호출한 결과를 곱한다.
                                                //     즉, 2씩 감소하면서 곱하는 형태.
}

int main(){
    int in;                                 // 사용자 입력을 받을 정수형 변수 'in' 선언.
    scanf("%d", &in);                           // 사용자로부터 정수를 입력받아 'in' 변수에 저장한다.
                                         // 문제 답이 15라는 건, 'in'에 특정 숫자가 입력되었을 때 그 결과가 15라는 뜻이다.
                                         // 15를 유도하는 'in' 값은 5일 때다. (아래 계산 과정 참고)
                                             // 즉, 사용자가 5를 입력했다고 가정하고 문제를 푼다.

    printf("%d", func(in));                           // func 함수에 'in' 값을 넘겨 계산한 결과를 출력한다.
}

✅최종 결과
15


func(5)의 계산 과정 (입력값이 5일 때)  
사용자가 5를 입력했다고 가정하고 func(5)의 호출 흐름을 따라가 보자.

func(5)  
i가 5이므로 i <= 1 조건 False.  

return 5 * func(5 - 2) ➡️ 5 * func(3)  

func(3)  
i가 3이므로 i <= 1 조건 False.  

return 3 * func(3 - 2) ➡️ 3 * func(1)  

func(1)  
i가 1이므로 i <= 1 조건 True.  

return 1 (기저 조건 도달, 재귀 종료)  

이제 역순으로 값을 합쳐보자.

func(1)은 1을 반환  

func(3)은 3 * func(1) 이었으므로, 3 * 1 = 3을 반환  

func(5)은 5 * func(3) 이었으므로, 5 * 3 = 15를 반환  
 -------------------------------------------------------------------------------------------------------

## 📘 정보처리기사 실기 - C언어 수치 처리 문제

### 문제 19)
다음 C언어 프로그램의 괄호 안에 들어갈 알맞은 답을 작성하시오.

#include<stdio.h> // 표준 입출력 함수 쓰려고 포함시키는 헤더 파일

int main(){
    int num = 1234;                       // 원본 숫자. 이걸 거꾸로 만들 거다.
    int div = 10;                         // 10으로 나누고 나머지 구하는 데 쓸 숫자. 자릿수 분리용.
    int res = 0;                            // 결과를 저장할 변수. 처음엔 0으로 시작.

    while(num > 0){                             // ① 여기에 '>'가 들어가야 한다.
                                              // 'num'이 0보다 클 때만 계속 반복하라는 뜻.
                                              // 'num'이 0이 되면 모든 자릿수를 다 처리했다는 거니까 루프를 멈춰야지.
        res = res * div;                         // 현재 'res' 값에 10을 곱한다.
                                                 // 이렇게 하면 'res'에 이미 저장된 숫자들을 왼쪽으로 한 칸씩 미는 효과가 난다.
                                                         // (예: res가 4였으면 40이 됨)

        res = res + num % div;                                       // ② 여기에 '%'가 들어가야 한다.
                                                           // 'num % div'는 'num'을 'div'로 나눈 **나머지**를 구하는 연산이다.
                                                       // 예를 들어 1234 % 10 하면 4가 나온다. 이게 가장 오른쪽 자릿수지.
                                                                           // 이 나머지를 'res'에 더해서 새로운 숫자의 자릿수로 붙인다.

        num = num / div;                         // ③ 여기에 '/'가 들어가야 한다.
                                                     // 'num = num / div'는 'num'을 'div'로 나눈 **몫**을 다시 'num'에 저장한다.
                                                   // 예를 들어 1234 / 10 하면 123이 나온다. 가장 오른쪽 자릿수를 제거하는 거지.
    }
                                                            // 루프 과정 추적: (num=1234, div=10, res=0)
                                                            // 1. num = 1234 (0보다 큼)
                                                            //    res = 0 * 10 = 0
                                                            //    res = 0 + 1234 % 10 = 0 + 4 = 4
                                                            //    num = 1234 / 10 = 123
                                                        
                                                            // 2. num = 123 (0보다 큼)
                                                            //    res = 4 * 10 = 40
                                                            //    res = 40 + 123 % 10 = 40 + 3 = 43
                                                            //    num = 123 / 10 = 12
                                                        
                                                            // 3. num = 12 (0보다 큼)
                                                            //    res = 43 * 10 = 430
                                                            //    res = 430 + 12 % 10 = 430 + 2 = 432
                                                            //    num = 12 / 10 = 1
                                                        
                                                            // 4. num = 1 (0보다 큼)
                                                            //    res = 432 * 10 = 4320
                                                            //    res = 4320 + 1 % 10 = 4320 + 1 = 4321
                                                            //    num = 1 / 10 = 0
                                                        
                                                            // 5. num = 0 (0보다 크지 않음) -> 루프 종료

    printf("%d", res); // 최종 'res' 값인 4321을 출력한다.
}

✅최종 결과

① >

② %

③ /

📌 해설:
최종 요약

>: while문의 조건으로, 숫자가 0보다 클 때까지 반복해서 모든 자릿수를 처리하는 데 사용한다.

%: 숫자의 **가장 오른쪽 자릿수(1의 자리)**를 분리해낼 때 사용하는 나머지 연산자다.

/: 숫자의 가장 오른쪽 자릿수를 제거할 때 사용하는 몫 연산자다.

 -------------------------------------------------------------------------------------------------------

### 문제 20) 다음 C언어 프로그램의 결과를 쓰시오


int isPrime(int number){               // 어떤 숫자가 소수인지 아닌지 판별하는 함수다.
    int i;
    for (i = 2; i < number; i++){           // 2부터 'number' 바로 전까지 반복한다.
        if(number % i == 0)                 // 'number'를 'i'로 나눴을 때 나머지가 0이면 (즉, 나누어 떨어지면)
            return 0;                              // 'number'는 소수가 아니므로 0을 반환하고 함수 종료.
    }
    return 1;                             // 반복문이 끝날 때까지 한 번도 나누어 떨어지지 않았다면, 'number'는 소수이므로 1을 반환한다.
                                          // (참고: 1은 소수가 아니지만, 이 함수는 1 이하의 숫자가 들어오면 무조건 1을 반환하는 문제가 있음.
                                        // 하지만 여기서는 2부터 시작하므로 크게 문제되지 않는다.)
}

int main(void){
    int number = 13195;                                       // 소인수를 찾을 대상 숫자.
    int max_div = 0;                                    // 가장 큰 소인수를 저장할 변수. 0으로 초기화.
    int i;                                                                // 반복문을 위한 변수.

    for(i = 2; i < number; i++)                                 // 'i'가 2부터 'number' 바로 전까지 (13194까지) 반복한다.
                                                                   // 이 루프는 'number'의 약수들을 찾기 위함이다.
        if(isPrime(i) == 1 && number % i == 0)                     // (1) 'i'가 소수이고 (isPrime(i) == 1),
                                                                      // (2) 'number'가 'i'로 나누어 떨어지면 (number % i == 0)
                                                                              //    -> 즉, 'i'가 'number'의 소인수이면
            max_div = i;                                     // 현재 'i' 값을 'max_div'에 저장한다.
                                                                     // 이 루프는 'i'가 증가하면서 계속 업데이트되므로,
                                                                     // 최종적으로 'max_div'에는 'number'의 **가장 큰 소인수**가 남게 된다.

                                                                          // 13195의 소인수를 찾아보자:
                                                                          // 13195 % 2 != 0
                                                                          // 13195 % 3 != 0
                                                                          // 13195 % 5 == 0 -> isPrime(5) == 1 (5는 소수) -> max_div = 5
                                                                          // ...
                                                                          // 13195 % 7 == 0 -> isPrime(7) == 1 (7은 소수) -> max_div = 7
                                                                          // ...
                                                                          // 13195 % 13 == 0 -> isPrime(13) == 1 (13은 소수) -> max_div = 13
                                                                          // ...
                                                                          // 13195 % 19 == 0 -> isPrime(19) == 1 (19는 소수) -> max_div = 19
                                                                          // ...
                                                                          // 13195 % 29 == 0 -> isPrime(29) == 1 (29는 소수) -> max_div = 29
                                                                          // 이제 29보다 큰 수들 중 13195의 약수이면서 소수인 수는 더 이상 없다.
                                                                          // (13195 = 5 * 7 * 13 * 29)
                                                                          // 따라서 루프가 끝나면 max_div에는 29가 저장되어 있다.

    printf("%d", max_div);                                                   // 최종적으로 'max_div' 값을 출력한다.
    return 0;                                                                     // 프로그램 정상 종료.
}

답: 29

 -------------------------------------------------------------------------------------------------------
