## 📘 정보처리기사 실기 - RAID 관련 문제 정리

### 문제 1)
다음 설명에 맞는 RAID 단계를 쓰시오.

- 두개 이상의 하드디스크를 병렬로 연결해, 하나의 하드디스크처럼 이용하는 기술이다  
- 스트라이프 방식으로 구현한다.  
- 데이터가 분산되어 저장하기 때문에 하나의 하드디스크에 문제가 생기면 다른 디스크까지 사용이 불가능해진다.

**답: RAID 0**

---

# ✅ RAID 종류 정리 – 빠르게! 안전하게! 직관적으로!

---

## 📌 RAID란?

> 여러 개의 하드디스크를 묶어서  
> **속도**도 빠르게! **안정성**도 높이기 위한 저장 기술

---

## 🧩 RAID 형태 요약표

| RAID 종류 | 설명 | 갓반인식 요약 |
|-----------|------|---------------|
| ⚡ **RAID-0 (스트라이핑)** | 데이터를 디스크에 나눠서 저장 → **속도 빠름** | “**파일 쪼개서 여러명에게 나눠줌** → 작업 빠름! 근데 한 명만 사라져도 다 끝남” |
| 🛡️ **RAID-1 (미러링)** | 동일한 데이터를 두 디스크에 복사 저장 → **안정성 최고** | “**복사본이 항상 있음** → 하나 고장 나도 문제 없음 (느릴 수 있음)” |
| 🤖 **RAID-2** | 해밍 코드로 에러 수정 → **이론적**, 거의 안 씀 | “컴퓨터 전공자가 좋아할 이론 전용, 실전은 노잼” |
| ⚙️ **RAID-3** | **바이트 단위 스트라이핑 + 패리티 디스크 1개** | “1바이트 단위로 쪼개고 감시자(패리티) 따로 있음” |
| 🔧 **RAID-4** | **블록 단위 스트라이핑 + 패리티 디스크 1개** | “RAID-3을 블록 단위로 바꿈 = 성능 조금 개선” |
| 💎 **RAID-5** | **패리티와 데이터를 전부 디스크에 분산 저장** | “**속도+안정성 균형 최강**! → 기업에서도 많이 씀” |
| 🔐 **RAID-6** | RAID-5 + **패리티 2개 저장** | “**두 개가 동시에 망가져도 복구 가능!** → 더 안전해짐” |

---

## 🔥 갓반인 요약

| 질문 | 답변 |
|------|------|
| 속도 최고인데 위험한 건? | **RAID-0** |
| 느리지만 안전한 건? | **RAID-1** |
| 가장 많이 쓰는 실속형은? | **RAID-5** |
| RAID-5보다 더 안전한 건? | **RAID-6** |

---

## 🎯 정리 한 줄 요약

> RAID-0: **빠르지만 무방비**  
> RAID-1: **느리지만 완전 백업**  
> RAID-5: **빠름 + 안정성의 황금 밸런스**  
> RAID-6: **RAID-5보다 더 안전, 패리티 2개**

📦 **데이터는 소중하니까, RAID는 제대로 알고 쓰자!**



 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 트랜잭션 회복 기법 관련 문제 정리

### 문제 2)
다음은 로그 기반 회복 기법에서 사용되는 명령어이다.  
해당하는 항목을 보기에서 찾아 적으시오.

1. 트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 **재실행하여 복구**를 수행한다.  
2. 트랜잭션 로그를 이용하여 오류와 관련된 내용을 **취소하여 복구**를 수행한다.

**답:**
- 1) REDO  
- 2) UNDO

---
# ✅ 트랜잭션 개념 총정리 – 쉽고 직관적으로 끝내기!

---

## 📌 트랜잭션 회복 기법

| 기법  | 설명 | 갓반인식 예시 |
|-------|------|----------------|
| 🔙 **UNDO** | 실패한 작업을 **되돌림** | “배달앱에서 주문 중 에러 나면 → 주문 취소하고 원래대로 복구” |
| 🔁 **REDO** | 성공한 작업을 **다시 반영** | “정상적으로 주문 완료됐는데, 앱 껐다 켜도 **결제 내역 남아 있음**” |

> UNDO: 에러났을 땐 되돌려!  
> REDO: 끝까지 잘 됐으면 기억해!

---

## 🔐 트랜잭션 4대 특성 – ACID

| 특성 | 설명 | 갓반인 요약 |
|------|------|-------------|
| ⚙️ **원자성 (Atomicity)** | **모두 수행 or 전부 취소** | “편의점에서 3개 사기로 했는데, 하나라도 결제 안 되면 전체 결제 취소” |
| 🔄 **일관성 (Consistency)** | 수행 전후 **데이터 상태 일관** | “이체하면 A 계좌 빠진 만큼 B 계좌 늘어야 함 = 총합은 같아야 해” |
| 🧩 **격리성 (Isolation)** | 동시에 실행돼도 **서로 영향 없음** | “두 명이 동시에 장바구니 계산해도 내 계산엔 너 영향 없어야 함” |
| 💾 **영속성 (Durability)** | 완료된 결과는 **영구 저장** | “앱 꺼도 주문내역은 DB에 그대로 남아있음” |

---

## 🧠 핵심 요약

> 트랜잭션은 **"모두 or 전혀"**,  
> 데이터는 항상 **정상 상태 유지**,  
> 다른 트랜잭션과 **간섭 금지**,  
> 끝낸 건 **영원히 저장!**

---

## 🔥 갓반인 요약 한 방에

- ✅ UNDO: 실패했으면 돌려  
- ✅ REDO: 성공했으면 다시 해  
- ✅ ACID:  
  - A: 전부 or 전혀  
  - C: 데이터 흐름 정상 유지  
  - I: 트랜잭션끼리 싸우지 마  
  - D: 결과는 절대 안 날아가

> 📌 진짜 은행처럼 작동하게 만드는 핵심 원리 = 트랜잭션


 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 데이터베이스 이상현상

### 문제 3)
데이터베이스의 이상현상 중 **삭제이상**에 대해 간략히 서술하시오.

**답:**  
한 튜플을 삭제할 때 **연쇄 삭제 현상**으로 인해 **원하지 않는 정보 손실**이 발생하는 현상

---

# ✅ 이상현상(Anomaly) 완전 정리 – 데이터 꼬임 방지 필수 개념!

---

## 📌 이상현상이란?

> 테이블에 **중복**이나 **종속성 문제** 때문에  
> 데이터 무결성이 깨지는 **비정상적인 현상**  
> → 보통 **정규화를 안 했을 때** 발생함!

---

## 🔍 이상현상의 종류

| 종류 | 설명 | 갓반인식 요약 |
|------|------|----------------|
| 📝 **삽입이상 (Insertion Anomaly)** | 불필요한 정보까지 **강제로 입력**해야 하는 상황 | “강의 추가하려는데, 학생정보도 같이 써야 함…” |
| 🗑️ **삭제이상 (Deletion Anomaly)** | 어떤 정보 지우면 **필요한 정보까지 같이 날아감** | “학생 삭제했더니, 강의 자체도 같이 사라짐…?” |
| ✏️ **갱신이상 (Update Anomaly)** | 중복된 정보 수정 시 **한 군데만 고치면 불일치** | “교수님 이름 바꿨는데, 다른 칸엔 그대로 남아있음…” |

---

## 🚨 삭제이상 예시로 완전 이해

| 학생이름 | 학번 | 강의명   |
|----------|------|----------|
| 홍길동   | 1001 | DB개론   |
| 김영희   | 1002 | DB개론   |
| 이철수   | 1003 |          |

> 💣 이철수 정보 삭제 → DB개론 자체가 날아감  
> → 학생 삭제했을 뿐인데 **강의 정보까지 손실**  
> → **삭제이상 발생!**

---

## ✅ 핵심 요약

- **이상현상 = 데이터가 꼬이는 현상**
- 삽입할 때 불편하고, 삭제하면 위험하고, 수정하면 헷갈림
- 💡 **정규화**를 통해 예방 가능!

---

## 🔧 갓반인 한줄 요약

> 데이터 테이블 잘못 만들면,  
> 넣을 때 귀찮고, 지울 때 위험하고, 고칠 때 골치 아픔.  
> 그래서 **정규화**가 약이자 해답임!


 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 네트워크 보안 프로토콜

### 문제 4)
아래 임시 키 무결성 프로토콜의 영문 약어를 쓰시오.

> 임시 키 무결성 프로토콜은 IEEE 802.11의 무선 네트워킹 표준으로 사용되는 보안 프로토콜이다.  
> 임시 키 무결성 프로토콜은 IEEE 802.11i의 작업 그룹과 와이파이 얼라이언스에서 WEP를  
> 하드웨어 교체 없이 대체하기 위해 고안되었다.

**답: TKIP**

---

# ✅ TKIP, WPA, WPA2 완전정리 – 무선 보안 핵심 개념

---

## 📌 TKIP (Temporal Key Integrity Protocol)

TKIP는 옛날에 쓰던 **WEP 보안의 구멍**을 메우기 위해 등장한 무선 보안 프로토콜이야.

| 특징 | 설명 |
|------|------|
| 🔒 **보안 강화 목적** | WEP보다 강한 보안 제공 |
| 🔧 **기존 장비 호환** | WEP 장비 그대로 사용 가능 (펌웨어 업그레이드만으로 적용) |
| 📦 **패킷별 키 사용** | 같은 데이터여도 매번 다른 키로 암호화함 (`Per-packet key`) |
| 🧪 **무결성 검사** | 메시지가 중간에 바뀌었는지 확인하는 `MIC` 기능 포함 |
| 🚫 **재전송 공격 방지** | 이전에 썼던 패킷 다시 보내는 공격 차단 |

> 💬 쉽게 말해:  
> TKIP는 **“WEP 리폼 버전”** → 기존 장비 바꾸지 않고도 쓸 수 있는 **임시 보안 패치**

---

## 📌 WPA vs WPA2 차이점

| 구분       | WPA                            | WPA2                    |
|------------|----------------------------------|--------------------------|
| 🔐 **암호화 방식** | TKIP                         | **AES** (더 강력하고 최신) |
| 🛡️ **보안 수준**   | 중간 (WEP보단 좋고 WPA2보단 약함) | **강력한 보안 제공**       |
| 📜 **표준**       | IEEE 802.11i (부분 적용)      | IEEE 802.11i (완전 적용)  |
| 🧠 **핵심 기술**   | TKIP                         | AES + CCMP              |

> 💬 갓반인 감성 요약:
> - **WEP**: 물 샌다  
> - **TKIP**: 대충 땜빵함  
> - **WPA**: 땜빵 기반 보안  
> - **WPA2**: 아예 새로 단단히 지음 (AES로 완전 무장)

---

## ✅ 한 줄 요약

**TKIP는 WEP 보완용, WPA는 TKIP 기반, WPA2는 AES 기반으로 가장 안전한 무선 보안 체계다!**

 -------------------------------------------------------------------------------------------------------

### 문제 5) 아래 설명하는 내용을 영문 약자로 쓰시오

> 특별한 하드웨어 없이 인간의 자연스러운 움직임을 인식하여 정보를 제공한다.

**답: NUI (Natural User Interface)**

---

# ✅ UI 설계 원칙 – 갓반인도 바로 이해하는 핵심 정리

---

## 📌 UI 설계 4대 원칙

| 원칙       | 설명                                                                 |
|------------|----------------------------------------------------------------------|
| 🎯 **직관성** | 버튼이나 메뉴가 **딱 보면 뭔지 바로 이해**돼야 함<br>예: 휴지통 아이콘 = 삭제 |
| ✅ **유효성** | 사용자가 **원하는 걸 정확하고 쉽게** 달성할 수 있어야 함               |
| 🧠 **학습성** | 처음 써보는 사람도 **빠르게 익히고 사용할 수 있어야 함**                 |
| 🔁 **유연성** | 다양한 사용자 상황에도 맞게 작동하면서 **오류는 최소화**해야 함           |

---

## 📌 쉽게 이해하는 예시

- 🔘 버튼에 "확인" 말고 **"저장하기"**라고 쓰면 → 직관성 Good  
- 💡 회원가입할 때 필수 항목만 받고, 절차 간단하게 → 유효성 Good  
- 🧭 처음 접속해도 네비게이션 바로 이해 가능 → 학습성 Good  
- 🔄 입력하다 실수해도 **자동 저장** or **취소 버튼** → 유연성 Good  

---

## 🧾 참고: NUI는 뭐임?

> 👋 **NUI (Natural User Interface)**  
> 마우스나 키보드 없이, **손짓, 목소리, 얼굴 인식** 등 **자연스러운 행동**으로 조작하는 UI

예:  
- 스마트폰에서 손짓으로 화면 넘기기  
- 얼굴 인식 잠금 해제  
- 음성으로 "알람 맞춰줘" 하기

---

## ✅ 요약

**UI 설계의 핵심은 누구나 쉽게, 정확히, 빠르게, 유연하게 사용할 수 있게 만드는 것!**  
좋은 UI는 말 안 해도 딱 보면 다 알 수 있어야 함 😎



 -------------------------------------------------------------------------------------------------------

## 📘 정보처리기사 실기 - 소스코드 분석 도구 및 테스트 유형 분류

### 문제 6)
다음 소스코드 분석 도구에 대한 설명으로 알맞은 답을 보기에서 찾아 작성하시오

1. 소스코드의 **실행 없이**, 코드의 **의미를 분석하여 결함을 찾아내는** 코드분석 기법  
2. 소스코드를 **실행하여 프로그램의 동작이나 결과를 확인**하고, **메모리 누수, 스레드 결함** 등을 분석하는 기법

**답:**  
1) STATIC  
2) DYNAMIC

---
# ✅ 애플리케이션 테스트 유형 총정리 – 쉽고 빠르게 이해하기

---

## 1️⃣ 프로그램 실행 여부에 따른 분류

| 종류         | 설명                                                      | 갓반인 쉬운 예시                      |
|--------------|-----------------------------------------------------------|-------------------------------------|
| 🔍 **정적 테스트**  | 프로그램 **실행 안 하고** 코드나 문서 리뷰로 결함 찾기             | 코드 읽어보고 문법, 버그 없는지 점검             |
| ▶️ **동적 테스트**  | 프로그램 **실제로 실행**해서 동작과 오류 확인                   | 프로그램 돌려서 기능 제대로 작동하는지 확인         |

---

## 2️⃣ 테스트 기법에 따른 분류

| 종류             | 설명                                         | 갓반인 쉬운 예시                    |
|------------------|----------------------------------------------|-----------------------------------|
| 🧰 **화이트박스 테스트** | 내부 코드 구조 알고 테스트 (코드 깊숙이 분석)             | 요리법(코드) 다 알면서 맛 평가하기           |
| 📦 **블랙박스 테스트**   | 내부 모르는 상태에서 입력과 출력만 보고 테스트            | 선물 상자 열어보기 전 안 내용 모르는 상태에서 평가 |

---

## 3️⃣ 테스트 시각에 따른 분류

| 종류         | 설명                                     | 갓반인 쉬운 예시                          |
|--------------|------------------------------------------|-----------------------------------------|
| ✔️ **검증 테스트**  | 제품이 요구사항대로 정확히 만들어졌는지 검사               | "설계도대로 집이 지어졌나?" 확인           |
| 🕵️ **확인 테스트**  | 사용자 입장에서 제대로 작동하는지 확인                     | "집에서 전기, 수도 다 잘 작동하나?" 체험 테스트 |

---

## 4️⃣ 기타 목적별 테스트

| 테스트 종류     | 설명                                              | 갓반인 쉬운 예시                       |
|----------------|---------------------------------------------------|--------------------------------------|
| 🔄 **회복 테스트**  | 일부러 고장 내고, 복구 잘 되는지 테스트                    | 정전 시 발전기 작동 여부 확인               |
| 🔐 **안전 테스트**  | 시스템 보안 취약점 점검                                | 도둑 침입 막는 경보 시스템 점검             |
| 💪 **강도 테스트**  | 과부하 줘도 시스템 잘 버티는지 검사                      | 사람이 너무 몰려도 엘리베이터 정상 작동 확인    |
| ⚡ **성능 테스트**  | 속도, 처리량, 자원 사용량 측정                           | 자동차 가속력, 연비 테스트                  |
| 🧱 **구조 테스트**  | 코드 복잡도, 분기 등 내부 구조 분석                       | 집 구조 안전 점검                          |
| 🔁 **회귀 테스트**  | 수정 후 기존 기능 문제 없는지 확인                         | 리모델링 후 기존 설비 문제 없는지 확인          |
| ⚖️ **병행 테스트**  | 변경 시스템과 기존 시스템 동일 입력으로 비교                  | 신형, 구형 자동차 성능 비교                    |
| 📊 **A/B 테스트**  | 두 버전 중 사용자 반응 비교                               | 두 광고 중 어떤 게 더 인기 많은지 실험           |
| 🚦 **스모크 테스트** | 빌드 후 핵심 기능 빠르게 점검                              | 집 짓고 바로 가스, 전기 켜보는 것과 같음          |

---

## 5️⃣ 테스트 기반 분류

| 종류               | 설명                                  | 갓반인 쉬운 예시                      |
|--------------------|-------------------------------------|------------------------------------|
| 📜 **명세 기반 테스트** | 요구사항 문서 따라 테스트 (= 블랙박스)     | 요리법 따라 음식 맛 평가              |
| 🏗️ **구조 기반 테스트** | 코드 구조 보고 테스트 (= 화이트박스)       | 요리사 조리 과정 직접 점검             |
| 🎯 **경험 기반 테스트** | 테스터 경험과 직관으로 수행                  | 요리사가 직감으로 맛보는 평가           |

---

## 🎯 한 줄 요약

- **정적**: 실행 없이 검사 / **동적**: 실제 실행해 검사  
- **화이트박스**: 속 들여다보고 / **블랙박스**: 겉만 보고 판단  
- **검증**: 설계대로 잘 됐나? / **확인**: 사용자 입장에서 잘 되나?  
- 목적별 테스트 다양 → 복구, 안전, 성능 등 다 다름  
- 테스트는 **문서(명세), 코드(구조), 경험** 세 갈래로 진행됨  

---

## 🔥 갓반인 감성 요약

> 테스트는  
> “**코드 잘 썼나?**(화이트박스)  
> **기능 제대로 되나?**(블랙박스)  
> “설계대로 됐나?(검증)  
> “사용자 만족하나?(확인)”  
> 그리고 다양한 상황에 맞게  
> “고장내고 복구도 테스트!”  
> “부하 주고 성능도 본다!”  
> 이렇게 꼼꼼하게 진행하는 작업임!

 -------------------------------------------------------------------------------------------------------


### 문제 7)
아래에 설명하는 테스트 도구를 쓰시오.

- 자바 프로그래밍 언어용 **유닛 테스트 프레임워크**  
- 테스트 결과는 **TEST 클래스**로 개발자에게 테스트 방법 및 클래스의 **HISTORY**를 공유 가능  
- **어노테이션**으로 간결하게 지원

**답: JUNIT**

---

# ✅ JUnit 한눈에 정리 – 자바 단위 테스트 필수 도구

---

## 📌 JUnit이란?

- 자바 코드가 **정상 작동하는지 자동으로 검사**해주는 단위 테스트 프레임워크  
- `@Test` 같은 **어노테이션**으로 테스트 코드 쉽게 작성 가능  
- 여러 테스트를 **반복 실행**하며 자동화에 최적화됨

---

## 📌 주요 어노테이션과 역할

| 어노테이션      | 역할                                            |
|-----------------|-------------------------------------------------|
| `@Test`         | 테스트할 메서드임을 표시                          |
| `@BeforeEach`   | 각 테스트 실행 **직전에 수행하는 준비 작업**      |
| `@AfterEach`    | 각 테스트 실행 **끝난 후 정리 작업**               |
| `@BeforeAll`    | 모든 테스트 시작 전에 딱 한 번 실행 (static 메서드)  |
| `@AfterAll`     | 모든 테스트가 끝난 후 딱 한 번 실행 (static 메서드)  |
| `@Disabled`     | 해당 테스트를 **실행하지 않도록 비활성화**           |

---

## 🧠 쉽게 이해하는 예시

- `@Test`: “이 함수가 잘 작동하는지 봐줘!”  
- `@BeforeEach`: “테스트하기 전에 준비 운동 해놓기”  
- `@AfterEach`: “테스트 끝나면 정리하고 뒷정리”  
- `@BeforeAll`: “전체 테스트 시작 전에 한 번만 준비”  
- `@AfterAll`: “전체 테스트 끝나고 한 번만 청소”  
- `@Disabled`: “이번 테스트는 잠깐 쉬어가자”

---

## ✅ 요약

JUnit은 자바 개발자가 **코드 검증을 쉽고 빠르게 자동화**하도록 도와주는 도구이며, 어노테이션을 활용해 테스트의 시작과 끝, 실행 여부 등을 간편히 제어할 수 있음!


#### ✅ JUnit 사용 예시 (Java)

```java
import org.junit.jupiter.api.*;

public class CalculatorTest {

    Calculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new Calculator();
    }

    @Test
    void testAdd() {
        Assertions.assertEquals(5, calculator.add(2, 3));
    }

    @AfterEach
    void tearDown() {
        calculator = null;
    }
}

# ✅ JUnit 장점 – 왜 꼭 써야 할까?

- **코드 품질 향상과 유지보수 편리**  
  → 테스트 코드를 통해 버그를 초기에 잡아내고, 코드가 깨지지 않도록 도와줌

- **리팩토링 시 기능 오류 빠르게 발견**  
  → 코드 구조 바꿀 때도 기존 기능이 잘 작동하는지 즉시 확인 가능

- **CI/CD 환경에서 자동화 테스트에 필수적**  
  → 지속적 통합/배포 과정에 테스트 자동화로 안정적인 개발 프로세스 지원

 -------------------------------------------------------------------------------------------------------
### 문제 8) 블랙박스 테스트 기법 3가지 고르기


1. EQUIVALENCE PARTITIONING  
2. BOUNDARY VALUE ANALYSIS  
3. BASE PATH TEST  
4. LOOP TEST  
5. DECISION COVERAGE  
6. CAUSE-EFFECT GRAPH

답: 1, 2, 6

---

# ✅ 블랙박스 테스트 기법 쉽게 이해하기 – 갓반인도 척척!

---

## 1️⃣ 동등분할기법 (Equivalence Partitioning)

- 입력값을 **비슷한 그룹(동등 클래스)**으로 쪼갬  
- 각 그룹에서 대표값 한두 개만 테스트하면 됨  
- 예) 나이를 3구간으로 나누기:  
  - 0~17 (미성년자)  
  - 18~59 (성인)  
  - 60~120 (노년층)  
- 각 구간에서 1~2개 값만 검사해도 전체를 검사한 효과!

---

## 2️⃣ 경계값 분석 (Boundary Value Analysis)

- 오류가 자주 나는 **입력값 경계(최소, 최대, 그 주변 값)** 집중 공략  
- 예) 입력 범위 1~100이라면:  
  - 1, 2, 99, 100 을 테스트!  
- 경계에서 버그가 많이 발생하니까 집중적으로 검사하는 기법임

---

## 3️⃣ 원인-효과 그래프 검사 (Cause-Effect Graphing)

- 입력 조건(원인)과 결과(효과)를 **논리 그래프로 그림**  
- 조건과 결과 관계를 체계적으로 분석해서  
- **중요한 테스트 케이스만 쏙쏙 뽑아내는 스마트한 방법**  
- 복잡한 조건 많을 때 특히 유용함!

---

## ⚠️ 참고: 이건 블랙박스가 아님! (화이트박스 기법)

- BASE PATH TEST  
- LOOP TEST  
- DECISION COVERAGE  

→ 내부 코드 구조를 분석해서 테스트함

---

## 🎯 딱 정리!

> 블랙박스 테스트는  
> “속은 안 보고, 결과만 본다!”  
> 입력을 그룹으로 쪼개고, 경계값을 집중 공격하며,  
> 조건과 결과 논리까지 따져서  
> 효율 좋은 테스트 케이스를 만드는 방법임!



 -------------------------------------------------------------------------------------------------------

### 문제 9) 설명에 대한 영어 약자 쓰기

**답:** ISMS

---

# ✅ ISMS와 관련 인증 한눈에 정리 – 갓반인도 쉽게 이해하는 정보보호 핵심

---

## 📌 ISMS란?

- **Information Security Management System**  
- 기업이 중요한 정보를 **안전하게 관리하기 위한 체계적인 시스템**  
- 보안 정책 수립, 책임자 지정, 자산 관리, 접근 통제, 사고 대응 등 다양한 보안 절차 포함  
- 쉽게 말해, 회사가 정보보호를 ‘철저히’ 하려고 만든 보안 매뉴얼과 실행 시스템

---

## 📌 ISMS 인증이란?

- 제3자 기관이 기업의 ISMS가 국제 표준(예: ISO/IEC 27001)을 잘 지키는지 **평가하고 부여하는 공식 인증**  
- 인증 획득 시, 회사가 정보보호를 제대로 하고 있다는 객관적 증거가 됨  
- 그래서 고객, 거래처, 투자자에게 **신뢰도 팍 올라가는 효과**가 있음

---

## 📌 관련 용어 한눈에 보기

| 약어        | 설명                                         |
|-------------|----------------------------------------------|
| **PIMS**     | 개인정보 보호에 집중한 관리체계 인증           |
| **ISMS-P**   | ISMS와 PIMS를 합친, 정보보호 + 개인정보 보호 인증 |
| **ITSEC**    | 유럽에서 만든 정보보안 평가 기준               |
| **TCSEC**    | 미국 국방부 기준 컴퓨터 보안 평가               |
| **CC (Common Criteria)** | 전 세계적으로 쓰이는 정보보안 제품 평가 기준    |

---

## 🔥 짧고 굵은 정리

> ISMS 인증 =  
> “우리 회사는 정보보호 시스템을 철저히 갖추고 잘 운영하고 있으니 믿어도 된다!”  
> 라고 **공식적으로 인정받는 것**임.

---

## 🧠 쉽게 이해하는 예시

- 회사가 중요한 문서 금고를 만들고,  
- 누가 열쇠를 가지고 누구만 열 수 있는지,  
- 사고 나면 어떻게 대응할지 모두 체계적으로 정해놓고,  
- 제3자가 와서 “이 금고 시스템 안전하다!” 하고 인증해 주는 것과 같음.


 -------------------------------------------------------------------------------------------------------
문제 10) 다음은 데이터베이스 키에 대한 설명이다. 빈칸에 들어갈 내용을 알맞게 쓰시오

1. 슈퍼키는 (1)의 속성을 갖는다.  
2. 후보키는 (1)과 (2)의 속성을 갖는다.

답:  
1) 유일성  
2) 최소성

---
# ✅ 슈퍼키(Super Key) vs 후보키(Candidate Key) 쉽게 이해하기 – 갓반인도 척척!

---

## 📌 슈퍼키 (Super Key)

- 테이블에서 **한 행(row)을 유일하게 딱 하나만 가리킬 수 있는 속성들의 묶음**  
- 예시:  
  - (학번)  
  - (이름, 전화번호)  
  - (학번, 이름)  
- 중요한 점은 **유일성(중복 없는 식별력)**이 꼭 지켜져야 함  
- 즉, ‘중복 없이 특정 행을 구분할 수 있는 모든 조합’을 슈퍼키라고 부름

---

## 📌 후보키 (Candidate Key)

- 슈퍼키 중에서 **최소한의 속성만 남긴 것**  
- 다시 말해, **하나라도 빼면 유일성을 잃는 ‘딱 필요한’ 키**  
- 예시:  
  - (학번) → 후보키 가능 (단독으로 유일 식별 가능)  
  - (학번, 이름) → 후보키 아님 (이름 빼도 됨)  
- 후보키는 유일성 + **최소성** 모두 만족해야 함

---

## 📌 한눈에 정리

| 구분       | 의미                        | 조건                         | 예시                 |
|------------|-----------------------------|------------------------------|----------------------|
| 슈퍼키     | 유일성 있는 모든 키 후보       | 중복 없어야 함                 | (학번), (학번, 이름)    |
| 후보키     | 최소한의 속성만 남긴 슈퍼키    | 하나라도 빼면 중복 발생        | (학번)                |

---

## 🧠 쉽게 이해하는 예시

- 학생 테이블에서  
- ‘학번’만 있어도 학생을 딱 구분할 수 있음 → 후보키  
- ‘학번 + 이름’ 같이 필요 이상으로 포함해도 유일성은 있지만 → 슈퍼키  
- 후보키 중에서 하나를 골라 **기본키(Primary Key)**로 지정함!

---

## 🔥 핵심

> 슈퍼키 = 유일성 있는 모든 키 가능성  
> 후보키 = 쓸데없는 속성 뺀 최소 유일 키  
> 기본키 = 후보키 중 하나 골라 지정

 -------------------------------------------------------------------------------------------------------

문제 11) 다음에서 설명하는 공격유형을 쓰시오

이 공격은 APT 공격에서 주로 쓰이는 공격이며, 타겟이 자주 들어가는 홈페이지를 파악했다가,  
그 홈페이지의 취약점을 통해 악성코드를 심어 사용자가 모르게  
해당 악성코드를 다운받게 하고, 다운로드 된 악성코드를 통해 공격하는 방식을 취한다.  

답: WATERING HOLE

---
# ✅ 워터링 홀(Watering Hole) 공격 쉽게 이해하기 – 갓반인도 척척!

---

## 📌 워터링 홀 공격이란?

- 공격자가 특정 조직이나 사람이 자주 방문하는  
  **‘믿을 만한 웹사이트’**를 노림  
- 그 사이트에 **몰래 악성코드**를 심어놓음  
- 피해자는 평소처럼 방문했다가 몰래 감염되고,  
  공격자는 내부 정보 훔치거나 네트워크 침투 가능

---

## 📌 핵심 특징

- **은밀함**: 감염된 사실을 사용자도 모르고 발견하기 어려움  
- **표적 공격**: 특정 조직이나 사람만 노리고 집중 공격  
- **복합 공격**: 최신 취약점(제로데이)을 활용해 방어를 피해감

---

## 📌 대응 방법

- 자주 방문하는 사이트의 보안 강화하기  
- 웹 애플리케이션 방화벽(WAF) 설치  
- 사용자 대상 보안 교육 강화  
- 항상 최신 보안 패치와 업데이트 적용

---

## 🧠 쉽게 이해하는 예시

- 회사 직원들이 자주 가는 커피숍 근처 카페 홈페이지가 있는데,  
- 공격자가 그 홈페이지에 몰래 바이러스를 심음  
- 직원들이 평소처럼 카페 홈페이지에 접속하자,  
- 컴퓨터가 몰래 감염되어 회사 내부 네트워크가 뚫림

---

## 🔥 핵심 정리

> 워터링 홀 공격 =  
> “너가 믿고 자주 가는 곳에 숨어 있는 함정”  
> 그래서 항상 방문하는 사이트도 조심해야 함!



 -------------------------------------------------------------------------------------------------------

문제 12) 다음 V모델에서 테스트 단계에 대한 설명으로 괄호 안에 들어갈 내용을 쓰시오

요구사항분석 (4)
↓ 		    ↑
기능명세 분석 (3)
↓ 		    ↑
설계		     (2)
↓ 		     ↑
개발 		    (1)

답:  
1) 단위 테스트  
2) 통합 테스트  
3) 시스템 테스트  
4) 인수 테스트

---

# ✅ V모델(Verification and Validation Model) 쉽게 정리 – 갓반인도 척척!

---

## 📌 V모델이란?

- 소프트웨어 개발 단계와 테스트 단계를 **쌍으로 연결**한 모델  
- 각 개발 단계가 끝나면 바로 대응되는 테스트를 수행해  
- 문제를 빨리 찾아내고 바로 고칠 수 있도록 함

---

## 📌 각 개발 단계와 대응 테스트

| 개발 단계        | 대응 테스트            | 설명                                     |
|------------------|-----------------------|------------------------------------------|
| 요구사항 분석     | 인수 테스트 (Acceptance Test) | 실제 사용자 입장에서 요구사항이 잘 충족됐는지 확인 |
| 기능 명세 분석    | 시스템 테스트 (System Test)     | 전체 시스템이 명세대로 제대로 동작하는지 검사      |
| 설계 단계        | 통합 테스트 (Integration Test) | 여러 모듈을 연결해 인터페이스가 잘 맞는지 확인      |
| 구현 단계        | 단위 테스트 (Unit Test)         | 각 모듈별 기능이 제대로 작동하는지 점검              |

---

## 🔥 핵심 정리

- 개발 단계가 내려갈수록 테스트도 더 **구체적이고 세부적**으로 진행됨  
- 테스트는 개발 단계에서 만들어진 결과물이 제대로 됐는지 **검증하는 과정**  
- 초기에 문제를 잡아내서 수정하니 품질 관리에 최고임!

---

## 🧠 쉽게 이해하는 예시

- 집을 짓는 과정으로 비유하면,  
- 설계도면이 제대로 됐는지 먼저 확인(설계 단계 → 통합 테스트)  
- 벽돌 하나하나 제대로 쌓았는지 검사(구현 단계 → 단위 테스트)  
- 전체 집이 설계대로 잘 완성됐는지 점검(기능 명세 분석 → 시스템 테스트)  
- 집주인이 만족하는지 마지막 확인(요구사항 분석 → 인수 테스트)  

---

> V모델 = 개발 단계와 테스트 단계가 ‘짝꿍’인 꼼꼼한 품질관리 방법!

 -------------------------------------------------------------------------------------------------------
문제 13) 다음 SQL 결과에 알맞는 쿼리를 작성하시오

| NAME | SCORE |
|------|-------|
| LEE  | 95    |
| KIM  | 90    |
| SONG | 60    |

```sql
SELECT NAME, SCORE FROM 성적 (1) BY (2) (3)

답:

ORDER

SCORE

DESC

해설
ORDER BY 절은 결과를 특정 컬럼을 기준으로 정렬할 때 사용
(1) BY (2) (3)은 각각 ORDER BY SCORE DESC로 채워져야 함
SCORE 컬럼 기준으로 내림차순 정렬(DESC)하여 점수가 높은 순서대로 출력됨
 -------------------------------------------------------------------------------------------------------
### 문제 14) 파이썬 리스트 함수 선택

1. 요소를 확장해주는 역할을 하며, 모든 항목을 하나씩 리스트에 추가  
2. 리스트 내부 요소를 꺼내면서 삭제 후 반환  
3. 리스트 내부 요소의 순서를 뒤집음

---

### 답  
1) `extend`  
2) `pop`  
3) `reverse`

---

### 📌 해설: 리스트 메서드 핵심 정리 – 갓반인도 척척!

- **`extend`**  
  리스트에 다른 리스트나 반복 가능한 객체의 모든 요소를 하나씩 쭉 추가함  
  (덧붙이기, 붙여넣기)

extend는 “리스트에 새 친구들 한 명씩 데려오기”

- **`pop`**  
  리스트에서 마지막 요소(기본) 또는 지정한 인덱스 요소를 꺼내 삭제 후 그 값을 반환  
  (꺼내기 + 삭제 동시에)

pop은 “마지막 친구 꺼내서 보내기”

- **`reverse`**  
  리스트 내 요소들의 순서를 완전 뒤집음  
  (역순 정렬 아님! 그냥 뒤집기)

reverse는 “친구들 줄 세우기 뒤집기”
---

### 🧠 예시 코드

```python
lst = [1, 2, 3]

lst.extend([4, 5])   # lst -> [1, 2, 3, 4, 5]

val = lst.pop()      # val = 5, lst -> [1, 2, 3, 4]

lst.reverse()        # lst -> [4, 3, 2, 1]

 -------------------------------------------------------------------------------------------------------
문제 15) 다음 파이썬 코드에서 출력되는 결과를 작성하시오

def func1(num1, num2=2):                       # 'func1'이라는 함수를 정의했다.
                                               # num1: 필수 매개변수 (값을 꼭 넘겨줘야 함)
                                                 # num2=2: 기본 매개변수. num2에 값이 안 넘어오면 기본적으로 2를 사용한다.
    print('a=', num1, 'b=', num2)                   # 'a=' 다음에 num1 값, 'b=' 다음에 num2 값을 출력한다.

func1(20)                                             # 'func1' 함수를 호출하면서 'num1'에만 20을 넘겨줬다.
                                                        # 'num2'는 값을 넘겨주지 않았으므로, 기본값인 2가 사용된다.
                                                            # 따라서 'num1'은 20, 'num2'는 2가 된다.
✅최종 결과
a= 20 b= 2 

 -------------------------------------------------------------------------------------------------------
문제 16) 다음 java 코드 중 밑줄에 들어갈 알맞은 코드를 작성하시오.

class Car implements Runnable {                   // (1) Car 클래스가 Runnable 인터페이스를 구현(implements)했다.
                                                       // Runnable 인터페이스는 run() 메소드를 포함하고 있어서,
                                                 // Car 클래스는 run() 메소드를 반드시 구현해야 한다.
                                                   // (근데 여기 코드에는 run()이 없네? 그럼 컴파일 에러 나는데,
                                                     // 일단 문제 의도는 빈칸 채우기니까 Car가 맞다고 보자.
                                                         // 실제 코드라면 run() 메소드를 추가해야 함.)
    int a;
    public void fun(){
        System.out.println("func call");
    }
                                                  // 여기에 public void run() { /* 스레드가 실행할 코드 */ } 가 있어야 정상 작동함
}

public class Main {
    public static void main (String [] args){
                                                                              // (2) Thread 객체를 생성할 때, Runnable 인터페이스를 구현한 객체를 인자로 넘겨줘야 한다.
                                                                              //     Car 클래스가 Runnable을 구현했으니, 'new Car()'를 여기에 넣는 거지.
        Thread t1 = new Thread(new Car());
        t1.start();                                           // (3) 스레드를 시작한다. 이러면 위에 있는 Car 클래스의 run() 메소드가 호출됨.
                                                        //     (만약 Car에 run() 메소드가 없으면 실행이 제대로 안 되거나 에러 남.)
    }
}

✅최종 결과
Car

이 코드는 자바에서 **멀티스레딩(Multithreading)**을 구현하는 방법 중 하나인 Runnable 인터페이스를 사용하는 방식이야.
Thread 객체를 만들 때 Runnable을 구현한 클래스의 인스턴스를 넘겨줘야 하거든.

```java
class Car implements Runnable { // (1) Car 클래스가 Runnable 인터페이스를 구현(implements)했다.
                               // Runnable 인터페이스는 run() 메소드를 포함하고 있어서,
                               // Car 클래스는 run() 메소드를 반드시 구현해야 한다.
                               // (근데 여기 코드에는 run()이 없네? 그럼 컴파일 에러 나는데,
                               // 일단 문제 의도는 빈칸 채우기니까 Car가 맞다고 보자.
                               // 실제 코드라면 run() 메소드를 추가해야 함.)
    int a;
    public void fun(){
        System.out.println("func call");
    }
    // 여기에 public void run() { /* 스레드가 실행할 코드 */ } 가 있어야 정상 작동함
}

public class Main {
    public static void main (String [] args){
                      // (2) Thread 객체를 생성할 때, Runnable 인터페이스를 구현한 객체를 인자로 넘겨줘야 한다.
                        //     Car 클래스가 Runnable을 구현했으니, 'new Car()'를 여기에 넣는 거지.
        Thread t1 = new Thread(new Car());
        t1.start();                     // (3) 스레드를 시작한다. 이러면 위에 있는 Car 클래스의 run() 메소드가 호출됨.
                                    //     (만약 Car에 run() 메소드가 없으면 실행이 제대로 안 되거나 에러 남.)
    }
}


왜 Car가 들어가야 하냐고?
자바에서 스레드를 만들고 실행하는 방법은 크게 두 가지야:

Thread 클래스를 **상속(extends)**받는 방법

Runnable **인터페이스를 구현(implements)**하는 방법

지금 문제 코드를 보면 class Car implements Runnable이라고 되어 있잖아? 즉, Car 클래스는 Runnable 인터페이스를 구현한 클래스라는 거지.

Thread 객체를 생성할 때, new Thread() 괄호 안에 Runnable 타입의 객체를 넣어줄 수 있어.
new ______() 이 빈칸에는 바로 Runnable을 구현한 클래스인 Car의 객체가 들어가야 하는 거다.

그래서 new Car()를 넣으면, Thread t1은 Car 클래스에 정의된 (원래는 있어야 할) run() 메소드를 실행할 준비가 되는 거지.

참고: 이 코드대로라면 Car 클래스에 public void run() 메소드가 없어서 컴파일 에러가 난다.
 Runnable 인터페이스를 구현하려면 run() 메소드를 반드시 오버라이딩해야 하거든. 이건 문제의 함정일 수도 있고, 아니면 그냥 빈칸 채우는 의도만 가진 문제일 수도 있음.
 -------------------------------------------------------------------------------------------------------

문제 17) 다음 java 프로그램의 결과를 쓰시오

class A {
    int a;                       // 'a'라는 정수형 멤버 변수
    int b;                       // 'b'라는 정수형 멤버 변수
}

public class Main {
    static void func1(A a){                     // func1 메소드: A 타입 객체의 참조값을 받아서 그 객체의 'a' 멤버에 10을 곱한다.
        a.a *= 10;
    }
    static void func2(A a){                           // func2 메소드: A 타입 객체의 참조값을 받아서 그 객체의 'a' 멤버에 'b' 멤버를 더한다.
        a.a += a.b;
    }

    public static void main(String[] args) {
        A a = new A();                                   // (1) 'A' 클래스의 새로운 객체를 만들고, 그 객체를 가리키는 참조 변수 'a'를 선언한다.
                                                       //    초기에는 a.a와 a.b 모두 기본값인 0으로 초기화된다.

        a.a = 100;                                     // (2) 객체 'a'의 멤버 변수 'a.a'에 100을 할당한다.
                                                             //    현재 객체 상태: {a=100, b=0}

        func1(a);                                          // (3) func1 메소드를 호출하면서 객체 'a'의 참조값을 넘겨준다.
                                                             //    func1 안에서 a.a *= 10; 이 실행되므로, 원본 객체 'a'의 'a.a' 값도 바뀐다.
                                                             //    a.a = 100 * 10 = 1000이 된다.
                                                             //    현재 객체 상태: {a=1000, b=0}

        a.b = a.a;                                           // (4) 객체 'a'의 멤버 변수 'a.b'에 현재 'a.a'의 값(1000)을 할당한다.
                                                                 //    현재 객체 상태: {a=1000, b=1000}

        func2(a);                                                // (5) func2 메소드를 호출하면서 객체 'a'의 참조값을 넘겨준다.
                                                                   //    func2 안에서 a.a += a.b; 이 실행되므로, 원본 객체 'a'의 'a.a' 값도 바뀐다.
                                                                   //    a.a = a.a (1000) + a.b (1000) = 2000이 된다.
                                                                   //    현재 객체 상태: {a=2000, b=1000}

        System.out.println(a.a);                                     // (6) 최종적으로 객체 'a'의 멤버 변수 'a.a' 값을 출력한다.
    }
}

✅최종 결과
2000



 -------------------------------------------------------------------------------------------------------

문제 18) 다음 c언어 프로그램의 출력결과를 쓰시오.  
(단 입력값은 5가 들어왔다고 가정한다.)

```c
#include<stdio.h>                     // 표준 입출력 함수를 사용하기 위한 헤더 파일

                                          // func 함수: 재귀적으로 숫자를 계산한다.
int func(int i){
    if(i <= 1) return 1;                 // (1) 기저 조건(Base Case): i가 1 이하(1 또는 0 또는 음수)이면 1을 반환하고 재귀 호출을 멈춘다.
    return i * func(i-2);                 // (2) 재귀 호출: 현재 i 값에 'i-2'를 인자로 func 함수를 다시 호출한 결과를 곱한다.
                                                //     즉, 2씩 감소하면서 곱하는 형태.
}

int main(){
    int in;                                 // 사용자 입력을 받을 정수형 변수 'in' 선언.
    scanf("%d", &in);                           // 사용자로부터 정수를 입력받아 'in' 변수에 저장한다.
                                         // 문제 답이 15라는 건, 'in'에 특정 숫자가 입력되었을 때 그 결과가 15라는 뜻이다.
                                         // 15를 유도하는 'in' 값은 5일 때다. (아래 계산 과정 참고)
                                             // 즉, 사용자가 5를 입력했다고 가정하고 문제를 푼다.

    printf("%d", func(in));                           // func 함수에 'in' 값을 넘겨 계산한 결과를 출력한다.
}

✅최종 결과
15


func(5)의 계산 과정 (입력값이 5일 때)  
사용자가 5를 입력했다고 가정하고 func(5)의 호출 흐름을 따라가 보자.

func(5)  
i가 5이므로 i <= 1 조건 False.  

return 5 * func(5 - 2) ➡️ 5 * func(3)  

func(3)  
i가 3이므로 i <= 1 조건 False.  

return 3 * func(3 - 2) ➡️ 3 * func(1)  

func(1)  
i가 1이므로 i <= 1 조건 True.  

return 1 (기저 조건 도달, 재귀 종료)  

이제 역순으로 값을 합쳐보자.

func(1)은 1을 반환  

func(3)은 3 * func(1) 이었으므로, 3 * 1 = 3을 반환  

func(5)은 5 * func(3) 이었으므로, 5 * 3 = 15를 반환  
 -------------------------------------------------------------------------------------------------------

## 📘 정보처리기사 실기 - C언어 수치 처리 문제

### 문제 19)
다음 C언어 프로그램의 괄호 안에 들어갈 알맞은 답을 작성하시오.

#include<stdio.h> // 표준 입출력 함수 쓰려고 포함시키는 헤더 파일

int main(){
    int num = 1234;                       // 원본 숫자. 이걸 거꾸로 만들 거다.
    int div = 10;                         // 10으로 나누고 나머지 구하는 데 쓸 숫자. 자릿수 분리용.
    int res = 0;                            // 결과를 저장할 변수. 처음엔 0으로 시작.

    while(num > 0){                             // ① 여기에 '>'가 들어가야 한다.
                                              // 'num'이 0보다 클 때만 계속 반복하라는 뜻.
                                              // 'num'이 0이 되면 모든 자릿수를 다 처리했다는 거니까 루프를 멈춰야지.
        res = res * div;                         // 현재 'res' 값에 10을 곱한다.
                                                 // 이렇게 하면 'res'에 이미 저장된 숫자들을 왼쪽으로 한 칸씩 미는 효과가 난다.
                                                         // (예: res가 4였으면 40이 됨)

        res = res + num % div;                                       // ② 여기에 '%'가 들어가야 한다.
                                                           // 'num % div'는 'num'을 'div'로 나눈 **나머지**를 구하는 연산이다.
                                                       // 예를 들어 1234 % 10 하면 4가 나온다. 이게 가장 오른쪽 자릿수지.
                                                                           // 이 나머지를 'res'에 더해서 새로운 숫자의 자릿수로 붙인다.

        num = num / div;                         // ③ 여기에 '/'가 들어가야 한다.
                                                     // 'num = num / div'는 'num'을 'div'로 나눈 **몫**을 다시 'num'에 저장한다.
                                                   // 예를 들어 1234 / 10 하면 123이 나온다. 가장 오른쪽 자릿수를 제거하는 거지.
    }
                                                            // 루프 과정 추적: (num=1234, div=10, res=0)
                                                            // 1. num = 1234 (0보다 큼)
                                                            //    res = 0 * 10 = 0
                                                            //    res = 0 + 1234 % 10 = 0 + 4 = 4
                                                            //    num = 1234 / 10 = 123
                                                        
                                                            // 2. num = 123 (0보다 큼)
                                                            //    res = 4 * 10 = 40
                                                            //    res = 40 + 123 % 10 = 40 + 3 = 43
                                                            //    num = 123 / 10 = 12
                                                        
                                                            // 3. num = 12 (0보다 큼)
                                                            //    res = 43 * 10 = 430
                                                            //    res = 430 + 12 % 10 = 430 + 2 = 432
                                                            //    num = 12 / 10 = 1
                                                        
                                                            // 4. num = 1 (0보다 큼)
                                                            //    res = 432 * 10 = 4320
                                                            //    res = 4320 + 1 % 10 = 4320 + 1 = 4321
                                                            //    num = 1 / 10 = 0
                                                        
                                                            // 5. num = 0 (0보다 크지 않음) -> 루프 종료

    printf("%d", res); // 최종 'res' 값인 4321을 출력한다.
}

✅최종 결과

① >

② %

③ /

📌 해설:
최종 요약

>: while문의 조건으로, 숫자가 0보다 클 때까지 반복해서 모든 자릿수를 처리하는 데 사용한다.

%: 숫자의 **가장 오른쪽 자릿수(1의 자리)**를 분리해낼 때 사용하는 나머지 연산자다.

/: 숫자의 가장 오른쪽 자릿수를 제거할 때 사용하는 몫 연산자다.

 -------------------------------------------------------------------------------------------------------

### 문제 20) 다음 C언어 프로그램의 결과를 쓰시오


int isPrime(int number){               // 어떤 숫자가 소수인지 아닌지 판별하는 함수다.
    int i;
    for (i = 2; i < number; i++){           // 2부터 'number' 바로 전까지 반복한다.
        if(number % i == 0)                 // 'number'를 'i'로 나눴을 때 나머지가 0이면 (즉, 나누어 떨어지면)
            return 0;                              // 'number'는 소수가 아니므로 0을 반환하고 함수 종료.
    }
    return 1;                             // 반복문이 끝날 때까지 한 번도 나누어 떨어지지 않았다면, 'number'는 소수이므로 1을 반환한다.
                                          // (참고: 1은 소수가 아니지만, 이 함수는 1 이하의 숫자가 들어오면 무조건 1을 반환하는 문제가 있음.
                                        // 하지만 여기서는 2부터 시작하므로 크게 문제되지 않는다.)
}

int main(void){
    int number = 13195;                                       // 소인수를 찾을 대상 숫자.
    int max_div = 0;                                    // 가장 큰 소인수를 저장할 변수. 0으로 초기화.
    int i;                                                                // 반복문을 위한 변수.

    for(i = 2; i < number; i++)                                 // 'i'가 2부터 'number' 바로 전까지 (13194까지) 반복한다.
                                                                   // 이 루프는 'number'의 약수들을 찾기 위함이다.
        if(isPrime(i) == 1 && number % i == 0)                     // (1) 'i'가 소수이고 (isPrime(i) == 1),
                                                                      // (2) 'number'가 'i'로 나누어 떨어지면 (number % i == 0)
                                                                              //    -> 즉, 'i'가 'number'의 소인수이면
            max_div = i;                                     // 현재 'i' 값을 'max_div'에 저장한다.
                                                                     // 이 루프는 'i'가 증가하면서 계속 업데이트되므로,
                                                                     // 최종적으로 'max_div'에는 'number'의 **가장 큰 소인수**가 남게 된다.

                                                                          // 13195의 소인수를 찾아보자:
                                                                          // 13195 % 2 != 0
                                                                          // 13195 % 3 != 0
                                                                          // 13195 % 5 == 0 -> isPrime(5) == 1 (5는 소수) -> max_div = 5
                                                                          // ...
                                                                          // 13195 % 7 == 0 -> isPrime(7) == 1 (7은 소수) -> max_div = 7
                                                                          // ...
                                                                          // 13195 % 13 == 0 -> isPrime(13) == 1 (13은 소수) -> max_div = 13
                                                                          // ...
                                                                          // 13195 % 19 == 0 -> isPrime(19) == 1 (19는 소수) -> max_div = 19
                                                                          // ...
                                                                          // 13195 % 29 == 0 -> isPrime(29) == 1 (29는 소수) -> max_div = 29
                                                                          // 이제 29보다 큰 수들 중 13195의 약수이면서 소수인 수는 더 이상 없다.
                                                                          // (13195 = 5 * 7 * 13 * 29)
                                                                          // 따라서 루프가 끝나면 max_div에는 29가 저장되어 있다.

    printf("%d", max_div);                                                   // 최종적으로 'max_div' 값을 출력한다.
    return 0;                                                                     // 프로그램 정상 종료.
}

답: 29

 -------------------------------------------------------------------------------------------------------
