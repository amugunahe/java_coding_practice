## 📘 정보처리기사 실기 - RAID 관련 문제 정리

### 문제 1)
다음 설명에 맞는 RAID 단계를 쓰시오.

- 두개 이상의 하드디스크를 병렬로 연결해, 하나의 하드디스크처럼 이용하는 기술이다  
- 스트라이프 방식으로 구현한다.  
- 데이터가 분산되어 저장하기 때문에 하나의 하드디스크에 문제가 생기면 다른 디스크까지 사용이 불가능해진다.

**답: RAID 0**

---

### 📌 RAID 형태 요약

- **RAID-0**: 스트라이핑(Striping) 사용  
  → 성능 향상에 유리하나 **복구 기능 없음**, **데이터 손실 위험 큼**

- **RAID-1**: 미러링(Mirroring) 사용  
  → 동일한 데이터를 **두 개의 디스크에 복제 저장**하여, **고가용성 확보**

- **RAID-2**: **해밍코드(Hamming Code)**를 사용하여 오류 정정 기능 제공  
  → 이론적이지만, 실제 사용은 드묾

- **RAID-3**: 한 개의 디스크를 **패리티(parity) 정보 저장용**으로 사용  
  → **바이트 단위** 스트라이핑

- **RAID-4**: RAID-3과 유사하지만, **블록 단위**로 데이터 분산 저장  
  → 특정 디스크에 패리티 저장

- **RAID-5**: 데이터와 패리티 정보를 **모든 디스크에 분산 저장**  
  → 패리티 디스크 병목 문제 해소, **가장 널리 사용됨**

- **RAID-6**: RAID-5에서 한 단계 더 강화된 형태로, **두 개의 패리티 정보**를 저장  
  → 2개의 디스크가 동시에 고장나도 데이터 복구 가능


 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 트랜잭션 회복 기법 관련 문제 정리

### 문제 2)
다음은 로그 기반 회복 기법에서 사용되는 명령어이다.  
해당하는 항목을 보기에서 찾아 적으시오.

1. 트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 **재실행하여 복구**를 수행한다.  
2. 트랜잭션 로그를 이용하여 오류와 관련된 내용을 **취소하여 복구**를 수행한다.

**답:**
- 1) REDO  
- 2) UNDO

---

### 📌 관련 개념 정리

#### ✅ 트랜잭션 회복 기법
- **UNDO**: 실패한 트랜잭션의 작업을 **취소**하고 이전 상태로 **복구**  
- **REDO**: 성공적으로 완료된 트랜잭션의 결과를 **다시 실행**하여 복구

---

### ✅ 트랜잭션의 4대 특성 (ACID)

| 특성명 | 설명 |
|--------|------|
| **원자성 (Atomicity)** | 모든 작업이 전부 수행되거나 전혀 수행되지 않아야 함 |
| **일관성 (Consistency)** | 트랜잭션 수행 전후에 데이터의 **일관성이 유지**되어야 함 |
| **격리성 (Isolation)** | 동시에 수행되는 트랜잭션들이 **서로 간섭하지 않도록** 보장 |
| **영속성 (Durability)** | 성공적으로 완료된 트랜잭션의 결과는 **영구적으로 반영**되어야 함 |




 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 데이터베이스 이상현상

### 문제 3)
데이터베이스의 이상현상 중 **삭제이상**에 대해 간략히 서술하시오.

**답:**  
한 튜플을 삭제할 때 **연쇄 삭제 현상**으로 인해 **원하지 않는 정보 손실**이 발생하는 현상

---

### 📌 관련 개념 설명

#### ✅ 이상현상(Anomaly)이란?
테이블에서 **중복**이나 **종속성 문제** 등으로 인해 **데이터 무결성**이 깨지는 비정상적인 현상들을 말함.  
주로 정규화를 하지 않았을 때 발생함.

---

#### ✅ 이상현상의 종류

| 이상현상 | 설명 |
|----------|------|
| **삽입이상 (Insertion Anomaly)** | 특정 정보를 저장하려면 **불필요한 정보도 함께 입력해야** 하는 현상 |
| **삭제이상 (Deletion Anomaly)** | **하나의 정보를 삭제**하려다 **원하지 않는 다른 정보도 삭제**되는 현상 |
| **갱신이상 (Update Anomaly)** | 중복된 정보가 여러 튜플에 존재하여, **일부만 수정 시 불일치**가 발생하는 현상 |

---

#### ✅ 삭제이상 예시

예를 들어, 아래와 같은 학생-강의 테이블이 있다고 할 때:

| 학생이름 | 학번 | 강의명   |
|----------|------|----------|
| 홍길동   | 1001 | DB개론   |
| 김영희   | 1002 | DB개론   |
| 이철수   | 1003 |          |

위에서 **이철수** 학생의 정보만 삭제하려 했으나,  
**강의명도 함께 삭제된다면** 해당 강의에 대한 정보 자체가 사라지게 되는 문제 → **삭제이상**



 -------------------------------------------------------------------------------------------------------
## 📘 정보처리기사 실기 - 네트워크 보안 프로토콜

### 문제 4)
아래 임시 키 무결성 프로토콜의 영문 약어를 쓰시오.

> 임시 키 무결성 프로토콜은 IEEE 802.11의 무선 네트워킹 표준으로 사용되는 보안 프로토콜이다.  
> 임시 키 무결성 프로토콜은 IEEE 802.11i의 작업 그룹과 와이파이 얼라이언스에서 WEP를  
> 하드웨어 교체 없이 대체하기 위해 고안되었다.

**답: TKIP**

---

### 📌 관련 개념 설명

#### ✅ TKIP (Temporal Key Integrity Protocol)

- **TKIP**는 **WEP (Wired Equivalent Privacy)**의 취약점을 보완하기 위해 개발된 **무선 보안 프로토콜**
- **IEEE 802.11i** 표준의 일부이며, WPA(Wi-Fi Protected Access)의 핵심 구성 요소
- 기존의 WEP 하드웨어를 **물리적 교체 없이** 보완할 수 있도록 설계됨
- 다음 기능을 포함함:
  - **패킷당 키 다변화 (Per-packet key mixing)**
  - **무결성 검사 코드(MIC: Message Integrity Check)** 사용
  - **재전송 공격 방지**

#### ✅ WPA와 WPA2의 차이점

| 항목       | WPA (Wi-Fi Protected Access)       | WPA2 |
|------------|-------------------------------------|-------|
| 암호화 방식 | TKIP                               | AES   |
| 보안 수준   | WEP보다 우수하나 WPA2보다 약함     | 강력한 보안 제공 |
| 표준       | IEEE 802.11i (부분 적용)            | IEEE 802.11i (완전 적용) |



 -------------------------------------------------------------------------------------------------------

문제 5) 아래 설명하는 내용을 영문 약자로 쓰시오

특별한 하드웨어 없이 인 간의 자연스러운 움직임을 인식하여 정보를 제공한다.

답: NUI

UI설계 원칙

직관성 
-화면의 버튼, 항목, 입력란 등 누구나 쉽게 이해하고 사용할 수 있도록 한다.

유효성
- 사용자의 목적을 정확히 달성할 수 있도록 유용하고 효과적이여야 한다.

학습성
- 사용자가 쉽게 배우고 익힐 수 있어야 한다.

유연성
- 사용자의 요구를 최대한 수용하면서 오류를 최소화해야한다


 -------------------------------------------------------------------------------------------------------

## 📘 정보처리기사 실기 - 소스코드 분석 도구 및 테스트 유형 분류

### 문제 6)
다음 소스코드 분석 도구에 대한 설명으로 알맞은 답을 보기에서 찾아 작성하시오

1. 소스코드의 **실행 없이**, 코드의 **의미를 분석하여 결함을 찾아내는** 코드분석 기법  
2. 소스코드를 **실행하여 프로그램의 동작이나 결과를 확인**하고, **메모리 누수, 스레드 결함** 등을 분석하는 기법

**답:**  
1) STATIC  
2) DYNAMIC

---

### 📌 애플리케이션 테스트 유형 분류

#### ✅ 1. 프로그램 실행 여부에 따른 분류

| 구분 | 설명 |
|------|------|
| **정적 테스트 (Static Testing)** | 프로그램을 **실행하지 않고** 문서나 소스코드를 검토하여 결함을 찾음 (ex. 코드리뷰, 정적 분석 도구) |
| **동적 테스트 (Dynamic Testing)** | 프로그램을 **실제로 실행**하여 동작을 관찰하고 오류를 탐색함 (ex. 단위 테스트, 통합 테스트) |

---

#### ✅ 2. 테스트 기법에 따른 분류

| 구분 | 설명 |
|------|------|
| **화이트박스 테스트** | 내부 로직과 소스코드 구조를 알고 수행하는 테스트 |
| **블랙박스 테스트** | 내부 구조를 모른 채 외부 요구사항(입출력)에 따라 테스트 |

---

#### ✅ 3. 테스트 시각에 따른 분류

| 구분 | 설명 |
|------|------|
| **검증 테스트 (Verification)** | 제품이 요구사항을 **정확히 충족하는지** 검사 |
| **확인 테스트 (Validation)** | 사용자의 **요구에 맞게 동작하는지** 확인 |

---

### 📌 기타 테스트 목적별 분류

| 테스트 목적 | 설명 |
|-------------|------|
| **회복 테스트** | 고의적인 실패를 유도하여 시스템의 복구 능력을 평가 |
| **안전 테스트** | 시스템의 보안 취약점을 점검 |
| **강도 테스트** | 과도한 부하를 줘서 시스템의 안정성 평가 |
| **성능 테스트** | 응답시간, 처리량, 자원 사용량 등을 측정 |
| **구조 테스트** | 소스코드 복잡도, 분기 등을 분석 |
| **회귀 테스트** | 수정된 코드가 기존 기능에 영향 주는지 확인 |
| **병행 테스트** | 기존 시스템과 변경된 시스템을 동일 입력으로 비교 |
| **A/B 테스트** | 두 가지 버전의 시스템 중 어떤 것이 더 나은지 비교 |
| **스모크 테스트** | 빌드 후 핵심 기능들이 작동하는지 빠르게 확인 |

---

### 📌 테스트 기반 분류

| 분류 | 설명 |
|------|------|
| **명세 기반 테스트** | 요구사항 명세서를 기준으로 테스트 (= 블랙박스 테스트) |
| **구조 기반 테스트** | 소스코드의 논리 구조를 기반으로 테스트 (= 화이트박스 테스트) |
| **경험 기반 테스트** | 테스터의 경험이나 직관을 활용하여 수행하는 테스트 |



 -------------------------------------------------------------------------------------------------------


### 문제 7)
아래에 설명하는 테스트 도구를 쓰시오.

- 자바 프로그래밍 언어용 **유닛 테스트 프레임워크**  
- 테스트 결과는 **TEST 클래스**로 개발자에게 테스트 방법 및 클래스의 **HISTORY**를 공유 가능  
- **어노테이션**으로 간결하게 지원

**답: JUNIT**

---

### 📌 관련 개념 설명

#### ✅ JUnit이란?

- **자바(Java)** 언어용 단위 테스트(Unit Test) 프레임워크
- 테스트 코드를 작성하여 **개발한 코드의 정확성 검증**에 사용
- 반복 가능한 테스트 수행이 가능하며, **자동화 테스트** 기반 구축에 핵심적인 역할
- **어노테이션 기반**으로 테스트 작성이 간단하고 직관적

---

### ✅ 주요 어노테이션

| 어노테이션 | 설명 |
|------------|------|
| `@Test` | 테스트 메서드를 지정 |
| `@BeforeEach` | 각 테스트 실행 전 수행 |
| `@AfterEach` | 각 테스트 실행 후 수행 |
| `@BeforeAll` | 모든 테스트 실행 전 한 번 수행 (static) |
| `@AfterAll` | 모든 테스트 실행 후 한 번 수행 (static) |
| `@Disabled` | 해당 테스트 메서드를 **실행하지 않음** |

---

### ✅ JUnit 사용 예시 (Java)

```java
import org.junit.jupiter.api.*;

public class CalculatorTest {

    Calculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new Calculator();
    }

    @Test
    void testAdd() {
        Assertions.assertEquals(5, calculator.add(2, 3));
    }

    @AfterEach
    void tearDown() {
        calculator = null;
    }
}

✅ 장점
코드의 품질 향상 및 유지보수 용이

리팩토링 시 기능 이상 유무 빠르게 검출 가능

CI/CD 환경에서 자동화 테스트 도구로 활용 가능

 -------------------------------------------------------------------------------------------------------
문제 8) 다음 보기 중에서 블랙박스 테스트 기법을 3가지 골라 작성하시오

1. EQUIVALENCE PARTITIONING  
2. BOUNDARY VALUE ANALYSIS  
3. BASE PATH TEST  
4. LOOP TEST  
5. DECISION COVERAGE  
6. CAUSE-EFFECT GRAPH

답: 1, 2, 6

---

### 블랙박스 테스트 기법 상세 설명

#### 1) 동등분할기법 (Equivalence Partitioning)  
- 입력 자료에 초점을 맞춰 테스트 케이스를 만드는 기법으로, 입력 도메인을 동등한 그룹(분할)으로 나누어  
  각 그룹에서 대표값을 선택하여 테스트한다.  
- 이렇게 하면 모든 가능한 입력을 테스트하지 않고도 충분한 커버리지를 확보할 수 있다.  
- 예를 들어, 나이 입력값이 0~120일 때 0~17, 18~59, 60~120 등으로 나누어 각 구간의 대표값을 테스트한다.

#### 2) 경계값 분석 (Boundary Value Analysis)  
- 입력 값의 경계(최소, 최대, 경계 바로 위/아래 등)에서 오류가 발생할 가능성이 높기 때문에,  
  경계값과 그 주변 값을 집중적으로 테스트하는 기법이다.  
- 예를 들어, 입력 범위가 1~100이라면 1, 2, 100, 99 등 경계 근처 값들을 테스트한다.

#### 3) 원인-효과 그래프 검사 (Cause-Effect Graph)  
- 입력 조건(원인)과 그에 따른 출력(효과) 간의 관계를 논리적으로 분석해 그래프로 표현한다.  
- 이를 통해 가능한 입력 조합을 체계적으로 파악하고, 효율적이고 효과적인 테스트 케이스를 도출하는 기법이다.  
- 복잡한 조건문이나 논리 구조를 가진 시스템에서 테스트 케이스를 설계할 때 유용하다.

---

### 기타 참고

- **오류 예측 검사**  
  과거 경험이나 테스터의 직관을 기반으로 예상되는 오류를 중심으로 테스트하는 기법이다.

- **비교 검사**  
  여러 버전의 프로그램에 동일한 입력을 제공하여 결과가 일치하는지 비교하는 테스트 기법이다.

- **BASE PATH TEST, LOOP TEST, DECISION COVERAGE**  
  이들은 내부 구조와 로직을 분석하는 화이트박스 테스트 기법에 속한다.

---

필요하면 더 구체적인 예시나 추가 설명도 알려주세요!



 -------------------------------------------------------------------------------------------------------

문제 9) 다음 설명에 대한 답을 영어 약자로 쓰시오

기업이 주요 정보자산을 보호하기 위해 수립, 관리, 운영하는 정보 보호 관리체계가  
인증 기준에 적합한지를 심사하여 인증을 부여하는 제도

답: ISMS

---

### 해설 및 추가 설명

**ISMS (Information Security Management System, 정보보호 관리체계)** 는  
기업이나 조직이 정보 자산을 체계적으로 보호하기 위해 수립·운영하는 경영 시스템이다.  
이 관리체계는 정보 보안 정책, 조직 내 책임과 권한, 자산 관리, 인적 보안, 물리적 보안,  
접근 통제, 사고 대응 등 다양한 보안 관리 절차와 통제를 포함한다.

**ISMS 인증**은 제3자 인증기관이 기업의 정보보호 관리체계가 일정한 국제 또는 국가 표준 (예: ISO/IEC 27001)에 부합하는지 평가해 부여하는 공식 인증이다.  
이를 통해 기업은 정보보호 수준을 객관적으로 증명하고, 신뢰성을 높일 수 있다.

---

### 관련 용어 및 비교

- **PIMS (Personal Information Management System)**  
  개인정보 보호에 특화된 관리체계 인증으로, 개인정보 처리와 관련된 관리절차를 중점 평가한다.

- **ISMS-P**  
  ISMS와 PIMS를 통합한 인증으로, 정보보호와 개인정보보호를 함께 관리하는 체계에 대한 인증이다.

- **ITSEC (Information Technology Security Evaluation Criteria)**  
  유럽연합에서 제정한 정보보안 평가 기준으로, 시스템의 보안 기능을 등급별로 평가한다.

- **TCSEC (Trusted Computer System Evaluation Criteria, 미국 기준)**  
  미국 국방부가 만든 컴퓨터 보안 평가 기준으로, 시스템의 신뢰성을 등급화한다.

- **CC (Common Criteria, 국제평가기준)**  
  국제적으로 통용되는 정보보안 제품 평가 기준으로, 보안 기능과 보증 수준을 표준화한다.

---

### 요약

ISMS 인증은 기업이 정보보호를 위해 체계적인 관리체계를 구축하고 운영함을 객관적으로 입증하는 중요한 제도이며,  
국내외 다양한 보안 평가 기준과 함께 기업 정보보안의 신뢰성을 확보하는 데 기여한다.



 -------------------------------------------------------------------------------------------------------
문제 10) 다음은 데이터베이스 키에 대한 설명이다. 빈칸에 들어갈 내용을 알맞게 쓰시오

1. 슈퍼키는 (1)의 속성을 갖는다.  
2. 후보키는 (1)과 (2)의 속성을 갖는다.

답:  
1) 유일성  
2) 최소성

---

해설:  
- **슈퍼키 (Super Key)**는 릴레이션 내에서 각 튜플을 유일하게 식별할 수 있는 하나 이상의 속성들의 집합이다.  
  따라서 슈퍼키는 반드시 **유일성**(Uniqueness)을 만족해야 한다.  

- **후보키 (Candidate Key)**는 슈퍼키 중에서도 불필요한 속성을 모두 제거하여,  
  더 이상 속성을 제거할 수 없는 최소한의 유일한 키이다.  
  즉, 후보키는 **유일성**과 함께 **최소성**(Minimality) 속성을 만족한다.  

이 두 속성 덕분에 후보키는 데이터베이스 내에서 각 레코드를 정확하게 식별하는 기본 키(primary key) 후보가 된다.



 -------------------------------------------------------------------------------------------------------

문제 11) 다음에서 설명하는 공격유형을 쓰시오

이 공격은 APT 공격에서 주로 쓰이는 공격이며, 타겟이 자주 들어가는 홈페이지를 파악했다가,  
그 홈페이지의 취약점을 통해 악성코드를 심어 사용자가 모르게  
해당 악성코드를 다운받게 하고, 다운로드 된 악성코드를 통해 공격하는 방식을 취한다.  

답: WATERING HOLE

---

### 추가 설명

워터링 홀(Watering Hole) 공격은 표적 공격(Targeted Attack)의 일종으로, 공격자는 피해자가 자주 방문하는 신뢰할 수 있는 웹사이트를 선정해 해당 사이트의 보안 취약점을 찾아 악성코드를 삽입한다.  
피해자는 자신이 신뢰하는 사이트를 방문하면서 악성코드에 감염되고, 이를 통해 공격자는 내부 네트워크 접근, 정보 탈취, 추가 악성코드 설치 등의 공격을 수행한다.

이 공격은 다음과 같은 특징이 있다:  
- **은밀성**: 사용자가 직접 악성코드를 다운로드 받는다는 인식이 적어, 탐지 및 대응이 어렵다.  
- **표적성**: 특정 집단이나 조직을 겨냥해 공격 대상을 한정한다.  
- **복합적 공격**: 악성코드는 흔히 제로데이 취약점 등을 활용해 방어체계를 우회한다.

대응 방안으로는 방문 사이트의 보안 강화, 웹 방화벽 적용, 사용자 교육, 최신 보안 패치 적용 등이 있다.


 -------------------------------------------------------------------------------------------------------

문제 12) 다음 V모델에서 테스트 단계에 대한 설명으로 괄호 안에 들어갈 내용을 쓰시오

요구사항분석 (4)
↓ 		    ↑
기능명세 분석 (3)
↓ 		    ↑
설계		     (2)
↓ 		     ↑
개발 		    (1)

yaml
복사
편집

답:  
1) 단위 테스트  
2) 통합 테스트  
3) 시스템 테스트  
4) 인수 테스트

---

### 해설 및 추가 설명

V모델(Verification and Validation Model)은 소프트웨어 개발과 테스트 활동을 병행하는 모델로, 각 개발 단계에 대응하는 테스트 단계가 명확히 매칭되어 있다.  
이는 개발 단계에서 정의한 요구사항과 설계가 올바르게 구현되었는지 확인하기 위한 체계적인 방법을 제공한다.

- **개발 단계**에 대응하는 **단위 테스트(Unit Testing)**  
  → 프로그램의 가장 작은 단위인 모듈을 독립적으로 테스트하여 기능이 올바른지 확인한다.

- **설계 단계**에 대응하는 **통합 테스트(Integration Testing)**  
  → 여러 모듈을 통합하여 모듈 간 상호작용과 인터페이스가 제대로 동작하는지 검증한다.

- **기능명세 분석 단계**에 대응하는 **시스템 테스트(System Testing)**  
  → 전체 시스템이 명세된 요구사항을 충족하는지 검증하는 단계로, 시스템 전체를 대상으로 한다.

- **요구사항분석 단계**에 대응하는 **인수 테스트(Acceptance Testing)**  
  → 최종 사용자의 관점에서 요구사항이 모두 반영되어 실제 환경에서 제대로 동작하는지 검증한다.

이와 같이 V모델은 개발 단계와 테스트 단계를 수직으로 연결하여 각 단계별 산출물이 다음 단계의 입력과 테스트 기준이 된다.


 -------------------------------------------------------------------------------------------------------
문제 13) 다음 SQL 결과에 알맞는 쿼리를 작성하시오

| NAME | SCORE |
|------|-------|
| LEE  | 95    |
| KIM  | 90    |
| SONG | 60    |

```sql
SELECT NAME, SCORE FROM 성적 (1) BY (2) (3)

답:

ORDER

SCORE

DESC

해설:

ORDER BY 절을 사용하여 결과를 정렬할 때,

SCORE 컬럼을 기준으로

내림차순(DESC) 정렬하여 점수가 높은 순으로 출력한다.
 -------------------------------------------------------------------------------------------------------
문제 14) 다음 설명과 관련된 파이썬 함수를 골라 작성하시오

1. 요소를 확장해주는 역할을 하며, 모든 항목을 하나의 요소로 추가  
2. 리스트 내부 요소를 꺼내주는 함수, 해당 함수를 호출하면 리스트에서 해당 값을 삭제하면서 리턴시켜준다.  
3. 리스트 내부의 요소의 순서를 뒤집어주는 역할을 한다.

답:  
1) `extend`  
2) `pop`  
3) `reverse`

---

해설:  
- `extend`: 리스트에 다른 리스트나 반복 가능한 객체의 모든 요소를 하나씩 추가한다.  
- `pop`: 리스트에서 마지막 요소(또는 인덱스 지정 시 해당 위치 요소)를 꺼내면서 리스트에서 삭제하고 그 값을 반환한다.  
- `reverse`: 리스트 요소의 순서를 뒤집는다.

 -------------------------------------------------------------------------------------------------------
문제 15) 다음 파이썬 코드에서 출력되는 결과를 작성하시오

```python
def func1(num1, num2=2):
    print('a=', num1, 'b=', num2)

func1(20)
답: a= 20 b= 2

해설:
func1 함수는 두 번째 매개변수 num2에 기본값 2가 지정되어 있다.
따라서 func1(20) 호출 시 num1은 20이 되고, num2는 기본값 2가 사용된다.
출력 결과는 a= 20 b= 2가 된다.
 -------------------------------------------------------------------------------------------------------
문제 16) 다음 java 코드 중 밑줄에 들어갈 알맞은 코드를 작성하시오.

```java
class Car implements Runnable {
    int a;
    public void fun(){
        System.out.println("func call");
    }
}

public class Main {
    public static void main (String [] args){
        Thread t1 = new Thread(new _____());
        t1.start();
    }
}
답: Car

해설:
Thread 생성자의 인자로 Runnable 인터페이스를 구현한 객체를 넣어야 하므로, Car 클래스의 인스턴스를 생성해야 한다.
따라서 new Car()가 밑줄에 들어가야 한다.
 -------------------------------------------------------------------------------------------------------

문제 17) 다음 java 프로그램의 결과를 쓰시오

```java
class A {
    int a;
    int b;
}

public class Main {
    static void func1(A a){
        a.a *= 10;
    }
    static void func2(A a){
        a.a += a.b;
    }

    public static void main(String[] args) {
        A a = new A();
        a.a = 100;
        func1(a);
        a.b = a.a;
        func2(a);
        System.out.println(a.a);
    }
}

답: 2000

해설:

a.a = 100 으로 초기화됨.

func1(a) 호출 시 a.a *= 10 → 100 * 10 = 1000

a.b = a.a → a.b = 1000

func2(a) 호출 시 a.a += a.b → 1000 + 1000 = 2000

출력값은 2000이 된다.

 -------------------------------------------------------------------------------------------------------

문제 18) 다음 c언어 프로그램의 출력결과를 쓰시오.  
(단 입력값은 5가 들어왔다고 가정한다.)

```c
#include<stdio.h>
int func(int i){
    if(i <= 1) return 1;
    return i * func(i-2);
}
int main(){
    int in;
    scanf("%d", &in);
    printf("%d", func(in));
}
답: 15

해설:
입력값이 5일 때 func(5)를 호출하면 다음과 같다.

func(5) = 5 * func(3)

func(3) = 3 * func(1)

func(1) = 1 (기저조건)

따라서
func(3) = 3 * 1 = 3
func(5) = 5 * 3 = 15

즉, 함수는 i가 1 이하가 될 때까지 2씩 감소시키면서 i 값들을 곱하는 방식으로 동작한다.
결과는 5 * 3 * 1 = 15가 출력된다.

복사
편집

 -------------------------------------------------------------------------------------------------------

## 📘 정보처리기사 실기 - C언어 수치 처리 문제

### 문제 19)
다음 C언어 프로그램의 괄호 안에 들어갈 알맞은 답을 작성하시오.

```c
#include<stdio.h>
int main(){
    int num = 1234;
    int div = 10;
    int res = 0;
    while(num ①0){
        res = res * div;
        res = res + num② div;
        num = num③ div;
    }
    printf("%d", res);
}

답:

① >

② %

③ /

📌 해설:
해당 코드는 정수의 자릿수를 뒤집어서 출력하는 프로그램입니다.

예시:
입력값 num = 1234 → 출력값 4321

✅ 각 줄의 의미 분석:
while(num > 0)       // ①: num이 0보다 클 때 반복
반복 조건: num이 0이 되기 전까지 루프 반복

res = res * div;     // 자릿수 자리 올림 (10배 증가)
기존의 res를 10배 하여 다음 숫자를 자리수 맞춰 저장할 준비

res = res + num % div;   // ②: 1의 자리 숫자 추출하여 res에 추가
%: 나머지 연산자, 현재 num의 마지막 자릿수(1의 자리)를 추출

num = num / div;     // ③: num을 10으로 나눠서 다음 자릿수 준비
/: 정수 나눗셈, 현재 자릿수 제거

✅ 결과 실행 흐름 예시 (num = 1234):
num	res	설명
1234	0	초기값
123	4	4 추출 후 저장
12	43	res = 4×10 + 3
1	432	res = 43×10 + 2
0	4321	res = 432×10 + 1

✅ 최종 출력
4321
 -------------------------------------------------------------------------------------------------------

### 문제 20) 다음 C언어 프로그램의 결과를 쓰시오

```c
int isPrime(int number){
    int i;
    for (i =2; i <number; i++){
        if(number % i == 0)
            return 0;
    }
    return 1;
}

int main(void){
    int number = 13195, max_div = 0, i;
    for(i = 2; i < number; i++)
        if(isPrime(i) == 1 && number % i == 0)
            max_div = i;

    printf("%d", max_div);
    return 0;
}

답: 29

✅ 코드 설명
🔹 isPrime(int number) 함수
매개변수 number가 소수인지 판별하는 함수

2부터 number-1까지 나누어 떨어지는 수가 있으면 0 (소수 아님) 반환

없으면 1 (소수임) 반환

🔹 main 함수 동작 흐름
number = 13195

2부터 13194까지 반복하면서, 다음 두 조건을 만족하는 수 i를 찾음:

i가 소수이고

number가 i로 나누어 떨어질 경우 (약수일 경우)

조건을 만족하면 max_div = i 로 갱신

즉, 13195의 소인수 중 가장 큰 값을 찾는 프로그램

📌 13195의 소인수들:
5 × 7 × 13 × 29
→ 모두 소수이며, 13195를 나눌 수 있음

📌 해설:
이 프로그램은 number = 13195의 소인수 중 가장 큰 수를 찾는 코드이다.

isPrime(i)가 참이고 number % i == 0인 값만 max_div에 저장되며,

최종적으로 가장 큰 소인수 29가 출력된다.

 -------------------------------------------------------------------------------------------------------
