## 문제 1) 다음 특정 DDOS 공격 방식 설명

공격자는 출발지 IP 주소를 피해자의 IP로 위조하여 다수의 호스트가 연결된 네트워크 브로드캐스트 주소로  
ICMP 에코 요청을 전송한다. 그 결과, 브로드캐스트 네트워크에 연결된 모든 호스트들이 피해자 IP로 대량의  
ICMP 에코 응답(Echo Reply)을 보내게 되면서, 피해자가 과도한 트래픽으로 인해 서비스 장애를 겪게 된다.  

**답:** 스머프(스머핑, smurf)

📌 관련 개념 설명:

### 스머프 공격 (Smurf Attack)  
- ICMP(Internet Control Message Protocol) 에코 요청을 네트워크의 브로드캐스트 주소로 보냄  
- **출발지 IP 주소를 피해자의 IP로 스푸핑**하여 다수 호스트가 피해자에게 ICMP 응답(Echo Reply)을 보냄  
- 피해자는 대량의 ICMP 응답을 받아 **서비스 거부(DoS)** 상태에 빠짐  
- **트래픽 증폭(amplification)** 공격의 일종이며, 브로드캐스트가 열려 있는 네트워크에서 위험

---

### DDoS 공격 주요 유형

| 공격명         | 특징 및 방식                                                                                  |
|----------------|----------------------------------------------------------------------------------------------|
| **Smurf Attack**   | ICMP 요청 + 브로드캐스트 + IP 스푸핑 → 대량 응답 폭탄                                        |
| **SYN Flooding**   | TCP 3-way 핸드쉐이크 중 SYN 요청만 과도하게 보내 서버 연결 대기 큐 자원 고갈                 |
| **UDP 플러딩**     | 무작위 포트에 UDP 패킷 대량 전송 → ICMP unreachable 응답 유도 → 자원 고갈                  |
| **Ping 플러딩**    | 과도한 ICMP Echo 요청 전송으로 대상 시스템 응답 처리 자원 소모                              |
| **Ping of Death**  | 과도한 크기의 ICMP 패킷을 조각내어 전송, 재조합 시 시스템 다운 유도                         |
| **Teardrop Attack**| 비정상 IP 조각 패킷 전송, 재조합 오류로 시스템 다운                                        |
| **Land Attack**    | 출발지와 목적지 IP 모두 피해자 IP로 설정, 자기 자신에게 요청 보내 시스템 장애                |

---

### 정보보안 3요소 (CIA Triad)

| 요소       | 설명                                                         | 예시                         |
|------------|--------------------------------------------------------------|------------------------------|
| **기밀성 (Confidentiality)** | 인가되지 않은 사용자가 정보에 접근하지 못하도록 보호                  | 데이터 암호화, 접근 통제       |
| **무결성 (Integrity)**       | 데이터가 인가되지 않게 변경되지 않고, 변경 여부를 확인할 수 있음         | 해시 함수, 메시지 인증 코드(MAC) |
| **가용성 (Availability)**    | 인가된 사용자가 필요한 시점에 자원과 서비스를 이용할 수 있음             | 백업, 이중화, 장애 복구 시스템  |

※ **고가용성 (High Availability)**: 장애 발생 시에도 서비스 연속성을 유지할 수 있도록 설계된 시스템 구조  

📌 관련 개념 설명:

### 스머프 공격 (Smurf Attack)  
- 예를 들어서 누가 “야, OO한테 다 같이 메시지 보내!”라고 네트워크 전체에 지시하는 거야.  
- 근데 그 메시지 출발지를 피해자 IP로 바꿔서 보내니까  
- 네트워크에 있는 컴퓨터들이 한꺼번에 피해자한테 답장 보내는 거야.  
- 그러면 피해자는 갑자기 엄청난 메시지 폭탄에 시달리게 되고,  
- 컴퓨터가 너무 바빠서 제대로 못 버티게 되는 거지.  
- 쉽게 말하면, 친구들한테 “OO야, 너한테 편지 보내!”라고 속여서  
- 편지가 한꺼번에 몰려오는 상황이라고 생각하면 돼.

---

### DDoS 공격 주요 유형 쉽게 설명

| 공격명         | 쉽게 설명                                        |
|----------------|------------------------------------------------|
| **Smurf Attack**   | 친구들한테 피해자한테 다 같이 메시지 보내라고 속임 (메시지 폭탄)       |
| **SYN Flooding**   | 계속 “안녕? 연결할래?”라고 요청만 보내서 상대방이 감당 못 하게 함    |
| **UDP 플러딩**     | 아무 포트로 계속 불특정 메시지 보내서 상대방 짜증나게 함     |
| **Ping 플러딩**    | “여기 있어?”라는 신호를 너무 많이 보내서 상대방 바쁘게 함           |
| **Ping of Death**  | 너무 큰 메시지를 쪼개서 보내 컴퓨터 멈추게 함 |
| **Teardrop Attack**| 이상한 방식으로 쪼갠 메시지 보내서 컴퓨터 헷갈리게 함               |
| **Land Attack**    | “나한테 나 좀 만나러 와!” 하면서 자기 자신한테 공격해서 혼란 유발    |

---

### 정보보안 3요소 (CIA Triad) 쉽게 예시로 이해하기

| 요소       | 쉽게 이해하는 예시                                 |
|------------|--------------------------------------------------|
| **기밀성** | 친구한테만 비밀 편지 보내기 (다른 사람은 못 봄)  |
| **무결성** | 편지가 중간에 누가 몰래 바꾸지 않았는지 확인하기  |
| **가용성** | 친구가 편지를 언제든 받을 수 있게 항상 대기하기  |

---

**정리하자면**  
- 스머프 공격은 친구들한테 피해자한테 한꺼번에 메시지 보내라고 속여서  
  피해자가 감당 못 하게 만드는 거야.  
- 보안 3요소는 친구랑 비밀편지 주고받을 때  
  누가 훔쳐보거나 바꾸지 않고, 친구가 언제든 편지를 받을 수 있게 하는 원칙이야.


-----------------------------------------------------------------------------------

## 문제 2) 다음 설명에 해당하는 기술이 무엇인가

사설 네트워크(Private Network)를 외부 인터넷 환경과 분리하여, 안전하게 데이터를 주고 받기 위해  
터널링(Tunneling)을 활용하는 기술이 있다. 이 기술은 IPsec 등 다양한 암호화 프로토콜을 사용해  
데이터 기밀성과 무결성을 보장하며, 기업이나 조직에서는 원격지 사용자들도 내부 네트워크에 안전하게  
접속할 수 있도록 이를 자주 이용한다.

**답:** VPN# 📌 IP 관련 주요 기술 쉽게 정리

인터넷과 네트워크 운영에서 자주 쓰이는 핵심 기술들을 아주 쉽게 설명할게.

---

## 1) NAT (Network Address Translation)  
- **역할:** 사설 IP와 공인 IP 사이를 바꿔준다.  
- **종류:**  
  - **Static NAT:** 내부 IP 1개 ↔ 외부 IP 1개 (1:1 매핑)  
  - **Dynamic NAT:** 내부 IP 여러 개 ↔ 외부 IP 여러 개 중 일부 사용  
  - **PAT (Port Address Translation):** 하나의 공인 IP에 여러 사설 IP를 포트 번호로 구분해 매핑  
- **갓반 예시:** 집에서 여러 기기가 동시에 인터넷 써도 하나의 공인 IP로 접속 가능!

---

## 2) DNS (Domain Name System)  
- **역할:** 사람에게 친숙한 도메인 이름(예: google.com)을 컴퓨터가 이해하는 IP 주소로 바꿔준다.  
- **갓반 예시:** www.naver.com 입력하면 네이버 서버 IP 주소를 찾아 연결해줌  

---

## 3) QoS (Quality of Service)  
- **역할:** 네트워크에서 중요한 데이터(영상통화, 게임 등)에 우선순위를 줘서 끊김 없이 통신 보장  
- **갓반 예시:** 집에서 영상통화 중인데, 누가 대용량 다운로드해도 영상은 끊기지 않게 함  

---

## 4) VPN (Virtual Private Network)  
- **역할:** 인터넷 같은 공용망 위에 안전한 ‘가상 터널’을 만들어서 사설망처럼 안전하게 통신 가능  
- **기술:**  
  - **터널링:** 데이터 숨겨서 보냄  
  - **암호화:** IPsec, SSL/TLS, PPTP, L2TP 등 사용  
- **갓반 예시:** 재택근무자가 집에서 회사 내부 서버에 안전하게 접속할 때 사용  

---

## 5) DHCP (Dynamic Host Configuration Protocol)  
- **역할:** 네트워크에 접속하는 기기에 자동으로 IP 주소를 나눠주는 마법사 같은 역할  
- **갓반 예시:** 집에 새로 연결한 스마트폰이 자동으로 IP 받아서 인터넷 바로 되는 거  

---

## 요약표: IP 관련 기술 한눈에

| 기술명 | 주요 역할과 특징                               | 갓반 예시                                   |
|--------|----------------------------------------------|---------------------------------------------|
| **NAT** | 사설 IP ↔ 공인 IP 변환, IP 부족 문제 해결    | 집안 여러 기기가 하나의 공인 IP로 인터넷 접속 |
| **DNS** | 도메인 이름 ↔ IP 주소 변환                   | www.google.com을 컴퓨터가 이해하는 IP로 변환 |
| **QoS** | 중요한 트래픽 우선 처리로 끊김 방지          | 영상통화 중 다운로드 많아도 영상 끊기지 않음   |
| **VPN** | 공용망 위에 안전한 가상 터널 만들어 사설망처럼 사용 | 재택근무자가 회사망 안전하게 접속               |
| **DHCP**| 네트워크 접속 장치에 자동 IP 주소 할당       | 새 스마트폰 자동으로 IP 받아 인터넷 연결        |

---

※ 이 기술들이 없으면 현대 인터넷과 기업 네트워크가 제대로 운영되기 어렵다!



-----------------------------------------------------------------------------------
--
## 문제 3) 객체 간의 협력과 상호작용을 설계하는 패턴들의 묶음을 무엇이라 하는지 패턴 그룹의 명칭을 작성해라

소프트웨어 디자인 패턴은 크게 생성패턴(Creational Pattern), 구조패턴(Structural Pattern),  
그리고 특정 패턴 그룹으로 구분된다.  
이 특정 패턴 그룹은 객체나 클래스가 서로 상호작용하는 방식에 초점을 맞추며  
클래스 간의 책임 분배나 알고리즘 변화에 유연하게 대응할 수 있도록 설계 방안을 제시한다.  
이 그룹에는 옵서버(Observer), 상태(State), 전략(Strategy) 등과 같은 대표적인 패턴들이 포함된다.

**답:** 행위 패턴

# 📌 소프트웨어 디자인 패턴 3대 그룹과 행위 패턴 정리

소프트웨어 디자인 패턴은 객체 간 상호작용과 책임 분배를 설계하는 방법을 정형화한 것이다.  
특히 **행위 패턴(Behavioral Patterns)**은 객체들 간 소통과 협력을 중점으로 한다.

---

## 1) 디자인 패턴 3대 그룹

| 패턴 그룹                  | 설명                                                      | 대표 패턴 예시                                               |
|---------------------------|-----------------------------------------------------------|--------------------------------------------------------------|
| 생성 패턴 (Creational)       | 객체 생성 방법을 추상화해 유연한 생성 지원                  | Singleton, Factory Method, Abstract Factory, Builder, Prototype |
| 구조 패턴 (Structural)       | 클래스/객체를 조합해 큰 구조를 만드는 방법                  | Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy |
| 행위 패턴 (Behavioral)       | 객체 간 책임 분배와 상호작용 설계                           | Observer, State, Strategy, Command, Template Method, Mediator, Chain of Responsibility |

---

## 2) 행위 패턴 주요 특징과 갓반인 예시

- **책임 분배와 소통**에 초점  
- 시스템을 유연하고 확장성 있게 설계 가능  
- 주요 패턴과 간단 설명

| 패턴 이름        | 설명                                                                                      | 갓반인 예시                                              |
|-----------------|-----------------------------------------------------------------------------------------|---------------------------------------------------------|
| Observer        | 한 객체 상태 변하면 등록된 다른 객체들이 자동으로 알림 받음                                | 뉴스 구독자가 새로운 뉴스가 올라오면 자동으로 알림 받음      |
| State           | 객체 상태에 따라 행동이 동적으로 바뀜                                                  | 교통신호등이 빨간불/초록불에 따라 다른 행동 수행              |
| Strategy        | 알고리즘을 캡슐화해 런타임에 알고리즘을 바꿀 수 있음                                     | 결제 방식을 카드/페이팔 등으로 런타임에 선택 가능              |
| Command         | 요청을 객체로 캡슐화해 호출자와 수행자 분리                                            | 리모컨이 버튼 누를 때 명령을 객체로 처리하여 다양한 기기 조작   |
| Template Method | 알고리즘의 뼈대를 정의하고, 구체적인 단계는 하위 클래스가 구현                             | 요리법 기본 틀은 같고, 재료 준비만 요리사마다 다르게 구현        |
| Mediator        | 객체 간 복잡한 상호작용을 중앙 집중식으로 관리                                          | 항공 교통 관제사가 비행기 간 통신을 조율                       |
| Chain of Responsibility | 요청을 처리할 객체를 체인으로 연결해 순차 처리                                         | 고객 서비스 요청이 상담원→팀장→부장 순서로 전달됨               |

---

※ 디자인 패턴은 유지보수성 ↑, 코드 재사용 ↑, 팀 내 의사소통 원활에 큰 도움을 준다.



-----------------------------------------------------------------------------------

## 문제 4) 다음에서 설명하는 세 가지 대표적인 커버리지를 1, 2, 3 순서대로 각각 한글로 작성하시오

소프트웨어 테스트에서 코드의 검증 범위를 정량적으로 평가하는 '테스트 커버리지(Test Coverage)' 기법에는 여러 유형이 있다.  
예를 들어, 코드 상의 모든 문장이 최소 한 번 이상 실행되는지를 검사하는 (1),  
if나 switch 같은 분기문이 각각 정상적으로 수행되는지 확인하는 (2),  
그리고 각 조건식이 참/거짓으로 조합되도록 확인하는 (3) 커버리지가 대표적이다.

**답:**  
1) 구문 커버리지  
2) 분기 커버리지 / 결정 커버리지  
3) 조건 커버리지

# 📌 테스트 커버리지 종류 쉽게 정리

테스트 커버리지는 **테스트가 소스코드의 어느 정도를 실행했는지** 측정하는 지표야.  
주로 구문 → 분기(결정) → 조건 커버리지 순으로 이해하면 편해.

---

## 1) 기본 커버리지 종류

| 커버리지 종류                | 설명                                                      | 예시/특징                                  |
|-----------------------------|-----------------------------------------------------------|--------------------------------------------|
| 구문 커버리지 (Statement Coverage) | 코드의 모든 한 줄 한 줄(구문)이 최소 한 번은 실행되었는지 확인 | if문 내부 문장이 실행됐는지 체크             |
| 분기 커버리지 (Branch/Decision Coverage) | 조건문 등 분기점의 참/거짓이 각각 한 번씩 실행됐는지 확인      | if문의 참일 때, 거짓일 때 모두 실행됐는지 확인 |
| 조건 커버리지 (Condition Coverage) | 복합 조건문에서 각 조건이 참과 거짓 각각 한 번씩 실행됐는지 확인  | if (A && B)에서 A가 T/F, B가 T/F인 경우 체크  |

---

## 2) 추가 커버리지 유형

| 커버리지 유형                | 설명                                                                                 |
|-----------------------------|--------------------------------------------------------------------------------------|
| 조건/결정 커버리지 (C/D)       | 조건 커버리지와 결정 커버리지를 함께 확인하는 형태                                   |
| 변경 조건/결정 커버리지 (MC/DC) | 각 조건이 결정 결과에 독립적으로 영향을 미치는지 검증하는 고신뢰성 테스트 (항공, 의료 등)   |
| 다중 조건 커버리지            | 조건식 내 모든 조건 조합을 100% 테스트                                               |
| 경로 커버리지 (Path Coverage)  | 가능한 모든 실행 경로를 전부 테스트                                                  |

---

## 3) 주의 사항

- 높은 커버리지는 코드 실행량이 많다는 뜻이지, **버그가 없다는 보장은 아님**  
- 보통 실무에서는 구문+분기 커버리지부터 시작하고, 중요 시스템에선 MC/DC 등 더 엄격한 기준을 추가로 사용  

---

## 갓반인 예시

- if (x > 0 && y == 10) 문에서  
  - 구문 커버리지: if문 내부 코드가 한 번이라도 실행됐으면 OK  
  - 분기 커버리지: x > 0 조건이 참일 때, 거짓일 때 모두 실행되어야 함  
  - 조건 커버리지: x > 0과 y == 10 각각이 참과 거짓인 경우가 테스트돼야 함  
  - MC/DC: x나 y 각각이 결과에 독립적으로 영향을 미쳤는지 확인  




-------------------------------------------------------------------------------------------------------------------------------------------

## 문제 5) 관계형 데이터베이스(Relational Database)에서 테이블을 설계할 때, 아래와 같은 역할을 하는 네 가지 키가 있다.

1) 한 테이블의 특정 속성이 다른 테이블(또는 동일 테이블)의 튜플을 참조함으로써, 테이블 간의 연관관계와 무결성을 유지하기 위한 키  
2) 릴레이션에서 각 튜플을 고유하게 식별하며, 속성의 집합이 최소로 구성되어 있는 키  
3) 위 2번 키가 여러 개 존재할 경우 그중 기본키로 선정되지 않은 키  
4) 릴레이션에서 모든 튜플을 유일하게 식별할 수 있는 속성들의 부분집합(적어도 하나 이상의 2번 키를 포함)으로 구성된 키  

**답:**  
1) 참조키 = 외래키  
2) 후보키  
3) 대체키  
4) 슈퍼키

# 📌 키(Key) 및 데이터베이스 설계 핵심 정리

관계형 데이터베이스에서 테이블 간 무결성과 식별성을 위해 다양한 키가 사용돼.  
외래키는 테이블 간 관계 유지, 후보키는 유일한 키 후보들, 기본키는 대표 키, 대체키는 후보키 중 선택 안 된 것, 슈퍼키는 후보키를 포함한 더 넓은 개념이야.

---

## 1) 키(Key)의 종류

| 키 종류     | 설명                                                        | 갓반인 예시                             |
|-------------|-------------------------------------------------------------|---------------------------------------|
| 슈퍼키       | 튜플을 유일하게 식별 가능한 속성들의 집합. 후보키 포함         | (학번), (학번+이름), (주민번호) 등       |
| 후보키       | 최소성 만족한 슈퍼키, 여러 후보키 존재 가능                   | (학번), (주민번호)                      |
| 기본키       | 후보키 중 대표로 선택, 중복·NULL 불가                        | (학번)                                 |
| 대체키       | 후보키 중 기본키 아닌 나머지                                 | (주민번호)                             |
| 외래키       | 다른 테이블 기본키 참조해 테이블 관계 표현                    | 학생 테이블의 학과 코드                  |

---

## 2) 데이터베이스 설계 단계

| 단계         | 설명                                                      |
|--------------|-----------------------------------------------------------|
| 개념 설계     | ER 다이어그램 등 요구사항 모델링                           |
| 논리 설계     | DBMS 독립적 릴레이션 스키마 설계                            |
| 물리 설계     | 실제 DBMS 환경 맞춤 구현 (정규화, 인덱스 설계 포함)          |

---

## 3) 정규화 (Normalization)

| 정규형        | 핵심 내용                                                  |
|---------------|------------------------------------------------------------|
| 1정규형 (1NF)  | 도메인이 원자값(더 쪼갤 수 없는 값)으로 구성               |
| 2정규형 (2NF)  | 기본키 일부에만 종속된 속성 제거 (부분 함수 종속 제거)       |
| 3정규형 (3NF)  | 비키 속성이 다른 비키 속성에 종속된 경우 제거 (이행 함수 종속 제거) |
| BCNF          | 결정자가 후보키 아닌 경우 제거                              |
| 4정규형 (4NF)  | 다치 종속 제거                                             |
| 5정규형 (5NF)  | 조인 종속 제거                                             |

---

## 4) 트랜잭션의 4가지 특성 (ACID)

| 특성       | 설명                                                    |
|------------|---------------------------------------------------------|
| 원자성     | 작업은 전부 수행되거나 전혀 수행되지 않아야 함             |
| 일관성     | 트랜잭션 전후 데이터 상태가 항상 일관되어야 함             |
| 독립성     | 동시에 실행되는 트랜잭션 간 간섭을 방지                     |
| 영속성     | 성공한 트랜잭션 결과는 영구히 저장됨                        |

---

## 5) 갓반인 예시

- 슈퍼키 / 후보키 / 기본키 / 대체키  
  학생 테이블에서:  
  - 슈퍼키: (학번), (학번+이름), (학번+생년월일) 등 여러 조합 가능  
  - 후보키: (학번), (주민번호) — 유일하고 최소 조건 만족  
  - 기본키: (학번) — 대표 키  
  - 대체키: (주민번호) — 기본키 외 후보키  

- 외래키  
  학생 테이블의 학과 코드가 학과 테이블 기본키인 학과 코드를 참조  

- 트랜잭션  
  은행 이체 시 보내는 계좌 잔액 감소와 받는 계좌 잔액 증가 작업은 한 트랜잭션으로 묶어, 어느 하나 실패 시 모두 취소(원자성 보장)



-----------------------------------------------------------------------------------

## 문제 6) URL은 크게 아래와 같은 5가지 구성 요소로 이루어진다.  
다음 각각 요소(5가지)를 URL에서 나타나는 순서에 맞게 적으시오.

1) query: 서버에 전달할 추가 데이터  
2) path: 서버 내 특정 자원을 가리키는 경로  
3) scheme: 리소스에 접근하는 방법이나 프로토콜  
4) authority: 사용자 정보, 호스트명, 포트번호  
5) fragment: 특정 문서 내의 위치  

예시 URL:  
https://user:pass@exam.com:8080/products/items?id=123&s=asc#specs  

답: 4-3-1-2-5

# 📌 URL 구조 완전 정복

야, 이 URL은 인터넷 주소의 기본 구조를 보여주는 거야.  
복잡해 보이지만, 각 부분이 어떤 역할을 하는지 알면 존나 쉬워.

---

## 1) scheme (스키마)

- 예: `https`
- 역할:  
  어떤 **통신 규약(프로토콜)**을 사용해서 서버에 접속할지를 알려주는 부분  
- 설명:  
  웹에서는 보통 `http`나 `https`를 쓰는데,  
  `https`는 `http`에 보안 기능이 더해진 것이라고 보면 돼.  
- 갓반인 예시:  
  - `http://` → 보안 없는 일반 웹 접속  
  - `https://` → 보안 강화된 웹 접속 (예: 은행 사이트)

---

## 2) authority (권한 / 권위)

- 예: `user:pass@exam.com:8080`
- 역할:  
  접속하려는 **서버 주소와 인증 정보**를 나타내는 부분  
- 설명:  
  - `user:pass@`: 서버에 접속할 때 필요한 **사용자 이름(user)**과 **비밀번호(pass)** (특정 시스템에서 사용)  
  - `exam.com`: 접속할 서버의 **도메인 이름(주소)**  
  - `:8080`: 서버의 **포트 번호** (보통 웹 서버는 80 또는 443, 특수한 경우 포트 번호 명시)  
- 갓반인 예시:  
  - `admin:1234@myserver.com:3000` → 아이디가 `admin`, 비밀번호 `1234`, 서버는 `myserver.com`이고, 포트는 3000번

---

## 3) path (경로)

- 예: `/products/items`
- 역할:  
  서버 내에서 **어떤 자원(파일, 페이지 등)에 접근할지 경로를 지정**하는 부분  
- 설명:  
  웹사이트 내 폴더 구조 또는 특정 페이지 위치라고 생각하면 쉬워  
- 갓반인 예시:  
  - `/blog/posts/2025` → 2025년 블로그 게시물 페이지  
  - `/images/logo.png` → 로고 이미지 파일 위치

---

## 4) query (쿼리 / 질의)

- 예: `?id=123&s=asc`
- 역할:  
  서버에 **추가 정보(매개변수)를 전달**하는 부분  
- 설명:  
  - `?` 다음에 키=값 형태로 여러 데이터를 넘김  
  - 여러 쿼리는 `&`로 구분  
- 갓반인 예시:  
  - `?search=phone&sort=price` → 검색어는 'phone', 가격순 정렬 요청  
  - `?page=2&limit=20` → 2페이지, 한 페이지에 20개 항목 요청

---

## 5) fragment (프래그먼트 / 조각)

- 예: `#specs`
- 역할:  
  웹페이지 내부의 **특정 위치(앵커)**로 바로 이동하기 위한 식별자  
- 설명:  
  서버로는 전송되지 않고, 브라우저가 받은 후 페이지 내에서만 사용됨  
- 갓반인 예시:  
  - `#section3` → 문서 내 3번째 섹션으로 바로 이동  
  - `#contact` → 연락처 부분으로 즉시 스크롤

---

# 🎯 정리

| URL 구성 요소 | 역할 요약                        | 갓반인 예시                  |
|---------------|---------------------------------|------------------------------|
| scheme        | 접속 프로토콜 지정               | `https://`                   |
| authority     | 서버 주소 및 인증 정보 포함       | `user:pass@exam.com:8080`    |
| path          | 서버 내 파일/페이지 경로          | `/products/items`            |
| query         | 서버에 전달하는 매개변수          | `?id=123&s=asc`              |
| fragment      | 페이지 내 특정 위치 식별자        | `#specs`                     |

---

URL이 처음엔 복잡해도 이렇게 하나씩 뜯어보면 엄청 쉽고 명확해져!  
각 부분이 무슨 역할 하는지만 알면 웹 주소는 완전 내 손 안에 있어.

📌 관련 개념 설명:

### ✅ URL(Uniform Resource Locator) 구성 요소 설명 및 순서

[https://user:pass@exam.com:8080/products/items?id=123&s=asc#specs
 \___/  \___________________________/ \_________/ \__________/ \___/
  (1)            (2)                     (3)         (4)       (5)
scheme        authority                 path       query    fragment]
 \___/   \___________________________/ \_________/ \__________/ \___/
  (1)             (2)                     (3)         (4)       (5)


답: 4-3-1-2-5
-----------------------------------------------------------------------------------

## 문제 7) 아래 사례에서 '학번'을 기본키로 지정했을 때  
null값과 중복값을 모두 허용하지 않도록 하는 무결성 제약 조건은 무엇인지 쓰시오

어느 대학의 "학생" 테이블에서 '학번'을 기본키(Primary Key)로 지정하려고 한다.  
이때 데이터베이스가 자동으로 다음을 강제하도록 설정하였다.  

1. 학번에 NULL 값을 입력할 수 없다.  
2. 이미 존재하는 학번과 중복된 값을 입력할 수 없다.  

이로써 테이블에 유효하지 않은 학번 정보가 저장되는 일을 막아  
데이터가 정확하게 관리되도록 하였다.

**답:** 개체 무결성 제약조건

**해설:**  
기본키로 지정된 '학번'은 테이블의 각 튜플을 유일하게 식별하는 역할을 하며,  
데이터베이스는 기본키 제약을 통해 자동으로 **NULL 금지** 및 **중복 금지** 규칙을 적용한다.  
이러한 특성은 개체 무결성(Entity Integrity)에 해당한다.

📌 관련 개념 설명:

### ✅ 무결성 제약조건 (Integrity Constraints)

관계형 데이터베이스에서 **데이터의 정확성, 일관성**을 보장하기 위해 제약 조건을 설정한다.  
주요 무결성 제약조건은 다음과 같다:

| 제약조건 종류               | 설명                                                                                     |
|----------------------------|------------------------------------------------------------------------------------------|
| **개체 무결성 (Entity Integrity)**      | 기본키(Primary Key)는 **반드시 NOT NULL이며 유일(unique)**해야 함.  <br>→ 테이블의 각 튜플(행)을 식별하기 위한 핵심 규칙.    |
| **참조 무결성 (Referential Integrity)** | 외래키(Foreign Key)는 참조하는 기본키가 **존재해야 함**.  <br>→ 부모 테이블의 값이 삭제되거나 존재하지 않으면 오류 발생           |
| **도메인 무결성 (Domain Integrity)**    | 속성 값이 정의된 **데이터 타입, 범위, 형식**을 벗어나지 않도록 제한 <br>→ 예: 점수는 0~100 사이만 허용                           |
| **사용자 정의 무결성 (User-defined)**   | 업무 규칙에 따라 사용자가 직접 정의한 제약조건 <br>→ 예: 급여는 최소 200만원 이상이어야 함 등                                    |

---

### ✅ 개체 무결성과 기본키 제약 조건

- **기본키는 자동으로 개체 무결성을 만족해야 함**
  - **NULL 불허**
  - **중복 불허**

- 예시:

```sql
CREATE TABLE 학생 (
  학번 CHAR(10) PRIMARY KEY,
  이름 VARCHAR(20)
);

-----------------------------------------------------------------------------------

## 문제 8) 중앙 집중적 기반 시설 없이 각 무선 단말기들이 직접 연결되어 임시 통신망을 형성하고,  
군사작전이나 긴급의료 등의 응용 분야에서 활용되는 이 네트워크 방식을 무엇이라 하는지 쓰시오

군사작전 지역이나 긴급 의료 상황 등 기반 시설이 파괴되거나 부재한 환경에서는  
빠르게 통신망을 구축하는 것이 매우 중요하다. 이를 위해 무선 단말기들이 중앙 집중식 기지국 없이  
서로 직접 연결하여 통신할 수 있는 네트워크 기술이 종종 활용된다. 이 방식은 기기간 자율적인  
경로 설정과 유지가 가능하여, 재난 구조 활동이나 전장 같은 이동성이 높은 환경에서도  
효과적으로 사용될 수 있다.

**답:** 애드혹 네트워크 (ad-hoc network)

## ✅ 애드혹 네트워크 (Ad-hoc Network) 완전 쉬운 정리

---

### 🔍 **해설:**

애드혹 네트워크는  
👉 **AP(Access Point)**나 **고정된 인프라 없이**,  
👉 **무선 단말기들끼리 직접 연결**해서 구성하는 자율적인 네트워크야.  

💡 즉, "야, 너랑 나랑 직접 통신하자!" 이런 구조.  
🏕️ **군대, 재난 현장, 응급상황**에서 인프라 없어도 즉시 연결돼서 아주 유용해.

---

### 📌 핵심 정리표

| 항목       | 설명                                                                                     |
|------------|------------------------------------------------------------------------------------------|
| ✅ 정의       | **중앙 장비 없이** 단말기들끼리 직접 통신하여 네트워크를 구성 |
| ✅ 특징       | - **빠른 구성** 가능 (플러그 없이 바로 통신)<br>- **동적으로 변화하는 구조** (노드가 움직여도 OK)<br>- **자체 라우팅**으로 데이터 전달<br>- **인프라 없어도** 운영 가능 |
| ✅ 활용 예시  | - 군사작전 (야전에서 통신)<br>- 지진/홍수 등 재난 구조<br>- 응급환자 의료 통신<br>- 차량 간 통신(VANET)<br>- 센서 네트워크(MANET) |

---

### 🤜 인프라 기반 네트워크 vs 애드혹 네트워크

| 구분                    | 기반 구조 네트워크                         | 애드혹 네트워크                                  |
|-------------------------|--------------------------------------------|---------------------------------------------------|
| 구성 방식               | **AP(Access Point)** 등 중앙 장비 필요     | **AP 없이 단말기끼리 직접 연결**                   |
| 구축 속도               | 느림 (설치 필요)                           | 빠름 (그냥 연결됨)                                |
| 유연성/확장성           | 낮음                                       | **매우 높음** (노드 추가/이동 자유로움)            |
| 예시                    | 와이파이, 사무실 무선랜                    | 군대 무전기, 응급현장 통신, VANET 등               |

---

### 📘 애드혹 네트워크의 확장 개념

| 용어            | 설명                                                             |
|-----------------|------------------------------------------------------------------|
| **MANET**       | Mobile Ad-hoc Network: **이동성 강한 노드**들이 모인 네트워크 (예: 군사 장비, 로봇) |
| **VANET**       | Vehicular Ad-hoc Network: **차량 간 통신**을 위한 애드혹 네트워크 (예: 자율주행 협업) |

---

### ✅ 한 줄 요약

> 애드혹 네트워크는 **인프라 없이도 단말기들끼리 알아서 똑똑하게 통신하는 자율형 네트워크**다.  
> 빠르고 유연해서, **군사·재난·응급** 상황에서 핵심적인 역할을 한다! 💥




-----------------------------------------------------------------------------------

## 문제 9) UML을 보고 알맞는 관계를 선택하여 작성하시오

```
            차
      /      |       ＼
1) 타이어   바퀴    엔진

            차
      ↗     ↑      ↖
2) 버스    택시    승용차

3) 텔레비전 ---> 리모콘
```

**답:**  
1) 연관 관계  
2) 일반화 관계  
3) 의존 관계## ✅ UML 관계 3가지 핵심 정리 (feat. 갓반인)

### 1️⃣ 연관 관계 (Association)  
> "**같이 있어야 의미 있음** – 서로 연결되어 함께 굴러감"

🧠 **정의:**  
- 객체끼리 **구조적으로 연결**되어 있음  
- 한 객체가 다른 객체의 **구성 요소**처럼 동작  
- 서로 독립적이지만, 관계가 **명확하고 지속됨**

🚌 **예시 (갓반인식)**  
- **차 ←→ 타이어, 엔진, 바퀴**  
  - 타이어 빠지면 차 못 굴러  
  - 차는 이 부품들과 **연결되어야만** 굴러감

🔧 UML 기호: `실선`

---

### 2️⃣ 일반화 관계 (Generalization)  
> "**부모 자식 관계** – 상속해서 기능 물려받음"

🧠 **정의:**  
- **상위 클래스**의 속성과 기능을 **하위 클래스**가 물려받음  
- "**is-a 관계**" → A는 B이다  
- 상속(extends)

🚌 **예시 (갓반인식)**  
- **차 → 버스 / 택시 / 승용차**  
  - 버스는 차다 ✅  
  - 택시도 차다 ✅  
  - 상위 개념(차)이 있고, 하위 개념들이 구체화된 케이스

🔧 UML 기호: `실선 + 빈 삼각형(상속 방향)`

---

### 3️⃣ 의존 관계 (Dependency)  
> "**잠깐 빌려 쓰는 사이** – 없어도 존재는 가능"

🧠 **정의:**  
- 한 클래스가 **다른 클래스의 기능을 일시적으로 사용**  
- 의존 대상이 없어도 객체는 존재 가능  
- 느슨한 연결 → "**일시적 사용**"

🚌 **예시 (갓반인식)**  
- **텔레비전 → 리모콘**  
  - 리모콘 없어도 텔레비전은 작동 가능  
  - 근데 리모콘이 있으면 더 편리하지  
  - 잠깐 사용하는 관계

🔧 UML 기호: `점선 + 화살표`

---

## ✅ 기타 UML 관계도 요약 정리

| 관계 유형       | 설명                                          | UML 표현                    | 갓반인 예시 |
|----------------|-----------------------------------------------|-----------------------------|-------------|
| **일반화 (Generalization)** | 상속 관계 (is-a)                             | `실선 + 빈 삼각형`             | 차 → 택시 |
| **연관 (Association)**     | 구조적 연결 (has-a)                         | `실선`                        | 차 → 바퀴 |
| **의존 (Dependency)**      | 일시적 사용 (uses-a)                        | `점선 + 화살표`               | TV → 리모콘 |
| **실체화 (Realization)**   | 클래스가 인터페이스 구현                   | `점선 + 빈 삼각형`             | Remote → SamsungTV implements |
| **집약 (Aggregation)**     | 포함하지만 생명주기 독립                   | `실선 + 빈 마름모`             | 반 → 학생 (학생은 다른 반에 가도 됨) |
| **합성 (Composition)**     | 포함 + 생명주기 공유 (강한 소유)           | `실선 + 채워진 마름모`         | 집 → 방 (집 없어지면 방도 사라짐) |

---

## 🧠 그림 없이도 느낌 오는 정리

- **일반화** = "상속이다"  
- **연관** = "부품/구성 요소다"  
- **의존** = "잠깐 빌려 쓴다"  
- **집약** = "소유는 하되 독립적이다"  
- **합성** = "내가 죽으면 쟤도 죽는다"


```

-----------------------------------------------------------------------------------

## 문제 11) LRU 알고리즘을 적용했을 때 발생하는 페이지 부재(페이지 폴트) 횟수를 구하시오  
(단, 할당된 프레임의 수는 3개이다)

**페이지 참조 순서:**  
7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1  

**프레임 상태 변화 및 폴트 여부:**  
```
Step:     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
Input:    7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1
Frame1:   7  7  7  2  2  2  2  4  4  4  0  0  1  1  1  1  1  1  1  1
Frame2:      0  0  0  0  0  0  0  0  3  3  3  3  3  0  0  0  0  0  0
Frame3:         1  1  1  3  3  3  2  2  2  2  2  2  2  2  7  7  1
Fault?:   O  O  O  O  X  O  X  O  O  O  O  X  O  X  O  X  O  X  X
```

**답:** 12회

---
## ✅ 📌 LRU 알고리즘이 뭐냐?

> **LRU (Least Recently Used)** =  
> “**가장 오래전에 사용한 페이지**를 제일 먼저 버린다.”

### 🧠 핵심 로직

- 메모리에 **없는 페이지** 요청 →  
  📛 **페이지 폴트 발생 + 교체**  
- 메모리에 **있는 페이지** 요청 →  
  ✅ **최근 사용한 걸로 시간 갱신** (폴트 없음)

---

### 💡 갓반인 예시

> 페이지 순서: `1 2 3 4 1 2 5 1 2 3 4 5`  
> 프레임 3칸이라고 가정!

🧾 결과 요약: **페이지 폴트 12회 중 9회 발생**

```
프레임 상태 변화를 보면:
1 → 2 → 3 → 4(1 out) → 1 → 2 → 5(3 out) → 1 → 2 → 3(4 out) → 4(5 out) → 5(1 out)
```

---

## 🧠 페이지 교체 알고리즘 요약표

| 알고리즘 | 요약 설명 | 갓반인 스타일 예시 |
|----------|-----------|---------------------|
| **FIFO** | 먼저 들어온 놈을 먼저 내보냄 | `1 2 3` → 다음이 `4`면 1이 나감 |
| **OPT** | **앞으로 제일 안 쓸 놈**을 제거 | `2 3 2 1 5 2 4` → 향후에 안 나올 애 제거 |
| **LRU** | **오래전에 쓴 놈**부터 제거 | `1 2 3` → 다음이 `4`면 **1**이 가장 오래전에 사용됨 |
| **LFU** | **사용 횟수 제일 적은 놈** 제거 | `1 2 1 3 2 4` → 3, 4는 적게 쓰임 |
| **SCR** | FIFO + 기회 1번 더 줌 | 사용 비트 1이면 뒤로 넘겨 |
| **NUR** | 최근 사용 안된 페이지 우선 제거 | 사용 + 수정 비트로 판단 |

---

## ✅ CPU 스케줄링 알고리즘 요약

### 🔹 선점형 (Preemptive)

> CPU 뺏을 수 있음. "야 너 나와봐"가 가능

| 알고리즘 | 설명 | 갓반인 예시 |
|----------|------|--------------|
| **Round Robin** | 타임쿼텀 지나면 뺏김 | `A(5초)`, 쿼텀 3초 → A(3) 끝나고 다음 프로세스 |
| **SRT (최단 남은 시간 우선)** | 실행 중인 거라도 더 짧은 애 오면 바꿈 | P1(남은 4초) 실행 중, P2(남은 2초) 오면 → P2 |
| **MLQ (다단계 큐)** | 인터랙티브/배치 나눠서 큐 관리 | 게임은 우선 큐, 백업은 후순위 큐 |
| **MLFQ** | 큐 간 이동 가능. 우선순위 변화 있음 | 오래 돌리면 하위 큐로 떨어짐 (너 일 좀 쉬어) |

---

### 🔸 비선점형 (Non-Preemptive)

> CPU 한 번 잡으면 끝날 때까지 절대 안 뺏김

| 알고리즘 | 설명 | 갓반인 예시 |
|----------|------|-------------|
| **FCFS** | 먼저 온 작업 먼저 처리 | `P1(3초)`, `P2(1초)` → 무조건 P1부터 |
| **SJF** | 실행시간 가장 짧은 작업 먼저 | `P1(5초)`, `P2(2초)` → P2 먼저 |
| **HRN** | (대기+실행)/실행 비율로 우선순위 | 오래 기다린 작업일수록 우선 |
| **기한부 스케줄링** | 마감 시간 임박한 작업 먼저 처리 | `P1(마감 10초)`, `P2(마감 3초)` → P2 우선 |

---

## ✅ 기타 개념 요약

| 용어 | 설명 | 갓반인 예시 |
|------|------|-------------|
| **Aging (에이징)** | 우선순위 낮은 작업의 우선순위를 점점 올려줌 | 오래 기다리면 자동으로 VIP 됨 |
| **Starvation (기아)** | 우선순위 낮아서 계속 대기만 함 | SJF에서 긴 작업 계속 무시됨 |




-----------------------------------------------------------------------------------

## 문제 11

**문제**  
SQL 명령어에 맞는 출력 결과를 작성하시오.

### [employee] 테이블

| no | name   | p_id |
|----|--------|------|
| 1  | 이흥직 | 10   |
| 2  | 이창훈 | 20   |
| 3  | 이경직 | 10   |

### [project] 테이블

| p_id | name      |
|------|-----------|
| 10   | CJOne     |
| 20   | Asiana    |
| 30   | SignsSEA  |

### SQL 명령문

SELECT
  count(*)
FROM employee e
INNER JOIN project p
  ON e.p_id = p.p_id
WHERE p.name IN (
  SELECT name FROM project p
  WHERE p.p_id IN (
    SELECT p_id FROM employee
    GROUP BY p_id
    HAVING count(*) < 2
  )
);

답: 1


📌 설명 (안쪽 쿼리부터 차근차근 풀어나가는 게 핵심!)
야, 이 SQL 쿼리는 존나 길고 복잡해 보이지? 근데 쫄지 마! SQL은 안쪽 쿼리부터 바깥쪽으로 하나씩 풀어보면 별거 아니야. 계층적으로 파고들어 보자.

1. 제일 안쪽 쿼리부터 분석: SELECT p_id FROM employee GROUP BY p_id HAVING count(*) < 2
SELECT p_id FROM employee GROUP BY p_id: employee 테이블에서 p_id (프로젝트 ID)별로 묶어.

p_id = 10: 이흥직, 이경직 (2명)

p_id = 20: 이창훈 (1명)

HAVING count(*) < 2: 각 p_id 그룹의 직원 수가 2명보다 적은(1명) 것만 골라.

p_id = 10은 2명이니까 탈락.

p_id = 20은 1명이니까 통과.

이 쿼리 결과: 20
(즉, 직원이 2명 미만인 프로젝트 ID는 20번 프로젝트뿐이다.)

2. 중간 쿼리 분석: SELECT name FROM project p WHERE p.p_id IN (결과_1번)
이제 위에서 나온 20을 p.p_id IN (...) 안에 넣어.

SELECT name FROM project WHERE p_id IN (20): project 테이블에서 p_id가 20인 프로젝트의 name을 찾아.

project 테이블을 보면 p_id = 20은 **Asiana**지?

이 쿼리 결과: 'Asiana'
(즉, 직원이 2명 미만인 프로젝트의 이름은 'Asiana'다.)

3. 가장 바깥쪽 메인 쿼리 분석: SELECT count(*) FROM employee e INNER JOIN project p ON e.p_id = p.p_id WHERE p.name IN (결과_2번)
이제 위에서 나온 'Asiana'를 p.name IN (...) 안에 넣어.

WHERE p.name IN ('Asiana'): 이 조건을 만족하는 데이터를 찾을 거야.

먼저 employee 테이블과 project 테이블을 p_id가 같은 것끼리 INNER JOIN 해봐.


### ✅ INNER JOIN 결과 테이블

| e.no | e.name  | e.p_id | p.p_id | p.name  |
|------|---------|--------|--------|---------|
| 1    | 이흥직   | 10     | 10     | CJOne   |
| 2    | 이창훈   | 20     | 20     | Asiana  |
| 3    | 이경직   | 10     | 10     | CJOne   |


이제 이 조인 결과 중에서 p.name이 'Asiana'인 것만 골라내.

p.name = 'CJOne' (이흥직): 탈락
p.name = 'Asiana' (이창훈): 통과!
p.name = 'CJOne' (이경직): 탈락

최종적으로 남는 행: 이창훈 (p_id 20, Asiana) 한 명!

마지막으로 SELECT count(*)니까, 남은 행의 개수를 세면 돼.

남은 행은 1개지?

최종 결과: 1


-----------------------------------------------------------------------------------

문제 12) Java 코드 출력 결과


public class Main {

                                                          // func 메서드: 문자열 배열의 인접한 요소들을 비교하여 'O' 또는 'N'을 출력한다.
                                                          // m: 문자열 배열
                                                          // n: 배열의 길이
    static void func(String[] m, int n) {
                                                              // i는 1부터 n-1까지 반복한다. (배열의 두 번째 요소부터 시작하여 이전 요소와 비교)
        for (int i = 1; i < n; i++) {
                                                                    // 핵심: m[i - 1] == m[i]
                                                                    // 자바에서 '==' 연산자는 기본 타입(primitive type)에서는 값을 비교하지만,
                                                                    // 객체(Object) 타입에서는 '참조(reference)'를 비교한다.
                                                                    // 즉, 두 변수가 '같은 메모리 주소'를 가리키고 있는지 확인한다.
                                                                    // 문자열의 '내용'을 비교하려면 'equals()' 메소드를 사용해야 한다. (예: m[i - 1].equals(m[i]))

            if (m[i - 1] == m[i]) {                                         // 이전 문자열과 현재 문자열의 '참조'가 같은지 비교!
                System.out.print("O");                                       // 참조가 같으면 'O' 출력
            } else {
                System.out.print("N");                                                   // 참조가 다르면 'N' 출력
            }
        }
    }

    public static void main(String[] args) {
        String[] m = new String[4];                                                     // 크기 4인 문자열 배열 선언. (인덱스 0, 1, 2, 3)

                                                                                    // 문자열 리터럴 할당:
                                                                                    // 자바는 문자열 리터럴("A", "B" 등)을 'String Pool'이라는 특별한 메모리 공간에 저장하고 재활용한다.
                                                                                    // 같은 문자열 리터럴은 같은 객체를 참조하게 된다.
        m[0] = "A";                                                                 // String Pool에 있는 "A" 객체를 참조
        m[1] = "A";                                                                                       // String Pool에 있는 기존의 "A" 객체를 참조 (m[0]과 동일한 객체)
  
                                                                                                  // new String("A"):
                                                                                                  // 'new' 키워드를 사용하면 String Pool을 사용하지 않고,
                                                                                                  // 힙(Heap) 메모리에 '새로운 String 객체'를 생성한다.
                                                                                                  // 따라서 내용이 같더라도 다른 주소를 가진 객체가 된다.
        m[2] = new String("A");                                                                     // 힙에 새로 생성된 "A" 객체를 참조 (m[0], m[1]과는 다른 객체)

        m[3] = "B";                                                                           // String Pool에 있는 "B" 객체를 참조

                                                                                                    // 배열 m의 상태 (참조):
                                                                                                    // m[0] -> "A" (String Pool)
                                                                                                    // m[1] -> "A" (String Pool)  <- m[0]과 같은 주소!
                                                                                                    // m[2] -> "A" (Heap, 새로 생성) <- m[0], m[1]과 다른 주소!
                                                                                                    // m[3] -> "B" (String Pool)
                                                                                            
                                                                                                    // func 함수를 호출한다.
        func(m, 4);
    }
}



✅ 출력 결과
ONN


  
  -----------------------------------------------------------------------------------
  
  🔢 문제 13) 파이썬 출력 값
                                                                                        # fnc 함수: 리스트를 뒤집는(reverse) 함수다.
                                                                                        # v: 리스트를 인자로 받는다. 파이썬에서는 리스트가 'mutable'하기 때문에
                                                                                        #    함수 안에서 리스트 내용을 변경하면 원본 리스트도 변경된다.
def fnc(dt):
                                                                                            # 리스트의 절반 길이만큼 반복한다.
                                                                                            # len(dt) // 2 는 정수 나눗셈으로, 리스트 길이가 짝수든 홀수든 상관없이
                                                                                            # 정중앙까지의 인덱스만 반복하게 한다.
                                                                                            # 예: 길이가 6이면 range(3) -> i는 0, 1, 2
    for i in range(len(dt) // 2):
                                                                                                # dt[i]는 앞에서부터 i번째 요소 (0부터 시작)
                                                                                                # dt[-i - 1]는 뒤에서부터 i번째 요소 (뒤에서 0번째는 -1, 뒤에서 1번째는 -2, ...)
                                                                                                # 이 두 요소의 값을 서로 바꾼다 (swap)
                                                                                                # 이 한 줄이 파이썬의 멋진 기능 중 하나인 '동시 할당'을 이용한 값 교환이다.
        dt[i], dt[-i - 1] = dt[-i - 1], dt[i]

                                                                                                                # 초기 리스트
list = [1, 2, 3, 4, 5, 6]

                                                                                                                        # fnc 함수를 호출해서 리스트를 변경한다.
fnc(list) # 이 호출로 인해 'list' 변수가 가리키는 실제 리스트의 내용이 변경된다.

                                                                                                      # fnc 함수 실행 후 'list'의 변화:
                                                                                                      # 초기: [1, 2, 3, 4, 5, 6]
                                                                                                      #
                                                                                                      # i = 0: dt[0], dt[-1] 교환 (1과 6)
                                                                                                      #        [6, 2, 3, 4, 5, 1]
                                                                                                      #
                                                                                                      # i = 1: dt[1], dt[-2] 교환 (2와 5)
                                                                                                      #        [6, 5, 3, 4, 2, 1]
                                                                                                      #
                                                                                                      # i = 2: dt[2], dt[-3] 교환 (3과 4)
                                                                                                      #        [6, 5, 4, 3, 2, 1]
                                                                                                      #
                                                                                                      # 루프 종료. 'list'는 이제 [6, 5, 4, 3, 2, 1] 이 된다.
                                                                                                      
                                                                                                      # 변경된 리스트에서 짝수 인덱스 요소들의 합에서 홀수 인덱스 요소들의 합을 뺀다.
                                                                                                      # 파이썬의 슬라이싱(Slicing)을 이용한다.
                                                                                                      
                                                                                                      # list[::2]: 시작부터 끝까지 2칸 간격으로 (즉, 짝수 인덱스만)
                                                                                                      #            [list[0], list[2], list[4]] -> [6, 4, 2]
                                                                                                      # sum(list[::2]) = 6 + 4 + 2 = 12
                                                                                                      
                                                                                                      # list[1::2]: 인덱스 1부터 시작하여 끝까지 2칸 간격으로 (즉, 홀수 인덱스만)
                                                                                                      #             [list[1], list[3], list[5]] -> [5, 3, 1]
                                                                                                      # sum(list[1::2]) = 5 + 3 + 1 = 9
                                                                                                      
                                                                                                      # 최종 계산: 12 - 9 = 3
print(sum(list[::2]) - sum(list[1::2]))


🟩 정답
3



-----------------------------------------------------------------------------------

🔢 문제 14) C 언어 코드 출력 결과

#include <stdio.h>                                     // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일

                                                        // fnc 함수 정의
int fnc() {
                                                              // 핵심: static int x = 0;
                                                              // 'static' 변수는 함수가 호출될 때마다 초기화되지 않고,
                                                              // 프로그램 실행 시 '딱 한 번'만 초기화된다.
                                                              // 그 후 함수가 호출될 때마다 이전 호출에서 변경된 값을 계속 유지한다.
    static int x = 0;                                           // 이 줄은 프로그램 시작 시 단 한 번만 실행됨. x는 0으로 초기화.

    x += 2;                                                       // fnc 함수가 호출될 때마다 이 static 변수 x에 2를 더한다.
    return x;                                                         // static 변수 x의 현재 값을 반환한다.
}

int main() {
                                                                                      // main 함수의 지역 변수 x.
                                                                                      // 이건 fnc 함수의 static 변수 x와는 '전혀 다른' 별개의 변수다.
                                                                                      // 이름만 같을 뿐, 서로 다른 메모리 공간에 존재한다.
    int x = 0;

    int sum = 0;                                                                     // 합계를 저장할 변수를 0으로 초기화한다.

                                                                                    // for 루프: 총 4번 반복한다. (i 값은 0, 1, 2, 3)
    for (int i = 0; i < 4; i++) {
        x++;                                                                             // 이 x는 'main 함수의 지역 변수 x'이다.
                                                                             // 루프가 돌 때마다 이 x는 1씩 증가하지만, 이 값은 sum 계산에 직접적인 영향을 주지 않는다.
                                                                             // (fnc 함수에 전달되지도, fnc 함수의 static x와 관련도 없다.)

        sum += fnc();                                                         // fnc 함수를 호출하고 그 반환값을 sum에 더한다.
                                                                                // fnc 함수의 static x는 이 호출마다 값이 2씩 증가하고, 그 증가된 값을 반환한다.
    }

                                                                                          // for 루프 실행 과정 및 sum, fnc의 static x 값 변화 추적:
                                                                                          // --------------------------------------------------------------------------------------
                                                                                          // 초기 상태: main.x = 0, sum = 0, fnc.x (static) = 0 (초기화)
                                                                                          // --------------------------------------------------------------------------------------
                                                                                          // 1. i = 0:
                                                                                          //    main.x++ -> main.x = 1
                                                                                          //    fnc() 호출: fnc.x += 2 -> fnc.x = 2. fnc()는 2를 반환.
                                                                                          //    sum += 2 -> sum = 2
                                                                                          //    현재: main.x = 1, sum = 2, fnc.x = 2
                                                                                          // --------------------------------------------------------------------------------------
                                                                                          // 2. i = 1:
                                                                                          //    main.x++ -> main.x = 2
                                                                                          //    fnc() 호출: fnc.x += 2 -> fnc.x = 4. fnc()는 4를 반환.
                                                                                          //    sum += 4 -> sum = 2 + 4 = 6
                                                                                          //    현재: main.x = 2, sum = 6, fnc.x = 4
                                                                                          // --------------------------------------------------------------------------------------
                                                                                          // 3. i = 2:
                                                                                          //    main.x++ -> main.x = 3
                                                                                          //    fnc() 호출: fnc.x += 2 -> fnc.x = 6. fnc()는 6을 반환.
                                                                                          //    sum += 6 -> sum = 6 + 6 = 12
                                                                                          //    현재: main.x = 3, sum = 12, fnc.x = 6
                                                                                          // --------------------------------------------------------------------------------------
                                                                                          // 4. i = 3:
                                                                                          //    main.x++ -> main.x = 4
                                                                                          //    fnc() 호출: fnc.x += 2 -> fnc.x = 8. fnc()는 8을 반환.
                                                                                          //    sum += 8 -> sum = 12 + 8 = 20
                                                                                          //    현재: main.x = 4, sum = 20, fnc.x = 8
                                                                                          // --------------------------------------------------------------------------------------
                                                                                          // 루프 종료.

    printf("%d", sum);                                                                     // 최종 sum 값인 20을 출력한다.

    return 0;                                                                               // 프로그램 성공 종료.
}

✅ 정답
답: 20



-----------------------------------------------------------------------------------
🔢 문제 15) 파이썬 코드

                                                          # fnc 함수: 입력값 v의 타입에 따라 다른 값을 반환한다.
def fnc(v):
                                                              # v의 타입이 문자열(str)과 같으면
                                                              # type("")은 문자열 리터럴의 타입, 즉 <class 'str'>을 나타낸다.
    if type(v) == type(""):
        return len(v)  # v의 길이(문자 개수)를 반환

                                                                              # v의 타입이 정수(int)와 같으면
                                                                              # type(100)은 정수 리터럴의 타입, 즉 <class 'int'>를 나타낸다.
    elif type(v) == type(100):
        return 101                                                           # 무조건 101을 반환

                                                                      # 그 외 다른 타입이면 (문자열도 아니고 정수도 아니면)
    else:
                                                                              return 20      # 무조건 20을 반환

                                                                              # 각 변수들을 선언하고 초기화한다.
a = "100.0"                                                                   # 문자열(str) 타입. (길이: 5)
b = 100.0                                                                         # 실수(float) 타입.
c = (100, 200)                                                                         # 튜플(tuple) 타입.

                                                                                      # print(fnc(a) + fnc(b) + fnc(c))
                                                                                      # 각 변수를 fnc 함수에 넣고 나온 결과들을 합해서 출력한다.
                                                                                      
                                                                                      # 1. fnc(a) 호출:
                                                                                      #    a는 "100.0" (str 타입).
                                                                                      #    if type(v) == type("") 조건이 True.
                                                                                      #    return len(v) 실행 -> len("100.0")은 5.
                                                                                      #    fnc(a) 결과: 5
                                                                                      
                                                                                      # 2. fnc(b) 호출:
                                                                                      #    b는 100.0 (float 타입).
                                                                                      #    if type(v) == type("") 조건이 False.
                                                                                      #    elif type(v) == type(100) 조건도 False. (float은 int가 아니다!)
                                                                                      #    else 블록 실행.
                                                                                      #    return 20 실행.
                                                                                      #    fnc(b) 결과: 20
                                                                                      
                                                                                      # 3. fnc(c) 호출:
                                                                                      #    c는 (100, 200) (tuple 타입).
                                                                                      #    if type(v) == type("") 조건이 False.
                                                                                      #    elif type(v) == type(100) 조건도 False.
                                                                                      #    else 블록 실행.
                                                                                      #    return 20 실행.
                                                                                      #    fnc(c) 결과: 20
                                                                                      
                                                                                      # 최종 합산: 5 + 20 + 20 = 45
print(fnc(a) + fnc(b) + fnc(c))

✅ 정답
답: 45



-----------------------------------------------------------------------------------

🔢 문제 16) 자바 코드

class A {                                           // 부모 클래스 A
    int x = 3;                                       // 1. 부모 클래스의 인스턴스 변수 'x'.
                                                 //    클래스 A 타입의 객체에서 'x'에 직접 접근하면 이 값이 보인다.

    int getX() {                                       // 2. 부모 클래스의 메서드 'getX'.
                                                           //    이 메서드는 자신의 클래스(A)에 정의된 'x'를 사용한다.
        return x * 2;                                               // (A.x인 3) * 2 = 6
    }
}

class B extends A {                                                   // 자식 클래스 B (A를 상속받음)
                                                              // 3. 자식 클래스의 인스턴스 변수 'x'.
                                                              //    이것은 부모 클래스 A의 'x'를 '오버라이딩(Overriding)'하는 것이 아니라,
                                                              //    부모의 'x'를 '숨기는(Hiding)' 것이다.
                                                              //    즉, B 객체 내에는 A의 x와 B의 x가 각각 존재한다.
                                                              //    B 타입의 참조 변수로는 B의 x가, A 타입의 참조 변수로는 A의 x가 보인다.
    int x = 7;

                                                                          // 4. 자식 클래스의 메서드 'getX'.
                                                                          //    이것은 부모 클래스 A의 'getX' 메서드를 '오버라이딩(Overriding)'한 것이다.
                                                                          //    메서드 오버라이딩은 런타임에 실제 객체 타입에 따라 호출되는 메서드가 결정된다 (다형성).
                                                                          //    이 메서드는 자신의 클래스(B)에 정의된 'x'를 사용한다.
    @Override                                                               // 오버라이딩임을 명시하는 어노테이션 (생략 가능하지만 쓰는 것이 좋다)
    int getX() {
        return x * 3;                                                                     // (B.x인 7) * 3 = 21
    }
}

class Main {
    public static void main(String[] args) {
                                                                                                    // 5. 'A' 타입의 참조 변수 'a'가 'B' 객체를 가리킨다. (다형성)
                                                                                                    //    'a'의 '선언된(Declared)' 타입은 A이지만, '실제(Actual)' 객체 타입은 B이다.
        A a = new B();

                                                                                                // 6. 'B' 타입의 참조 변수 'b'가 'B' 객체를 가리킨다.
        B b = new B();
                                                                                          
                                                                                                  // 7. 각 값들을 계산해서 합산 후 출력한다.
                                                                                                  // 이 부분이 핵심! 다형성과 변수 숨김의 규칙을 알아야 정확히 계산할 수 있다.
                                                                                                  // System.out.print(a.getX() + a.x + b.getX() + b.x);
                                                                                                  //
                                                                                                  // - a.getX():
                                                                                                  //   메서드는 '실제 객체' 타입에 따라 결정된다 (런타임 다형성).
                                                                                                  //   'a'는 'B' 객체를 가리키므로, B 클래스의 getX()가 호출된다.
                                                                                                  //   B의 getX()는 B의 x(7)를 사용하므로, 7 * 3 = 21
                                                                                                  //   결과: 21
                                                                                                  //
                                                                                                  // - a.x:
                                                                                                  //   인스턴스 변수는 '참조 변수의 선언된 타입'에 따라 결정된다 (컴파일 타임).
                                                                                                  //   'a'의 선언된 타입은 'A'이므로, A 클래스의 x(3)가 참조된다.
                                                                                                  //   결과: 3
                                                                                                  //
                                                                                                  // - b.getX():
                                                                                                  //   'b'는 'B' 타입의 참조 변수이고 'B' 객체를 가리키므로, B 클래스의 getX()가 호출된다.
                                                                                                  //   B의 getX()는 B의 x(7)를 사용하므로, 7 * 3 = 21
                                                                                                  //   결과: 21
                                                                                                  //
                                                                                                  // - b.x:
                                                                                                  //   'b'의 선언된 타입은 'B'이므로, B 클래스의 x(7)가 참조된다.
                                                                                                  //   결과: 7

        System.out.print(a.getX() + a.x + b.getX() + b.x);
                                                                                                        // 최종 계산: 21 + 3 + 21 + 7 = 52
    }
}

✅ 정답
답: 52


-----------------------------------------------------------------------------------

🔢 문제 17) c 코드 출력

#include <stdio.h>                                         // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일

                                                          // 노드 구조체 정의
                                                          // value: 이 노드가 저장하는 데이터 (정수)
                                                          // next: 다음 노드를 가리키는 포인터. 연결 리스트를 구성한다.
struct Node {
    int value;
    struct Node* next;
};

                                                                    // f 함수: 연결 리스트의 특정 부분(p 이후)의 노드들을 재정렬하는 함수
                                                                    // p: 현재 노드를 가리키는 포인터
void f(struct Node* p) {
                                                                    // p의 다음 노드를 q에 저장한다.
                                                                    // 만약 리스트가 A -> B -> C 순서라면, p=A, q=B 이다.
    struct Node* q = p->next;

                                                                    // q가 NULL이 아니면 (즉, p 다음에 최소한 하나의 노드가 더 있으면) 실행
    if (q != NULL) {
                                                                      // q의 다음 노드를 r에 저장한다.
                                                                      // 만약 리스트가 A -> B -> C 순서라면, p=A, q=B, r=C 이다.
        struct Node* r = q->next;
                                                            
                                                                    // r이 NULL이 아니면 (즉, q 다음에 최소한 하나의 노드가 더 있으면) 실행
                                                                    // 이 조건은 리스트에 최소 3개 이상의 노드가 있을 때만 f 함수가 의미 있는 작업을 한다는 뜻이다.
                                                                    // (p -> q -> r 순서로 존재해야 함)
        if (r != NULL) {
                                                                        // 현재 상태: p -> q -> r

            q->next = NULL;                                             // q의 다음 연결을 끊는다.
                                                                    // 이제 q는 리스트의 끝(마지막 노드)이 된다.
                                                                    // 상태: p -> q   r -> ... (q와 r 사이의 연결이 끊어짐)

            r->next = q;                                                      // r의 다음을 q로 연결한다.
                                                                        // 상태: p -> q   r -> q
                                                      
                                                                  // p의 다음을 r로 연결하는 코드가 없다! 이 부분이 이 함수의 핵심이자 맹점이다.
                                                                  // p->next = r; 이라는 코드가 없기 때문에,
                                                                  // f 함수가 끝날 때 p의 다음은 여전히 원래 q를 가리키고 있게 된다.
                                                                  // 즉, p -> q는 유지된다.
                                                                  // 다만, q의 다음은 NULL이 되고, r의 다음은 q가 된다.
                                                                  // 결과적으로: p -> q (next는 NULL) 그리고 r -> q (next는 NULL)로, 원래 리스트의 뒷부분이 잘려나간다.
        }
    }
}

int main() {
                                                              // 값 1, 2, 3을 가진 노드들을 생성하고 NULL로 초기화한다.
    struct Node n1 = {1, NULL};                               // n1: {value: 1, next: NULL}
    struct Node n2 = {2, NULL};                                 // n2: {value: 2, next: NULL}
    struct Node n3 = {3, NULL};                                   // n3: {value: 3, next: NULL}

                                                                    // 노드들을 연결한다.
    n1.next = &n3;                                             // n1의 다음은 n3를 가리킨다. (1 -> 3)
    n3.next = &n2;                                         // n3의 다음은 n2를 가리킨다. (3 -> 2)

                                                              // 이 시점의 연결 리스트 상태:
                                                              // n1 (value: 1) -> n3 (value: 3) -> n2 (value: 2) -> NULL
                                                          
                                                              // f 함수를 호출하여 n1부터 시작하는 리스트를 넘겨 노드를 재정렬한다.
                                                              // f(&n1) 호출 시:
                                                              // p = &n1 (value 1)
                                                              // q = p->next = &n3 (value 3)
                                                              // q는 NULL이 아니므로 if (q != NULL) 진입
                                                              // r = q->next = &n2 (value 2)
                                                              // r은 NULL이 아니므로 if (r != NULL) 진입
                                                              //
                                                              // 1. q->next = NULL; // n3.next = NULL;
                                                              //    n3의 다음 연결이 끊어지고 NULL이 된다.
                                                              //    리스트 상태: n1 -> n3 -> NULL,   n2 -> NULL (n3와 n2 사이의 연결이 끊어짐)
                                                              //
                                                              // 2. r->next = q;    // n2.next = &n3;
                                                              //    n2의 다음이 n3를 가리키게 된다.
                                                              //    리스트 상태: n1 -> n3 -> NULL,   n2 -> n3 -> NULL
                                                              //
                                                              // 중요: f 함수 내에서 p->next (즉, n1.next)를 변경하는 코드는 전혀 없다.
                                                              //      따라서 n1.next는 여전히 &n3를 가리키고 있다.

    f(&n1);                                                   // 이 함수 호출 후 리스트의 최종 상태:
                                                          // n1 -> n3 -> NULL
                                                          // 그리고 n2 -> n3 -> NULL 이라는 또 다른 "연결된" 구조가 생겨났지만,
                                                          // n1으로부터 시작하는 리스트는 n3에서 끝난다.

                                                                // c 포인터를 n1에 맞추고 리스트를 순회하며 값을 출력한다.
    struct Node* c = &n1;
    while (c != NULL) {                                                     // c가 NULL이 될 때까지 반복
        printf("%d", c->value); // 현재 c가 가리키는 노드의 값을 출력
        c = c->next;                                        // c를 다음 노드로 이동
    }

    return 0;
}

✅ 최종 출력
답: 13



-----------------------------------------------------------------------------------

문제 18) C언어 코드 출력 결과를 구하시오
#include <stdio.h>                                                                 // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일
                                                                                    
                                                                                    // fnc 함수: 이중 포인터(int**)를 받아서 배열의 값을 변경한다.
                                                                                    // int** ptr: int* 타입 (정수 포인터)의 주소를 가리키는 포인터.
                                                                                    //            결과적으로 'int' 값을 가리키는 포인터의 주소를 받는다.
                                                                                    // int size: 배열의 크기
void fnc(int** ptr, int size) {
                                                                                        // 루프를 돌면서 배열의 각 요소를 변경한다.
    for (int i = 0; i < size; i++) {
                                                                                        // *ptr: ptr이 가리키는 값. 이건 int* 타입이다. (main 함수에서 'p'의 값, 즉 'arr'의 시작 주소)
                                                                                        // (*ptr + i): 'arr'의 시작 주소에서 'i'만큼 떨어진 메모리 주소.
                                                                                        //              이는 arr[i]의 주소와 같다.
                                                                                        // *(*ptr + i): (*ptr + i)가 가리키는 메모리 주소에 있는 '값'.
                                                                                        //              이는 arr[i]의 값과 같다.
                                                                                
                                                                                        // 이 줄은 arr[i]의 값을 (arr[i] + i) % size로 업데이트한다.
                                                                                        // (원래 값 + 현재 인덱스)를 배열 크기(size)로 나눈 나머지를 새로운 값으로 할당한다.
        *(*ptr + i) = (*(*ptr + i) + i) % size;
    }
}

int main() {
                                                                                                              // 1. 정수 배열 'arr' 초기화. 크기는 5 (자동으로 결정됨).
                                                                                                              // arr: {3, 1, 4, 1, 5}
    int arr[] = {3, 1, 4, 1, 5};

                                                                                                          // 2. int* 타입의 포인터 'p'를 선언하고 'arr'의 첫 번째 요소 주소를 가리키게 한다.
                                                                                                          // 'arr' 배열의 이름 자체가 첫 번째 요소의 주소를 의미한다.
    int* p = arr;                                                                                             // p는 arr[0] (값 3)의 주소를 가리킴.

                                                                                                                // 3. int** 타입의 이중 포인터 'pp'를 선언하고 포인터 'p'의 주소를 가리키게 한다.
                                                                                                                // 즉, 'pp'는 'p'를 통해 'arr' 배열에 접근할 수 있게 된다.
    int** pp = &p;                                                                                       // pp는 포인터 변수 p 자체의 주소를 가리킴.

                                                                                                                  // 4. fnc 함수를 호출한다.
                                                                                                                  // 'pp' (int** 타입)와 배열의 크기 5를 넘겨준다.
                                                                                                                  // fnc 함수 안에서 ptr은 pp가 가리키는 'p'의 주소를 받는다.
                                                                                                                  // *ptr은 'p'의 값, 즉 'arr'의 시작 주소가 된다.
    fnc(pp, 5);

                                                                                                                          // fnc 함수 호출 후 'arr' 배열의 변화:
                                                                                                                          // 초기 arr: {3, 1, 4, 1, 5}, size = 5
                                                                                                                      
                                                                                                                          // i = 0: arr[0] = (arr[0] + 0) % 5 = (3 + 0) % 5 = 3 % 5 = 3
                                                                                                                          //         arr: {3, 1, 4, 1, 5} (변화 없음)
                                                                                                                      
                                                                                                                          // i = 1: arr[1] = (arr[1] + 1) % 5 = (1 + 1) % 5 = 2 % 5 = 2
                                                                                                                          //         arr: {3, 2, 4, 1, 5}
                                                                                                                      
                                                                                                                          // i = 2: arr[2] = (arr[2] + 2) % 5 = (4 + 2) % 5 = 6 % 5 = 1
                                                                                                                          //         arr: {3, 2, 1, 1, 5}
                                                                                                                      
                                                                                                                          // i = 3: arr[3] = (arr[3] + 3) % 5 = (1 + 3) % 5 = 4 % 5 = 4
                                                                                                                          //         arr: {3, 2, 1, 4, 5}
                                                                                                                      
                                                                                                                          // i = 4: arr[4] = (arr[4] + 4) % 5 = (5 + 4) % 5 = 9 % 5 = 4
                                                                                                                          //         arr: {3, 2, 1, 4, 4}
                                                                                                                      
                                                                                                                          // fnc 함수 실행 종료 후 arr 배열은 {3, 2, 1, 4, 4}가 된다.
                                                                                                                      
                                                                                                                          // 5. arr 배열의 세 번째 값(인덱스 2)을 출력한다.
    printf("%d", arr[2]);                                                                                                 // arr[2]의 현재 값은 1이다.
    
    return 1;                                                                                               // main 함수는 보통 0을 반환하여 성공을 나타내지만, 여기선 1을 반환하도록 되어 있다.
                                                                                                              // 프로그램의 동작에는 영향을 주지 않는다.
}

✅ 출력 결과

1



-----------------------------------------------------------------------------------

문제 19) 다음 Java 코드의 출력 결과를 쓰시오.

public class Main {
    public static void main(String[] args) {
        int sum = 0;                                                     // sum 변수를 0으로 초기화한다.

        try { // 예외 발생 가능성이 있는 코드를 감싸는 블록
            func();                                                     // func() 메서드를 호출한다.
                                                                          // func() 메서드는 강제로 NullPointerException을 발생시킨다.
        } catch (NullPointerException e) {                             // NullPointerException이 발생하면 이 catch 블록이 실행된다.
                                                                     // 'e'는 발생한 예외 객체를 참조한다.
            sum = sum + 1;                                           // sum에 1을 더한다. (sum은 이제 0 + 1 = 1)
        } catch (Exception e) {                                         // 그 외 다른 모든 Exception이 발생하면 이 catch 블록이 실행된다.
                                                                            // NullPointerException은 Exception의 자식 클래스이므로,
                                                                            // 만약 위에 NullPointerException을 위한 catch 블록이 없었다면 이 블록이 잡았을 것이다.
                                                                            // 하지만 여기서는 NullPointerException이 이미 위에서 처리되었으므로, 이 블록은 실행되지 않는다.
            sum = sum + 10;
        } finally {                                               // finally 블록: 예외 발생 여부, catch 블록 실행 여부와 상관없이 무조건 이 블록은 실행된다.
                                                                      // 주로 자원 해제(파일 닫기, 네트워크 연결 끊기 등) 코드를 여기에 넣는다.
            sum = sum + 100;                                         // sum에 100을 더한다. (sum은 이제 1 + 100 = 101)
        }
        System.out.print(sum);                                         // 최종 sum 값을 출력한다.
    }

                                                                                  // func 메서드: Exception을 던질 수 있다고 선언 (throws Exception)
                                                                                  // 이 메서드를 호출하는 쪽에서는 이 예외를 처리하거나 다시 던져야 한다.
    static void func() throws Exception {
                                                                                // 강제로 NullPointerException을 발생시킨다.
                                                                                // NullPointerException은 RuntimeException의 자식이며, RuntimeException은 Exception의 자식이다.
        throw new NullPointerException();
    }
}

✅ 정답
101


-----------------------------------------------------------------------------------

문제 20) 다음 Java 코드의 출력 결과를 쓰시오.
class Printer {
                                                                                        // 메소드 오버로딩: 동일한 이름의 메소드가 여러 개 있지만, 파라미터 타입이 다르다.
                                                                                    
                                                                                        // 1. print(Integer a): Integer 객체를 파라미터로 받는 print 메소드
                                                                                        // Integer는 기본 타입 int의 래퍼(Wrapper) 클래스이다.
    void print(Integer a) {
        System.out.print("A" + a);                                                             // 출력 예: "A10"
    }

                                                                                            // 2. print(Object a): Object 객체를 파라미터로 받는 print 메소드
                                                                                            // Object는 자바의 모든 클래스의 최상위 부모 클래스이다.
                                                                                            // 따라서 어떤 타입의 객체든 이 메소드의 파라미터로 올 수 있다.
    void print(Object a) {
        System.out.print("B" + a);                                                         // 출력 예: "Bhello"
    }

                                                                                // 3. print(Number a): Number 객체를 파라미터로 받는 print 메소드
                                                                                // Number 클래스는 Integer, Double, Float 등 숫자 관련 래퍼 클래스들의 부모 클래스이다.
                                                                                // Integer는 Number의 자식 클래스이다.
    void print(Number a) {
        System.out.print("C" + a);                                                   // 출력 예: "C20.5"
    }
}
                                                                  
                                                                  // 4. 제네릭 클래스 Collection<T>
                                                                  // <T>는 타입 파라미터(Type Parameter)로, 이 클래스를 사용할 때 어떤 타입이든 올 수 있음을 의미한다.
                                                                  // 컴파일 시점에 T는 실제 타입으로 결정된다.
class Collection<T> {
    T value;                                                               // T 타입의 멤버 변수

                                                                            // Collection 클래스의 생성자
    public Collection(T t) {
        value = t;                                                                 // 생성 시 T 타입의 값을 저장한다.
    }

                                                              // Printer 객체를 생성하고, 이 Collection이 가지고 있는 'value'를 Printer의 print 메소드에 전달한다.
    public void print() {
        new Printer().print(value);                             // 이 부분이 중요!
                                                                // 'value'의 실제 타입에 따라 Printer 클래스의 어떤 'print' 메소드가 호출될지 결정된다.
    }
}

public class Main {
    public static void main(String[] args) {
                                                                          // new Collection<>(0).print();
                                                                          // 1. Collection 객체 생성: new Collection<>(0)
                                                                          //    - 여기서 '0'은 기본 타입(primitive type) int이다.
                                                                          //    - 하지만 제네릭 타입 <T>는 기본 타입을 직접 받을 수 없고, 객체 타입만 받는다.
                                                                          //    - 이때 자바의 '오토박싱(Autoboxing)' 기능이 발동한다.
                                                                          //    - int 0은 자동으로 Integer 객체 0으로 '박싱(boxing)'되어 Collection의 T 타입으로 전달된다.
                                                                          //    - 따라서 Collection<T>에서 T는 Integer로 추론(inference)된다.
                                                                          //    - 즉, new Collection<Integer>(Integer.valueOf(0))와 동일하다.

                                                                              // 2. .print() 호출: 생성된 Collection 객체의 print() 메소드 호출
                                                                              //    - Collection 객체는 Integer 타입의 value (값 0)를 가지고 있다.
                                                                              //    - print() 메소드 안에서 new Printer().print(value); 가 실행된다.
                                                                              //    - 이때 value의 실제 타입은 Integer이다.
                                                                      
                                                                              // 3. Printer.print() 메소드 오버로딩 결정:
                                                                              //    - Printer 클래스에는 print(Integer a), print(Object a), print(Number a) 세 가지 메소드가 있다.
                                                                              //    - value (타입: Integer)를 파라미터로 넘겼을 때, 자바 컴파일러는 가장 '구체적인(specific)' 타입을 가진 오버로드된 메소드를 찾는다.
                                                                              //    - Integer는 Object의 자식이고, Number의 자식이다.
                                                                              //    - print(Integer a)가 가장 Integer 타입에 정확히 일치하는(exact match) 메소드이다.
                                                                              //    - 따라서 print(Integer a) 메소드가 호출된다.
        new Collection<>(0).print();
    }
}

✅ 정답
B0


