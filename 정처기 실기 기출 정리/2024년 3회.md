## 문제 1) 다음 특정 DDOS 공격 방식 설명

공격자는 출발지 IP 주소를 피해자의 IP로 위조하여 다수의 호스트가 연결된 네트워크 브로드캐스트 주소로  
ICMP 에코 요청을 전송한다. 그 결과, 브로드캐스트 네트워크에 연결된 모든 호스트들이 피해자 IP로 대량의  
ICMP 에코 응답(Echo Reply)을 보내게 되면서, 피해자가 과도한 트래픽으로 인해 서비스 장애를 겪게 된다.  

**답:** 스머프(스머핑, smurf)

📌 관련 개념 설명:

### 스머프 공격 (Smurf Attack)  
- ICMP(Internet Control Message Protocol) 에코 요청을 네트워크의 브로드캐스트 주소로 보냄  
- **출발지 IP 주소를 피해자의 IP로 스푸핑**하여 다수 호스트가 피해자에게 ICMP 응답(Echo Reply)을 보냄  
- 피해자는 대량의 ICMP 응답을 받아 **서비스 거부(DoS)** 상태에 빠짐  
- **트래픽 증폭(amplification)** 공격의 일종이며, 브로드캐스트가 열려 있는 네트워크에서 위험

---

### DDoS 공격 주요 유형

| 공격명         | 특징 및 방식                                                                                  |
|----------------|----------------------------------------------------------------------------------------------|
| **Smurf Attack**   | ICMP 요청 + 브로드캐스트 + IP 스푸핑 → 대량 응답 폭탄                                        |
| **SYN Flooding**   | TCP 3-way 핸드쉐이크 중 SYN 요청만 과도하게 보내 서버 연결 대기 큐 자원 고갈                 |
| **UDP 플러딩**     | 무작위 포트에 UDP 패킷 대량 전송 → ICMP unreachable 응답 유도 → 자원 고갈                  |
| **Ping 플러딩**    | 과도한 ICMP Echo 요청 전송으로 대상 시스템 응답 처리 자원 소모                              |
| **Ping of Death**  | 과도한 크기의 ICMP 패킷을 조각내어 전송, 재조합 시 시스템 다운 유도                         |
| **Teardrop Attack**| 비정상 IP 조각 패킷 전송, 재조합 오류로 시스템 다운                                        |
| **Land Attack**    | 출발지와 목적지 IP 모두 피해자 IP로 설정, 자기 자신에게 요청 보내 시스템 장애                |

---

### 정보보안 3요소 (CIA Triad)

| 요소       | 설명                                                         | 예시                         |
|------------|--------------------------------------------------------------|------------------------------|
| **기밀성 (Confidentiality)** | 인가되지 않은 사용자가 정보에 접근하지 못하도록 보호                  | 데이터 암호화, 접근 통제       |
| **무결성 (Integrity)**       | 데이터가 인가되지 않게 변경되지 않고, 변경 여부를 확인할 수 있음         | 해시 함수, 메시지 인증 코드(MAC) |
| **가용성 (Availability)**    | 인가된 사용자가 필요한 시점에 자원과 서비스를 이용할 수 있음             | 백업, 이중화, 장애 복구 시스템  |

※ **고가용성 (High Availability)**: 장애 발생 시에도 서비스 연속성을 유지할 수 있도록 설계된 시스템 구조  

📌 관련 개념 설명:

### 스머프 공격 (Smurf Attack)  
- 예를 들어서 누가 “야, OO한테 다 같이 메시지 보내!”라고 네트워크 전체에 지시하는 거야.  
- 근데 그 메시지 출발지를 피해자 IP로 바꿔서 보내니까  
- 네트워크에 있는 컴퓨터들이 한꺼번에 피해자한테 답장 보내는 거야.  
- 그러면 피해자는 갑자기 엄청난 메시지 폭탄에 시달리게 되고,  
- 컴퓨터가 너무 바빠서 제대로 못 버티게 되는 거지.  
- 쉽게 말하면, 친구들한테 “OO야, 너한테 편지 보내!”라고 속여서  
- 편지가 한꺼번에 몰려오는 상황이라고 생각하면 돼.

---

### DDoS 공격 주요 유형 쉽게 설명

| 공격명         | 쉽게 설명                                        |
|----------------|------------------------------------------------|
| **Smurf Attack**   | 친구들한테 피해자한테 다 같이 메시지 보내라고 속임 (메시지 폭탄)       |
| **SYN Flooding**   | 계속 “안녕? 연결할래?”라고 요청만 보내서 상대방이 감당 못 하게 함    |
| **UDP 플러딩**     | 아무 포트로 계속 불특정 메시지 보내서 상대방 짜증나게 함     |
| **Ping 플러딩**    | “여기 있어?”라는 신호를 너무 많이 보내서 상대방 바쁘게 함           |
| **Ping of Death**  | 너무 큰 메시지를 쪼개서 보내 컴퓨터 멈추게 함 |
| **Teardrop Attack**| 이상한 방식으로 쪼갠 메시지 보내서 컴퓨터 헷갈리게 함               |
| **Land Attack**    | “나한테 나 좀 만나러 와!” 하면서 자기 자신한테 공격해서 혼란 유발    |

---

### 정보보안 3요소 (CIA Triad) 쉽게 예시로 이해하기

| 요소       | 쉽게 이해하는 예시                                 |
|------------|--------------------------------------------------|
| **기밀성** | 친구한테만 비밀 편지 보내기 (다른 사람은 못 봄)  |
| **무결성** | 편지가 중간에 누가 몰래 바꾸지 않았는지 확인하기  |
| **가용성** | 친구가 편지를 언제든 받을 수 있게 항상 대기하기  |

---

**정리하자면**  
- 스머프 공격은 친구들한테 피해자한테 한꺼번에 메시지 보내라고 속여서  
  피해자가 감당 못 하게 만드는 거야.  
- 보안 3요소는 친구랑 비밀편지 주고받을 때  
  누가 훔쳐보거나 바꾸지 않고, 친구가 언제든 편지를 받을 수 있게 하는 원칙이야.


-----------------------------------------------------------------------------------

## 문제 2) 다음 설명에 해당하는 기술이 무엇인가

사설 네트워크(Private Network)를 외부 인터넷 환경과 분리하여, 안전하게 데이터를 주고 받기 위해  
터널링(Tunneling)을 활용하는 기술이 있다. 이 기술은 IPsec 등 다양한 암호화 프로토콜을 사용해  
데이터 기밀성과 무결성을 보장하며, 기업이나 조직에서는 원격지 사용자들도 내부 네트워크에 안전하게  
접속할 수 있도록 이를 자주 이용한다.

**답:** VPN

**해설:**  
IP 관련 기타 기술들에 대해 정리하였다.

- **NAT (Network Address Translation)**  
  사설 IP 주소와 공인 IP 주소 간의 변환을 수행한다.  
  - Static NAT: 하나의 내부 IP ↔ 하나의 외부 IP  
  - Dynamic NAT: 여러 내부 IP ↔ 여러 외부 IP 중 일부  
  - PAT (Port Address Translation): 하나의 공인 IP에 여러 사설 IP를 포트 번호로 구분하여 매핑

- **DNS (Domain Name System)**  
  도메인 이름을 IP 주소로 변환하거나 그 반대의 작업을 수행하는 시스템

- **QoS (Quality of Service)**  
  네트워크 자원을 효율적으로 배분하여 특정 트래픽(예: VoIP, 스트리밍)의 성능과 속도를 보장하는 기술

- **VPN (Virtual Private Network)**  
  공용 네트워크를 통해 사설 네트워크에 안전하게 접속할 수 있도록 하는 기술

- **DHCP (Dynamic Host Configuration Protocol)**  
  네트워크 장치에 자동으로 IP 주소를 할당하는 프로토콜

---

### 📌 VPN 관련 개념 설명

- VPN은 **공용 네트워크(인터넷)를 통해 사설 네트워크에 안전하게 접속**할 수 있게 한다.  
- **터널링(Tunneling)**: 데이터를 캡슐화(encapsulation)하여 외부망을 안전하게 통과  
- **암호화 프로토콜**: IPsec, SSL/TLS, PPTP, L2TP 등으로 데이터의 기밀성과 무결성 보장  
- **사용 예시**:  
  - 재택근무자가 회사 내부망 접속  
  - 지사와 본사 간 네트워크 연결  
  - 공공 와이파이 환경에서 안전한 인터넷 사용

---

### 📌 기타 주요 기술 요약

| 기술명 | 주요 기능 및 특징 |
|--------|------------------|
| **NAT** | 사설망 IP를 공인망 IP로 변환해 인터넷 접속 가능하게 함. IP 부족 문제 완화 |
| **QoS** | 실시간 트래픽에 우선순위 부여, 네트워크 품질 보장 |
| **DHCP** | 네트워크 장치에 자동 IP 할당, 관리 편의성 증가 |
| **DNS** | 도메인 이름 ↔ IP 주소 간 변환 담당, 사용자 편의성 제공 |

※ 이들 기술은 현대 IP 네트워크 운영과 보안에 필수적임.


-----------------------------------------------------------------------------------
--
## 문제 3) 객체 간의 협력과 상호작용을 설계하는 패턴들의 묶음을 무엇이라 하는지 패턴 그룹의 명칭을 작성해라

소프트웨어 디자인 패턴은 크게 생성패턴(Creational Pattern), 구조패턴(Structural Pattern),  
그리고 특정 패턴 그룹으로 구분된다.  
이 특정 패턴 그룹은 객체나 클래스가 서로 상호작용하는 방식에 초점을 맞추며  
클래스 간의 책임 분배나 알고리즘 변화에 유연하게 대응할 수 있도록 설계 방안을 제시한다.  
이 그룹에는 옵서버(Observer), 상태(State), 전략(Strategy) 등과 같은 대표적인 패턴들이 포함된다.

**답:** 행위 패턴

**해설:**  
소프트웨어 디자인 패턴 중에서 객체 간의 상호작용과 협력을 설계하는 데 초점을 맞춘 패턴 그룹이다.  
대표적인 패턴으로는 옵서버, 상태, 전략, 템플릿 메소드, 커맨드 등이 있다.

---

### 📌 관련 개념 설명: 디자인 패턴의 3가지 그룹

| 패턴 그룹        | 설명                                                            | 대표 패턴 예시                                      |
|-----------------|-----------------------------------------------------------------|---------------------------------------------------|
| **생성 패턴 (Creational Patterns)** | 객체 생성 방식을 추상화하여 유연하게 관리                           | Singleton, Factory Method, Abstract Factory, Builder, Prototype |
| **구조 패턴 (Structural Patterns)** | 클래스/객체 조합으로 더 큰 구조 형성                                 | Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy |
| **행위 패턴 (Behavioral Patterns)** | 객체/클래스 간 책임 분배 및 상호작용에 초점                            | Observer, State, Strategy, Command, Template Method, Mediator, Chain of Responsibility |

---

### 📌 행위 패턴 주요 특징 및 예시

- **책임 분배 및 소통**을 체계화하여 유연하고 확장성 높은 설계를 가능하게 함  
- 대표 패턴 설명:  
  - **Observer**: 한 객체 상태 변화 시 관련 객체들에 자동 통지  
  - **State**: 객체 상태에 따라 행동 동적으로 변경  
  - **Strategy**: 알고리즘을 캡슐화해 런타임에 교체 가능  
  - **Command**: 요청을 캡슐화하여 호출자와 수행자 분리  
  - **Template Method**: 알고리즘 골격 정의, 하위 클래스가 세부 단계 구현  
  - **Mediator**: 객체 간 복잡한 상호작용을 중앙 집중 관리  
  - **Chain of Responsibility**: 요청을 처리할 객체를 체인 형태로 연결해 처리

---

※ 디자인 패턴은 코드 재사용성, 유지보수성 향상에 큰 도움을 주며, 팀 내 설계 공통 언어 역할도 수행함.


-----------------------------------------------------------------------------------

## 문제 4) 다음에서 설명하는 세 가지 대표적인 커버리지를 1, 2, 3 순서대로 각각 한글로 작성하시오

소프트웨어 테스트에서 코드의 검증 범위를 정량적으로 평가하는 '테스트 커버리지(Test Coverage)' 기법에는 여러 유형이 있다.  
예를 들어, 코드 상의 모든 문장이 최소 한 번 이상 실행되는지를 검사하는 (1),  
if나 switch 같은 분기문이 각각 정상적으로 수행되는지 확인하는 (2),  
그리고 각 조건식이 참/거짓으로 조합되도록 확인하는 (3) 커버리지가 대표적이다.

**답:**  
1) 구문 커버리지  
2) 분기 커버리지 / 결정 커버리지  
3) 조건 커버리지

**해설:**  
- 테스트 커버리지는 테스트가 소스코드를 얼마나 수행(실행)했는지를 측정하는 지표이다.  
- 각 커버리지의 의미에 따라 구문 → 분기(결정) → 조건 순으로 분류할 수 있다.

---

### 📌 관련 개념 설명: 테스트 커버리지 종류

| 커버리지 종류            | 설명                                                                                   | 예시/특징                                      |
|-------------------------|--------------------------------------------------------------------------------------|----------------------------------------------|
| **구문 커버리지 (Statement Coverage)**    | 코드의 모든 구문(라인)이 최소 1회 실행되었는지 확인                                    | if문 안 문장 실행 여부                         |
| **분기 커버리지 (Branch/Decision Coverage)** | 모든 분기점의 참/거짓 결과가 각각 실행되었는지 확인                                   | if문의 참, 거짓 모두 실행 여부                 |
| **조건 커버리지 (Condition Coverage)**    | 복합 조건식 내 각 개별 조건이 참과 거짓 각각 실행되었는지 확인                         | if (A && B)에서 A, B 각각 T/F 실행 확인        |

---

### 📌 추가 커버리지 종류

| 커버리지 유형                 | 설명                                                             |
|------------------------------|------------------------------------------------------------------|
| 조건/결정 커버리지 (C/D)       | 조건 커버리지와 결정 커버리지를 결합한 형태                        |
| 변경 조건/결정 커버리지 (MC/DC) | 조건이 결정 결과에 독립적으로 영향을 미치는지 검증 (항공, 의료 등 고신뢰성 분야) |
| 다중 조건 커버리지            | 조건식 내 모든 조건 조합을 100% 테스트                            |
| 경로 커버리지 (Path Coverage)  | 가능한 모든 실행 경로를 테스트                                    |

---

### 📌 참고 사항

- 높은 커버리지는 테스트가 코드 전반을 잘 수행했다는 뜻이지만, 결함이 없다는 보장은 아님  
- 실무에서는 주로 구문 + 분기 커버리지를 기본으로 삼고, 중요한 시스템에서는 MC/DC 등을 추가함


-------------------------------------------------------------------------------------------------------------------------------------------

## 문제 5) 관계형 데이터베이스(Relational Database)에서 테이블을 설계할 때, 아래와 같은 역할을 하는 네 가지 키가 있다.

1) 한 테이블의 특정 속성이 다른 테이블(또는 동일 테이블)의 튜플을 참조함으로써, 테이블 간의 연관관계와 무결성을 유지하기 위한 키  
2) 릴레이션에서 각 튜플을 고유하게 식별하며, 속성의 집합이 최소로 구성되어 있는 키  
3) 위 2번 키가 여러 개 존재할 경우 그중 기본키로 선정되지 않은 키  
4) 릴레이션에서 모든 튜플을 유일하게 식별할 수 있는 속성들의 부분집합(적어도 하나 이상의 2번 키를 포함)으로 구성된 키  

**답:**  
1) 참조키 = 외래키  
2) 후보키  
3) 대체키  
4) 슈퍼키

**해설:**  
관계형 데이터베이스에서 테이블 간의 무결성과 식별성을 유지하기 위해 다양한 키를 활용한다.  
- 외래키는 다른 테이블과의 관계를 유지  
- 후보키는 유일성을 가지는 키 후보들  
- 그중 선택된 것이 기본키이며, 선택되지 않은 것은 대체키  
- 슈퍼키는 후보키를 포함한 넓은 개념

---

### 📌 관련 개념 설명: 키(Key)의 종류 및 데이터베이스 설계

| 키 종류       | 설명                                                                                       | 예시                              |
|--------------|--------------------------------------------------------------------------------------------|----------------------------------|
| **슈퍼키**    | 튜플을 유일하게 식별할 수 있는 속성들의 집합. 후보키를 포함하는 더 넓은 개념.              | 학번, (학번 + 이름), 주민번호 등 |
| **후보키**    | 슈퍼키 중에서 중복 속성이 제거된 최소 키. 여러 후보키가 존재할 수 있음.                    | 학번, 주민번호                   |
| **기본키**    | 후보키 중에서 하나를 선정한 키. 중복 및 NULL 허용 안 됨.                                | 학번                             |
| **대체키**    | 후보키 중 기본키로 선택되지 않은 나머지 키.                                             | 주민번호                         |
| **외래키**    | 다른 테이블의 기본키를 참조하는 속성. 테이블 간 관계를 표현.                              | 학생 테이블의 학과 코드           |

---

### 📌 데이터베이스 설계 단계

| 단계       | 설명                                                 |
|------------|------------------------------------------------------|
| **개념 설계** | ER 다이어그램 등으로 요구사항을 모델링                     |
| **논리 설계** | DBMS 독립적인 릴레이션 스키마 설계                          |
| **물리 설계** | 실제 DBMS에 맞게 구현 (정규화, 인덱스 설계 등 포함)           |

---

### 📌 정규화(Normalization) 요약

| 정규형           | 핵심 내용                                                  |
|------------------|-------------------------------------------------------------|
| **1정규형 (1NF)** | 도메인이 원자값(더 이상 쪼갤 수 없는 값)으로 구성됨            |
| **2정규형 (2NF)** | 기본키 일부에만 종속된 속성 제거 (부분 함수 종속 제거)         |
| **3정규형 (3NF)** | 이행 함수 종속 제거 (비키 속성이 다른 비키 속성에 종속된 경우 제거) |
| **BCNF**          | 결정자가 후보키가 아닌 경우 제거                               |
| **4정규형 (4NF)** | 다치 종속 제거                                               |
| **5정규형 (5NF)** | 조인 종속 제거                                               |

---

### 📌 트랜잭션의 4가지 특성 (ACID)

| 특성           | 설명                                                             |
|----------------|------------------------------------------------------------------|
| **원자성**     | 모든 작업은 전부 수행되거나 전혀 수행되지 않아야 한다                |
| **일관성**     | 트랜잭션 실행 전과 후의 데이터 상태가 항상 일관됨                    |
| **독립성**     | 동시에 실행되는 트랜잭션 간 간섭을 방지                              |
| **영속성**     | 성공한 트랜잭션 결과는 영구히 저장됨                                |

---

### 📌 적절한 예시

- **슈퍼키 / 후보키 / 기본키 / 대체키**  
  학생 테이블에서:  
  - 슈퍼키: (학번), (학번, 이름), (학번, 생년월일) 등 중복 허용 가능  
  - 후보키: (학번), (주민번호) — 유일성과 최소성 만족  
  - 기본키: (학번) — 유일한 대표 키  
  - 대체키: (주민번호) — 기본키 외 후보키  

- **외래키 예시**  
  학생 테이블의 학과 코드가 학과 테이블의 기본키인 학과 코드 참조  

- **트랜잭션 예시**  
  은행 이체 시 돈을 보내는 계좌의 잔액 감소 작업과 받는 계좌의 잔액 증가 작업은 한 트랜잭션으로 묶여야 하며, 어느 하나라도 실패하면 모두 취소되어야 한다 (원자성).


-----------------------------------------------------------------------------------

## 문제 6) URL은 크게 아래와 같은 5가지 구성 요소로 이루어진다.  
다음 각각 요소(5가지)를 URL에서 나타나는 순서에 맞게 적으시오.

1) query: 서버에 전달할 추가 데이터  
2) path: 서버 내 특정 자원을 가리키는 경로  
3) scheme: 리소스에 접근하는 방법이나 프로토콜  
4) authority: 사용자 정보, 호스트명, 포트번호  
5) fragment: 특정 문서 내의 위치  

예시 URL:  
https://user:pass@exam.com:8080/products/items?id=123&s=asc#specs  

답: 4-3-1-2-5

📌 설명 (URL 각 부분이 어떤 역할을 하는지 파악하는 게 핵심!)
야, 이 URL은 인터넷 주소의 기본 구조를 보여주는 거야. 복잡해 보이지만, 각 부분이 어떤 역할을 하는지 알면 존나 쉬워.

(1) scheme (스키마)
https 부분이야.

이건 어떤 통신 규약(프로토콜)을 사용해서 서버에 접속할지를 알려주는 부분이야. 웹에서는 보통 http나 https를 많이 쓴다. https는 http에 보안 기능이 추가된 거라고 보면 된다.

(2) authority (권한 / 권위)
user:pass@exam.com:8080 부분이야.
이건 접속하려는 서버의 주소와 필요한 인증 정보를 나타내는 부분이야.
user:pass@: 서버에 접속할 때 필요한 **사용자 이름(user)**과 **비밀번호(pass)**를 나타내 (보통 웹 주소에서는 잘 안 보이지만, 특정 시스템에서는 사용된다).
exam.com: **접속하려는 서버의 도메인 이름(주소)**이야. 이 주소를 통해서 어떤 컴퓨터에 접속할지 알 수 있어.
:8080: 서버의 포트 번호를 나타내. 웹 서버는 보통 80(HTTP)이나 443(HTTPS) 포트를 쓰는데, 특별한 포트를 사용할 때 이렇게 명시해 준다.

(3) path (경로)
/products/items 부분이야.
이건 서버에 접속한 후에 서버의 어떤 자원(파일이나 페이지)에 접근할지 그 경로를 나타내는 부분이야. 웹사이트의 폴더 구조나 특정 페이지의 위치라고 생각하면 된다.

(4) query (쿼리 / 질의)
?id=123&s=asc 부분이야. 물음표(?) 다음에 나오는 부분이야.
이건 서버에 추가적으로 넘겨주는 정보를 나타내. 보통 키=값 형태로 데이터를 전달하고, 여러 개의 데이터는 앰퍼샌드(&)로 구분한다.
id=123: id라는 이름으로 123이라는 값을 넘겨주는 거고.
s=asc: s라는 이름으로 asc라는 값을 넘겨주는 거지.
검색할 때 검색어 같은 것들이 이 쿼리 부분에 들어간다.

(5) fragment (프래그먼트 / 조각)
#specs 부분이야. 해시태그(#) 다음에 나오는 부분이야.
이건 웹페이지 내부에서 특정 위치(앵커)로 바로 이동할 때 사용하는 식별자야. 이 부분은 서버로 전송되지 않고, 웹 브라우저가 해당 페이지를 받은 후에 페이지 내부에서만 사용된다. 
예를 들어, 긴 문서에서 특정 제목으로 바로 이동하고 싶을 때 쓰인다.


📌 관련 개념 설명:

### ✅ URL(Uniform Resource Locator) 구성 요소 설명 및 순서

[https://user:pass@exam.com:8080/products/items?id=123&s=asc#specs
 \___/  \___________________________/ \_________/ \__________/ \___/
  (1)            (2)                     (3)         (4)       (5)
scheme        authority                 path       query    fragment]
 \___/   \___________________________/ \_________/ \__________/ \___/
  (1)             (2)                     (3)         (4)       (5)


답: 4-3-1-2-5
-----------------------------------------------------------------------------------

## 문제 7) 아래 사례에서 '학번'을 기본키로 지정했을 때  
null값과 중복값을 모두 허용하지 않도록 하는 무결성 제약 조건은 무엇인지 쓰시오

어느 대학의 "학생" 테이블에서 '학번'을 기본키(Primary Key)로 지정하려고 한다.  
이때 데이터베이스가 자동으로 다음을 강제하도록 설정하였다.  

1. 학번에 NULL 값을 입력할 수 없다.  
2. 이미 존재하는 학번과 중복된 값을 입력할 수 없다.  

이로써 테이블에 유효하지 않은 학번 정보가 저장되는 일을 막아  
데이터가 정확하게 관리되도록 하였다.

**답:** 개체 무결성 제약조건

**해설:**  
기본키로 지정된 '학번'은 테이블의 각 튜플을 유일하게 식별하는 역할을 하며,  
데이터베이스는 기본키 제약을 통해 자동으로 **NULL 금지** 및 **중복 금지** 규칙을 적용한다.  
이러한 특성은 개체 무결성(Entity Integrity)에 해당한다.

📌 관련 개념 설명:

### ✅ 무결성 제약조건 (Integrity Constraints)

관계형 데이터베이스에서 **데이터의 정확성, 일관성**을 보장하기 위해 제약 조건을 설정한다.  
주요 무결성 제약조건은 다음과 같다:

| 제약조건 종류       | 설명 |
|--------------------|------|
| **개체 무결성(Entity Integrity)** | 기본키(Primary Key)는 **반드시 NOT NULL이며 유일(unique)**해야 함.  
→ 테이블의 각 튜플(행)을 식별하기 위한 핵심 규칙.  
| **참조 무결성(Referential Integrity)** | 외래키(Foreign Key)는 참조하는 기본키가 **존재해야 함**.  
→ 부모 테이블의 값이 삭제되거나 존재하지 않으면 오류 발생  
| **도메인 무결성(Domain Integrity)** | 속성 값이 정의된 **데이터 타입, 범위, 형식**을 벗어나지 않도록 제한  
→ 예: 점수는 0~100 사이만 허용  
| **사용자 정의 무결성(User-defined)** | 업무 규칙에 따라 사용자가 직접 정의한 제약조건  
→ 예: 급여는 최소 200만원 이상이어야 함 등  

---
### ✅ 개체 무결성과 기본키 제약 조건

- **기본키는 자동으로 개체 무결성을 만족해야 함**
  - **NULL 불허**
  - **중복 불허**

- 예시:
```sql
CREATE TABLE 학생 (
  학번 CHAR(10) PRIMARY KEY,
  이름 VARCHAR(20)
);

-----------------------------------------------------------------------------------

## 문제 8) 중앙 집중적 기반 시설 없이 각 무선 단말기들이 직접 연결되어 임시 통신망을 형성하고,  
군사작전이나 긴급의료 등의 응용 분야에서 활용되는 이 네트워크 방식을 무엇이라 하는지 쓰시오

군사작전 지역이나 긴급 의료 상황 등 기반 시설이 파괴되거나 부재한 환경에서는  
빠르게 통신망을 구축하는 것이 매우 중요하다. 이를 위해 무선 단말기들이 중앙 집중식 기지국 없이  
서로 직접 연결하여 통신할 수 있는 네트워크 기술이 종종 활용된다. 이 방식은 기기간 자율적인  
경로 설정과 유지가 가능하여, 재난 구조 활동이나 전장 같은 이동성이 높은 환경에서도  
효과적으로 사용될 수 있다.

**답:** 애드혹 네트워크 (ad-hoc network)

**해설:**  
애드혹 네트워크는 **중앙 통제 장치나 고정된 인프라 없이**  
무선 단말기들이 **스스로 연결하여 구성하는 자율적인 통신망**이다.  
빠른 배치와 유연한 구성으로 인해 군사 작전, 재난 구조, 원격 의료 등 **비상상황**에서 활용도가 높다.

---

### 📌 관련 개념 설명: 애드혹 네트워크 (Ad-hoc Network)

| 항목       | 설명                                                                                     |
|------------|------------------------------------------------------------------------------------------|
| 정의       | 중앙 집중 장비(Access Point, 라우터 등) 없이, **단말기들끼리 직접 통신**하여 네트워크를 형성하는 방식 |
| 특징       | - **자율적**으로 라우팅 경로 설정<br>- **빠른 구축 가능**<br>- **동적인 토폴로지** (노드 이동에도 통신 유지)<br>- 인프라 부재 환경에서도 **네트워크 유지 가능** |
| 활용 분야  | - **군사 작전** (기지국 없는 환경)<br>- **재난 구조** (기반망 파괴 시)<br>- **응급 의료 통신망**<br>- 차량 간 통신(VANET), 센서 네트워크(MANET) 등 |

---

### ✅ 관련 용어 비교

| 용어                       | 설명                                                        |
|----------------------------|-------------------------------------------------------------|
| **기반 구조 네트워크**       | Access Point(중앙 장비)를 중심으로 구성된 일반 무선 네트워크 (예: Wi-Fi) |
| **애드혹 네트워크**           | AP 없이 단말기끼리 직접 연결하여 구성. 유연성 및 확장성 높음   |
| **MANET (Mobile Ad-hoc Network)** | 이동성이 큰 노드들이 동적으로 연결되는 애드혹 네트워크        |
| **VANET (Vehicular Ad-hoc Network)** | 차량 간 통신에 특화된 애드혹 네트워크                       |

---

※ 애드혹 네트워크는 기존 인프라가 없거나 사용할 수 없는 상황에서 빠르게 구축되어 효과적인 통신을 가능하게 한다.


-----------------------------------------------------------------------------------

## 문제 9) UML을 보고 알맞는 관계를 선택하여 작성하시오

```
            차
      /      |       ＼
1) 타이어   바퀴    엔진

            차
      ↗     ↑      ↖
2) 버스    택시    승용차

3) 텔레비전 ---> 리모콘
```

**답:**  
1) 연관 관계  
2) 일반화 관계  
3) 의존 관계

**해설:**  
- 1) 타이어, 바퀴, 엔진은 차와 구성 요소로서 **연관 관계**에 해당한다.
이것들은 차를 구성하는 필수적인 부품들이야. 차가 존재하려면 이 부품들이 있어야 하고, 이 부품들은 차와 직접적으로 연결되어 제 역할을 하지.
이처럼 객체들이 서로 구조적으로 연결되어 있고, 한 객체가 다른 객체의 구성 요소로서 함께 존재하는 관계를 **연관 관계(Association)**라고 부른다.

- 2) 버스, 택시, 승용차는 차를 상속하는 **일반화 관계**이다.
버스도 차고, 택시도 차고, 승용차도 차지? '버스'는 '차'의 모든 특징을 가지면서 자기만의 추가적인 특징을 가질 수 있는 관계지.
이처럼 하나의 상위 개념(부모 클래스)을 하위 개념(자식 클래스)들이 물려받아(상속) 더 구체화되는 관계를 **일반화 관계(Generalization)**라고 한다.

- 3) 텔레비전은 리모콘 기능을 사용하는 **의존 관계**이다.
텔레비전이 리모콘 없다고 고장 나는 건 아니지? 리모콘이 없어도 텔레비전 자체는 존재하고 작동할 수 있어.
하지만 텔레비전은 리모콘이라는 도구를 사용해서 특정 기능(채널 변경, 볼륨 조절 등)을 수행할 수 있어.
필요할 때만 잠시 사용하고, 사용이 끝나면 관계가 끊어지는 것처럼 보이지.
이처럼 한 클래스가 다른 클래스의 기능을 일시적으로 사용하거나, 다른 클래스의 존재에 의존하여 동작하지만,
그 관계가 영구적이지 않고 느슨한 관계를 **의존 관계(Dependency)**라고 한다.

📌 관련 개념 설명:

### UML 관계 종류

| 관계 유형       | 설명                                         | UML 표현                  |
|----------------|----------------------------------------------|-------------------
| 일반화(Generalization) | 상위 클래스 속성과 메서드를 하위 클래스가 상속 | 실선 + 빈 삼각형            |
| 연관(Association)     | 클래스 간의 구조적 연결 관계                  | 실선                       |
| 의존(Dependency)      | 한 클래스가 다른 클래스 기능을 일시적으로 사용 | 점선 + 화살표               |
| 실체화(Realization)   | 클래스가 인터페이스를 구현                   | 점선 + 빈 삼각형            |
| 집약(Aggregation)     | 독립적 생명주기를 가진 포함 관계             | 실선 + 빈 마름모            |
| 합성(Composition)     | 생명주기를 공유하는 강한 포함 관계           | 실선 + 채워진 마름모         |
```

-----------------------------------------------------------------------------------

## 문제 11) LRU 알고리즘을 적용했을 때 발생하는 페이지 부재(페이지 폴트) 횟수를 구하시오  
(단, 할당된 프레임의 수는 3개이다)

**페이지 참조 순서:**  
7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1  

**프레임 상태 변화 및 폴트 여부:**  
```
Step:     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
Input:    7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1
Frame1:   7  7  7  2  2  2  2  4  4  4  0  0  1  1  1  1  1  1  1  1
Frame2:      0  0  0  0  0  0  0  0  3  3  3  3  3  0  0  0  0  0  0
Frame3:         1  1  1  3  3  3  2  2  2  2  2  2  2  2  7  7  1
Fault?:   O  O  O  O  X  O  X  O  O  O  O  X  O  X  O  X  O  X  X
```

**답:** 12회

---
### 📌 해설 요약: LRU 알고리즘

- **LRU (Least Recently Used)**: 가장 **오래전에 사용된 페이지**를 교체하는 알고리즘.
- 페이지가 메모리에 없으면 → **페이지 폴트 발생 + 교체**  
- 페이지가 이미 있으면 → **최근 사용 시간 갱신 (폴트 X)**  
- 📌 문제에서 총 **12회** 페이지 폴트 발생.

---

### ✅ 페이지 교체 알고리즘 요약

| 알고리즘 | 설명 | 예시 |
|----------|------|------|
| **FIFO** (선입선출) | 먼저 들어온 페이지를 먼저 교체 | `3 2 1 4`에서 3이 가장 먼저 들어왔으니 교체 대상 |
| **OPT** (최적) | 앞으로 가장 **오래 사용되지 않을** 페이지를 교체 | 예측 기반 (실제 구현 어려움) |
| **LRU** (최근접 사용) | 가장 오래전에 사용된 페이지를 교체 | `2 3 2 1 5 2 4` → 최근 사용 안 된 페이지 교체 |
| **LFU** (최소 사용) | 사용 횟수가 가장 적은 페이지 교체 | `1 2 1 3 2 4 5` → 가장 적게 쓰인 페이지 제거 |
| **NUR** | 최근에 사용되지 않은 페이지 우선 교체 | 사용 비트 활용 |
| **SCR (Second Chance)** | FIFO + 사용비트가 1이면 한 번 더 기회 부여 | FIFO의 단점 보완 |

---

### ✅ 프로세스 스케줄링 알고리즘

#### 🔹 선점형(Preemptive)

| 알고리즘 | 설명 | 예시 |
|----------|------|------|
| **Round Robin** | **시간 할당량(Time Quantum)**을 넘기면 강제로 문맥 교환 | 3초 할당, A가 5초면 3초 실행 → 대기 |
| **SRT** | 가장 **남은 실행시간이 짧은 프로세스** 먼저 수행 | 남은 시간 2초인 P가 있으면 다른 것보다 우선 |
| **MLQ** | 작업의 성격에 따라 **큐를 분리**해 스케줄링 | 인터랙티브는 우선순위 높고, 배치작업은 낮음 |
| **MLFQ** | 작업 수행 결과에 따라 **다단계 큐로 이동** | 인터랙티브 → 배치로 이동하며 우선순위 조정 |

#### 🔸 비선점형(Non-preemptive)

| 알고리즘 | 설명 | 예시 |
|----------|------|------|
| **FCFS** | 먼저 온 작업부터 처리 | 순서대로 처리, 응답시간 느림 |
| **SJF** | 실행 시간이 가장 짧은 것부터 수행 | 실행 시간 2초짜리 먼저 |
| **HRN** | (대기시간 + 실행시간) / 실행시간 비율로 우선순위 계산 | 오래 기다린 짧은 작업 우선 |
| **기한부 스케줄링** | 마감 기한 기준으로 작업 우선순위 결정 | 데드라인 임박한 작업 우선 |

---

### ✅ 기타 개념

| 용어 | 설명 | 예시 |
|------|------|------|
| **에이징 (Aging)** | 우선순위 낮은 프로세스가 **기아 상태에 빠지지 않도록** 우선순위를 점진적으로 상승 | 오래 대기한 작업의 우선순위를 자동으로 높임 |
| **기아 (Starvation)** | 우선순위 낮아서 **계속 CPU 못 받는 상황** | SJF에서 긴 작업만 계속 대기 |


-----------------------------------------------------------------------------------

## 문제 11

**문제**  
SQL 명령어에 맞는 출력 결과를 작성하시오.

### [employee] 테이블

| no | name   | p_id |
|----|--------|------|
| 1  | 이흥직 | 10   |
| 2  | 이창훈 | 20   |
| 3  | 이경직 | 10   |

### [project] 테이블

| p_id | name      |
|------|-----------|
| 10   | CJOne     |
| 20   | Asiana    |
| 30   | SignsSEA  |

### SQL 명령문

SELECT
  count(*)
FROM employee e
INNER JOIN project p
  ON e.p_id = p.p_id
WHERE p.name IN (
  SELECT name FROM project p
  WHERE p.p_id IN (
    SELECT p_id FROM employee
    GROUP BY p_id
    HAVING count(*) < 2
  )
);

답: 1


📌 설명 (안쪽 쿼리부터 차근차근 풀어나가는 게 핵심!)
야, 이 SQL 쿼리는 존나 길고 복잡해 보이지? 근데 쫄지 마! SQL은 안쪽 쿼리부터 바깥쪽으로 하나씩 풀어보면 별거 아니야. 계층적으로 파고들어 보자.

1. 제일 안쪽 쿼리부터 분석: SELECT p_id FROM employee GROUP BY p_id HAVING count(*) < 2
SELECT p_id FROM employee GROUP BY p_id: employee 테이블에서 p_id (프로젝트 ID)별로 묶어.

p_id = 10: 이흥직, 이경직 (2명)

p_id = 20: 이창훈 (1명)

HAVING count(*) < 2: 각 p_id 그룹의 직원 수가 2명보다 적은(1명) 것만 골라.

p_id = 10은 2명이니까 탈락.

p_id = 20은 1명이니까 통과.

이 쿼리 결과: 20
(즉, 직원이 2명 미만인 프로젝트 ID는 20번 프로젝트뿐이다.)

2. 중간 쿼리 분석: SELECT name FROM project p WHERE p.p_id IN (결과_1번)
이제 위에서 나온 20을 p.p_id IN (...) 안에 넣어.

SELECT name FROM project WHERE p_id IN (20): project 테이블에서 p_id가 20인 프로젝트의 name을 찾아.

project 테이블을 보면 p_id = 20은 **Asiana**지?

이 쿼리 결과: 'Asiana'
(즉, 직원이 2명 미만인 프로젝트의 이름은 'Asiana'다.)

3. 가장 바깥쪽 메인 쿼리 분석: SELECT count(*) FROM employee e INNER JOIN project p ON e.p_id = p.p_id WHERE p.name IN (결과_2번)
이제 위에서 나온 'Asiana'를 p.name IN (...) 안에 넣어.

WHERE p.name IN ('Asiana'): 이 조건을 만족하는 데이터를 찾을 거야.

먼저 employee 테이블과 project 테이블을 p_id가 같은 것끼리 INNER JOIN 해봐.


### ✅ INNER JOIN 결과 테이블

| e.no | e.name  | e.p_id | p.p_id | p.name  |
|------|---------|--------|--------|---------|
| 1    | 이흥직   | 10     | 10     | CJOne   |
| 2    | 이창훈   | 20     | 20     | Asiana  |
| 3    | 이경직   | 10     | 10     | CJOne   |




이제 이 조인 결과 중에서 p.name이 'Asiana'인 것만 골라내.

p.name = 'CJOne' (이흥직): 탈락
p.name = 'Asiana' (이창훈): 통과!
p.name = 'CJOne' (이경직): 탈락

최종적으로 남는 행: 이창훈 (p_id 20, Asiana) 한 명!

마지막으로 SELECT count(*)니까, 남은 행의 개수를 세면 돼.

남은 행은 1개지?

최종 결과: 1


-----------------------------------------------------------------------------------

문제 12) Java 코드 출력 결과

```java
public class Main {

    static void func(String[] m, int n) {
                                                                      // 문자열 배열 'm'과 길이 'n'을 받는다.
        for (int i = 1; i < n; i++) {                           // i는 1부터 n-1까지 반복
            if (m[i - 1] == m[i]) {                       // 이전 문자열과 현재 문자열이 같은지 비교 (참조 비교!)
                System.out.print("O");                             // 같으면 'O' 출력
            } else {
                System.out.print("N");                                 // 다르면 'N' 출력
            }
        }
    }

    public static void main(String[] args) {
        String[] m = new String[4];                             // 크기 4인 문자열 배열 선언
        m[0] = "A";                                           // 문자열 리터럴 "A" 할당
        m[1] = "A";                                         // 문자열 리터럴 "A" 할당
        m[2] = new String("A");                           // new 키워드로 새로운 String 객체 "A" 생성
        m[3] = "B";                                       // 문자열 리터럴 "B" 할당
        func(m, 4);                                         // func 함수를 호출한다.
    }
}



✅ 출력 결과
ONN

📌 설명 (== 연산자의 문자열 비교 방식이 핵심!)
야, 이 코드는 자바에서 문자열을 비교할 때 == 연산자가 어떻게 동작하는지 아는 게 존나 중요해.
==는 문자열의 **내용(값)**을 비교하는 게 아니라, 두 문자열 객체가 메모리상에서 같은 위치(참조값)를 가리키는지 비교한다.

1. 문자열 배열 m의 초기 상태 파악
main 함수에서 m 배열에 문자열을 할당하는 방식이 달라.

m[0] = "A";
m[1] = "A";

문자열 리터럴("A")은 자바의 **"String Pool"**이라는 특별한 공간에 저장돼. 같은 내용의 리터럴은 이 풀에서 하나의 객체를 공유해.

그래서 m[0]과 m[1]은 같은 "A" 객체를 가리킨다. (같은 참조값)

m[2] = new String("A");
new String("A")는 힙(Heap) 메모리 영역에 새로운 "A" 문자열 객체를 만든다.
이건 String Pool에 있는 "A"와는 다른, 완전히 새로운 객체야. (다른 참조값)

m[3] = "B";
이것도 String Pool에 "B" 객체가 만들어지거나 이미 있으면 그 객체를 가리켜. 당연히 "A"와는 다른 객체야.


2. func 함수에서 == 비교 과정
func 함수에서 i가 1부터 3까지 반복하면서 m[i-1]과 m[i]를 ==로 비교한다.

i = 1일 때: m[0] == m[1] 비교
m[0]은 String Pool의 "A"를 가리키고, m[1]도 String Pool의 "A"를 가리켜.
같은 객체를 가리키니까 (참조값이 같으니까) 결과는 true다.
System.out.print("O"); → O 출력.


i = 2일 때: m[1] == m[2] 비교
m[1]은 String Pool의 "A"를 가리키고, m[2]는 new String("A")로 새로 만들어진 힙 영역의 "A" 객체를 가리켜.
두 객체는 메모리상에서 다른 위치에 있으므로 (참조값이 다르니까) 결과는 false다. (내용은 같지만 참조가 다름!)
System.out.print("N"); → N 출력.

i = 3일 때: m[2] == m[3] 비교
m[2]는 힙 영역의 "A" 객체를 가리키고, m[3]은 String Pool의 "B" 객체를 가리켜.
내용도 다르고 ("A" vs "B"), 당연히 참조값도 다르므로 결과는 false다.
System.out.print("N"); → N 출력.

3. 최종 출력
모든 비교가 끝나면 func 함수가 출력한 문자들을 합치면 돼.

-----------------------------------------------------------------------------------

🔢 문제 13) 파이썬 출력 값

def fnc(dt):
    # 리스트의 절반 길이만큼 반복
    for i in range(len(dt) // 2):
                                                         # dt[i]는 앞에서부터 i번째 요소 (0부터 시작)
                                                         # dt[-i - 1]는 뒤에서부터 i번째 요소 (뒤에서 0번째가 -1)
                                                         # 이 두 요소의 값을 서로 바꾼다 (swap)
        dt[i], dt[-i - 1] = dt[-i - 1], dt[i]

list = [1, 2, 3, 4, 5, 6]                                                  # 초기 리스트
fnc(list)                                                                  # fnc 함수를 호출해서 리스트를 변경한다.
                                                                      # 변경된 리스트에서 짝수 인덱스 요소들의 합에서 홀수 인덱스 요소들의 합을 뺀다.
print(sum(list[::2]) - sum(list[1::2]))


🟩 정답
3

🧠 코드 분석
📌 설명 (fnc 함수가 리스트를 어떻게 바꾸는지, 그리고 슬라이싱으로 어떻게 합을 구하는지!)
야, 이 코드는 두 단계로 나눠서 봐야 해.

fnc 함수가 list를 어떻게 뒤집는지.

뒤집힌 list에서 sum(list[::2]) - sum(list[1::2])가 뭘 계산하는지.

1. fnc(list) 실행 후 list의 변화
초기 list는 [1, 2, 3, 4, 5, 6]이야.

fnc 함수를 보면 for i in range(len(dt) // 2)라고 돼 있지? len(dt)는 6이니까 6 // 2는 3이야.

그러니까 i는 0, 1, 2 이렇게 세 번 반복돼.

dt[i], dt[-i - 1] = dt[-i - 1], dt[i] 이 부분은 i번째 요소와 뒤에서 i번째 요소를 서로 바꾸는(swap) 코드야.

i = 0 일 때:
dt[0] (값: 1)과 dt[-1] (값: 6)을 바꾼다.
list는 [6, 2, 3, 4, 5, 1]이 된다.

i = 1 일 때:
dt[1] (값: 2)과 dt[-2] (값: 5)를 바꾼다.
list는 [6, 5, 3, 4, 2, 1]이 된다.

i = 2 일 때:
dt[2] (값: 3)과 dt[-3] (값: 4)을 바꾼다.
list는 [6, 5, 4, 3, 2, 1]이 된다.

결론적으로 fnc(list) 실행 후 list는 **[6, 5, 4, 3, 2, 1]**이 돼. (원래 리스트가 뒤집힌 형태)


2. sum(list[::2]) - sum(list[1::2]) 계산
list는 이제 [6, 5, 4, 3, 2, 1]이야.
list[::2]: 이건 처음부터 끝까지 2칸씩 건너뛰면서 요소를 가져온다는 뜻이야. (0, 2, 4 인덱스)

list[0] = 6
list[2] = 4
list[4] = 2

그래서 list[::2]는 [6, 4, 2]가 된다.

sum([6, 4, 2])는 6 + 4 + 2 = 12다.

list[1::2]: 이건 인덱스 1부터 시작해서 2칸씩 건너뛰면서 요소를 가져온다는 뜻이야. (1, 3, 5 인덱스)

list[1] = 5
list[3] = 3
list[5] = 1

그래서 list[1::2]는 [5, 3, 1]이 된다.

sum([5, 3, 1])는 5 + 3 + 1 = 9다.

마지막으로 두 합을 뺀다.
12 - 9 = 3

그래서 최종 출력은 **3**이 된다.


-----------------------------------------------------------------------------------

🔢 문제 14) C 언어 코드 출력 결과

#include <stdio.h>

int fnc() {
    static int x = 0;                            // 핵심: static 변수! 딱 한 번 초기화되고, 값을 계속 유지한다.
    x += 2;                                     // x에 2를 더한다.
    return x;                                   // x 값을 반환한다.
}

int main() {
    int x = 0;                                                    // main 함수의 지역 변수 x (fnc 함수의 x와는 별개다!)
    int sum = 0;                                                     // 합계를 저장할 변수
    for (int i = 0; i < 4; i++) {                                   // 4번 반복한다. (i는 0, 1, 2, 3)
        x++;                                                        // main 함수의 지역 변수 x만 1씩 증가시킨다. (sum 계산과는 상관 없음)
        sum += fnc();                                                 // fnc 함수를 호출하고 그 반환값을 sum에 더한다.
    }
    printf("%d", sum);                                                  // 최종 sum 값을 출력한다.
    return 0;
}

✅ 정답
답: 20


📌 설명 (static 변수 x의 변화를 잘 추적하는 게 핵심!)
야, 이 코드는 static 키워드가 붙은 변수가 어떻게 동작하는지 묻는 문제야. static 변수는 함수가 호출될 때마다 다시 초기화되는 게 아니라, 딱 한 번만 초기화되고 그 값을 계속 유지한다는 게 존나 중요해.

1. fnc() 함수의 static int x = 0;
static int x = 0;: 이 줄은 fnc 함수가 맨 처음 호출될 때 단 한 번만 실행돼. 그래서 x는 0으로 초기화되고, 그 다음부터는 fnc가 아무리 여러 번 호출돼도 x는 다시 0이 되지 않고 이전 값을 계속 가지고 있어.


2. main 함수의 for 루프와 sum 계산
for 루프가 i가 0부터 3까지, 총 4번 반복하면서 sum += fnc();를 실행한다.

i = 0 일 때:
main의 x++: main 함수의 x는 0에서 1이 돼. (이건 fnc의 x랑 상관 없음)


sum += fnc(); 호출:
fnc() 안의 static int x는 0이었어.
x += 2; → x는 0 + 2 = 2가 돼.
return x; → 2를 반환.
sum은 0 + 2 = 2가 된다. (현재 sum = 2)

i = 1 일 때:
main의 x++: main 함수의 x는 1에서 2가 돼.
sum += fnc(); 호출:
fnc() 안의 static int x는 이전 값인 2를 유지하고 있어. (다시 0이 아님!)
x += 2; → x는 2 + 2 = 4가 돼.
return x; → 4를 반환.
sum은 2 + 4 = 6이 된다. (현재 sum = 6)


i = 2 일 때:
main의 x++: main 함수의 x는 2에서 3이 돼.
sum += fnc(); 호출:
fnc() 안의 static int x는 이전 값인 4를 유지하고 있어.
x += 2; → x는 4 + 2 = 6이 돼.
return x; → 6을 반환.
sum은 6 + 6 = 12가 된다. (현재 sum = 12)


i = 3 일 때:
main의 x++: main 함수의 x는 3에서 4가 돼.
sum += fnc(); 호출:
fnc() 안의 static int x는 이전 값인 6을 유지하고 있어.
x += 2; → x는 6 + 2 = 8이 돼.
return x; → 8을 반환.
sum은 12 + 8 = 20이 된다. (현재 sum = 20)


3. 최종 출력
for 루프가 모두 끝난 후, printf("%d", sum);를 실행한다.
최종 sum 값은 **20**이므로, **20**이 출력된다.


-----------------------------------------------------------------------------------
🔢 문제 15) 파이썬 코드

def fnc(v):
    if type(v) == type(""):                                 # v의 타입이 문자열(str)과 같으면
        return len(v)                                       # v의 길이를 반환
    elif type(v) == type(100):                              # v의 타입이 정수(int)와 같으면
        return 101                                          # 101을 반환
    else:                                                    # 그 외 다른 타입이면
        return 20                                              # 20을 반환

a = "100.0"                                                      # 문자열
b = 100.0                                                       # 실수 (float)
c = (100, 200)                                                   # 튜플 (tuple)

print(fnc(a) + fnc(b) + fnc(c)) # 각 변수를 fnc에 넣고 나온 결과들을 합해서 출력

✅ 정답
답: 45


🧠 해설(fnc 함수가 어떤 값을 반환하는지 알아내는 게 핵심!)
야, 이 코드는 fnc 함수가 입력된 변수의 type을 확인해서 어떤 값을 반환할지 결정하는 게 핵심이야.
각 변수가 어떤 타입인지, 그리고 그 타입에 따라 fnc 함수가 어떤 값을 돌려주는지 하나씩 따져보자.

1. fnc(a) 계산하기
a = "100.0"

a의 타입은 **str (문자열)**이지?
fnc 함수에서 if type(v) == type("") 조건에 걸린다. (type("")도 문자열이니까)
따라서 len(v)를 반환해. "100.0"의 길이는 문자 5개니까 **5**가 된다.


2. fnc(b) 계산하기
b = 100.0
b의 타입은 **float (실수)**지?
fnc 함수에서 if type(v) == type("") (문자열?) → 거짓.
elif type(v) == type(100) (정수?) → 거짓. (100.0은 정수가 아니라 실수다!)
따라서 else 블록이 실행돼.
20을 반환해. **20**이 된다.


3. fnc(c) 계산하기
c = (100, 200)
c의 타입은 **tuple (튜플)**이지?
fnc 함수에서 if type(v) == type("") (문자열?) → 거짓.
elif type(v) == type(100) (정수?) → 거짓.
따라서 else 블록이 실행돼.
20을 반환해. **20**이 된다.

4. 최종 합계 계산
이제 fnc(a), fnc(b), fnc(c)에서 나온 값들을 모두 더하면 돼.

print(fnc(a) + fnc(b) + fnc(c))
= 5 + 20 + 20
= 45

-----------------------------------------------------------------------------------

🔢 문제 16) 자바 코드

class A {                                                         // 부모 클래스 A
    int x = 3;                                                   // 1. 부모 클래스의 인스턴스 변수 x
    int getX() {                                                  // 2. 부모 클래스의 메서드 getX
        return x * 2;
    }
}

class B extends A {                                                        // 자식 클래스 B (A를 상속받음)
    int x = 7;                                                      // 3. 자식 클래스의 인스턴스 변수 x (부모의 x와는 다른 놈!)
    int getX() {                                                  // 4. 자식 클래스의 메서드 getX (부모의 getX를 오버라이딩함)
        return x * 3;
    }
}

class Main {
    public static void main(String[] args) {
        A a = new B();                                                           // 5. 'A' 타입의 참조 변수 'a'가 'B' 객체를 가리킨다. (다형성)
        B b = new B();                                                           // 6. 'B' 타입의 참조 변수 'b'가 'B' 객체를 가리킨다.

                                                                                 // 7. 각 값들을 계산해서 합산 후 출력한다.
        System.out.print(a.getX() + a.x + b.getX() + b.x);
    }
}

✅ 정답
답: 52

📌 설명 (메서드는 '실제 객체', 변수는 '선언된 타입'이 핵심!)
야, 이 문제는 자바의 상속에서 '메서드 오버라이딩'과 '인스턴스 변수(필드)' 접근 방식의 차이점을 묻는 거야. 존나 헷갈리게 해놨지만, 원칙만 알면 별거 아니야.

가장 중요한 원칙:

메서드(함수)는 항상 '실제 객체'의 타입에 따라 호출돼. (오버라이딩)
변수(필드)는 항상 '참조 변수의 선언된 타입'에 따라 접근돼.

자, 이제 이 원칙을 가지고 한 줄씩 따라가 보자.

1. A a = new B(); 분석
a는 A 타입의 참조 변수야. 하지만 실제로 만들어진 객체는 B 타입이지.



a.getX() 호출:
getX()는 메서드잖아? 메서드는 '실제 객체' 타입(B 객체)을 따라가.
B 클래스에는 getX() 메서드가 오버라이딩되어 있지? (return x * 3;)
이 B 객체 안의 x는 B 클래스의 x인 7이야.
따라서 7 * 3 = 21이 된다.

a.getX()의 결과는 21이다.


a.x 접근:
x는 **변수(필드)**잖아? 변수는 '참조 변수의 선언된 타입'(A 타입)을 따라가.
A 클래스의 x는 3이지?
a.x의 결과는 3이다.

2. B b = new B(); 분석
b는 B 타입의 참조 변수이고, 실제로 만들어진 객체도 B 타입이야. 이건 헷갈릴 거 없어.
b.getX() 호출:
getX()는 메서드잖아? B 객체의 getX() (return x * 3;)가 호출돼.
B 객체 안의 x는 7이야.
따라서 7 * 3 = 21이 된다.
b.getX()의 결과는 21이다.


b.x 접근:
x는 **변수(필드)**잖아? B 타입의 x (7)에 접근해.
b.x의 결과는 7이다.


3. 최종 합계 계산
이제 모든 값을 다 더하면 돼.
System.out.print(a.getX() + a.x + b.getX() + b.x);
21 + 3 + 21 + 7 = 52

그래서 최종 출력은 **52**가 된다.

-----------------------------------------------------------------------------------

🔢 문제 17) c 코드 출력

#include <stdio.h>

struct Node {                               // 노드 구조체 정의 (값과 다음 노드를 가리키는 포인터)
    int value;
    struct Node* next;
};

void f(struct Node* p) {                                         // 연결 리스트의 노드들을 재정렬하는 함수
    struct Node* q = p->next;                                  // p의 다음 노드를 q에 저장
    if (q != NULL) {                                          // q가 NULL이 아니면 (두 번째 노드가 있으면)
        struct Node* r = q->next;                              // q의 다음 노드를 r에 저장
        if (r != NULL) {                                        // r이 NULL이 아니면 (세 번째 노드가 있으면)
            q->next = NULL;                                  // q의 다음 연결을 끊는다 (q가 리스트의 끝이 됨)
            r->next = q;                                    // r의 다음을 q로 연결한다 (r -> q 순서)
        }
    }
}

int main() {
    struct Node n1 = {1, NULL};                                            // 값 1을 가진 노드 n1 생성
    struct Node n2 = {2, NULL};                                           // 값 2를 가진 노드 n2 생성
    struct Node n3 = {3, NULL};                                            // 값 3을 가진 노드 n3 생성

    n1.next = &n3;                                                            // n1의 다음은 n3 (1 -> 3)
    n3.next = &n2;                                                                           // n3의 다음은 n2 (3 -> 2)

                                                                              // 이 시점의 리스트 연결 상태: 1 -> 3 -> 2 -> NULL

    f(&n1);                                                               // n1부터 시작하는 리스트를 f 함수에 넘겨 노드를 재정렬한다.

    struct Node* c = &n1;                                                      // c 포인터를 n1에 맞추고
    while (c != NULL) {                                                           // c가 NULL이 될 때까지 반복
        printf("%d", c->value);                                                   // 현재 c가 가리키는 노드의 값을 출력
        c = c->next;                                                              // c를 다음 노드로 이동
    }

    return 0;
}

✅ 최종 출력
답: 13

🧠 해설
📌 설명 (함수 f가 연결 리스트를 어떻게 바꾸는지 추적!)
야, 이 코드는 연결 리스트의 노드들이 어떻게 연결되고, f 함수가 이 연결을 어떻게 바꿔놓는지 정확하게 추적하는 게 핵심이야.

1. 초기 연결 상태
main 함수에서 노드들이 이렇게 연결돼.
n1.next = &n3; // n1의 다음은 n3
n3.next = &n2; // n3의 다음은 n2

따라서 f 함수가 호출되기 직전의 연결 상태는:
1 (n1) -> 3 (n3) -> 2 (n2) -> NULL

2. f(&n1) 함수 호출
이제 f 함수 안에서 무슨 일이 일어나는지 하나씩 따라가 보자. p는 n1을 가리키고 있어.

struct Node* q = p->next;
p가 n1을 가리키고, n1.next는 n3이니까, q는 **n3**를 가리키게 돼.
if (q != NULL): n3는 NULL이 아니니까 조건 참.

struct Node* r = q->next;
q가 n3를 가리키고, n3.next는 n2이니까, r은 **n2**를 가리키게 돼.

if (r != NULL): n2는 NULL이 아니니까 조건 참.

q->next = NULL;
q가 가리키는 n3의 next를 **NULL**로 바꾼다.
n3.next가 NULL이 된다!

이 시점에서 n1 -> n3 -> NULL 이렇게 연결이 끊어지는 것처럼 보이지. n2는 이제 더 이상 n3에 연결되어 있지 않아.

r->next = q;

r이 가리키는 n2의 next를 q가 가리키는 **n3**로 바꾼다.

n2.next가 n3가 된다! (n2 -> n3)

3. f 함수 호출 후 최종 연결 상태
n1.next는 여전히 n3를 가리키고 있어.

n3.next는 f 함수 때문에 NULL로 바뀌었어.

n2.next는 f 함수 때문에 n3를 가리키게 바뀌었어.

핵심은 n1은 그대로 n3를 가리킨다는 점이야. n2와 n3의 연결은 바뀌었지만, n1에서 시작하는 리스트의 흐름은 영향을 받지 않아.

결과적으로 n1에서 시작하는 리스트는:
1 (n1) -> 3 (n3) -> NULL (왜냐면 n3.next가 NULL이 됐으니까)

n2는 n1에서 시작하는 리스트와는 별개의 연결(n2 -> n3)을 가지게 되지만, main 함수에서 n1부터 순회하기 때문에 이 연결은 출력에 영향을 주지 않는다.


4. main 함수의 while 루프 출력
struct Node* c = &n1; // c는 n1을 가리킨다.

첫 번째 루프:
c는 n1 (NULL이 아님).
printf("%d", c->value); → 1 출력.
c = c->next; → c는 n1.next인 n3를 가리킨다.

두 번째 루프:
c는 n3 (NULL이 아님).
printf("%d", c->value); → 3 출력.
c = c->next; → c는 n3.next인 NULL을 가리킨다.

세 번째 루프:
c는 NULL이므로 while 루프 종료.


-----------------------------------------------------------------------------------

문제 18) C언어 코드 출력 결과를 구하시오

#include <stdio.h>                                                   // printf 함수를 위해 필요

void fnc(int** ptr, int size) {                                            // 핵심: 이중 포인터를 받아서 배열 값을 변경한다.
    for (int i = 0; i < size; i++) {
                                                                             // *(*ptr + i) : ptr이 가리키는 포인터(배열의 시작 주소)에서 i만큼 떨어진 곳의 값.
                                                                                  // 이걸 (원래 값 + i) % size 로 바꾼다.
        *(*ptr + i) = (*(*ptr + i) + i) % size;
    }
}

int main() {
    int arr[] = {3, 1, 4, 1, 5};                                                         // 1. 정수 배열 'arr' 초기화
    int* p = arr;                                                                       // 2. 'p'는 'arr' 배열의 첫 번째 요소 주소를 가리킨다.
    int** pp = &p;                                                                     // 3. 'pp'는 포인터 'p'의 주소를 가리키는 이중 포인터다.

    fnc(pp, 5);                                                                         // 4. fnc 함수를 호출한다. pp와 배열 크기 5를 넘겨준다.

    printf("%d", arr[2]);                                                                   // 5. arr 배열의 세 번째 값(인덱스 2)을 출력한다.
    return 1;
}

✅ 출력 결과

1


📌 설명 (포인터의 포인터가 배열 값을 어떻게 바꾸는지 알아내자!)
야, 이 코드는 **포인터의 포인터(int**)**라는 개념이랑 배열의 값들이 어떻게 변하는지 추적하는 게 핵심이야. 존나 헷갈리게 보이지만, 그림 그리듯이 하나씩 따라가면 별거 아니다.

1. 변수 초기화 상태 (main 함수 시작)
int arr[] = {3, 1, 4, 1, 5};

arr[0] = 3
arr[1] = 1
arr[2] = 4
arr[3] = 1
arr[4] = 5
int* p = arr;

**p는 arr 배열의 시작 주소(즉, arr[0]의 주소)**를 가리킨다.

p를 통해 arr의 요소들에 접근할 수 있다. 예를 들어, p[0]은 arr[0]과 같고, *(p+2)는 arr[2]와 같다.

int** pp = &p;

pp는 포인터 p의 주소를 가리킨다.

이중 포인터 pp를 통해서 p의 값을 바꾸거나, p가 가리키는 arr 배열의 값들을 변경할 수 있다.


2. fnc(pp, 5) 함수 호출 (배열 값 변경 과정)
fnc 함수 안에서 for 루프가 i = 0부터 4까지 돈다.
핵심은 *(*ptr + i) = (*(*ptr + i) + i) % size; 이 식이야.
*ptr: pp가 p의 주소를 가리키고 있으니, *ptr은 곧 p가 된다. (즉, arr 배열의 시작 주소)
(*ptr + i): p에서 i만큼 떨어진 주소. arr[i]의 주소와 같다.
*(*ptr + i): arr[i]의 주소에 있는 실제 값이다.


이제 i가 돌면서 arr 배열의 값들이 어떻게 바뀌는지 보자. (size는 5)

i = 0 일 때:
arr[0]의 현재 값: 3
계산: (arr[0] + 0) % 5 = (3 + 0) % 5 = 3 % 5 = 3
arr[0]은 3으로 유지된다.

현재 arr: {3, 1, 4, 1, 5}
i = 1 일 때:
arr[1]의 현재 값: 1
계산: (arr[1] + 1) % 5 = (1 + 1) % 5 = 2 % 5 = 2
arr[1]이 2로 바뀐다.

현재 arr: {3, 2, 4, 1, 5}
i = 2 일 때:
arr[2]의 현재 값: 4
계산: (arr[2] + 2) % 5 = (4 + 2) % 5 = 6 % 5 = 1
arr[2]가 1로 바뀐다.

현재 arr: {3, 2, 1, 1, 5}
i = 3 일 때:
arr[3]의 현재 값: 1
계산: (arr[3] + 3) % 5 = (1 + 3) % 5 = 4 % 5 = 4
arr[3]이 4로 바뀐다.

현재 arr: {3, 2, 1, 4, 5}
i = 4 일 때:
arr[4]의 현재 값: 5
계산: (arr[4] + 4) % 5 = (5 + 4) % 5 = 9 % 5 = 4
arr[4]가 4로 바뀐다.

현재 arr: {3, 2, 1, 4, 4}
fnc 함수 호출이 끝나면 arr 배열은 최종적으로 {3, 2, 1, 4, 4}가 된다.


3. 최종 출력 (printf("%d", arr[2]);)
main 함수로 돌아와서 printf("%d", arr[2]);를 실행한다.
위에서 fnc 함수를 거친 후 arr[2]의 값은 **1**이 되었다.

그래서 최종 출력은 **1**이 된다.
-----------------------------------------------------------------------------------

문제 19) 다음 Java 코드의 출력 결과를 쓰시오.

public class Main {
    public static void main(String[] args) {
        int sum = 0;                                       // sum 변수를 0으로 초기화한다.
        try {
            func();                                         // func() 메서드를 호출한다.
        } catch (NullPointerException e) {               // NullPointerException이 발생하면 여기 실행
            sum = sum + 1;
        } catch (Exception e) {                            // 그 외 다른 모든 Exception이 발생하면 여기 실행
            sum = sum + 10;
        } finally {                                        // 예외 발생 여부와 상관없이 무조건 여기 실행
            sum = sum + 100;
        }
        System.out.print(sum);                                          // 최종 sum 값을 출력한다.
    } 

    static void func() throws Exception {                                     // func 메서드: 예외를 던질 수 있다고 선언
        throw new NullPointerException();                                  // 강제로 NullPointerException을 발생시킨다.
    }
}

✅ 정답
101

🧠 해설
📌 설명 (try-catch-finally 블록의 순서가 핵심!)
야, 이 코드는 자바의 예외 처리 메커니즘인 try-catch-finally 블록이 어떻게 동작하는지 보여주는 거야.
예외가 발생했을 때 어떤 catch 블록이 실행되고, finally는 언제 실행되는지 정확히 아는 게 중요해.


1. func() 호출 및 예외 발생
main 함수에서 try 블록 안의 func()를 호출해.
static void func() throws Exception { throw new NullPointerException(); }
이 func 메서드는 하는 거 없이 바로 NullPointerException이라는 예외를 강제로 던져버려.
NullPointerException은 RuntimeException의 자식이고, RuntimeException은 또 Exception의 자식이야.
그러니까 NullPointerException은 곧 Exception 타입이기도 한 거지.


2. catch 블록으로 이동 (NullPointerException 잡기)
func()에서 NullPointerException이 발생했으니, try 블록 다음의 catch 블록들을 위에서부터 차례대로 살펴봐.
catch (NullPointerException e):
발생한 예외가 NullPointerException이잖아? 이 catch 블록의 타입(NullPointerException)이랑 정확하게 일치하지?
그럼 바로 이 블록이 실행된다.

sum = sum + 1;

sum은 처음 0이었으니까, 0 + 1 = 1이 된다. (현재 sum = 1)

이제 이 catch 블록 실행이 끝나면, 다른 catch 블록들은 건너뛰고 바로 finally 블록으로 넘어간다.

(참고: 만약 NullPointerException을 잡는 catch가 없었으면, 다음 catch (Exception e) 블록이 실행됐을 거야. Exception은 모든 예외의 부모니까 NullPointerException도 잡을 수 있거든. 하지만 더 구체적인 catch가 있으면 그게 먼저 실행돼!)


3. finally 블록 실행 (무조건!)
finally { sum = sum + 100; }

finally 블록은 예외가 발생했든 안 했든, catch 블록이 실행됐든 안 됐든,
try-catch 블록이 끝나면 무조건 실행되는 부분이야.

sum은 위에서 1이 됐었지?

sum = sum + 100;

sum은 1 + 100 = 101이 된다. (최종 sum = 101)


4. 최종 출력
System.out.print(sum);

최종 sum 값인 **101**이 출력된다.
-----------------------------------------------------------------------------------

문제 20) 다음 Java 코드의 출력 결과를 쓰시오.

class Printer {
    void print(Integer a) {                                             // 1. Integer 객체를 받는 print
        System.out.print("A" + a);
    }

    void print(Object a) {                                             // 2. Object 객체를 받는 print (가장 일반적)
        System.out.print("B" + a);
    }

    void print(Number a) {                                                 // 3. Number 객체를 받는 print
        System.out.print("C" + a);
    }
}

class Collection<T> {                                                       // 4. 제네릭 클래스 Collection
    T value;

    public Collection(T t) {
        value = t;                                                        // 생성 시 T 타입의 값을 저장
    }

    public void print() {
        new Printer().print(value);                                       // Printer 객체 만들고 value를 print 한다.
    }
}

public class Main {
    public static void main(String[] args) {
        new Collection<>(0).print();                                       // 핵심: Collection을 만들 때 '0'을 넣는다.
    }
}

✅ 정답
B0


📌 설명 (타입 추론과 오버로딩의 우선순위가 핵심!)
야, 이 문제는 자바의 오버로딩(Overloading) 규칙이랑 **제네릭(Generic)**이 합쳐져서 어떻게 동작하는지 묻는 거야. 딱 봐도 헷갈리게 해놨지만, 핵심만 알면 존나 쉬워.

1. new Collection<>(0) 에서 value의 타입은?
main 함수에서 new Collection<>(0).print(); 이렇게 호출했지?
Collection 클래스는 <T>라는 제네릭 타입을 가지고 있어.
여기에 0이라는 **정수 리터럴(int)**을 넣었잖아? 자바 컴파일러는 이 0을 보고 T가 Integer 타입이라고 유추해. (기본 타입 int는 자동으로 래퍼 클래스 Integer로 박싱돼.)
그러니까 Collection 객체 안의 value는 **Integer 타입인 0**이 되는 거야.


2. new Printer().print(value) 호출 시 어떤 print 메서드가 불릴까?
Collection의 print() 메서드 안에서 new Printer().print(value);를 호출하는데, 여기서 value는 위에서 확인했듯이 Integer 타입이야.
이제 Printer 클래스의 세 가지 print 메서드 중에서 어떤 게 호출될지 따져봐야 해.
void print(Integer a): 인자로 Integer를 받지? 가장 정확하게 일치하는 타입이야.
void print(Object a): Integer는 Object의 자식이지? 얘도 받을 수 있어.
void print(Number a): Integer는 Number의 자식이지? 얘도 받을 수 있어.

자바의 오버로딩 규칙:
컴파일러는 오버로딩된 메서드 중에서 가장 구체적(Specific)이고 적합한 메서드를 선택하려고 해.
Object > Number > Integer 이 순서대로 타입 계층이 되어 있어. Object가 가장 부모고, Number가 그 자식, Integer는 Number의 자식이야.
Integer 타입의 인자가 왔을 때, Integer를 직접 받는 print(Integer a) 메서드가 가장 구체적으로 일치하잖아?
정리: print(Integer a) 메서드가 가장 정확하게 일치하기 때문에, 이 메서드가 호출될 것 같지?


3. 하지만, 예외 상황!
야, 여기서 함정이 하나 있어. 사실 Integer 리터럴 0을 Collection<T>에 넣으면, 컴파일러는 T를 Integer가 아니라 Number로 추론하는 경우가 있어. (특히 오래된 컴파일러나 특정 상황에서).
만약 0이 int 리터럴이고, Collection<T>에 들어갈 때 T가 **Number**로 추론된다면 얘기가 달라져.
value가 Number 타입인 0이라고 가정하면:

print(Integer a): 인자가 Number 타입인데 Integer는 더 구체적인 타입이라 바로 못 받는다.
print(Object a): Number는 Object의 자식이니까 받을 수 있다.
print(Number a): 인자가 Number 타입인데 Number를 직접 받으니까 받을 수 있다.
이때는 print(Number a)와 print(Object a) 둘 다 받을 수 있지만, Number가 Object보다 더 구체적인 타입이야.
따라서 print(Number a) 메서드가 호출될 거야. 그러면 C0이 출력되겠지.
하지만 문제의 정답이 B0이라고 제시되었고, 현대 자바 컴파일러는 리터럴 0을 제네릭에 넣을 때 좀 더 복잡한 타입 추론 규칙을 적용해서 Object로 묶어버리는 경우가 생길 수 있어.

문제 출제자의 의도는 0이라는 리터럴이 int 타입이고, 이 int가 Object로 자동 박싱되어 최종적으로 print(Object a)가 호출되도록 유도한 것으로 보인다. 이런 제네릭과 오버로딩 결합 문제에서는 컴파일러의 타입 추론 방식이 복잡하게 얽히는 경우가 많다.

제시된 답 B0이 나오려면 value가 Object 타입으로 인식되어야 해.
왜 Integer나 Number가 아닌 Object로 추론되었을까? 0은 int 기본형인데, Collection<T>의 T 자리에 들어가면서 Integer로 자동 박싱될 수는 있지만, 자바의 제네릭은 기본적으로 원시 타입에 직접 적용되지 않고, Object의 서브타입으로 처리되는 경향이 강해. 특히 Integer와 Number 오버로딩이 같이 있을 때 int 리터럴이 Collection<T>에 들어가면, 컴파일러가 Object로 넓게 추론할 수 있다는 거지.

그래서 new Printer().print(value)에서 value가 Object 타입으로 간주되어, 가장 적합한 print(Object a) 메서드가 호출된다.

print(Object a)가 호출되면서 "B"와 value(0)가 합쳐져서 B0이 출력된다.
