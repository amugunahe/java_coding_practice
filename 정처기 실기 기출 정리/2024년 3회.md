## 문제 1) 다음 특정 DDOS 공격 방식 설명

공격자는 출발지 IP 주소를 피해자의 IP로 위조하여 다수의 호스트가 연결된 네트워크 브로드캐스트 주소로  
ICMP 에코 요청을 전송한다. 그 결과, 브로드캐스트 네트워크에 연결된 모든 호스트들이 피해자 IP로 대량의  
ICMP 에코 응답(Echo Reply)을 보내게 되면서, 피해자가 과도한 트래픽으로 인해 서비스 장애를 겪게 된다.  

**답:** 스머프(스머핑, smurf)

📌 관련 개념 설명:

**스머프 공격(Smurf Attack)**  
- ICMP(Internet Control Message Protocol) 에코 요청을 네트워크의 브로드캐스트 주소에 보내되,  
  **출발지 주소를 피해자의 IP로 스푸핑(spoofing)** 하여,  
  브로드캐스트에 연결된 다수의 호스트들이 **피해자에게 ICMP 응답(Echo Reply)** 을 보내도록 유도.  
- 피해자는 다수의 응답 트래픽을 받아 **서비스 거부(DoS)** 상태에 빠짐.  
- 이 공격은 **트래픽 증폭(amplification)** 을 이용한 공격이며, 브로드캐스트 기능이 열려 있는 네트워크에서 특히 위험함.

**DDoS 주요 유형 요약**  
- **Smurf Attack**: ICMP 요청 + 브로드캐스트 + IP 스푸핑 → 응답 폭탄  
- **SYN Flooding**: TCP 3-way handshake의 SYN 요청만 다수 전송해 서버의 연결 대기 큐 자원 고갈  
- **UDP 플러딩**: 무작위 포트에 대량의 UDP 패킷 전송 → 대상이 ICMP unreachable 응답 유도 → 자원 고갈  
- **Ping 플러딩**: ICMP Echo 요청을 과도하게 전송하여 대상 시스템의 응답 처리 자원 고갈  
- **Ping of Death**: 허용 크기 이상의 ICMP 패킷을 조각(fragment) 내어 전송, 재조합 시 시스템 다운 유도  
- **Teardrop Attack**: 오프셋 필드가 비정상인 조각화된 IP 패킷을 전송해 재조합 시 오류 발생 → 시스템 다운  
- **Land Attack**: 출발지와 목적지 IP 주소를 모두 피해자의 IP로 설정해 자기 자신에게 요청하게 함 → 시스템 장애

**정보보안의 3요소 (CIA Triad)**  
- **기밀성(Confidentiality)**: 인가되지 않은 사용자가 정보를 보지 못하도록 보호 (예: 암호화)  
- **무결성(Integrity)**: 인가되지 않은 변경을 방지, 변경 여부를 확인 가능해야 함 (예: 해시, MAC)  
- **가용성(Availability)**: 인가된 사용자가 원하는 때에 서비스나 자원에 접근 가능해야 함 (예: 백업, 이중화 등)

※ 고가용성(High Availability): 장애 발생 시에도 서비스를 지속적으로 유지할 수 있도록 설계된 시스템 구조. 
-----------------------------------------------------------------------------------

## 문제 2) 다음 설명에 해당하는 기술이 무엇인가

사설 네트워크(Private Network)를 외부 인터넷 환경과 분리하여, 안전하게 데이터를 주고 받기 위해  
터널링(Tunneling)을 활용하는 기술이 있다. 이 기술은 IPsec 등 다양한 암호화 프로토콜을 사용해  
데이터 기밀성과 무결성을 보장하며, 기업이나 조직에서는 원격지 사용자들도 내부 네트워크에 안전하게  
접속할 수 있도록 이를 자주 이용한다.

**답:** VPN

**해설:**  
IP 관련 기타 기술

- **NAT (Network Address Translation)**  
  사설 IP 주소와 공인 IP 주소 간의 변환  
  - Static NAT: 하나의 내부 IP ↔ 하나의 외부 IP  
  - Dynamic NAT: 여러 내부 IP ↔ 여러 외부 IP 중 일부  
  - PAT(Port Address Translation): 하나의 공인 IP에 여러 사설 IP를 포트 번호로 구분하여 매핑

- **DNS (Domain Name System)**  
  도메인 이름을 IP 주소로 변환하거나 그 반대의 작업을 수행

- **QoS (Quality of Service)**  
  네트워크 자원을 효율적으로 사용하여 특정 트래픽의 성능과 속도를 보장하는 기술

- **VPN (Virtual Private Network)**  
  공용 네트워크를 통해 사설 네트워크에 안전하게 접속할 수 있게 하는 기술

- **DHCP (Dynamic Host Configuration Protocol)**  
  네트워크 장치에 자동으로 IP 주소를 할당하는 프로토콜

📌 관련 개념 설명:

**VPN (Virtual Private Network)**  
- VPN은 **공용 네트워크(인터넷)**를 이용해 **사설 네트워크에 안전하게 접속**할 수 있도록 해주는 기술이다.  
- **터널링(Tunneling)**: 내부 데이터를 캡슐화(encapsulation)하여 안전하게 외부망을 통과시킴  
- **암호화 프로토콜**: IPsec, SSL/TLS, PPTP, L2TP 등이 사용되며, 데이터의 **기밀성과 무결성**을 보장  
- **사용 예시**:  
  - 재택근무자들이 회사 내부망에 접속  
  - 지사와 본사를 연결  
  - 공공 와이파이에서 안전하게 인터넷 사용

**기타 정리:**

- **NAT**는 사설망에서 공인망과 통신할 수 있게 해주며, 주소 부족 문제 해결에도 기여  
- **QoS**는 실시간 트래픽(VoIP, 스트리밍 등)에 우선순위를 부여하여 품질 보장  
- **DHCP**는 IP 주소를 자동 할당하여 관리 편의성을 높임  
- **DNS**는 사람이 읽기 쉬운 도메인과 기계가 사용하는 IP 주소 간 변환 담당  

-----------------------------------------------------------------------------------
--
## 문제 3) 객체 간의 협력과 상호작용을 설계하는 패턴들의 묶음을 무엇이라 하는지 패턴 그룹의 명칭을 작성해라

소프트웨어 디자인 패턴은 크게 생성패턴(Creational Pattern), 구조패턴(Structural Pattern),  
그리고 특정 패턴 그룹으로 구분된다.  
이 특정 패턴 그룹은 객체나 클래스가 서로 상호작용하는 방식에 초점을 맞추며  
클래스 간의 책임 분배나 알고리즘 변화에 유연하게 대응할 수 있도록 설계 방안을 제시한다.  
이 그룹에는 옵서버(Observer), 상태(State), 전략(Strategy) 등과 같은 대표적인 패턴들이 포함된다.

**답:** 행위 패턴

**해설:**  
소프트웨어 디자인 패턴 중에서 객체 간의 상호작용과 협력을 설계하는 데 초점을 맞춘 패턴 그룹이다.  
대표적인 패턴으로는 옵서버, 상태, 전략, 템플릿 메소드, 커맨드 등이 있다.

📌 관련 개념 설명:

**디자인 패턴(Design Pattern)**  
소프트웨어 설계 시 자주 발생하는 문제에 대한 **재사용 가능한 해결책**을 의미한다.  
디자인 패턴은 크게 3가지 그룹으로 나뉜다:

1. **생성 패턴 (Creational Patterns)**  
   - 객체 생성 방식을 추상화하여 시스템이 객체를 생성, 구성하는 방식을 유연하게 변경 가능하게 함  
   - 예: **Singleton, Factory Method, Abstract Factory, Builder, Prototype**

2. **구조 패턴 (Structural Patterns)**  
   - 클래스나 객체를 조합하여 더 큰 구조를 만드는 데 초점  
   - 예: **Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy**

3. **행위 패턴 (Behavioral Patterns)**  
   - 객체나 클래스 간의 **책임 분배**와 **상호작용** 방식에 초점  
   - 알고리즘을 캡슐화하거나 객체 간 통신을 유연하게 함  
   - 예:  
     - **Observer**: 한 객체의 상태 변화 시 종속 객체들에 자동 통지  
     - **State**: 객체 상태에 따라 행동을 바꾸는 패턴  
     - **Strategy**: 알고리즘을 캡슐화하여 런타임에 교체 가능  
     - **Command**, **Template Method**, **Mediator**, **Chain of Responsibility** 등

※ 디자인 패턴은 유지보수성과 재사용성을 높이고, 코드 구조를 명확하게 해준다.

-----------------------------------------------------------------------------------

## 문제 4) 다음에서 설명하는 세 가지 대표적인 커버리지를 1, 2, 3 순서대로 각각 한글로 작성하시오

소프트웨어 테스트에서 코드의 검증 범위를 정량적으로 평가하는 '테스트 커버리지(Test Coverage)' 기법에는 여러 유형이 있다.  
예를 들어, 코드 상의 모든 문장이 최소 한 번 이상 실행되는지를 검사하는 (1),  
if나 switch 같은 분기문이 각각 정상적으로 수행되는지 확인하는 (2),  
그리고 각 조건식이 참/거짓으로 조합되도록 확인하는 (3) 커버리지가 대표적이다.

**답:**  
1) 구문 커버리지  
2) 분기 커버리지 / 결정 커버리지  
3) 조건 커버리지

**해설:**  
- 테스트 커버리지는 테스트가 소스코드를 얼마나 수행(실행)했는지를 측정하는 지표이다.  
- 각 커버리지의 의미에 따라 구문 → 분기(결정) → 조건 순으로 분류할 수 있다.

📌 관련 개념 설명:

**테스트 커버리지(Test Coverage)**  
- **정량적으로** 테스트가 코드의 어느 정도를 실행했는지를 평가하는 지표  
- 높은 커버리지가 반드시 결함 없음은 아니지만, **테스트의 충실도**를 판단하는 기준

### 1. **구문 커버리지 (Statement Coverage)**  
- 소스코드의 **모든 구문(라인)**이 **최소 1번 이상 실행**되었는지를 측정  
- 가장 기본적인 커버리지  
- 예: if문 안에 있는 문장이 실행되었는가?

### 2. **분기 커버리지 / 결정 커버리지 (Branch/Decision Coverage)**  
- if, switch 등 **모든 분기점(branch point)**의 **참/거짓(True/False)** 결과가 **모두 실행**되었는지를 확인  
- 모든 경로를 따라가지는 않지만, **조건문마다 양쪽 흐름을 모두 타는지 확인**  
- 결정 커버리지라는 용어도 함께 사용됨

### 3. **조건 커버리지 (Condition Coverage)**  
- **복합 조건식 안의 각 개별 조건**이 **참과 거짓**으로 한 번씩 수행되었는지를 확인  
- 예: `if (A && B)`라면 A가 T/F, B가 T/F 모두 한 번씩 실행되는지 확인  
- 모든 조합은 아니며, 각 **조건식의 독립적 평가**에 초점

---

### ✅ 그 외 커버리지 종류 요약:

| 커버리지 유형              | 설명 |
|---------------------------|------|
| 조건/결정 커버리지 (C/D)     | 조건 커버리지 + 결정 커버리지의 결합 |
| 변경 조건/결정 커버리지 (MC/DC) | 결정 포인트 내 개별 조건이 결과에 **독립적으로 영향**을 주는지 검증 |
| 다중 조건 커버리지         | 조건의 **모든 조합**을 100% 테스트 |
| 경로 커버리지 (Path Coverage) | 가능한 모든 경로를 테스트 |

※ 실무에서는 **구문 + 분기 커버리지**를 기본으로 하며, **조건/결정 커버리지**나 **MC/DC**는 고신뢰성 시스템(항공, 의료 등)에서 사용됨

-------------------------------------------------------------------------------------------------------------------------------------------

## 문제 5) 관계형 데이터베이스(Relational Database)에서 테이블을 설계할 때, 아래와 같은 역할을 하는 네 가지 키가 있다.

1) 한 테이블의 특정 속성이 다른 테이블(또는 동일 테이블)의 튜플을 참조함으로써, 테이블 간의 연관관계와 무결성을 유지하기 위한 키  
2) 릴레이션에서 각 튜플을 고유하게 식별하며, 속성의 집합이 최소로 구성되어 있는 키  
3) 위 2번 키가 여러 개 존재할 경우 그중 기본키로 선정되지 않은 키  
4) 릴레이션에서 모든 튜플을 유일하게 식별할 수 있는 속성들의 부분집합(적어도 하나 이상의 2번 키를 포함)으로 구성된 키  

**답:**  
1) 참조키 = 외래키  
2) 후보키  
3) 대체키  
4) 슈퍼키

**해설:**  
관계형 데이터베이스에서 테이블 간의 무결성과 식별성을 유지하기 위해 다양한 키를 활용한다.  
- 외래키는 다른 테이블과의 관계를 유지  
- 후보키는 유일성을 가지는 키 후보들  
- 그중 선택된 것이 기본키이며, 선택되지 않은 것은 대체키  
- 슈퍼키는 후보키를 포함한 넓은 개념

📌 관련 개념 설명:

### ✅ 키(Key)의 종류

| 키 종류     | 설명 |
|------------|------|
| **슈퍼키(Super Key)** | 튜플을 유일하게 식별할 수 있는 속성들의 집합. 중복 가능. (예: 학번, 주민번호 등 포함 모두 가능) |
| **후보키(Candidate Key)** | 슈퍼키 중에서 **중복 속성이 제거된 최소 키**. 한 테이블에 여러 개 존재 가능 |
| **기본키(Primary Key)** | 후보키 중에서 **하나를 선정한 키**. 중복·NULL 불허 |
| **대체키(Alternate Key)** | 후보키 중에서 **기본키로 선택되지 않은 나머지 키들** |
| **외래키(Foreign Key)** | 다른 테이블의 기본키를 참조. 테이블 간 관계를 표현. 참조 무결성 제약조건 적용 대상 |

---

### ✅ 데이터베이스 설계 단계

1. **개념 설계**  
   - 사용자의 요구사항을 바탕으로 **ER 다이어그램** 등 개념 모델로 설계  
   - "머릿속에 있는 것을 끄집어내는 단계"

2. **논리 설계**  
   - 특정 DBMS에 독립적인 **논리적 구조 설계**  
   - 릴레이션 스키마로 표현됨

3. **물리 설계**  
   - 실제 DBMS에 맞게 구현, **정규화/비정규화**, **인덱스 설계** 등 수행

---

### ✅ 정규화(Normalization)

| 정규형 | 핵심 개념 |
|--------|------------|
| **1정규형 (1NF)** | 도메인이 원자값으로 구성 (반복 속성 제거) |
| **2정규형 (2NF)** | 부분 함수 종속 제거 (기본키의 일부분에만 종속된 속성 제거) |
| **3정규형 (3NF)** | 이행 함수 종속 제거 (비키 속성이 다른 비키 속성에 종속된 경우 제거) |
| **BCNF** | 결정자가 후보키가 아닌 경우 제거 |
| **4정규형 (4NF)** | 다치 종속 제거 |
| **5정규형 (5NF)** | 조인 종속 제거 |

---

### ✅ 트랜잭션의 4가지 특성 (ACID)

| 요소 | 설명 |
|------|------|
| **원자성 (Atomicity)** | 모든 작업은 전부 수행되거나 전혀 수행되지 않아야 함 |
| **일관성 (Consistency)** | 트랜잭션 실행 전과 후의 데이터베이스 상태가 일관됨 |
| **독립성 (Isolation)** | 동시에 수행되는 트랜잭션 간의 간섭을 방지 |
| **영속성 (Durability)** | 성공적으로 완료된 트랜잭션의 결과는 영구히 보존됨 |

※ 트랜잭션은 데이터베이스에서 무결성과 안정성을 보장하는 핵심 단위임
-----------------------------------------------------------------------------------

## 문제 6) URL은 크게 아래와 같은 5가지 구성 요소로 이루어진다.  
다음 각각 요소(5가지)를 URL에서 나타나는 순서에 맞게 적으시오.

1) query: 서버에 전달할 추가 데이터  
2) path: 서버 내 특정 자원을 가리키는 경로  
3) scheme: 리소스에 접근하는 방법이나 프로토콜  
4) authority: 사용자 정보, 호스트명, 포트번호  
5) fragment: 특정 문서 내의 위치  

예시 URL:  
https://user:pass@exam.com:8080/products/items?id=123&s=asc#specs  

답: 4-3-1-2-5

**GPT답:** 3 - 4 - 2 - 1 - 5

**해설:**  
URL은 인터넷 리소스를 가리키는 통합 자원 식별자이며, 다음과 같은 요소로 구성된다.  
문제에 제시된 순서는 의미별 설명 순서이고, 실제 URL에서의 **출현 순서 기준으로 정답은 3-4-2-1-5**이다.

📌 관련 개념 설명:

### ✅ URL(Uniform Resource Locator) 구성 요소 설명 및 순서

https://user:pass@exam.com:8080/products/items?id=123&s=asc#specs
 \___/  \___________________________/ \_________/ \__________/ \___/
  (1)            (2)                     (3)         (4)       (5)
scheme        authority                 path       query    fragment



답: 4-3-1-2-5
-----------------------------------------------------------------------------------

## 문제 7) 아래 사례에서 '학번'을 기본키로 지정했을 때  
null값과 중복값을 모두 허용하지 않도록 하는 무결성 제약 조건은 무엇인지 쓰시오

어느 대학의 "학생" 테이블에서 '학번'을 기본키(Primary Key)로 지정하려고 한다.  
이때 데이터베이스가 자동으로 다음을 강제하도록 설정하였다.  

1. 학번에 NULL 값을 입력할 수 없다.  
2. 이미 존재하는 학번과 중복된 값을 입력할 수 없다.  

이로써 테이블에 유효하지 않은 학번 정보가 저장되는 일을 막아  
데이터가 정확하게 관리되도록 하였다.

**답:** 개체 무결성 제약조건

**해설:**  
기본키로 지정된 '학번'은 테이블의 각 튜플을 유일하게 식별하는 역할을 하며,  
데이터베이스는 기본키 제약을 통해 자동으로 **NULL 금지** 및 **중복 금지** 규칙을 적용한다.  
이러한 특성은 개체 무결성(Entity Integrity)에 해당한다.

📌 관련 개념 설명:

### ✅ 무결성 제약조건 (Integrity Constraints)

관계형 데이터베이스에서 **데이터의 정확성, 일관성**을 보장하기 위해 제약 조건을 설정한다.  
주요 무결성 제약조건은 다음과 같다:

| 제약조건 종류       | 설명 |
|--------------------|------|
| **개체 무결성(Entity Integrity)** | 기본키(Primary Key)는 **반드시 NOT NULL이며 유일(unique)**해야 함.  
→ 테이블의 각 튜플(행)을 식별하기 위한 핵심 규칙.  
| **참조 무결성(Referential Integrity)** | 외래키(Foreign Key)는 참조하는 기본키가 **존재해야 함**.  
→ 부모 테이블의 값이 삭제되거나 존재하지 않으면 오류 발생  
| **도메인 무결성(Domain Integrity)** | 속성 값이 정의된 **데이터 타입, 범위, 형식**을 벗어나지 않도록 제한  
→ 예: 점수는 0~100 사이만 허용  
| **사용자 정의 무결성(User-defined)** | 업무 규칙에 따라 사용자가 직접 정의한 제약조건  
→ 예: 급여는 최소 200만원 이상이어야 함 등  

---

### ✅ 개체 무결성과 기본키 제약 조건

- **기본키는 자동으로 개체 무결성을 만족해야 함**
  - **NULL 불허**
  - **중복 불허**
- 예시:
```sql
CREATE TABLE 학생 (
  학번 CHAR(10) PRIMARY KEY,
  이름 VARCHAR(20)
);
-------------------------------------------------------------------------------------------------------------------------------------------
## 문제 8) 중앙 집중적 기반 시설 없이 각 무선 단말기들이 직접 연결되어 임시 통신망을 형성하고,  
군사작전이나 긴급의료 등의 응용 분야에서 활용되는 이 네트워크 방식을 무엇이라 하는지 쓰시오

군사작전 지역이나 긴급 의료 상황 등 기반 시설이 파괴되거나 부재한 환경에서는  
빠르게 통신망을 구축하는 것이 매우 중요하다. 이를 위해 무선 단말기들이 중앙 집중식 기지국 없이  
서로 직접 연결하여 통신할 수 있는 네트워크 기술이 종종 활용된다. 이 방식은 기기간 자율적인  
경로 설정과 유지가 가능하여, 재난 구조 활동이나 전장 같은 이동성이 높은 환경에서도  
효과적으로 사용될 수 있다.

**답:** 애드혹 네트워크 (ad-hoc network)

**해설:**  
애드혹 네트워크는 **중앙 통제 장치나 고정된 인프라 없이**  
무선 단말기들이 **스스로 연결하여 구성하는 자율적인 통신망**이다.  
빠른 배치와 유연한 구성으로 인해 군사 작전, 재난 구조, 원격 의료 등 **비상상황**에서 활용도가 높다.

📌 관련 개념 설명:

### ✅ 애드혹 네트워크 (Ad-hoc Network)

| 항목 | 설명 |
|------|------|
| 정의 | 중앙 집중 장비(Access Point, 라우터 등) 없이, **단말기들끼리 직접 통신**하여 네트워크를 형성하는 방식 |
| 특징 | - **자율적**으로 라우팅 경로 설정  
        - **빠른 구축 가능**  
        - **동적인 토폴로지** (노드가 이동해도 통신 유지)  
        - 인프라 부재 환경에서도 **네트워크 유지** 가능 |
| 활용 분야 | - **군사 작전** (기지국 없는 환경)  
            - **재난 구조** (기반망 파괴 시)  
            - **응급 의료 통신망**  
            - 차량 간 통신 (VANET), 센서 네트워크(MANET) 등 |

---

### ✅ 관련 용어 비교

| 용어             | 설명 |
|------------------|------|
| **기반 구조 네트워크 (Infrastructure Network)** | Access Point(중앙 장비)를 중심으로 구성된 일반적인 무선 네트워크 (예: Wi-Fi) |
| **애드혹 네트워크 (Ad-hoc Network)** | AP 없이 단말기끼리 직접 연결하여 구성. 유연성 ↑, 확장성 ↑ |
| **MANET (Mobile Ad-hoc Network)** | 노드들이 **이동성이 큰 애드혹 네트워크**. 이동하면서도 통신 유지 |
| **VANET (Vehicular Ad-hoc Network)** | 차량 간의 통신에 특화된 애드혹 네트워크 |

---

※ 애드혹 네트워크는 빠르게 구축되며, **기존 통신 인프라가 없거나 사용할 수 없는 상황**에서 효과적인 해결책이 된다.

-----------------------------------------------------------------------------------
## 문제 9) UML을 보고 알맞는 관계를 선택하여 작성하시오

```
                차
         /      |      ＼
1) 타이어 바퀴 엔진

                차
         ↗       ↑       ↖
2) 버스   택시   승용차

3) 텔레비전 ---> 리모콘
```

**답:**  
1) 연관 관계  
2) 일반화 관계  
3) 의존 관계

**해설:**  
- 1) 타이어, 바퀴, 엔진은 차와 구성 요소로서 **연관 관계**에 해당한다.  
- 2) 버스, 택시, 승용차는 차를 상속하는 **일반화 관계**이다.  
- 3) 텔레비전은 리모콘 기능을 사용하는 **의존 관계**이다.

📌 관련 개념 설명:

### UML 관계 종류

| 관계 유형       | 설명                                         | UML 표현                  |
|----------------|----------------------------------------------|-------------------
| 일반화(Generalization) | 상위 클래스 속성과 메서드를 하위 클래스가 상속 | 실선 + 빈 삼각형            |
| 연관(Association)     | 클래스 간의 구조적 연결 관계                  | 실선                       |
| 의존(Dependency)      | 한 클래스가 다른 클래스 기능을 일시적으로 사용 | 점선 + 화살표               |
| 실체화(Realization)   | 클래스가 인터페이스를 구현                   | 점선 + 빈 삼각형            |
| 집약(Aggregation)     | 독립적 생명주기를 가진 포함 관계             | 실선 + 빈 마름모            |
| 합성(Composition)     | 생명주기를 공유하는 강한 포함 관계           | 실선 + 채워진 마름모         |
```

-----------------------------------------------------------------------------------

## 문제 11) LRU 알고리즘을 적용했을 때 발생하는 페이지 부재(페이지 폴트) 횟수를 구하시오  
(단, 할당된 프레임의 수는 3개이다)

**페이지 참조 순서:**  
7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1  

**프레임 상태 변화 및 폴트 여부:**  
```
Step:     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
Input:    7  0  1  2  0  3  0  4  2  3  0  3  2  1  2  0  1  7  0  1
Frame1:   7  7  7  2  2  2  2  4  4  4  0  0  1  1  1  1  1  1  1  1
Frame2:      0  0  0  0  0  0  0  0  3  3  3  3  3  0  0  0  0  0  0
Frame3:         1  1  1  3  3  3  2  2  2  2  2  2  2  2  7  7  1
Fault?:   O  O  O  O  X  O  X  O  O  O  O  X  O  X  O  X  O  X  X
```

**답:** 12회

---

### 📌 해설

- **LRU (Least Recently Used)** 알고리즘은 **가장 오래전에 사용된 페이지를 교체**하는 방식입니다.
- 총 3개의 프레임이 있고, 각 페이지 참조가 일어날 때 다음과 같은 규칙으로 처리합니다:
  - **페이지가 프레임 안에 없으면 → 페이지 폴트 발생 + 교체**
  - **페이지가 이미 있으면 → 최근 사용으로 시간 갱신 (폴트 아님)**

→ 위의 표에서 `O`가 있는 경우가 **페이지 폴트**입니다. 총 12회 발생했습니다.

---

### 📌 관련 개념 정리

#### ✅ 페이지 교체 알고리즘

| 알고리즘 | 설명 |
|----------|------|
| **FIFO** (선입선출) | 먼저 들어온 페이지를 먼저 내보냄 |
| **OPT** (최적) | 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 (이론적 최적) |
| **LRU** (최근접 사용) | 가장 오래 전에 참조된 페이지를 교체 |
| **LFU** (최소 사용) | 사용 빈도가 가장 적은 페이지를 교체 |
| **NUR** (Not Used Recently) | 최근에 사용되지 않은 페이지를 우선 교체 |
| **SCR (Second Chance)** | FIFO + 사용 비트가 1이면 한 번 기회를 더 주는 방식 |

#### ✅ 프로세스 스케줄링 알고리즘

**선점형 (Preemptive)**  
- Round Robin (시간 할당 기반)  
- SRT (Shortest Remaining Time)  
- MLQ (Multilevel Queue)  
- MLFQ (Multilevel Feedback Queue)

**비선점형 (Non-preemptive)**  
- FCFS (First Come First Serve)  
- SJF (Shortest Job First)  
- HRN (Highest Response-ratio Next) → (대기시간 + 실행시간) / 실행시간  
- 우선순위 기반 스케줄링  
- 기한부 스케줄링

**관련 개념**  
- **에이징 (Aging)**: 낮은 우선순위 프로세스가 기아 상태에 빠지지 않도록 우선순위를 점진적으로 높이는 기법  
- **기아 (Starvation)**: 우선순위가 낮아 실행되지 못하는 현상 (SRT, MLQ, SJF, 기한부 등에서 발생 가능)
-----------------------------------------------------------------------------------
# 📘 정보처리기사 실기 정리 - 문제 11

---

## 문제 11

**문제**  
SQL 명령어에 맞는 출력 결과를 작성하시오.

### [employee] 테이블

| no | name   | p_id |
|----|--------|------|
| 1  | 이흥직 | 10   |
| 2  | 이창훈 | 20   |
| 3  | 이경직 | 10   |

### [project] 테이블

| p_id | name      |
|------|-----------|
| 10   | CJOne     |
| 20   | Asiana    |
| 30   | SignsSEA  |

### SQL 명령문

```sql
SELECT 
  count(*)
FROM employee e 
INNER JOIN project p
  ON e.p_id = p.p_id
WHERE p.name IN (
  SELECT name FROM project p 
  WHERE p.p_id IN (
    SELECT p_id FROM employee
    GROUP BY p_id
    HAVING count(*) < 2
  )
)

답: 1


SELECT p_id FROM employee GROUP BY p_id HAVING count(*) < 2
→ p_id = 10은 2명, p_id = 20은 1명 → 20만 조건 만족

SELECT name FROM project WHERE p_id IN (20)
→ p_id = 20 → 'Asiana'

메인 쿼리에서 p.name IN ('Asiana')
→ 즉, employee와 project를 JOIN한 후 project.name이 'Asiana'인 경우만 필터링

employee 테이블에서 p_id = 20인 사람은 이창훈 한 명 → 결과: 1명


---

## 문제 12  
자바 for 문

---

## 문제 13  
자바 for 문, 배열

---

## 문제 14  
파이썬, for문, 배열, 범위 구하기

---

## 문제 15  
C언어, for문, 정적변수

---

## 문제 16  
파이썬 출력 결과  
※ 자료형 요약  
- `[]`: 리스트  
- `()`: 튜플  
- `{}`: 셋  
- `{key: value}`: 딕셔너리  

---

## 문제 17  
C언어 코드, 구조체

---

## 문제 18  
C언어, 더블 포인터

---

## 문제 19  
자바 - try, catch, finally

---

## 문제 20  
자바 - 제네릭



 
