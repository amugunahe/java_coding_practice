# 문제 1

**문제**  
일정한 주기를 가지고 계속 검토해 나가며 필요할 때마다 요구사항을 더하고 수정하여 커다랗게 살을 붙이면서 개발해 나가는 프로세스 모델 방식이다.  
미리 정해진 몇 개의 단계에 따라 엄격한 순서대로 이루어지는 일직선의 과정인 폭포수의 프로세스와는 비교가 많이 되는 반대의 개념이다.  
이 소프트웨어 개발 방법론을 쓰시오.

**답**  
애자일

---

## 🌐 생명주기 모형의 종류  

### 🪜 폭포수 모형 (Waterfall Model)
- 야 이새끼는 그냥 FM이다.
- **계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수**  
- 한 번 내려가면 다시 못 올라감.  
- 융통성 개씹창. 유턴 없음.

---

### 🧪 프로토타입 모형 (Prototype Model)
- 시발, 개발 다 해놓고 맘에 안 든다고 지랄할까봐  
- **미리 견본(샘플)을 만들어서 보여주는 방식**  
- "이거 어떠냐?" 하고 고객 반응 확인하는 거지  
- 고객 피드백 받아서 제대로 다시 개발

---

### 🌀 나선형 모형 (Spiral Model)
- 위험 관리에 존나게 신경 쓰는 새끼다  
- **계획 → 위험 분석 → 개발 → 고객 평가** 반복  
- 위험 줄이는데 특화됨  
- 이거 계속 빙글빙글 돌아감 (나선형)

---

### ⚡ 애자일 방법론 (Agile)
- 오늘의 주인공!  
- 유연하고 존나게 빠른 개발 방식  
- **고객이랑 소통 오지게 하면서**,  
- 짧게 짧게 **반복(Iteration)** 하면서 점점 살 붙여간다  
- "일단 만들고 고쳐나간다!" 마인드

---

## 🎯 애자일 대표 방식들

### ✅ XP (익스트림 프로그래밍, eXtreme Programming)
- 애자일 대장 중 하나  
- 2주 간격으로 존나 짧게 반복 개발  
- **고객이랑 맨날 붙어서 피드백 받고, 테스트 존나 중요시**  
- 코드 단순하게! 리팩토링 자주!

### ✅ 스크럼 (Scrum)
- 이것도 애자일 대장  
- **30일마다 돌아가는 스프린트(Sprint)**라는 개발 주기 사용  
- **매일 아침 15분 데일리 스크럼 회의**  
  - 어제 뭐했냐  
  - 오늘 뭐할거냐  
  - 막힌 거 있냐  
- 진짜 빠르게 공유하면서 민첩하게 달림

### ✅ FDD (Feature Driven Development, 특징 주도 개발)
- 기능(Feature) 중심으로 개발  
- **2주 반복 개발**  
- "기능 단위로 쪼개서, 하나씩 집중적으로 개발하자"는 철학

---

## 🧠 요약

| 모형       | 특징 요약                                       |
|------------|--------------------------------------------------|
| 폭포수     | FM, 되돌아가기 힘듦, 단계적, 고정된 절차          |
| 프로토타입 | 샘플 먼저 보여주고 고객 피드백 반영               |
| 나선형     | 위험 분석 최우선, 반복 개발, 위험 관리 특화       |
| 애자일     | 빠르게 만들고 고쳐나감, 고객 소통 최우선         |
| XP         | 피드백 빠르게, 테스트 강조, 짧은 반복 주기        |
| 스크럼     | 스프린트 단위 개발, 매일 짧은 회의로 진도 체크    |
| FDD        | 기능 단위로 쪼개서 반복 개발                      |


-----------------------------------------------------------------------------------
# 문제 2

**문제**  
데이터베이스 설계의 순서이다. 빈칸에 해당하는 설계 순서를 쓰시오.  
요구사항 분석 → ( ) → ( ) → ( ) → 구현

**답**  
개념적 설계 → 논리적 설계 → 물리적 설계

---
# 🔧 DB 설계 단계 요약 (개념 존나 쉽게)

## 1️⃣ 개념적 설계  
> **뭘 만들 건지? 그림부터 그려!**

- 현실 세계를 **ERD(엔터티-관계 다이어그램)**로 표현  
- "학생이 수강한다", "회원이 주문한다" 같은 관계를 눈에 보이게 그림  
- 개체(Entity), 속성(Attribute), 관계(Relationship)를 정의

📌 예:  
- 개체: 학생, 과목, 교수  
- 관계: 수강, 지도

---

## 2️⃣ 논리적 설계  
> **그림 → 설계도 (DBMS에 맞게 변환)**

- 위에서 그린 ERD를 바탕으로 **테이블 구조로 바꿈**  
- 사용하는 DBMS(MySQL, Oracle 등)에 맞춰서 설계  
- **정규화**로 데이터 중복 제거 & 구조 정리  
- T/I 설계: 테이블(Table), 인덱스(Index) 어떻게 만들지 정함

📌 예:  
- 학생 테이블: 학번, 이름, 학년  
- 인덱스: 자주 검색되는 학번 컬럼에 인덱스 추가

---

## 3️⃣ 물리적 설계  
> **실제로 빠르게 잘 돌아가게 하자**

- **성능 튜닝** 고려: 인덱스, 파티션, 클러스터링 등  
- **View** 만들고, **반정규화**(필요할 땐 중복 허용)로 속도 빠르게  
- 저장 구조, 접근 경로 최적화해서 **빨라지고 튼튼하게**

📌 예:  
- 사용자 많은 테이블 파티션 나누기  
- View 만들어서 자주 보는 결과 미리 보여주기  
- JOIN 줄이려고 반정규화 (ex. 고객 주소를 주문 테이블에 중복 저장)

---

## 🧠 핵심 요약

| 단계       | 무슨 단계냐?                            | 핵심 키워드                           |
|------------|------------------------------------------|----------------------------------------|
| 개념적 설계 | 현실을 개념적으로 표현 (그림 그리기)     | ERD, 개체, 관계                       |
| 논리적 설계 | 설계도를 테이블로 구체화 (이론적 구조)   | 정규화, 테이블 구조, 인덱스           |
| 물리적 설계 | 성능 좋게 실제로 만들기 (최적화)         | 인덱스, 파티션, View, 반정규화        |

-----------------------------------------------------------------------------------


# 문제 3

**문제**  
일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다.  
( ) 은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 되는데, ( )에는 몇 가지 형태의 메시지 패턴이 있지만, 
보통의 경우 원격 프로시저 호출(RPC) 패턴으로 네트워크 노드(클라이언트)에서 다른 쪽 노드(서버)로 메시지를 요청하고, 서버는 메시지를 즉시 응답하게 되는 형식이다.  
즉 ( )는 XML을 이용해서 분산처리 환경에서 정보교환을 쉽게 할 수 있도록 도와준다.

**답**  
SOAP

---

## ✅ SOAP (Simple Object Access Protocol)  
> 📦 **"메시지를 주고받는 택배 기사"**

- **WSDL 설명서** 보고 어떤 메시지를 보내야 할지 파악함  
- **XML 형식**으로 데이터를 주고받음  
- 보통 **HTTP, SMTP** 같은 프로토콜 위에서 동작  
- 원격 프로시저 호출(RPC) 방식으로 서버에 요청 보내고 결과 받음

🧠 쉽게 말해:  
"어떤 함수를 어떻게 호출할지 알려주면, XML로 깔끔하게 싸서 보내주는 애"

---

## 📃 WSDL (Web Services Description Language)  
> 📑 **"웹서비스 설명서 (명세서)"**

- 이 웹서비스가 **무슨 기능을 하고, 어떻게 호출하고, 어떤 데이터를 쓰는지** 설명  
- SOAP가 이걸 참고해서 메시지를 보냄  
- XML 기반으로 되어 있음

🧠 쉽게 말해:  
"웹서비스 메뉴얼 — 어떻게 부를 건지, 무슨 데이터 줘야 되는지 다 적혀있음"

---

## 📚 UDDI (Universal Description, Discovery and Integration)  
> 🔍 **"웹서비스 도서관 or 주소록"**

- 웹서비스를 **등록하거나 찾을 수 있는 저장소**  
- 누가 어떤 웹서비스를 제공하는지 검색 가능  
- 기업 간 시스템 연동할 때 요긴함

🧠 쉽게 말해:  
"웹서비스가 어디 있는지 알려주는 도감. SOAP와 WSDL은 얘가 찾아줌"

---

## 🧠 핵심 요약

| 용어  | 한 줄 정리 |
|--------|-------------------------------|
| **SOAP** | 메시지 실어나르는 택배 기사 |
| **WSDL** | 서비스 메뉴얼 (기능, 사용법 설명) |
| **UDDI** | 웹서비스 도서관 (주소록, 검색소) |



-----------------------------------------------------------------------------------
# 문제 4

**문제**  
( )는 소프트웨어 변경사항을 체계적으로 추적하고 통제하는 것으로, ( )는 일반적인 단순 버전 관리 기반의 소프트웨어 운용을 좀 더 포괄적인 학술 분야의 형태로 넓히는 개념을 말한다.  
( )란 소프트웨어 소스코드 뿐만 아니라 개발 환경, 빌드 구조 등 전반적인 환경 내역에 대한 관리체계를 정의하고 있다.  
이를 지원하는 도구로 Git, SVN, CVS 등이 있다.

**답**  
형상관리, Software Configuration Management (SCM)

---

# 형상관리 (Configuration Management, SCM) 존나 쉽고 직관적으로 정리

---

## 형상관리 뭐냐?  
- 소프트웨어가 바뀔 때마다  
- 누가 언제 뭘 어떻게 바꿨는지 **꼼꼼하게 기록하고 관리하는 것**  
- 그냥 코드 버전만 관리하는 게 아니라,  
  개발 환경, 빌드 방법, 문서, 테스트까지 다 챙겨서  
- **"이거 언제든 원래대로 돌릴 수 있게 하고, 팀원들 작업 꼬이지 않게" 하는 것**

---

## 관련 개념 쉽게 설명

| 용어          | 쉽게 설명                                  |
|---------------|-------------------------------------------|
| **변경관리**   | 변경할 때마다 기록하고 승인 받아서 막무가내 변경 막음   |
| **버전관리**   | 파일 버전 저장 → 필요하면 이전 버전으로 돌릴 수 있음   |
| **형상관리**   | 코드 + 환경 + 문서 + 테스트 등 개발에 필요한 모든 것 관리 |

---

## 형상관리 절차 쉽게 이해하기

1. **형상 식별**  
   - "뭘 관리할 거야?" → 소프트웨어 구성 요소, 산출물 정함

2. **형상 통제**  
   - "바꿀 때 승인받아!" → 아무거나 막 바꾸지 못하게 통제

3. **형상 감사**  
   - "실제로 문서랑 똑같아?" → 관리하는 게 제대로 되어 있는지 확인

4. **형상 기록**  
   - "모든 변경 내역 기록" → 누가 언제 뭘 바꿨는지 언제든 확인 가능

---

## 버전관리 도구 종류 & 특징 (초간단)

| 방식               | 특징                                   | 누가 쓰면 좋음              |
|--------------------|--------------------------------------|----------------------------|
| **공유 폴더 방식**   | 파일 공유 폴더에 직접 저장, 단순함      | 혼자 하거나 작은 프로젝트   |
| **클라이언트/서버** | 중앙 서버에 저장, 팀원들이 통신해서 작업 | 팀 많고 큰 프로젝트         |
| **분산 저장소**     | 각자 PC에 전체 저장소 복제, 독립적 작업  | 인터넷 없어도 작업 가능, 유연 |

---

## 왜 형상관리가 존나 중요한가?

- 프로젝트가 커질수록 누가 뭘 바꿨는지 알기 어려움  
- 형상관리 없으면 실수하거나 꼬일 확률 급증  
- 잘 관리하면 문제 생겨도 쉽게 복구 가능  
- 빌드나 배포할 때 실수 줄이고 품질 유지 가능  
- 팀원들 간 협업 원활해짐

---

## 도구 고를 때 고려할 점 (초간단)

- 팀원이 몇 명인지? (작은 팀 vs 큰 팀)  
- 네트워크 환경은 어떤지? (항상 연결 가능 vs 가끔 끊김)  
- 기존에 쓰던 도구랑 호환되는지?  
- 배우기 쉽고, 커뮤니티(정보) 많은지?

--


-----------------------------------------------------------------------------------
# 문제 5

**문제**  
웹페이지 전체를 다시 로딩하지 않고도, 웹페이지의 일부만을 갱신할 수 있는 비동기 방식의 처리 기술 약어를 쓰시오.

**답**  
AJAX

---



---

## AJAX가 뭔지 한 줄로  
- **웹페이지 전체 새로고침 없이, 필요한 부분만 서버랑 통신해서 바로바로 바꾸는 기술**

---

## 왜 쓰냐?  
- 페이지 깜빡임 없이 빠르게 바뀌니까  
- 사용자한테 엄청 편하고 자연스러운 느낌 줌  
- 서버 부하도 줄여줌

---

## 어떻게 작동하냐?  
1. 자바스크립트가 서버에 “데이터 좀 줘!” 요청 보냄  
2. 서버가 필요한 데이터만 쏴줌  
3. 페이지 일부만 쓱 업데이트

---

## AJAX는 혼자 작동하는 게 아님  
- 자바스크립트 + DOM 조작 + 서버 요청( XMLHttpRequest ) + HTML/CSS 조합해서 동작함

---

-----------------------------------------------------------------------------------

# 문제 6

**문제**  
UI 설계 원칙 4가지 중 빈칸에 알맞은 용어를 쓰시오.  

- 직관성: 누구나 쉽게 이해하고 사용할 수 있어야 한다.  
- ( ) : 사용자의 목적을 정확하게 달성해야 한다.  
- 학습성: 누구나 쉽게 배우고 익힐 수 있어야 한다.  
- 유연성: 사용자의 요구를 최대한 수용하며, 오류를 최소화해야 한다.

**답**  
유효성


# UI 설계 원칙 아주 쉽고 딱 핵심만!

---

## 직관성 (Intuitiveness)  
- 별다른 공부 없이도 바로 이해하고 쓸 수 있어야 함.  
- ‘아~ 이거 이렇게 쓰는 거구나!’ 싶은 느낌.

## 유효성 (Validity)  
- UI가 사용자가 하려는 일을 제대로 할 수 있게 도와줘야 함.  
- 잘못된 기능이나 헛짓거리 안 하도록!

## 학습성 (Learnability)  
- 처음 써도 쉽게 배우고, 자꾸 쓰다 보면 더 빨리 익숙해져야 함.

## 유연성 (Flexibility)  
- 다양한 사용자 요구를 받아들이고, 실수해도 쉽게 고칠 수 있게 해야 함.

---

## 추가! 인터페이스 종류  
- **CLI (커맨드 라인 인터페이스)**: 키보드로 명령어 직접 쳐서 조작  
- **GUI (그래픽 사용자 인터페이스)**: 그림, 아이콘, 마우스 클릭 등 시각적이고 직관적인 조작


---

# 문제 7

**문제**  
프로그램을 실행시키지 않고, 소스코드에 대한 코딩 표준, 코딩 스타일, 복잡도, 보안 취약점, 잠재적인 결함을 찾는 테스트 활동은?

**답**  
정적분석, 정적테스트

# ✅ 테스트 유형별 분류

---

## 1️⃣ 단위 테스트 (Unit Testing)

- **정적 테스트**  
  - 프로그램 실행 없이, 코드만 보고 문제 있는지 확인  
  - 예: 코드 스타일, 보안 취약점 분석 등

- **동적 테스트**  
  - 프로그램을 실제로 실행해서 오류나 문제 찾음  
  - 예: 함수 단위로 실행하며 기대한 결과 나오는지 확인

---

## 2️⃣ 통합 테스트 (Integration Testing)

- **상향 테스트 (Bottom-up)**  
  - 하위 모듈부터 테스트 → 상위 모듈로 올라감  
  - 드라이버 사용

- **하향 테스트 (Top-down)**  
  - 상위 모듈부터 테스트 → 하위 모듈로 내려감  
  - 스텁 사용

- **빅뱅 테스트**  
  - 모든 모듈을 한꺼번에 붙여서 테스트  
  - 초기 오류 원인 찾기 어려움

---

## 3️⃣ 시스템 테스트 (System Testing)

- **기능 테스트**  
  - 기능이 제대로 작동하는지 확인 (ex. 버튼 누르면 동작함?)

- **비기능 테스트**  
  - 성능, 보안, 안정성 등 시스템의 ‘품질’ 측면 확인

---

## 4️⃣ 인수 테스트 (Acceptance Testing)

- **알파 테스트**  
  - 개발자 + 고객이 **함께** 테스트

- **베타 테스트**  
  - 실제 사용자들이 사용해보며 피드백  
  - 개발자는 관여 ❌

---

# 🧩 어플리케이션 테스트 분류표

| 기준               | 분류 내용 |
|--------------------|-----------|
| 프로그램 실행 여부 | ✅ 정적 테스트 / ✅ 동적 테스트 |
| 테스트 기법        | ✅ 화이트박스 테스트 / ✅ 블랙박스 테스트 |
| 테스트 관점        | ✅ 검증(Verification) / ✅ 확인(Validation) |
| 테스트 목적        | ✅ 회복 / 안전 / 강도 / 성능 / 구조 / 회귀 / 병행 테스트 등 |
| 테스트 기반        | ✅ 명세 기반 / ✅ 구조 기반 / ✅ 경험 기반 |

---

# 📌 추가 개념 설명

### 🔍 정적분석 (Static Analysis)
- 코드 실행 ❌  
- 코드만 분석해서 결함, 스타일 오류, 보안 이슈 확인  
- 예: SonarQube, FindBugs, PMD

### 🧪 동적분석 (Dynamic Analysis)
- 프로그램 실행하면서 기능/성능 확인  
- 예: JUnit으로 유닛 테스트

### 🔓 화이트박스 테스트
- 코드 **내부 구조**를 알고 테스트  
- 예: if문, 반복문 커버율 테스트

### 🎁 블랙박스 테스트
- 코드 **구조 몰라도** 입력-출력만 테스트  
- 예: 기능 요구사항 기반 테스트

### ✅ 검증 (Verification)
- **제대로 만들었는지** 확인  
- 설계 문서대로 잘 만들었는가?

### ✅ 확인 (Validation)
- **사용자 요구에 맞는지** 확인  
- 유저가 진짜 원하는 기능이 들어있는가?



-----------------------------------------------------------------------------------
# 문제 8

**문제**  
<학생> 테이블을 대상으로 <요구사항>을 적용하여 출력하는 SQL 문을 작성하시오.

**요구사항**  
3학년이거나 4학년 학생의 학번과 이름을 검색하시오.  
조건절 작성 시 IN 예약어를 사용하시오.

**<학생> 테이블 예시**  

| 학번   | 이름 | 학년 |
|--------|------|-------|
| 181101 | KKK  | 1     |
| 171201 | HHH  | 2     |
| 161107 | YYY  | 3     |
| 151403 | QQQ  | 4     |

**답안**  
```sql
SELECT 학번, 이름
FROM 학생
WHERE 학년 IN (3, 4);

------------------------------------------------------------------
# 문제 9] <student>테이블의 name 속성을 오름차순하여 idx_name를 인덱스명으로 하는 인덱스를 생성하는 SQL 명령문을 작성하시오

**답:**  
```sql
CREATE INDEX idx_name ON student(name ASC);

------------------------------------------------------------------

# 문제 10

**문제**  
보안의 취약점 중 하나인 SQL Injection(SQL 인젝션)에 대해 간략히 서술하시오.

## 🧨 SQL Injection (SQL 인젝션)

### ✅ 정의
- 웹 프로그램에 **악의적인 SQL 구문**을 넣어서  
  서버의 **데이터베이스를 조작하거나 털어가는** 공격

### 🎯 목적
- 사용자 정보 몰래 조회
- 비밀번호 없이 로그인 (인증 우회)
- 회원정보 수정, 삭제, 데이터 탈취

### 👾 존나 쉬운 예시
```sql
SELECT * FROM users WHERE id = '1' OR '1'='1';

원래는 "id가 1인 사용자만" 가져오려고 했는데

'1'='1'이 항상 참(True)이라서 → 모든 사용자 정보를 가져옴

🍜 비유:  
식당에 “홍길동 예약했어요” 라고 해야 예약 확인하는데  
"홍길동 또는 아무나 다 보여줘" 라고 말장난 치는 것 = SQL 인젝션

🛡️ 대응 방법  
입력값 검증: 사용자가 넣은 값을 필터링  

PreparedStatement 사용: SQL에 값을 미리 고정해놓고 변수만 바꿈  

ORM 사용 (JPA, MyBatis 등): SQL 자동 생성 도구로 인젝션 위험 낮춤

---

🐛 XSS (Cross-Site Scripting)  
✅ 정의  
웹 페이지에 **악성 스크립트(JavaScript)**를 몰래 심어서  
다른 사용자 브라우저에서 실행되게 하는 공격

🎯 목적  
쿠키/세션 탈취  

악성 사이트로 유도 (피싱)  

웹 화면 조작, 사용자 속이기

👾 존나 쉬운 예시  
```html
<script>alert('해킹당함');</script>

게시판 댓글에 이걸 써두면,
다른 사람이 그 댓글 보자마자 브라우저에서 알림 팝업 뜨고 쿠키 털림

🍜 비유:
게시판에 “안녕하세요” 쓰는 대신, 폭탄 단추 심어놓는 것

🛡️ 대응 방법
입력값을 HTML 이스케이프 처리 (< → <, > → >)

Content Security Policy (CSP) 설정해서 외부 JS 차단

신뢰 안 가는 스크립트는 무조건 막기

🔐 두 공격 비교 요약

| 항목     | SQL Injection               | XSS                             |
|----------|----------------------------|--------------------------------|
| 공격 대상 | 데이터베이스 (DB)            | 웹 사용자 브라우저               |
| 목적     | 인증 우회, DB 조작, 데이터 탈취 | 쿠키/세션 탈취, 피싱, 화면 조작    |
| 공격 방식 | SQL 구문 조작               | 악성 스크립트 삽입 (JavaScript 등) |
| 예시     | `' OR '1'='1`               | `<script>alert('해킹');</script>`  |
| 대응법   | 입력값 검증, PreparedStatement, ORM | HTML 이스케이프, CSP, 스크립트 차단 |

📌 핵심 요약 꿀팁  
- SQL 인젝션: "DB야! 이거 보여줘!"라고 속여서 DB 털기  
- XSS: "다른 사람 화면에 내 악성 코드를 실행시켜줘!"라고 브라우저 속이기  

🔥 SQL 인젝션 = 서버 털기  
🔥 XSS = 사용자 털기



------------------------------------------------------------------
# 문제 11] SQL 제어어(DCL) 중 ROLLBACK 명령에 대해 간략히 설명하시오

**답:**  
데이터베이스 내의 연산이 비정상적으로 종료되거나, 정상 수행이 되었더라도 이전 상태로 되돌리기 위한 명령어이다.  
즉, 트랜잭션 수행 중 오류 발생 시 **수행 전 상태로 복구**할 수 있도록 한다.

---

# 📘 SQL 명령어 & 트랜잭션 정리 (존나 쉽게, 직관적으로)

---

## ✅ SQL 명령어 종류

| 분류 | 풀네임 | 주요 명령어 | 하는 일 | 예시 느낌 |
|------|--------|-------------|---------|-----------|
| DDL | Data Definition Language | `CREATE`, `ALTER`, `DROP`, `TRUNCATE` | 테이블 구조 만들고 지우고 바꾸기 | 건물 뼈대 설계/철거 |
| DML | Data Manipulation Language | `SELECT`, `INSERT`, `UPDATE`, `DELETE` | 데이터 조회/입력/수정/삭제 | 안에 사람 들이고 빼고 바꾸기 |
| DCL | Data Control Language | `GRANT`, `REVOKE`, `COMMIT`, `ROLLBACK` | 권한 부여, 변경사항 저장 or 되돌리기 | 문 열쇠 주기/회수, 저장 버튼 누르기 |

---

## ✅ DCL 자주 쓰는 거 해석해줌

- `COMMIT` → 지금까지 한 거 **진짜 저장해!**
- `ROLLBACK` → **실수했으면 되돌려!**
- `GRANT` → **권한 줘!**
- `REVOKE` → **권한 뺏어!**

---

## 🔄 트랜잭션의 4가지 특성 (ACID)

| 특성 | 이름 | 의미 | 진짜 쉽게 말하면 |
|------|------|------|------------------|
| A | 원자성 (Atomicity) | 전부 성공 or 전부 실패 | 하나라도 실패하면 전부 취소! |
| C | 일관성 (Consistency) | DB 규칙은 지켜야 함 | 앞뒤 논리 맞아야 함 |
| I | 격리성 (Isolation) | 트랜잭션끼리 간섭 X | 동시에 작업해도 서로 영향 없음 |
| D | 영속성 (Durability) | 저장되면 영원히 보존 | `COMMIT` 하면 정전돼도 안 날아감 |

---

## ✅ 같이 외우면 좋은 포인트

- `DDL`은 트랜잭션 대상 아님 (바로 반영됨)
- `DML`은 트랜잭션 대상임 (`COMMIT`, `ROLLBACK` 가능)
- `DCL`은 권한, 저장 관련 명령


------------------------------------------------------------------

# 문제 12] 네트워크 계층(Network Layer, 3계층)에서 IP 패킷 단위의 데이터 변조 방지 및 암호화 기능을 제공하는 통신 규약을 쓰시오

**답:**  
IPSec

---

## 📌 관련 개념 정리

### ✅ OSI 7계층 요약

| 계층                   | 주요 기능                   | 예시            |
|------------------------|----------------------------|-----------------|
| 7. 응용(Application)     | 사용자 인터페이스, 이메일, 웹  | HTTP, FTP       |
| 6. 표현(Presentation)    | 데이터 표현, 암호화/복호화     | JPEG, ASCII     |
| 5. 세션(Session)         | 연결 관리, 동기화             | NetBIOS         |
| 4. 전송(Transport)       | 종단 간 신뢰성 있는 데이터 전송 | TCP, UDP        |
| 3. 네트워크(Network)     | 경로 선택, 주소 지정          | IP, ICMP        |
| 2. 데이터링크(Data Link) | 오류 검출, 프레임 전송        | MAC, 스위치     |
| 1. 물리(Physical)        | 비트 전송                   | 케이블, 허브    |

---

### ✅ IPSec (IP Security Protocol)

- **계층 위치:** 네트워크 계층 (3계층)  
- **기능:**  
  - IP 패킷 **암호화**  
  - 데이터 **기밀성, 무결성, 인증** 보장  
  - **종단 간 보안** 혹은 **게이트웨이 간 보안** 가능  

💡 **비유:**  
네트워크 위에서 우체국이 소포(패킷)를 보내는데,  
IPSec은 소포 겉면과 내용물을 모두 잠궈서 아무나 열어보지 못하게 하는 '금고' 같은 역할!

---

### IPSec 구성 프로토콜

| 구성 요소                  | 설명                                  |
|----------------------------|-------------------------------------|
| **AH (Authentication Header)**  | IP 패킷 무결성·인증 제공, 변조 방지          |
| **ESP (Encapsulating Security Payload)** | IP 페이로드 암호화로 기밀성 제공          |

---

### ✅ 비교: 보안 관련 프로토콜

| 프로토콜    | 사용 계층       | 특징                                   |
|-------------|-----------------|--------------------------------------|
| **IPSec**    | 네트워크 계층    | IP 패킷 단위 보안, VPN에서 많이 사용         |
| **SSL / TLS** | 전송 계층 위    | HTTPS, 웹 브라우저 보안 통신                    |
| **S-HTTP**   | 응용 계층       | HTTP에 보안 기능 추가 (덜 쓰임)                  |

💡 **쉽게 이해하기:**  
- **IPSec**: 네트워크 길에서 소포를 잠금  
- **SSL/TLS**: 편지 봉투를 잠궈서 안전하게 주고받기  
- **S-HTTP**: 편지 내용에 잠금장치 추가한 셈  

---

🎯 핵심 포인트  
- OSI 3계층인 네트워크 계층에서 작동하는 보안 프로토콜은 **IPSec**  
- SSL/TLS는 웹에서 안전하게 통신하려고 전송 계층 위에서 작동  
- IPSec은 VPN 같은 네트워크 통신 보안의 기본 중 기본임!

존나 쉽고 직관적이고 갓반인도 바로 이해 가능!

------------------------------------------------------------------

# 문제 13] 리눅스 커널을 기반으로 동작하며 자바와 코틀린 언어로 개발된 핸드폰이나 소형기기에 사용되는 오픈소스 플랫폼인 모바일 운영체제는 무엇인지 쓰시오

**답:**  
안드로이드

---

## 📌 관련 개념 정리

### ✅ 안드로이드(Android)

| 항목       | 설명                                                                 |
|------------|----------------------------------------------------------------------|
| 기반 커널   | **리눅스 커널**                                                      |
| 개발 언어   | **자바(Java)**, **코틀린(Kotlin)**                                 |
| 특징       | - 오픈소스 모바일 플랫폼  
              - 다양한 제조사에서 채택 (삼성, LG, 샤오미 등)  
              - Google Play 스토어를 통한 앱 배포                             |
| 구성 요소   | - 애플리케이션 프레임워크: 앱 개발을 쉽게 도와주는 다양한 API 제공  
              - 런타임 (ART): 앱 실행 시 자바 바이트코드를 네이티브 코드로 변환해서 빠르게 실행  
              - 리눅스 커널: 하드웨어 제어, 보안, 프로세스 관리 담당               |
| 사용 기기  | 스마트폰, 태블릿, 스마트워치, TV 등 다양한 스마트 디바이스              |

💡 **쉽게 이해하기**  
안드로이드는 **리눅스 커널** 위에 올라간 똑똑한 ‘모바일 운영체제’야.  
자바랑 코틀린으로 앱을 만들고, 이걸 **Google Play**라는 거대한 마트에서 팔지!  
삼성, LG 같은 회사들도 안드로이드를 가져다 자기 스마트폰에 넣어서 사용해.

📱 **비유**  
- 리눅스 커널은 땅(기초)  
- ART는 공장에서 원료(코드)를 빠르게 가공하는 기계  
- 애플리케이션 프레임워크는 다양한 공구들이 모여있는 작업대  
- 그리고 개발자는 이 작업대 위에서 앱이라는 멋진 제품을 만드는 장인

존나 쉽고 직관적이고 갓반인도 바로 이해 가능!

------------------------------------------------------------------


# 문제 14] 리눅스 또는 유닉스에서 a.txt 파일에 대해 다음 조건을 만족하는 권한을 부여하고자 한다. 다음 조건을 준수하여 적합한 명령어를 작성하시오.

## <조건>
- 사용자(Owner): 읽기(r), 쓰기(w), 실행(x) → **모두 부여**
- 그룹(Group): 읽기(r), 실행(x) → **쓰기 권한 없음**
- 기타 사용자(Others): 실행(x)만 부여

---
# ✅ chmod 명령어: 파일 권한 설정 정리

## 🧩 정답
`chmod 751 a.txt`

---
## 📌 chmod란? (존나 쉽고 직관적 예시)

chmod는 리눅스에서 “누가 파일에 뭘 할 수 있나?”를 정하는 스위치 같은 거야.

### 🍔 비유로 쉽게 이해하기  
- **파일**은 집이고  
- **소유자, 그룹, 기타 사용자**는 각각 ‘집 주인’, ‘가족’, ‘손님’ 같은 사람들!  
- chmod 숫자는 이 사람들이 집에서 할 수 있는 행동을 표시해.

| 숫자 | 의미           | 행동 예시                  |
|------|----------------|---------------------------|
| 7    | 읽기+쓰기+실행 | 집 들어오고, 청소하고, 문 열고 다 함 (완전 자유)  |
| 5    | 읽기+실행      | 집 안 들여다보고 문만 열 수 있음 (보기만 가능)   |
| 1    | 실행만         | 집 안 들여다보고 문만 열 수 있음 (열쇠만 있음)   |

### 🧪 예시  
`chmod 751 a.txt`  
- 소유자(7): 집 주인이 집 안에 들어와서 청소하고 뭘 하든지 다 할 수 있음  
- 그룹(5): 가족들은 집 안 들여다보고 문만 열 수 있음 (읽고 실행 가능)  
- 기타 사용자(1): 손님은 문만 열 수 있음 (실행만 가능)

---

### 💡 요점  
chmod는 ‘누가 파일에 접근해서 뭘 할 수 있을지’ 번호로 쫙 정리해주는 아주 중요한 스위치임.  
숫자가 높을수록 권한이 더 많고, 낮으면 제한 많다는 뜻!

존나 쉽고 직관적이고 갓반인도 바로 이해 가능!

### ✅ 권한 숫자 매핑표

| 권한           | 약어 | 이진수 | 8진수 |
|----------------|------|--------|-------|
| 읽기           | r    | 100    | 4     |
| 쓰기           | w    | 010    | 2     |
| 실행           | x    | 001    | 1     |
| 읽기+쓰기+실행 | rwx  | 111    | 7     |
| 읽기+실행      | r-x  | 101    | 5     |
| 실행만         | --x  | 001    | 1     |

🧪 chmod 751 a.txt 해석
소유자(7): rwx → 읽기 + 쓰기 + 실행

그룹(5): r-x → 읽기 + 실행

기타 사용자(1): --x → 실행만 가능

🛠️ 기타 명령어
chown: 소유자 변경
chown 사용자이름 파일명
ls -l: 파일 권한 확인

chmod +x 파일: 실행 권한 추가
------------------------------------------------------------------
 
# 문제 15

**문제**  
다음은 IP 인프라 서비스 관리 실무와 관련된 <실무 사례>에 대한 설명이다. 적합한 용어를 한글 또는 영문으로 써라.

---

## <실무 사례>  
A는 (주)한국 아이티 보안관제실에서 정보시스템의 정보관리를 위해 모니터링을 담당하며 근무하고 있다.  
시스템 운영 중 **자연재해나 시스템 장애** 등의 이유로 **대고객 서비스가 불가능한 경우**가 종종 발생한다.  
A는 이런 **장애 발생 시 서비스를 정상적으로 수행하는 구축 시스템을 관리**하는 역할을 한다.  
이 용어는 이런 **비상 상황이 발생했을 때 '서비스 중단 시점과 서비스 복원 시점 간의 최대 지연 시간'**을 가리킨다.

---

**답**  
복구 시간 목표 (Recovery Time Objective, RTO)

---

## 📌 관련 개념 정리

### ✅ RTO (Recovery Time Objective) - 목표 복구 시간
- 시스템 장애 발생 **이후부터 복구까지 허용 가능한 최대 시간**  
- 예: RTO가 2시간이면, **2시간 이내에 시스템이 복구되어야 함**

### ✅ RPO (Recovery Point Objective) - 목표 복구 시점
- 장애 발생 시점 기준으로 **데이터 손실을 허용할 수 있는 시점**  
- 예: RPO가 10분이면, 마지막 백업 시점이 **10분 전까지 보장**되어야 함

---

### ✅ 백업 유형

| 유형       | 설명                                                                 |
|------------|----------------------------------------------------------------------|
| 전체 백업   | 모든 데이터를 백업하는 방식. 가장 안정적이지만 **시간과 용량** 많이 소모됨 |
| 증분 백업   | **이전 백업 이후 변경된 데이터만** 백업. 빠르고 용량 적지만 복구 시 순차적으로 필요 |
| 차등 백업   | **전체 백업 이후 변경된 모든 데이터** 백업. 복구 시 전체 + 마지막 차등만 필요 |

---

# 문제 16]  
한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고,  
자동으로 내용이 갱신되는 방식으로 일대다(one to many) 의존성을 정의하는 디자인 패턴명을 **영문으로 쓰시오**  

---

# ✅ Observer Pattern (옵서버 패턴)

### 📌 핵심 개념 요약

| 항목       | 설명                                                                                                     |
|------------|--------------------------------------------------------------------------------------------------------|
| 🔍 정의    | **객체의 상태 변화**를 감지하여, 그 변화에 **의존하는 객체들에게 자동으로 알림**을 보내는 디자인 패턴    |
| 🧩 구조    | `Subject(주제)`와 `Observer(관찰자)`로 구성됨  
- **Subject**: 상태를 가지고 있고, 관찰자를 등록하거나 제거함  
- **Observer**: Subject의 상태 변화를 감지하고, 자동으로 갱신됨 |
| ⭐ 특징     | - **일대다(one-to-many)** 관계  
- **느슨한 결합(loose coupling)** 유지  
- Subject의 변경이 Observer들에게 **자동으로 전파됨**                       |
| 🛠️ 활용 예시 | - 버튼 클릭 같은 **GUI 이벤트 리스너**  
- 뉴스 **구독/발행 시스템**  
- **MVC 패턴**에서 Model이 바뀌면 View가 자동으로 갱신됨                    |

---

### 🧠 쉽게 풀어 설명하면?

> 어떤 애가 변하면, 이 애를 지켜보는 애들한테  
> "야 나 바꼈어!" 하고 알려주는 구조임.  
> 관찰자(Observer)는 그냥 감시만 하다가, 알려주면 "아하!" 하고 반응함.  
>  
> 이 구조 덕에 서로 빡세게 연결되지 않아도 자동으로 서로 반응함 = **느슨한 결합** 최고.


------------------------------------------------------------------

# 문제 17]  
다음 설명에 해당하는 **용어를 쓰시오**


- 자유롭게 사용이 가능하며, 저작권 표시 및 변경 허락 조건하에 **재배포 가능한 링크 기반 개방형 데이터**  
- **연계 데이터**와 **오픈 데이터**가 결합된 단어  
- 웹에 게시되는 데이터에 **식별자(URI)**를 부여하고 관련 정보를 구조적으로 제공  
- 저작권 없이 **무료로 제공**, 사용자가 정보를 **다양하고 효율적으로 활용**할 수 있도록 함  
- **HTTP, RDF, URI** 등의 웹표준 기술을 기반으로 시멘틱 웹을 구성  
- 출처가 다른 데이터라도 **URI를 통해 서로 연결**하여 활용  
- **데이터 재사용 가능**, **중복 감소**라는 장점이 있음

---

**답:**  
**Linked Open Data (LOD)**

---

# 📌 Linked Open Data (LOD) & 관련 개념 정리

---

## ✅ Linked Open Data (LOD)

| 항목       | 설명 |
|------------|------|
| 정의       | 웹에 공개된 데이터를 고유한 **URI**로 식별하고, 다른 데이터와 **링크(연결)**하여 **시멘틱 웹**을 실현하는 데이터 구조 |
| 핵심 기술  | - **HTTP**: 자원 요청/접근  
             - **URI**: 데이터 고유 식별  
             - **RDF**: 데이터 간 관계 표현 |
| 장점       | - 데이터 재활용 가능  
             - 서로 다른 데이터 간 연결성 향상  
             - 의미 있는 자동화 처리 가능 (시멘틱 웹 기반) |
| 활용 예    | - **국가 데이터 포털**  
             - **도서관 서지 데이터**  
             - **공공기관 행정 데이터 개방** 등 |

---

## ✅ 시멘틱 웹 (Semantic Web)

- 단순 텍스트 웹이 아니라, 컴퓨터가 **의미를 이해하고 처리하는 웹**  
- 데이터 간 **의미적 연결**로 자동 추론 가능  
- 핵심 기술:  
  - **RDF** (자원 간 관계 표현)  
  - **OWL** (온톨로지: 개념과 관계 정의)  
  - **SPARQL** (시멘틱 데이터 쿼리 언어)  

---

## ✅ REST (Representational State Transfer)

| 항목     | 설명 |
|----------|------|
| 정의     | **웹 자원**을 URI로 표현하고, HTTP 메서드(GET, POST 등)로 조작하는 설계 아키텍처 |
| 특징     | - 무상태성 (Stateless)  
             - 자원 기반 구조 (Resource-Oriented)  
             - **RESTful**: REST 원칙을 따르는 서비스 |
| 활용 예 | 웹 API, 모바일 앱 백엔드 통신 등 |

---

### 🧠 쉽게 풀어 설명하면?

- **LOD**는 “웹 데이터들이 서로 친구 맺고 연결되어 같이 똑똑해지는 것”  
- 그 기반이 **시멘틱 웹**: 컴퓨터가 “이 데이터가 뭔 뜻인지” 알아먹고, 자동으로 판단도 하는 똑똑한 웹  
- 그리고 데이터를 주고받는 데 자주 쓰이는 구조가 바로 **REST**:  
  “웹 주소(URI)로 자원을 콕 집어서, HTTP 명령어(GET, POST 등)로 다루는 편리한 규칙”  

즉,  
LOD + 시멘틱 웹 + REST = 똑똑하고 연결 잘 되는 현대 웹 데이터 세상!



-----------------------------------------------------------------------------------

### 🧩 문제 18) 다음은 Python 언어로 작성된 프로그램이다. 실행 결과를 쓰시오.

```python
asia = {'한국', '중국', '일본'}
asia.add('베트남')
asia.add('중국')
asia.remove('일본')
asia.update(['홍콩', '한국', '태국'])
print(asia)

✅ 정답
{'한국', '중국', '베트남', '홍콩', '태국'}

🧠 해설

asia = {'한국', '중국', '일본'}
📌 add('베트남')
'베트남' 추가됨
→ {'한국', '중국', '일본', '베트남'}

📌 add('중국')
'중국'은 이미 존재 → 중복 무시됨
→ 그대로 유지: {'한국', '중국', '일본', '베트남'}

📌 remove('일본')
'일본' 제거됨
→ {'한국', '중국', '베트남'}

📌 update(['홍콩', '한국', '태국'])
여러 요소 추가

'한국'은 이미 있음 → 무시
→ 최종 집합: {'한국', '중국', '베트남', '홍콩', '태국'}

-----------------------------------------------------------------------------------
### 🧩 문제 19) Java 프로그램은 `<처리결과>`와 같이 결과가 출력된다.  
다음 Java 프로그램에서 `<?>`에 들어갈 Java 표현을 대소문자를 구별하여 쓰시오.

```java
class Parent {
    void show() {
        System.out.println("Parent");
    }
}

class Child extends Parent {
    void show() {
        System.out.println("Child");
    }
}

public class Exam {
    public static void main(String[] args) {
        Parent pa = <?> child();
        pa.show();
    }
}

✅ 정답

답: new

왜 new Child()가 들어가야 하냐고?  
`Parent pa = new Child();` 이게 바로 **다형성(Polymorphism)**이라는 건데,  
부모 타입의 변수가 자식 객체를 참조할 수 있다는 거임.

그리고 `pa.show();` 이 부분에서 pa가 Child 객체라서  
Child 클래스의 show() 메소드가 실행되는 거임.  
이걸 메소드 오버라이딩이라고 한다.  
부모랑 자식 둘 다 같은 이름의 메소드를 가지고 있을 때,  
자식 메소드가 부모 메소드를 덮어쓰는 거라고 보면 됨.  
알잘딱깔센 이해했지?

-----------------------------------------------------------------------------------
문제 20] 다음은 java 작성된 프로그램이다 출력값을 써라 

## 🔹 코드 원문

class A {                                             // 부모 클래스 A
    int a;                                             // int 타입 변수 'a'
    public A(int n) {                               // 생성자 A. int n을 받아서
        a = n;                                           // 'a'에 그 값을 넣어줌.
    }
    public void print() {                               // print 메소드. 'a='랑 'a' 값 출력.
        System.out.println("a=" + a);
    }
}

class B extends A {                                         // 자식 클래스 B. A를 상속받음.
    public B(int n) {                                       // 생성자 B. int n을 받아서
        super(n);                                           // **super(n)** 이게 핵심! 부모 클래스 A의 생성자를 호출하는 거야.
                                                            // 그래서 A 클래스의 'a'에 10이 저장됨. (obj = new B(10) 때문에)
        super.print();                                           // **super.print()** 이것도 핵심! 부모 클래스 A의 print() 메소드를 호출하는 거야.
                                                                           // 그래서 "a=10"이 출력되는 거지.
    }
}

public class Exam {
    public static void main(String[] args) {
        B obj = new B(10);                                                 // B 클래스의 객체 obj를 생성하면서 10을 인자로 넘김.
                                                                     // 이 순간 B의 생성자가 호출되고, 그 안에서 부모의 생성자랑 print 메소드가 차례로 실행됨.
    }
}

답: a=10

🔍 코드 설명
왜 이렇게 나오냐고?  
`super()` 키워드가 중요함. 자식 클래스에서 `super()`를 쓰면  
**부모 클래스의 멤버(생성자나 메소드)**에 접근할 수 있어.

`B obj = new B(10);` -> `B(10)` 생성자 호출.

`super(n);` (여기서는 `super(10);`) -> 부모 클래스 A의 생성자가 호출돼서  
A 클래스의 `a` 변수에 10이 들어감.

`super.print();` -> 부모 클래스 A의 `print()` 메소드가 호출됨.

결국, A 클래스에 있는 `a` 값이 10이니까 `a=10`이 출력되는 거임.

