
### 문제 1)
아래 응집도와 관련하여 **응집도가 높은 순에서 낮은 순으로** 답안을 작성하시오.

1. 기능

2. 교환

3. 우연

4. 시간


### ✅ 정답  
**1 - 2 - 4 - 3**  
→ **기능 - 교환 - 시간 - 우연**


# 🔧 응집도(Cohesion)란?

> 하나의 모듈(함수, 클래스 등) 안에서 **구성요소들이 얼마나 같은 목적을 향해 움직이느냐**를 나타내는 정도

- **응집도 높음 = 서로 밀접하게 연관된 일만 함 → 좋은 구조!**  
- **응집도 낮음 = 잡다한 일 다 함 → 유지보수 어렵고 버그 유발**

---

## ✅ 응집도 수준별 정리 + 갓반인 예시

| 응집도           | 설명                     | 품질    | 예시 (비유)                                  |
|------------------|--------------------------|---------|----------------------------------------------|
| 🟥 **우연적 응집도**  | 그냥 막 모아둠               | ❌ 최악   | "한 파일에 계산, 프린터 설정, 로그인 코드 다 들어있음"   |
| 🟥 **논리적 응집도**  | 비슷한 작업을 조건에 따라 선택  | ❌ 나쁨   | "if문으로 작업 나눠서: 출력? 저장? 전송? 전부 있음"     |
| 🟧 **시간적 응집도**  | 비슷한 시점에 수행됨           | ⛔ 낮음   | "초기화 함수에 DB연결, 로그설정, 화면세팅 다 때려넣음"    |
| 🟨 **절차적 응집도**  | 순서 따라 하긴 하는데 목적이 다름 | ⚠ 보통   | "사용자 입력 받고 → 로깅하고 → 저장까지 하나에 있음"      |
| 🟨 **통신적 응집도**  | 같은 데이터를 다룸              | 👍 양호   | "같은 고객정보로 조회/수정/출력 수행"                   |
| 🟨 **순차적 응집도**  | 앞 결과를 다음 작업에 사용       | 👍 양호   | "파일 읽고 → 파싱하고 → 출력하는 흐름"                   |
| 🟩 **기능적 응집도**  | 한 가지 목적만!                | ✅ 최고   | "파일 저장 기능만 깔끔하게 담당"                        |

---

### 🔑 요점 정리

- 👉 **응집도는 '내부끼리 얼마나 한 마음으로 일하느냐'**  
- 👉 **높을수록 유지보수, 재사용성, 디버깅에 유리**  
- 👉 암기 순서: `우논시절통순기` (우연 < 논리 < 시간 < 절차 < 통신 < 순차 < 기능)

---

# 🔗 결합도(Coupling)도 같이 보자!

> **모듈 간 연결성의 정도. 느슨할수록 좋음**

| 결합도           | 설명                     | 품질    | 예시 (비유)                              |
|------------------|--------------------------|---------|------------------------------------------|
| 🟩 **자료 결합도**   | 값만 주고받음               | ✅ 최고   | "함수에 숫자만 전달 (ex. sum(5, 7))"         |
| 🟨 **스탬프 결합도**  | 구조체 등 덩어리 전달         | 👍 양호   | "사용자 구조체 통째로 전달"                   |
| 🟨 **제어 결합도**   | 실행 흐름 결정 플래그 전달      | ⚠ 보통   | "flag=true 넘겨서 내부 분기 처리"             |
| 🟧 **외부 결합도**   | 외부환경과 연결              | ⛔ 낮음   | "파일 포맷, 하드웨어에 직접 의존"              |
| 🟥 **공통 결합도**   | 전역변수 공유               | ❌ 나쁨   | "모든 함수가 global변수 쓰는 상황"              |
| 🟥 **내용 결합도**   | 다른 모듈의 내부까지 침범       | ❌ 최악   | "A모듈이 B모듈의 내부 변수나 코드에 접근"         |

---

### 🔐 기억 포인트

- 응집도는 **높을수록 좋고**,  
- 결합도는 **낮을수록 좋다**

> ✅ **좋은 설계 = 높은 응집도 + 낮은 결합도**



----------------------------------------------------------------------------------

## 📝 문제 2) 네트워크 용어 (영문 약어 작성)

### ❓ 문제
다음에서 설명하는 네트워크 용어를 **영문 약어**로 작성하시오.

> 다음은 인터넷 프로토콜 스위트의 데이터 교환을 위해 네트워크 장치 간의 정보를 배포하는 데 사용되는 **링크 상태 라우팅 프로토콜**이다.  
> 이 프로토콜은 **최단경로 우선 원칙**을 사용하여 라우팅 결정을 내리며, **리피터가 동일한 계층의 다른 라우터와 직접적으로 정보를 교환**할 수 있도록 한다.  
> 특히 **대규모 네트워크에서 효율적**이며, **라우팅 테이블을 최신 상태로 유지**하기 위해 자주 업데이트된다.  
> 라우터는 이 프로토콜을 사용하여 **네트워크 변경 사항에 신속하게 반응**하고, 네트워크의 각 세그먼트에서 정보를 **동기화하는 데 필요한 데이터**를 교환한다.



### ✅ 정답  
**OSPF**  
(Open Shortest Path First)



# 🚦 OSPF (Open Shortest Path First) 해설

## ✅ 한 줄 요약  
**OSPF는 네트워크 안에서 "가장 빠른 길"을 실시간 계산해서 알려주는 똑똑한 네비게이션 시스템**

---

## 🧠 핵심 특징

| 항목             | 설명                                   | 현실 비유                            |
|------------------|--------------------------------------|------------------------------------|
| 💡 라우팅 프로토콜 | 링크 상태 기반 (Link-State)            | "각 지점 간 도로 상황(링크 상태)을 서로 공유" |
| 📌 알고리즘       | SPF (Dijkstra 알고리즘)                | "내비게이션처럼 가장 빠른 길 계산"         |
| 🔄 정보 교환      | LSA (Link-State Advertisement)로 주고받음 | "내 위치랑 도로 상황을 주변에 방송함"        |
| ⚡ 반응 속도      | 변화 생기면 즉시 재계산                | "차 사고나면 바로 길 다시 안내해줌"           |
| 🧭 사용 범위      | IGP 계열 (내부 라우팅용), 대규모 네트워크에 적합 | "회사 내부망에 사용하는 빠른 내비"            |

---

## 🛣 라우팅 프로토콜 분류

### 📍 1. 정적 라우팅 (Static Routing)
- 사람이 직접 일일이 길 지정  
- 🔧 **직접 설정해야 해서 유연성은 낮지만**, 단순한 환경에서는 유리  
> 예: "네비 없이 지도로 길 외워서 다님"

---

### 📍 2. 동적 라우팅 (Dynamic Routing)
- 라우터끼리 **자동으로 경로 계산 및 교환**  
- 실시간으로 변화에 대응 가능  
- 두 종류로 나뉨:

| 분류               | 프로토콜           | 특징                 |
|--------------------|--------------------|----------------------|
| **IGP (내부망용)**  | RIP, OSPF 등       | 조직 내부에 적합      |
| **EGP (외부망용)**  | BGP                | ISP(인터넷 사업자) 간 연결 시 사용 |

---

## 🔄 IGP 내부 비교: RIP vs OSPF

| 항목         | **RIP**                    | **OSPF**                        |
|--------------|----------------------------|--------------------------------|
| 💡 알고리즘   | 거리 벡터 (Distance Vector) | 링크 상태 (Link-State)           |
| 📏 기준       | 홉 수 (몇 번 거쳐가는지)    | 실제 경로 비용 (속도, 지연 등)    |
| 🐢 속도       | 느림 (수렴 느림)             | 빠름 (즉시 재계산)               |
| 🚧 한계       | 15홉 제한, 대규모 부적합      | 대규모 네트워크에 최적           |
| 🤝 구조       | 단순, 설정 쉬움              | 조금 복잡하지만 효율적            |

---

## 🧠 암기 포인트 요약

- OSPF = **링크 상태 기반**, SPF 알고리즘, **빠른 반응**, 대규모에 강함  
- RIP = **홉 수 기반**, 느림, **소규모에서만 적합**  
- OSPF는 회사 내 **사내망 전용 고급 내비**, RIP은 **구식 노선버스 느낌**





----------------------------------------------------------------------------------

## 📝 문제 3) 애플리케이션 테스트 커버리지

### ❓ 문제
다음은 소프트웨어 테스팅에서 사용되는 **테스트 커버리지 기준** 중 하나이다.  
이 기준은 **각 결정점에서 모든 가능한 결정 결과를 최소 한 번 이상 실행**하도록 요구하며,  
모든 **조건식이 참(True)과 거짓(False)이 되도록** 만들어진다.  
이를 통해 개발자와 테스터는 **소프트웨어 내의 결정점에서 발생할 수 있는 다양한 조건 변경 사항들이 올바르게 처리되고 있는지** 검증할 수 있다.  
이러한 테스트 커버리지는 **조건의 모든 논리적 경로를 테스트**하여 **소프트웨어의 품질을 향상**시키는 데 중요한 역할을 한다.

---

# ✅ 변경 조건/결정 커버리지 (MC/DC)

## 🔍 한 줄 요약  
**조건 하나만 바꿨을 때, 결과가 바뀌는지 보는 아주 정밀한 테스트 방식**

---

## 🧠 핵심 개념
- 여러 조건이 있는 `if문`에서,  
  → **각 조건이 결과에 독립적으로 영향을 주는지** 확인해야 함  
- 조건이 True/False 되는 것만으로는 부족함  
  → **"결과에도 진짜 영향을 줬는가?"**가 포인트

---

## 📌 갓반인용 예시

```java
if (A || B) {
  // 실행
}
케이스	A	B	결과
①	F	F	X (실행 안 함)
②	T	F	O (실행)
③	F	T	O (실행)

✅ 이렇게 A와 B가 각자 바뀌었을 때 결과도 바뀌면 → MC/DC 충족

🎯 왜 중요한가?
항공기, 자율주행, 의료기기처럼 사람 생명에 관련된 시스템에서는
단순히 “잘 실행됨”만으론 안 됨

→ 조건 하나하나가 결과에 영향을 주는지 입증해야 함

→ 그래서 MC/DC는 필수 요건
# 🪜 테스트 커버리지 비교 (갓반인 버전)

| 커버리지 종류         | 설명                                      | 갓반인 예시                               |
|----------------------|-----------------------------------------|------------------------------------------|
| 구문 커버리지         | 코드 한 줄 한 줄 다 실행해보는 것             | “코드 전체를 한 번은 다 밟아본다”          |
| 조건 커버리지         | 조건문 안 각 조건이 True, False 되는지 확인    | “A가 True일 때, False일 때 각각 확인”       |
| 결정 커버리지         | if문 전체 결과가 True 또는 False 되는지 확인   | “if문이 실행됐는지 안 됐는지 확인”          |
| 조건/결정 커버리지    | 조건 커버리지와 결정 커버리지를 둘 다 만족      | “각 조건 바꿔서 if 결과도 바뀌는지 보는 것”  |
| MC/DC                 | 각 조건이 결과에 독립적으로 영향을 주는지 검증 | “A만 바꿨을 때 결과 바뀌고, B만 바꿨을 때도 바뀌면 OK” |
| 다중 조건 커버리지    | 모든 조건 조합을 다 테스트 (비효율적)           | “A, B, C 각각 조합 가능한 모든 경우 다 해봄” |

---

### 💡 쉽게 정리하면?

- **구문 커버리지**: “코드 한 번씩은 다 밟아봤냐?”  
- **조건 커버리지**: “조건문 안 조건 True/False 다 봤냐?”  
- **결정 커버리지**: “if문 결과가 True/False 다 됐냐?”  
- **조건/결정 커버리지**: “조건 변화에 따라 if 결과도 변하냐?”  
- **MC/DC**: “각 조건 혼자 바꿨을 때 결과가 정말 달라지냐?”  
- **다중 조건 커버리지**: “모든 조건 조합을 완벽하게 다 시험함?”

---

### 🎯 왜 MC/DC가 중요한가?

- 단순히 조건만 바꾸는 게 아니라,  
- **각 조건이 결과에 독립적으로 영향 주는지** 반드시 증명해야 해서  
- **항공기, 의료, 자동차 등 사람 목숨 관련 시스템에서는 필수!**



🧠 암기 포인트
MC/DC = 조건 하나 바꿔서 결과 바뀌는지 확인

단순 커버리지보다 한 단계 더 깊이 테스트

생명/안전 관련 시스템에선 표준이자 의무 수준

----------------------------------------------------------------------------------
## 📝 문제 4) 보안 관련 악성 소프트웨어 용어

### ❓ 문제
다음은 컴퓨터 시스템 내에서 사용자의 허가 없이 **자신의 존재를 숨기고**,  
**관리자 레벨의 접근 권한을 얻기 위해 설계된 악성 소프트웨어의 한 유형**이다.  
이 소프트웨어는 시스템의 **기본적인 기능에 깊숙이 침투하여 활동을 감추며**,  
**다양한 보안 도구로부터 탐지를 피할 수 있다**.  
종종 **시스템 로그 파일을 수정하거나**, **키스트로크를 기록**하고,  
**비밀번호를 도용하는 등의 활동**을 포함할 수 있다.  
이러한 특성 때문에 보안 전문가들에게는 큰 위협이며, **제거가 매우 어렵다**.

---

### ✅ 정답  
**Rootkit (루트킷)**

---

### 🔍 해설

# 🧨 루트킷(Rootkit)

> 시스템 관리자 권한을 훔쳐서, **자기 존재를 숨긴 채**, 몰래 악성 행위를 계속하는 **은폐형 악성 코드**.

## 💣 한 줄 요약  
**“보안 시스템 눈속임하고 몰래 해킹을 지속하는 숨어있는 해커 도구”**

---

## ⚙️ 루트킷 특징

- **시스템 깊숙한 곳(운영체제 핵심)에 설치됨**
- 보안 프로그램, 관리자 눈에 **안 보이게 로그/파일/프로세스 조작**
- **키보드 입력 훔치기(키로깅), 백도어 심기, 비번 탈취, 원격제어** 등 가능
- 보안 소프트웨어가 **탐지도 제거도 잘 못함**
- **포맷이나 운영체제 재설치가 필요할 수도 있음**

---

## 📌 현실 예시

| 개념           | 현실 예시                                                  |
|----------------|------------------------------------------------------------|
| **루트킷 설치**  | 누가 내 PC에 몰래 침투해서 **‘작업 관리자’에도 안 뜨는 프로그램**을 심어놓음 |
| **로그 조작**   | 나 몰래 들어와 놓고 **접속 기록, 에러 기록 다 지워버림**               |
| **키로깅**      | 내가 **인터넷뱅킹 로그인할 때 키보드 입력을 몰래 저장**함              |
| **백도어**      | 내가 컴 꺼놔도 **외부에서 다시 몰래 접속할 수 있는 통로를 남겨둠**       |
| **보안 프로그램 우회** | 백신이 아예 **그 프로그램 자체를 못 보게 만들어놓음**                   |

---

## 📌 서비스 공격(DoS/DDoS)의 대표 예시들

| 공격명           | 설명                                             | 갓반인용 예시                                   |
|------------------|--------------------------------------------------|------------------------------------------------|
| **Smurf Attack** | 공격자가 엉뚱한 IP로 ICMP 브로드캐스트 → 피해자가 ICMP 폭탄 맞음   | A한테 전화할 때 **발신자 번호를 B로 조작**해서 B한테 항의 전화가 쏟아지게 함 |
| **Ping of Death**| 비정상적으로 **큰 ICMP 패킷**을 보내 시스템 다운           | 누가 **1GB짜리 메모를 휴대폰 문자로 보냄 → 폰 먹통됨**                  |
| **Teardrop Attack** | IP 조각을 **이상하게 쪼개서**, 시스템이 조합 못 하게 함        | 퍼즐을 일부러 **안 맞게 잘라서 보냄 → 프로그램 충돌**                   |
| **LAND Attack**  | 출발지/목적지 IP를 같게 해서 시스템 혼란                  | 누가 자기한테 자기 번호로 문자 보냄 → 시스템 멘붕                        |
| **SYN Flooding** | TCP 연결 요청만 계속하고 응답 안 받음 → 연결 큐 넘침           | 카페 입구에서 **계속 자리 예약만 하고 안 들어옴 → 대기열 폭발**           |
| **UDP Flooding** | 대상의 여러 포트에 **무작위 UDP 패킷 대량 전송**             | **무작위로 전화를 계속 걸어댐**. 받으면 아무 소리도 안 들림              |
| **Ping Flooding**| 계속 Ping만 날려서 대상 자원 과부하                      | “야 있어?”, “야 있냐?”, “야야야야야야...” 계속 말 거는 애               |

---

## 📌 정보보안의 3요소 (CIA Triad)

| 요소                   | 설명                                  | 현실 예시                                               |
|------------------------|-------------------------------------|--------------------------------------------------------|
| **기밀성 (Confidentiality)** | 허가된 사람만 정보 접근 가능                 | 회사 서버에 고객 정보가 있는데 **비밀번호 안 알면 접근 불가**              |
| **무결성 (Integrity)**      | 정보가 **원래대로 유지**되도록 보장           | 쇼핑몰에서 상품 가격이 갑자기 100만원 → 100원으로 바뀌면 안 됨           |
| **가용성 (Availability)**   | 정보나 시스템에 **언제든 접근 가능**           | 전산망 오류로 **ATM이 안 되면 가용성 깨진 것**                          |


 ----------------------------------------------------------------------------------

## 📝 문제 5) 사이버 공격 유형

### ❓ 문제
다음은 **고도로 조직화된 공격자 그룹이 특정 대상에 대해 장기간에 걸쳐 은밀하게 수행하는 사이버 공격 방법**이다.  
이러한 공격은 대개 **국가의 지원을 받는 해커들에 의해 수행**되며,  
**특정 기업, 정부 기관, 또는 중요 인프라**를 목표로 한다.  
공격자들은 **네트워크 내부에 오랫동안 숨어 있으면서 데이터를 탈취하거나 시스템을 조작**하여  
심각한 피해를 입힐 수 있다.  
이러한 공격은 일반적인 사이버 위협과 **목적과 수행 방식 면에서 구별되며**,  
**매우 정교하고 지속적인 모니터링**이 요구된다.

---

### ✅ 정답  
**APT (Advanced Persistent Threat)**

---

### 🔍 해설

# 🎯 APT (지능형 지속 위협, Advanced Persistent Threat)

## ✅ 한 줄 요약  
**“목표를 정하고 몰래 숨어들어, 장기간 정보를 빼내는 스파이 같은 해킹”**

---

## ⚙️ APT의 3요소

| 구성요소 | 의미 | 예시 |
|----------|------|------|
| **Advanced (고급)** | 보안 우회 기술, 전용 악성코드 사용 | 문서파일에 악성코드 심어 메일로 침투 |
| **Persistent (지속적)** | **오랜 시간 숨어서 활동** | 공격자는 들켰는지 감시하면서 몇 달, 몇 년도 존버 |
| **Threat (위협)** | 국가/기업 등에 **막대한 피해** | 기술 설계도 유출, 발전소 마비, 고객 정보 탈취 등 |

---

## 🕵️‍♀️ 현실 기반 예시

- 어떤 해커가 **“특정 방산업체”**를 목표로 삼음  
- 직원에게 **“급여 정산 안내”** 제목의 메일 발송 → **첨부파일 클릭 유도**  
- 감염되면 내부망으로 퍼짐, 중요한 서버에 **백도어 설치**  
- 수개월 동안 **기밀 문서, 설계도, 계약 정보** 빼냄  
- 보안팀은 거의 눈치 못 챔 → **나중에 털린 후 알게 됨**

---

## 🧨 APT와 관련 악성코드 종류 요약 (갓반인 해설 포함)

| 유형 | 설명 | 현실 비유 |
|------|------|-----------|
| **Worm** | 자가복제하며 네트워크 통해 퍼짐 | "단톡방에 걸린 링크 클릭 → 전부 감염됨" |
| **Trojan Horse** | 겉보기엔 정상, 내부는 악성 | "무료 게임 설치했는데 백그라운드에서 해킹함" |
| **Backdoor** | 몰래 들어오는 통로 | "도둑이 뒷문 따놓고 계속 드나듦" |
| **Virus** | 다른 파일에 붙어서 전염 | "한 엑셀파일 열었더니 전체 폴더가 감염됨" |
| **Ransomware** | 파일을 암호화하고 몸값 요구 | "회사 컴퓨터 파일 잠금 → 복호화하려면 돈 내라 함" |
| **Spyware** | 사용자 몰래 정보 수집 | "내 검색기록, 계좌번호 몰래 유출됨" |
| **Adware** | 광고 팝업, 리디렉션 | "브라우저 열 때마다 이상한 광고 사이트 뜸" |
| **APT** | 특정 목표에 맞춰 **장기적으로** 공격 | "특정 기업만 골라 몇 달 동안 해킹해서 설계도 빼감" |
| **Zero-day Attack** | 알려지지 않은 취약점 악용 | "보안패치 안 나온 허점을 미리 찔러 들어옴" |

---

## 🧠 갓반인을 위한 핵심 정리

- **APT는 단순한 해킹이 아님. 진짜 전쟁 수준임**
- 대부분 **국가 후원 or 산업 스파이** 성격 → 피해 규모가 엄청 큼
- **처음엔 이메일 한 통으로 시작 → 몇 개월 뒤 전사 해킹 완료됨**
- 탐지 어려움 + 퇴치도 어려움 → **사전 방어와 보안 교육이 핵심**

 ----------------------------------------------------------------------------------
## 📝 문제 6) 생성 디자인 패턴

### ❓ 문제
다음은 소프트웨어 공학에서 사용되는 **생성 디자인 패턴** 중 하나로,  
**관련 또는 의존하는 객체의 집합을 생성하기 위한 인터페이스**를 제공한다.  
이 패턴은 **구체적인 클래스를 지정하지 않고도 객체 생성을 캡슐화**하는 방법을 제공하여,  
**클라이언트 코드가 특정 클래스의 인스턴스에 직접 의존하지 않도록** 한다.  
이를 통해 클라이언트는 여러 제품군 중 필요한 제품을 선택하여 생성할 수 있으며,  
시스템의 **확장성과 유연성**이 증가된다.  
**다양한 환경에서 공통적으로 사용될 수 있는 제품군**을 생성하는 과정에서 특히 유용하다.

---
### ✅ 정답  
**Abstract Factory**  
(추상 팩토리 패턴)



# 🔍 Abstract Factory 패턴 쉽게 이해하기

## ✅ 한 줄 요약  
**“비슷한 종류 제품(객체) 묶음을 한 번에 만드는 공장 인터페이스”**

---

## 🧠 핵심 개념  
- 여러 관련 객체를 **제품군(Product Family)**으로 묶음  
- 이 제품군들을 만들 수 있는 **공장(Factory) 인터페이스를 제공**  
- 클라이언트는 구체적인 클래스 몰라도 제품군을 만들 수 있음  
- 제품군끼리 일관성 유지하면서 시스템 유연하게 설계 가능  
- 예) 윈도우용 버튼 + 체크박스, 맥용 버튼 + 체크박스 각각 다르게 만들 때 유용

---

## 📌 갓반인 예시

- 상상해봐:  
  **“가구 공장”**이 있어  
  - ‘모던 스타일’ 가구 세트 만들 공장  
  - ‘클래식 스타일’ 가구 세트 만들 공장  
- 각각 공장은 **의자, 소파, 테이블** 같은 제품군을 만들어 줌  
- 사용자는 그냥 “모던 가구 공장” 부르면 모던 의자, 모던 소파, 모던 테이블을 한꺼번에 받음  
- **어떤 스타일 공장(Concrete Factory)을 쓸지 몰라도** 항상 일관된 제품군을 받을 수 있음

---

## 📌 디자인 패턴 분류 관련  

| 분류    | 설명                            | 대표 패턴                          |
|---------|---------------------------------|-----------------------------------|
| 생성 패턴 | 객체 만드는 방법을 추상화          | Singleton, Factory Method, **Abstract Factory**, Builder, Prototype |
| 구조 패턴 | 클래스/객체 연결해 큰 구조 만듦    | Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy       |
| 행위 패턴 | 객체 간 역할 분배 및 알고리즘 관리 | Observer, Strategy, Command, State, Template Method 등                |

### 갓반인 예시  
- 생성 패턴: “새 제품 만드는 공장 설계도”  
- 구조 패턴: “레고 블록처럼 여러 부품을 조립”  
- 행위 패턴: “배달 음식 주문 처리, 누가 어떤 역할 할지 정함”

---

## 📌 객체지향 기본 개념  

| 개념   | 설명                   |
|--------|------------------------|
| 클래스 | 설계도 (객체 설계서)     |
| 객체   | 설계도로 만든 실체       |
| 속성   | 객체가 가진 데이터       |
| 메서드 | 객체가 할 수 있는 행동   |
| 메시지 | 객체에게 동작 요청하는 것 |

### 갓반인 예시  
- 클래스: 쿠키 틀  
- 객체: 틀로 찍어낸 쿠키  
- 속성: 쿠키 맛, 크기, 색깔  
- 메서드: 쿠키 굽기, 포장하기  
- 메시지: “굽기 시작해!”, “포장해줘!”

---

## 📌 SOLID 설계 원칙 간단 정리

| 원칙 | 뜻                  |
|------|---------------------|
| SRP  | 한 클래스는 한 가지 책임만 가져야 함 |
| OCP  | 확장에는 열려 있고, 변경에는 닫혀 있어야 함 |
| LSP  | 자식 클래스는 부모 대체 가능해야 함   |
| ISP  | 불필요한 인터페이스에 의존하지 말 것 |
| DIP  | 구체가 아니라 추상에 의존할 것        |

### 갓반인 예시  
- SRP: 주방 칼은 ‘자르기’만 담당, 청소는 청소 도구가 하게 하기  
- OCP: 새 요리법은 추가 가능, 기존 요리법은 바꾸지 않기  
- LSP: 초콜릿 케이크는 ‘케이크’로 바꿔 써도 문제 없어야 함  
- ISP: TV 리모컨에서 ‘라디오’ 버튼 빼고, 라디오 리모컨엔 ‘채널’ 버튼만 있게 하기  
- DIP: 전기 제품은 ‘전원’이란 추상에 연결, 콘센트 모양이 달라도 작동하게 하기


 ----------------------------------------------------------------------------------
## 📝 문제 7) 서브넷 마스크 기반 IP 주소 할당

### ❓ 문제  
아래 네트워크 구성에서 **2번, 4번, 6번 라우터에 할당 가능한 IP 주소**를 보기에서 찾아 작성하시오.

#### [적용된 IP 주소]  
- 1번) `192.168.35.12/24`  
- 3번) `129.200.10.16/22`  
- 5번) `192.168.36.32/24`  

#### [보기]  
- A) `192.168.35.72`  
- B) `129.200.8.249`  
- C) `192.168.36.249`  

---

### ✅ 정답  
- **2번:** `192.168.35.72`  
- **4번:** `129.200.8.249`  
- **6번:** `192.168.36.249`  

---
 

## 🔍 갓반인 해설  

#### 1) 2번 라우터 (192.168.35.12/24)  
- `/24`는 동네 경계가 `255.255.255.0` 이라서  
- ‘192.168.35.0’부터 ‘192.168.35.255’까지가 이 동네  
- ‘192.168.35.72’도 이 동네 안에 있으니  
→ 2번 라우터에 할당 가능!  

#### 2) 4번 라우터 (129.200.10.16/22)  
- `/22`는 동네 경계가 `255.255.252.0`이라  
- 네트워크가 4단위 블록으로 나뉘어 ‘129.200.8.0’부터 ‘129.200.11.255’까지  
- ‘129.200.10.16’은 10이니까 ‘8~11’ 사이 동네  
- ‘129.200.8.249’도 같은 동네 안!  
→ 4번 라우터에 할당 가능!  

#### 3) 6번 라우터 (192.168.36.32/24)  
- `/24`니까 동네 경계는 `255.255.255.0`  
- ‘192.168.36.0’부터 ‘192.168.36.255’까지  
- ‘192.168.36.249’도 같은 동네 안!  
→ 6번 라우터에 할당 가능!  

---

### 💡 쉽게 생각하기  
- IP 주소는 집 주소, 서브넷 마스크는 ‘동네 경계’  
- 같은 동네 사람들끼리만 소통 가능  
- /24는 작은 동네, /22는 좀 더 큰 동네 같은 느낌!

---

### 📌 관련 개념: CIDR 및 서브넷 마스크

| CIDR 표기 | 서브넷 마스크     | 호스트 개수           | 주소 범위 예시          |
|-----------|------------------|-----------------------|-------------------------|
| /24       | 255.255.255.0    | 256개 중 254개 사용 가능 | x.x.x.0 ~ x.x.x.255     |
| /22       | 255.255.252.0    | 1024개 중 1022개 사용 가능 | x.x.8.0 ~ x.x.11.255    |

- 서브넷 마스크는 IP 주소를 **네트워크 부분과 호스트 부분으로 나누는 표시**  
- **CIDR(씨더)**는 이걸 간단하게 표현하는 방법으로, 숫자가 클수록 네트워크 영역이 넓고, 작을수록 호스트 영역이 많음  
- 예를 들어, /24는 ‘마을’ 하나 크기, /22는 ‘큰 동네’ 크기라고 생각하면 쉽다  

---

### ✅ 갓반인 요약표

| 라우터 번호 | 적용된 IP           | 할당 가능한 IP         | 네트워크 확인 결과       |
|-------------|---------------------|------------------------|-------------------------|
| 2번         | 192.168.35.12/24    | 192.168.35.72          | “같은 마을(네트워크)”    |
| 4번         | 129.200.10.16/22    | 129.200.8.249          | “같은 큰 동네(네트워크)” |
| 6번         | 192.168.36.32/24    | 192.168.36.249         | “같은 마을(네트워크)”    |

---

### 🤔 쉽게 비유하자면

- IP 주소 = 집 주소  
- 서브넷 마스크 = ‘동네’ 경계선  
- CIDR 숫자 클수록 ‘동네’가 작아져서 같은 동네끼리만 서로 왕래 가능!  
- /24는 작은 동네, /22는 큰 동네 같은 개념임

-------------------------------------------------------------------------------------
## 📝 문제 8) SQL 조인(join) 종류

### ❓ 문제
다음은 **조인(join)**에 대한 설명이다.  
**괄호에 들어갈 알맞은 용어**를 작성하시오.

---

### ①  
두 테이블을 특정 조건을 기반으로 결합하는 조인 방법이다.  
이 조인은 조건이 `=`(동등)뿐만 아니라 `<`, `>`, `<=`, `>=`, `!=` 등의 **비교 연산자**를 사용할 수 있다.  
이 조인을 통해 다양한 조건을 기반으로 두 테이블 간의 관계를 정의하고,  
조건에 맞는 행을 결합하여 새로운 결과 집합을 만든다.  
> **정답: 세타 조인 (Theta Join)**

---

### ②  
두 테이블을 결합할 때, 조인 조건으로 `=`(동등) 연산자만을 사용하는 조인 방법이다.  
이 조인은 두 테이블의 특정 컬럼 값이 **동일한 행**들을 결합하여 결과 집합을 만든다.  
주로 **외래 키와 기본 키**를 매칭할 때 사용되며, **조건에 맞는 행만** 결과에 포함된다.  
> **정답: 동등 조인 (Equi Join)**

---

### ③  
두 테이블을 결합할 때, **동일한 이름의 컬럼**을 기반으로 동등 비교를 수행하여 조인하는 방법이다.  
이 조인은 **조인 조건을 명시하지 않아도**, 동일한 이름의 컬럼들을 자동으로 매칭하여 결합한다.  
결과 집합에는 **중복되는 컬럼이 하나만 포함**되며,  
두 테이블 간의 공통된 컬럼 값이 동일한 행들만 결합된다.  
> **정답: 자연 조인 (Natural Join)**

---

## ✅ 최종 정답 정리

| 번호 | 조인 유형             | 설명 |
|------|------------------------|------|
| 1번 | **세타 조인 (Theta Join)** | `=`, `<`, `>`, `<=`, `>=`, `!=` 등 **비교 연산자** 사용 가능 |
| 2번 | **동등 조인 (Equi Join)** | 오직 `=` 연산자만 사용 |
| 3번 | **자연 조인 (Natural Join)** | **같은 이름의 컬럼** 자동 매칭 + **중복 컬럼 제거**

---

## 📌 갓반인용 핵심 요약 + 예시

### 1️⃣ 세타 조인 (Theta Join)
- 📌 **모든 비교 연산자 사용 가능**
- 💬 예시 상황: "너 점수 80점 이상인 애들만 조인해줘!"
- 예시:
  ```sql
  SELECT * FROM A, B WHERE A.score >= B.cutline;

2️⃣ 동등 조인 (Equi Join)
📌 조건은 오직 = 하나만

💬 예시 상황: "학번이 같은 애들끼리 연결해!"

예시:

SELECT * FROM Student S, Score T WHERE S.id = T.id;


3️⃣ 자연 조인 (Natural Join)
📌 같은 이름 컬럼 자동 연결 + 중복 제거

💬 예시 상황: "같은 이름인 컬럼은 알아서 붙여줄게. 중복도 없앴어"

예시:
SELECT * FROM Student NATURAL JOIN Score;

### 📌 관련 개념: 조인의 종류

#### 📊 조인 한눈 요약

| 조인 종류     | 특징 |
|--------------|----------------------------------------------------|
| 세타 조인     | 다양한 연산자 비교 가능 (`=`, `<`, `>`, `!=` 등) |
| 동등 조인     | `=`만 사용 |
| 자연 조인     | 같은 컬럼 자동 연결 + 중복 제거 |
| 내부 조인     | 조건 맞는 것만 결과 |
| 외부 조인     | 조건 안 맞아도 한쪽 데이터는 전부 출력 |
| 자기 조인     | 같은 테이블을 두 번 불러서 비교 |

---

### 📌 데이터베이스 설계 3단계 요약

| 단계         | 설명 |
|--------------|-----------------------------|
| 개념적 설계  | ERD 그리는 단계 (DBMS 독립적) |
| 논리적 설계  | 정규화하고 테이블 설계 |
| 물리적 설계  | 실제 저장 방법, 인덱스 등 구현 관여 |


 ----------------------------------------------------------------------------------

## 📝 문제 8) 페이지 교체 알고리즘 - LRU / LFU 부재 횟수 계산

### ❓ 문제
다음 **페이지 참조 순서**를 고려하여  
**LRU**(Least Recently Used)와 **LFU**(Least Frequently Used) 알고리즘에 따른 **페이지 부재 횟수**를 구하시오.

> 페이지 프레임 수: **3개**

#### 📌 페이지 참조 순서:
1, 2, 3, 1, 2, 4, 1, 2, 5, 7


---

### ✅ 정답

- **LRU:** `6`
- **LFU:** `6`

---

### 🔍 시뮬레이션 해설

#### ✅ LRU (가장 오랫동안 사용되지 않은 페이지 교체)

| Step | 참조 페이지 | 프레임 상태         | 페이지 부재(O/X) |
|------|-------------|----------------------|------------------|
| 1    | 1           | 1 - -                | O                |
| 2    | 2           | 1 2 -                | O                |
| 3    | 3           | 1 2 3                | O                |
| 4    | 1           | 2 3 1 (1 사용됨)     | X                |
| 5    | 2           | 3 1 2 (2 사용됨)     | X                |
| 6    | 4           | 1 2 4 (3 제거)       | O                |
| 7    | 1           | 2 4 1 (1 사용됨)     | X                |
| 8    | 2           | 4 1 2 (2 사용됨)     | X                |
| 9    | 5           | 1 2 5 (4 제거)       | O                |
| 10   | 7           | 2 5 7 (1 제거)       | O                |

- **총 부재 횟수:** `6`

---

#### ✅ LFU (가장 적게 사용된 페이지 교체)

| Step | 참조 | 프레임 상태 (카운트)         | 부재(O/X) | 교체 기준 |
|------|------|-------------------------------|-----------|------------|
| 1    | 1    | 1(1) - -                       | O         |            |
| 2    | 2    | 1(1) 2(1) -                    | O         |            |
| 3    | 3    | 1(1) 2(1) 3(1)                 | O         |            |
| 4    | 1    | 1(2) 2(1) 3(1)                 | X         |            |
| 5    | 2    | 1(2) 2(2) 3(1)                 | X         |            |
| 6    | 4    | 1(2) 2(2) 4(1) (3 제거)        | O         | 3이 최소   |
| 7    | 1    | 1(3) 2(2) 4(1)                 | X         |            |
| 8    | 2    | 1(3) 2(3) 4(1)                 | X         |            |
| 9    | 5    | 1(3) 2(3) 5(1) (4 제거)        | O         | 4이 최소   |
| 10   | 7    | 1(3) 2(3) 7(1) (5 제거)        | O         | 5가 최소   |

- **총 부재 횟수:** `6`


### 📌 페이지 교체 알고리즘 요약

| 알고리즘 | 뜻 | 동작 방식 | 갓반인 예시 |
|----------|-----|-----------|--------------|
| **LRU**  | Least Recently Used | 가장 오래 전에 사용된 페이지를 교체 | 오래 전에 꺼낸 도시락부터 버리는 느낌 |
| **LFU**  | Least Frequently Used | 사용 횟수가 가장 적은 페이지를 교체 | 거의 안 쓰는 물건부터 버리는 느낌 |

---

### ✅ 핵심 차이
- **LRU**: **"언제 마지막으로 썼는지"**에 집중  
  → 최근에 안 쓴 애를 교체  
- **LFU**: **"얼마나 자주 썼는지"**에 집중  
  → 사용 횟수 적은 애를 교체

---

### 🧠 요약 암기
- **LRU** = "오래 안 쓴 거 out"
- **LFU** = "잘 안 쓰는 거 out"
---

### 📌 관련 개념 요약

#### 🔹 페이지 교체 알고리즘 종류

| 알고리즘 | 설명 | 갓반인 비유 |
|----------|------|-------------|
| **FIFO** | 먼저 들어온 페이지 제거 | 줄 먼저 선 애부터 퇴장 |
| **LRU** | 가장 오래 전에 사용된 페이지 제거 | 도시락 오래 안 먹은 애 버림 |
| **LFU** | 가장 적게 사용된 페이지 제거 | 거의 안 쓰는 앱부터 삭제 |
| **OPT** | 앞으로 가장 오랫동안 사용 안 될 페이지 제거 (이론상 최적) | 미래 예지해서 안 쓸 거 버림 |
| **SCR (Second Chance)** | FIFO + 사용 여부 확인 | 한 번 기회 주고 다시 FIFO |
| **NUR** | 사용/수정 비트 기반 교체 | 최근 안 쓴 & 안 고친 애부터 교체 |

---

### 📌 프로세스 스케줄링 알고리즘

| 구분 | 설명 | 대표 알고리즘 |
|------|------|----------------|
| **선점형** | CPU를 뺏어올 수 있음 | Round Robin, SRT, MLFQ |
| **비선점형** | CPU를 끝날 때까지 줌 | FCFS, SJF, HRN, 우선순위 |

---

### ✅ 핵심 요약

- **LRU** → "시간 기준" (언제 마지막으로 썼는지)
- **LFU** → "횟수 기준" (얼마나 자주 썼는지)
- **같은 횟수일 경우** → LFU는 먼저 들어온 페이지 제거 가능
- 문제 기준: 두 방식 모두 **페이지 부재 6회**

------------------------------------------------------------------
## ✅ 문제 10

> **다음 표에서 나타내고 있는 정규형을 쓰시오.**

| 학생 아이디 | 강좌명 | 담당 강사 |
|:-----------:|:------:|:---------:|
| 001         | 영어   | P001      |
| 002         | 한국사 | P002      |
| 003         | 영어   | P001      |
| 003         | 한국사 | P004      |
| 004         | 영어   | P003      |
| 004         | 한국사 | P004      |

---
## 🔎 정규화 분석 (정답: 제2정규형)

| 항목 | 내용 |
|------|------|
| 📌 기본키 후보 | (학생 아이디, 강좌명) |
| 🔄 함수 종속성 | (학생 아이디, 강좌명) → 담당 강사 <br> 강좌명 → 담당 강사 (👉 **이행적 종속**) |
| ✅ 제2정규형(2NF) | **부분 함수 종속 없음** |
| ❌ 제3정규형(3NF) 아님 | **비프라이머리 속성(담당 강사)**이 **기본키 아닌 속성(강좌명)**에 종속됨 |

🧠 **쉽게 말하면**  
- "담당 강사"는 "강좌명"만 알면 정해진다  
- 근데 "강좌명"은 기본키가 아님 → 이행적 종속!  
- 그래서 **3NF 아님**, 아직 **2NF 단계**임

---

## 💡 제3정규형으로 바꾸기 (분해)

### 학생수강 테이블 (학생이 어떤 과목 들었는지)

| 학생 아이디 | 강좌명 |
|-------------|--------|
| 001         | 영어   |
| 002         | 한국사 |
| 003         | 영어   |
| 003         | 한국사 |
| 004         | 영어   |
| 004         | 한국사 |

### 강좌 테이블 (과목별 강사 매핑)

| 강좌명 | 담당 강사 |
|--------|------------|
| 영어   | P001 / P003 |
| 한국사 | P002 / P004 |

⚠️ **주의!**  
한 과목에 **여러 명의 강사**가 있을 수도 있어서  
"1:N 관계인지", "강사별 시간표가 다른 건지" 등은 **추가 분석 필요**!

---

## ✅ 최종 정답: **제2정규형(2NF)**

🎯 **암기 포인트 요약**

| 정규형 | 핵심 조건 | 예시 비유 |
|--------|-----------|-----------|
| 1NF | 셀마다 원자값 | 셀에 값 여러 개 넣지 마! |
| 2NF | **부분 함수 종속 없음** | 전체 키로만 결정되게 |
| 3NF | **이행적 종속 없음** | A → B → C 형태 금지 (B는 키 아니면 안 돼!) |


  ----------------------------------------------------------------------------------

## 📝 문제 11) SQL 실행 결과 작성

### ❓ 문제
아래 SQL 문장을 수행하였을 때의 결과를 표로 작성하시오.


select b from t1
where c in
(
  select c from t2
  where d = 'k'
)
```

---

### 📋 테이블 정보

#### t1

| a | b | c |
|---|---|---|
| 1 | a | x |
| 2 | b | x |
| 1 | c | w |
| 3 | d | w |

#### t2

| c | d | e |
|---|---|---|
| x | k | 3 |
| y | k | 3 |
| z | s | 2 |

---

### ✅ 풀이 과정

1. **서브쿼리 실행**

select c from t2 where d = 'k'
```

→ 결과:

| c |
|---|
| x |
| y |

즉, c 값은 `'x'` 또는 `'y'`.

---

2. **외부 쿼리 실행**

select b from t1 where c in ('x', 'y')
```

t1에서 c가 `'x'` 또는 `'y'`인 레코드 찾기:

- t1에서 c = 'x'

| a | b | c |
|---|---|---|
| 1 | a | x |
| 2 | b | x |

- t1에서 c = 'y'

없음

---

### ✅ 최종 결과

| b |
|---|
| a |
| b |

---

### 📌 요약
- 서브쿼리에서 `d = 'k'`인 t2의 c 값 → `x`, `y`
- t1에서 c 값이 이 값들에 해당하는 행의 b 컬럼 출력
- 최종 결과는 **a**, **b**

  ---------------------------------------------------------------------------------- 
## 📝 문제

❓ 문제  
아래 SQL 문장을 수행하였을 때의 결과를 표로 작성하시오.

```sql
select
  count(*)
from table
where empno > 100
  and sal >= 3000
  or empno = 200
```

---

### 📋 테이블 정보

| empno | sal  |
|-------|------|
| 100   | 1000 |
| 200   | 3000 |
| 300   | 1500 |

---

### ✅ 풀이 과정

조건식을 괄호로 구분하면 아래와 같다:

```
(empno > 100 AND sal >= 3000) OR (empno = 200)
```

행별 조건 평가:

| empno | sal  | 조건 1: empno > 100 AND sal >= 3000 | 조건 2: empno = 200 | 전체 조건 결과 |
|-------|------|------------------------------------|----------------------|-----------------|
| 100   | 1000 | False (100 > 100 ? No)             | False                | False           |
| 200   | 3000 | True (200 > 100 AND 3000 ≥ 3000)   | True                 | True            |
| 300   | 1500 | False (1500 < 3000)                | False                | False           |

- 조건을 만족하는 행은 **empno = 200** 한 건 뿐

---

### ✅ 최종 결과

| count(*) |
|----------|
| 1        |

---

### 📌 요약

- AND 연산이 OR보다 우선순위가 높음
- 조건은 아래처럼 해석됨:
  - `(empno > 100 AND sal >= 3000) OR (empno = 200)`
- 조건을 만족하는 것은 **empno = 200** 한 건
- 최종 결과는 `count(*) = 1`


  ---------------------------------------------------------------------------------- 

## 📝 문제 13) C언어 코드 출력 결과

### ❓ 문제 코드

#include <stdio.h>

int main(){
    int v1 = 0, v2 = 35, v3 = 29;           // v1=0, v2=35, v3=29으로 초기화
    
                                                    // 조건문 (삼항 연산자): v1 > v2 ? v2 : v1
                                                    // v1(0) > v2(35) 는 거짓(false) 이므로, v1의 값인 0이 반환된다.
                                                    // 따라서 if(0) 이 된다.
    if (v1 > v2 ? v2 : v1) {                           // if (0) 이므로 이 블록은 실행되지 않는다.
        v2 = v2 << 2;                                 // << 는 왼쪽 비트 시프트 연산자. 숫자를 2의 제곱만큼 곱하는 것과 같다.
    } else {                                         // if 조건이 거짓(0)이므로 else 블록이 실행된다.
        v3 = v3 << 2;                                 // v3의 값을 왼쪽으로 2비트 시프트한다.
                                                    // 29를 왼쪽으로 2비트 시프트하면 29 * (2^2) = 29 * 4 = 116이 된다.
                                                    // 따라서 v3는 116이 된다.
    }
                                                    
                                                    // printf("%d", v2 + v3);
                                                    // v2는 여전히 35이고, v3는 116이다.
                                                    // 35 + 116 = 151
    printf("%d", v2 + v3);
}


### ✅ C 코드 실행 흐름 설명 (그대로 마크다운)

변수 초기값: v1 = 0, v2 = 35, v3 = 29로 시작한다.

조건문 계산: if (v1 > v2 ? v2 : v1) 이 부분은 if (0 > 35 ? 35 : 0) 이 된다.  
0 > 35는 당연히 거짓(false) 이지?  
그럼 ? 뒤에 : 다음에 오는 0이 선택된다.  
결국 if (0) 이 된다.

if (0)은 거짓: C언어에서 0은 거짓을 의미한다.  
그래서 if 블록(v2 = v2 << 2;)은 실행 안 되고,  
else 블록(v3 = v3 << 2;)이 실행된다.

---

### 🧠 v3 = v3 << 2; 이게 뭔데?

이게 핵심인데, `<<` 이건 '비트 시프트' 연산자다.  
쉽게 말해서 숫자를 2의 거듭제곱만큼 곱하는 거랑 똑같다고 보면 된다.

v3는 처음에 29였지?

v3 << 2는 29를 왼쪽으로 2비트 옮기는 거야.  
이건 `29 * (2의 2승)` 이랑 같아.

2의 2승은 4니까, 결국 `29 * 4`가 된다.  
29 * 4 = 116이다.  
그래서 v3는 이제 116이 되는 거지.

---

### ✅ 최종 결과

- v1은 계속 0.  
- v2는 if 블록을 안 탔으니 초기값 그대로 35.  
- v3는 else 블록에서 116으로 바뀌었다.

마지막 줄 `printf("%d", v2 + v3);` 는  
v2와 v3를 더해서 출력하라는 거잖아?

**35 + 116 = 151**

---------------------------------------------------------------------------------- 

## 📝 문제 14) C언어 코드 출력 결과

### ❓ 문제 코드
#include <stdio.h>    // 표준 입출력 함수 (printf)를 사용하기 위해 필요하다.
#include <string.h>   // 문자열 관련 함수 (strlen)를 사용하기 위해 필요하다.

// reverse 함수: char 포인터 'str'을 입력받아 해당 문자열을 뒤집는다.
// 'void'이므로 반환값은 없다. 문자열 자체가 변경된다.
void reverse(char* str) {
    int len = strlen(str);        // strlen(str): 문자열 'str'의 길이를 계산한다. (널 문자 제외)
                                 // 예: "ABCDEFGH"의 길이는 8이다.
    char* p1 = str;               // p1 포인터: 문자열의 시작 주소를 가리킨다. (즉, 'A'를 가리킴)
    char* p2 = str + len - 1;    // p2 포인터: 문자열의 끝 문자(널 문자 바로 앞)의 주소를 가리킨다.
                                 // str + 8 - 1 = str + 7. (즉, 'H'를 가리킴)

    // while 루프: p1이 p2보다 작을 동안 반복한다. (p1이 p2를 넘거나 같아지면 종료)
    // 문자열 양 끝에서 가운데로 오면서 문자를 교환하는 방식이다.
    while (p1 < p2) {
        char t = *p1;   // 임시 변수 't'에 p1이 가리키는 문자 저장 (temp)
        *p1 = *p2;      // p1 위치에 p2 문자를 덮어씀
        *p2 = t;        // p2 위치에 임시 변수 문자를 덮어씀
        p1++;           // p1을 오른쪽으로 한 칸 이동
        p2--;           // p2를 왼쪽으로 한 칸 이동
    }
    // 루프 종료 후 문자열이 역순으로 뒤집힌다.
    // 예: "ABCDEFGH" -> "HGFEDCBA"
}

int main(int argc, char* argv[]) {
    char str[100] = "ABCDEFGH";  // 문자열 초기화 (널 문자 포함 총 9바이트)
    reverse(str);                // 문자열 뒤집기 → "HGFEDCBA"
    int len = strlen(str);       // 길이 다시 계산 (8)

    // 인덱스 1, 3, 5, 7에 해당하는 문자만 출력
    for (int i = 1; i < len; i += 2) {
        printf("%c", str[i]);    // 각각 G, F, D, B 출력
    }
    printf("\n");                // 줄 바꿈
    return 0;                   // 정상 종료
}

🚀 최종 출력 결과
GFDB

🔍 동작 설명
char str[100] = "ABCDEFGH";
초기 문자열은 "ABCDEFGH"다.

reverse(str);
str이 **"HGFEDCBA"**로 뒤집힌다.

int len = strlen(str);
문자열 길이 len은 여전히 8이다.

for (int i = 1; i < len; i += 2)
뒤집힌 문자열 "HGFEDCBA"에서 인덱스 1, 3, 5, 7 문자만 출력한다.

i=1: str[1] = 'G'
i=3: str[3] = 'F'
i=5: str[5] = 'D'
i=7: str[7] = 'B'


---------------------------------------------------------------------------------- 

## 📝 문제 15) C언어 코드 출력 결과

### ❓ 문제 코드 (오류 및 누락 보완 포함)

#include <stdio.h>                         // 표준 입출력 함수 (printf)를 사용하기 위해 필요해.

                                          // ACC 구조체: 계좌 정보를 담는 틀을 만들어.
struct ACC {
    int accNum;                           // 계좌 번호를 저장할 정수형 변수야.
    double bal;                             // 잔액을 저장할 실수형 변수야. (double은 더 정밀한 실수)
};

void init(struct ACC *acc, int x, double y): 계좌 초기화 함수

                // init 함수: ACC 구조체 포인터 'acc'와 계좌 번호 'x', 초기 잔액 'y'를 입력받아 계좌를 초기화해.
                // 포인터를 사용해서 원본 ACC 구조체 변수의 값을 직접 변경한다.
void init(struct ACC *acc, int x, double y) {
    acc->accNum = x; // acc 포인터가 가리키는 곳의 accNum 멤버에 'x' 값을 할당해.
    acc->bal = y;    // acc 포인터가 가리키는 곳의 bal 멤버에 'y' 값을 할당해.
}
double sim(double base, int year): 복리 계산 함수
// sim 함수: 'base' 값(곱할 비율)과 'year' 횟수를 입력받아 'base'를 'year'번 곱한 값을 반환해.
// 여기서는 복리 계산 시 이자율을 적용하는 역할을 해. (원금 포함)
double sim(double base, int year) {
    double r = 1.0; // 결과를 저장할 변수 'r'을 1.0으로 초기화해.
    for (int i = 0; i < year; i++) { // 'year' 횟수만큼 반복한다.
        r *= base; // 'r'에 'base'를 계속 곱해나간다. (예: base * base * base ...)
    }
    return r; // 계산된 최종 값(복리율)을 반환해.
}

void xxx(struct ACC* acc, double en): 입출금(?) 로직 함수

// xxx 함수: ACC 구조체 포인터 'acc'와 금액 'en'을 입력받아.
// 'en' 값의 양수/음수 여부가 아니라, 'en'이 양수이면서 현재 잔액보다 작은지 여부에 따라 동작이 달라진다.
void xxx(struct ACC* acc, double en) {
    // if 조건문: 'en'이 0보다 크고 (양수) 동시에 'en'이 현재 잔액(acc->bal)보다 작은 경우.
    // 이 조건은 '잔액 내에서 출금'을 시도하는 상황과 비슷해.
    if (en > 0 && en < acc->bal) {
        acc->bal -= en; // 잔액에서 'en' 값을 뺀다. (출금)
    } else { // 위 조건이 아닌 경우. (en이 0이하이거나, en이 양수인데 잔액보다 크거나 같은 경우)
        acc->bal += en; // 잔액에 'en' 값을 더한다. (입금 또는 잔액 초과 출금 시 더해짐)
    }
}

void yyy(struct ACC* acc): 복리 적용 함수
// yyy 함수: ACC 구조체 포인터 'acc'를 입력받아 계좌 잔액에 복리(sim 결과)를 적용한다.
void yyy(struct ACC* acc) {
    // acc->bal에 'sim(1.1, 3)'의 결과값을 곱한다.
    // sim(1.1, 3)은 위에서 계산했듯이 1.331을 반환한다.
    acc->bal *= sim(1.1, 3); // acc->bal = acc->bal * 1.331;
}

int main()int main() { // 프로그램 실행 흐름
    struct ACC acc; // 'acc'라는 이름의 ACC 구조체 변수를 선언해.
    init(&acc, 9981, 2200.0); // 1. acc 구조체 변수의 주소를 넘겨 init 함수를 호출해.
                              //    acc.accNum = 9981
                              //    acc.bal = 2200.0
                              
    xxx(&acc, 100.0);         // 2. acc 구조체의 주소와 100.0을 넘겨 xxx 함수를 호출해.
                              //    en = 100.0 (양수)
                              //    acc.bal = 2200.0
                              //    조건: (100.0 > 0 && 100.0 < 2200.0) -> 참 (true)이야.
                              //    그래서 acc.bal = 2200.0 - 100.0 = 2100.0이 돼.



    yyy(&acc);                // 3. acc 구조체의 주소를 넘겨 yyy 함수를 호출해.
                              //    acc.bal은 현재 2100.0이야.
                              //    sim(1.1, 3)은 1.331을 반환해.
                              //    그래서 acc.bal = 2100.0 * 1.331 = 2795.1이 돼.



    printf("%d and %0.2f\n", acc.accNum, acc.bal); // 4. acc.accNum과 acc.bal의 최종 값을 출력해.
                                                   //    %0.2f는 실수를 소수점 이하 두 자리까지 출력하라는 의미야.
    return 0;                                       // 프로그램 정상 종료를 알려.

}

🚀 최종 출력 결과
9981 and 2795.10


위의 실행 흐름에 따라 acc.accNum은 9981이고,
acc.bal은 최종적으로 2795.1이 돼.
printf의 %0.2f 서식 지정자에 따라 소수점 이하 두 자리까지 출력되므로 2795.10이 된다.



9981 and 2795.10

코드 분석:  
main 함수 시작:

- `struct ACC acc;` : ACC 구조체 타입의 acc라는 변수를 만든다.
- 이 안에 accNum (계좌 번호)랑 bal (잔액)이 들어간다.

- `init(&acc, 9981, 2200.0);` 호출:  
  init 함수는 계좌를 초기화하는 함수다.  
  acc.accNum은 9981로, acc.bal은 2200.0으로 세팅된다.

- `xxx(&acc, 100.0);` 호출:  
  xxx 함수는 돈을 넣거나 빼는 함수인데, 좀 특이하게 동작한다.  
  en 값은 100.0이다.  
  `if (en > 0 && en < acc->bal)` 이 조건식을 봐라.  
  100.0 > 0 (참) 이고 100.0 < 2200.0 (참) 이다.  
  둘 다 참이니까 if 블록 안의 코드가 실행된다.  
  `acc->bal -= en;` : 잔액에서 en 값을 뺀다.  
  acc.bal은 2200.0 - 100.0 = 2100.0이 된다.

- `yyy(&acc);` 호출:  
  yyy 함수는 잔액에 sim 함수의 결과를 곱한다.  
  `sim(1.1, 3)` 계산:  
  sim 함수는 base를 year번 곱하는 함수다. (쉽게 말해 base의 year 제곱)  
  1.1을 3번 곱하니까 1.1 * 1.1 * 1.1 = 1.331이 된다.  
  `acc->bal *= 1.331;` : 현재 잔액에 1.331을 곱한다.  
  acc.bal은 2100.0 * 1.331 = 2795.1이 된다.

- `printf("%d and %0.2f\n", acc.accNum, acc.bal);` :  
  최종적으로 acc.accNum (9981)과 acc.bal (2795.10)을 출력한다.  
  %.2f는 소수점 둘째 자리까지 표시하라는 뜻이다.

---------------------------------------------------------------------------------- 

## 📝 문제 16) C언어 코드 출력 결과

### ❓ 문제 코드 (오타 및 오류 수정 포함)

#include <stdio.h>                             // 표준 입출력 함수 (printf)를 사용하기 위해 필요하다.
#include <ctype.h>                           // 문자 타입을 확인하는 함수 (isupper, islower, isdigit)를 사용하기 위해 필요하다.

int main() {
    char p[] = "It is 8";                       // 🚩 원본 문자열: 'p' 배열에 "It is 8"을 저장한다. (널 문자 '\0'까지 포함)
    char result[20];                           // 🚩 변환된 문자를 저장할 'result' 배열을 선언한다. 크기는 20으로 충분하다.
    int i;                                       // 🚩 루프 제어 변수 'i'를 선언한다.

                                        // for 루프: 'p' 배열의 각 문자를 처음부터 끝(널 문자 '\0'를 만날 때까지)까지 하나씩 순회한다.
    for (i = 0; p[i] != '\0'; i++) {
                                                    // if (isupper(p[i])): 현재 문자 p[i]가 '대문자'인지 확인한다.
        if (isupper(p[i])) {
                                            // 대문자 변환 규칙: (현재 대문자의 아스키 코드 - 'A'의 아스키 코드 + 5) % 26 + 'A'
                                            // 'A'를 기준으로 몇 번째 문자인지 계산하고, 5칸 뒤로 민 다음 26으로 나눈 나머지(알파벳 개수)를 구한다.
                                            // 그리고 다시 'A'를 더해서 변환된 대문자의 아스키 코드를 얻는다.
                                            // 예시: p[0] = 'I'
                                            // ('I' - 'A' + 5) % 26 + 'A'
                                            // (73 - 65 + 5) % 26 + 65   -> (8 + 5) % 26 + 65 -> 13 % 26 + 65 -> 13 + 65 = 78
                                            // 78은 아스키 코드로 'N'이다.
            result[i] = (p[i] - 'A' + 5) % 26 + 'A';
        }
                                        // else if (islower(p[i])): 현재 문자 p[i]가 '소문자'인지 확인한다.
        else if (islower(p[i])) {
                                              // 소문자 변환 규칙: (현재 소문자의 아스키 코드 - 'a'의 아스키 코드 + 10) % 26 + 'a'
                                              // 'a'를 기준으로 몇 번째 문자인지 계산하고, 10칸 뒤로 민 다음 26으로 나눈 나머지(알파벳 개수)를 구한다.
                                              // 그리고 다시 'a'를 더해서 변환된 소문자의 아스키 코드를 얻는다.
                                              // 예시 1: p[1] = 't'
                                              // ('t' - 'a' + 10) % 26 + 'a'
                                              // (116 - 97 + 10) % 26 + 97 -> (19 + 10) % 26 + 97 -> 29 % 26 + 97 -> 3 + 97 = 100
                                              // 100은 아스키 코드로 'd'이다.
                                              // 예시 2: p[3] = 'i'
                                              // ('i' - 'a' + 10) % 26 + 'a'
                                              // (105 - 97 + 10) % 26 + 97 -> (8 + 10) % 26 + 97 -> 18 % 26 + 97 -> 18 + 97 = 115
                                              // 115는 아스키 코드로 's'이다.
                                              // 예시 3: p[6] = 's'
                                              // ('s' - 'a' + 10) % 26 + 'a'
                                              // (115 - 97 + 10) % 26 + 97 -> (18 + 10) % 26 + 97 -> 28 % 26 + 97 -> 2 + 97 = 99
                                              // 99는 아스키 코드로 'c'이다.
            result[i] = (p[i] - 'a' + 10) % 26 + 'a';
        }
                                          // else if (isdigit(p[i])): 현재 문자 p[i]가 '숫자'인지 확인한다.
        else if (isdigit(p[i])) {
                                                // 숫자 변환 규칙: (현재 숫자의 아스키 코드 - '0'의 아스키 코드 + 3) % 10 + '0'
                                                // '0'을 기준으로 몇 번째 숫자인지 계산하고, 3칸 뒤로 민 다음 10으로 나눈 나머지(숫자 개수)를 구한다.
                                                // 그리고 다시 '0'을 더해서 변환된 숫자의 아스키 코드를 얻는다.
                                                // 예시: p[6] = '8' (원본 문자열의 7번째 문자)
                                                // ('8' - '0' + 3) % 10 + '0'
                                                // (56 - 48 + 3) % 10 + 48 -> (8 + 3) % 10 + 48 -> 11 % 10 + 48 -> 1 + 48 = 49
                                                // 49는 아스키 코드로 '1'이다.
            result[i] = (p[i] - '0' + 3) % 10 + '0';
        }
                                                // else: 위 조건들(대문자, 소문자, 숫자)에 해당하지 않는 경우 (공백, 특수문자 등)
        else {
            result[i] = p[i];                     // 변환 없이 원본 문자를 그대로 'result'에 복사한다.
                                          // 예시: p[2] = ' ' (공백), p[5] = ' ' (공백) -> 그대로 ' '으로 복사.
        }
    }
    result[i] = '\0';                           // 🚩 루프가 끝난 후, 'result' 문자열의 마지막에 널 문자('\0')를 붙여서
                                              // 문자열의 끝을 명확히 표시한다. 이게 없으면 printf가 이상한 값까지 읽을 수 있다.

    printf("%s\n", result);                 // 🚩 최종적으로 'result' 배열에 저장된 변환된 문자열을 출력한다.
    return 0;                                 // 프로그램이 정상적으로 종료되었음을 알린다.
}

🔍 문자열 p = "It is 8" 변환 과정 상세 추적  
원본 문자열: "I t   i s   8"

| 인덱스 | 원본 문자 p[i] | 분류    | 변환식                                      | 계산 과정                             | 변환 문자 result[i] |
|--------|---------------|---------|--------------------------------------------|-------------------------------------|---------------------|
| 0      | 'I'           | 대문자  | ('I' - 'A' + 5) % 26 + 'A'                  | (8 + 5) % 26 + 'A' = 13 + 'A'       | 'N'                 |
| 1      | 't'           | 소문자  | ('t' - 'a' + 10) % 26 + 'a'                 | (19 + 10) % 26 + 'a' = 3 + 'a'      | 'd'                 |
| 2      | ' '           | 기타    | 그대로                                    |                                     | ' '                 |
| 3      | 'i'           | 소문자  | ('i' - 'a' + 10) % 26 + 'a'                 | (8 + 10) % 26 + 'a' = 18 + 'a'      | 's'                 |
| 4      | 's'           | 소문자  | ('s' - 'a' + 10) % 26 + 'a'                 | (18 + 10) % 26 + 'a' = 2 + 'a'      | 'c'                 |
| 5      | ' '           | 기타    | 그대로                                    |                                     | ' '                 |
| 6      | '8'           | 숫자    | ('8' - '0' + 3) % 10 + '0'                  | (8 + 3) % 10 + '0' = 1 + '0'        | '1'                 |
| 7      | '\0'          | 널 문자 | 루프 종료 및 문자열 끝 표시                  |                                     | '\0'                |

🚀 최종 출력 결과  
변환된 result 배열의 내용을 합치면:

**Nd sc 1**

---------------------------------------------------------------------------------- 
## 📝 문제 17) Java 코드 실행 순서

### ❓ 문제 코드 (오타 수정 및 구조 보완)


class P {                     // 'P'라는 부모 클래스를 정의한다.
    int x, y;                   // 🚩 인스턴스 변수: 'x'와 'y'를 선언한다. 이 변수들은 P 클래스 객체의 고유한 상태를 나타낸다.

                                                    // P(int x, int y): 'P' 클래스의 생성자다.
                                                    // 객체가 생성될 때 호출되며, 전달받은 'x'와 'y' 값으로 인스턴스 변수를 초기화한다.
    P(int x, int y) {
        this.x = x;                               // 매개변수 x의 값을 인스턴스 변수 x에 할당한다.
        this.y = y;                                 // 매개변수 y의 값을 인스턴스 변수 y에 할당한다.
    }

                                                      // int getData(): 'getData' 메서드다. x와 y를 곱한 값을 반환한다.
                                                      // 이 메서드는 매개변수가 없는 형태다.
    int getData() {
        return x * y;
    }
}

class C extends P {                           // 'C' 클래스는 'P' 클래스를 상속받는다.
    int x;                             // 🚩 인스턴스 변수: 부모 클래스 P에도 'x'가 있지만, C 클래스에서 'x'를 다시 선언했다.
                                     // 이것은 '변수 가리기(Variable Hiding)'라고 한다.
                                   // C 객체는 P로부터 상속받은 'x'와 C 자체의 'x'를 둘 다 가지게 된다.
                                         // 일반적으로는 혼란을 피하기 위해 이런 식으로 변수 이름을 겹치지 않도록 한다.

                                              // C(int x): 'C' 클래스의 생성자다.
    C(int x) {
                                                        // super(x + 1, x);: 💡 중요! 부모 클래스 'P'의 생성자를 호출한다.
                                                        // 이 때, 부모 P의 x는 (전달받은 x + 1)로, P의 y는 (전달받은 x)로 초기화된다.
                                                        // 예: C(10) 호출 시 -> super(10 + 1, 10) -> super(11, 10)
                                                        //    따라서 P 객체 부분의 x는 11, y는 10이 된다.
        super(x + 1, x);
        this.x = x;                               // 자식 클래스 C 자신의 'x' 변수를 전달받은 'x' 값으로 초기화한다.
                                            // 예: C(10) 호출 시 -> C 객체의 x는 10이 된다.
    }

                                        // int getData(int n): 'getData' 메서드다. 매개변수 'n'이 있는 형태다.
                                        // 부모 클래스 P에도 'getData()' 메서드가 있지만, 이 메서드는 매개변수가 다르므로 '오버로딩(Overloading)'이다.
                                        // 오버라이딩(Override)이 아니다!
    int getData(int n) {
                                                    // super.getData(): 💡 중요! 부모 클래스 'P'의 'getData()' 메서드를 호출한다.
                                                    // 즉, P의 x와 P의 y를 곱한 값을 가져온다. (이 경우 11 * 10 = 110)
                                                    // 그리고 그 값에 매개변수 'n'을 더해서 반환한다.
        return super.getData() + n;
    }
                                                      // P 클래스에는 x와 y라는 인스턴스 변수가 있다.
                                                      // **생성자 P(int x, int y)**는 이 변수들을 초기화한다.
                                                      // getData() 메서드는 x * y 값을 반환한다.
                                              // public static void main(String[] args): 프로그램의 시작점이다.
    public static void main(String[] args) {
                                            // P p = new C(10);: 💡 다형성(Polymorphism)!
                                            // 'P' 타입의 참조 변수 'p'가 'C' 타입의 객체를 참조한다.
                                            // 즉, p는 C 객체를 가리키고 있지만, p가 접근할 수 있는 메서드나 변수는 컴파일 시점의 타입인 'P'에 정의된 것들이다.
                                            // 다만, 오버라이딩된 메서드는 런타임에 실제 객체 타입에 따라 호출된다 (동적 바인딩).
                                            // 여기서는 C(10) 생성자가 호출되므로,
                                            //   - P의 x는 11, y는 10으로 초기화되고,
                                            //   - C의 x는 10으로 초기화된다.
                                    
                                          # 클래스 C와 P의 관계 및 동작 설명
                                          
                                          - C 클래스는 P 클래스를 상속받는다.
                                          
                                          - 멤버 변수
                                            - `int x;`  
                                              C 클래스에도 `x`가 선언되어 **변수 가리기(Variable Hiding)**가 발생한다.  
                                              즉, C 객체는 부모 P로부터 상속받은 `x`와 C 자신의 `x`를 모두 가진다.
                                          - 생성자 `C(int x)`
                                            - `super(x + 1, x)`를 호출하여 부모 P의 `x`와 `y`를 초기화한다.  
                                            - 이후 `this.x = x;`로 자식 C 자신의 `x`를 초기화한다.
                                          
                                          - 예시: `new C(10)` 호출 시
                                            - 부모 P의 `x`는 `10 + 1 = 11`이 된다.
                                            - 부모 P의 `y`는 `10`이 된다.
                                            - 자식 C 자신의 `x`는 `10`이 된다.
                                          
                                          - 메서드 `int getData(int n)`
                                            - 부모 클래스 P의 `getData()`와 이름은 같지만 매개변수가 다르므로 **오버로딩(Overloading)**이다.
                                            - `super.getData()`를 호출하여 부모 P의 `getData()`를 실행하고, P의 `x * y` 값을 가져온다.


                                            
        P p = new C(10);

                                                  // System.out.println(p.getData());: 'p' 변수를 통해 'getData()' 메서드를 호출한다.
                                                  // 💡 중요! p는 'P' 타입이므로, 'P' 클래스에 정의된 매개변수 없는 'getData()' 메서드가 호출된다.
                                                  // 'C' 클래스에 있는 'getData(int n)'은 매개변수가 다르기 때문에 호출되지 않는다.
                                                  // 따라서, P 객체 부분의 x와 y (각각 11과 10)를 곱한 결과인 11 * 10 = 110이 반환된다.
        System.out.println(p.getData());
    }

}
                              P p = new C(10);: p는 Parent 타입으로 선언되었지만, 실제 객체는 Child다.
                              C(10) 생성자 호출:
                              super(10 + 1, 10) -> 부모 P의 x = 11, y = 10
                              this.x = 10 -> 자식 C의 x = 10
                              System.out.println(p.getData());: 이 호출이 핵심이다.
                              
                              p의 **선언된 타입이 P**이기 때문에, P 클래스에 있는 매개변수 없는 getData() 메서드가 호출된다.
                              이 P의 getData()는 P 자신의 x와 y를 곱하므로, 11 * 10 = 110이 된다.
                              만약 C 클래스에서 getData() 메서드를 오버라이딩했다면(즉, 매개변수 없는 getData()를 재정의했다면) C의 메서드가 호출되었을 것이다. 
                              하지만 여기서는 오버로딩(getData(int n))만 했으므로 부모 메서드가 호출된다.

답: 110


---------------------------------------------------------------------------------- 

## 📝 문제 18) Java 코드 출력 결과

### ❓ 문제 코드 (오타 및 수정 반영)

class Connection {
                                              // private static Connection _inst = null; : 🚩 '_inst'는 Connection 클래스의 유일한 인스턴스를 저장할 static 변수다.
                                              // 'static'이니까 모든 Connection 객체가 아닌, 클래스 자체에 속하는 변수고, 프로그램 실행 시 딱 한 번 생성된다.
                                              // 'private'이니까 외부에서 직접 접근 못 하고, 'null'로 초기화되어 아직 인스턴스가 없음을 나타낸다.
    private static Connection _inst = null;

                                // private int count = 0; : 🚩 이 Connection 인스턴스의 상태를 나타내는 인스턴스 변수다.
                                // 이 변수는 Connection 객체가 만들어질 때마다 생성되지만, 싱글톤 패턴이므로 단 하나의 객체만 만들어져서 이 변수도 유일하게 존재한다.
    private int count = 0;

                                                    // static public Connection get(): 🚩 이 메서드는 Connection 인스턴스를 얻는 유일한 방법이다.
                                                    // 'static'이라서 Connection 클래스명.get() 처럼 객체 생성 없이 호출할 수 있다.
                                                    // 'public'이라서 어디서든 호출 가능하다.
    static public Connection get() {
                                                  // if (_inst == null): 💡 핵심! _inst가 아직 생성되지 않았는지 (null인지) 확인한다.
        if (_inst == null) {
                                                  // _inst = new Connection();: _inst가 null이면, 새로운 Connection 인스턴스를 딱 한 번만 생성한다.
                                                  // 이후부터는 이 코드가 다시 실행되지 않는다.
            _inst = new Connection();
            return _inst;                                 // 새로 만든 인스턴스를 반환한다.
        }
                                                    // return _inst;: _inst가 이미 생성되어 있으면, 기존에 만들어둔 그 유일한 인스턴스를 반환한다.
        return _inst;
    }
                                                      
                                                          // public void count(): 'count' 인스턴스 변수의 값을 1 증가시킨다.
                                                          // 이 메서드는 인스턴스 메서드이므로, Connection 객체를 통해 호출해야 한다.
    public void count() {
        count++;
    }
                                                      
                                                          // public int getCount(): 'count' 인스턴스 변수의 현재 값을 반환한다.
                                                          // 이 메서드도 인스턴스 메서드다.
    public int getCount() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) {
                                                          // Connection conn1 = Connection.get();: 'Connection.get()'을 호출하여 Connection 인스턴스를 얻는다.
                                                          // 이때 _inst가 null이므로, 새로운 Connection 객체가 생성되고 conn1이 이를 참조한다.
                                                          // Connection._inst = (새로운 객체)
        Connection conn1 = Connection.get();
        conn1.count();                                         // conn1 (유일한 Connection 객체)의 count 값을 1 증가시킨다.
                                                               // count = 1

                                                // Connection conn2 = Connection.get();: 다시 'Connection.get()'을 호출한다.
                                                // 이때 _inst는 null이 아니므로, 새로운 객체가 생성되지 않고 기존의 _inst (conn1이 참조하는 그 객체)를 반환한다.
                                                // 따라서 conn2도 conn1과 동일한 Connection 객체를 참조한다.
        Connection conn2 = Connection.get();
        conn2.count();                               // conn2 (conn1과 동일한 객체)의 count 값을 1 증가시킨다.
                                                   // count = 2

                                                // Connection conn3 = Connection.get();: 또 다시 'Connection.get()'을 호출한다.
                                                // 마찬가지로 기존의 _inst (conn1, conn2와 동일한 객체)를 반환한다.
                                                // conn3도 conn1, conn2와 동일한 Connection 객체를 참조한다.
        Connection conn3 = Connection.get();
        conn3.count();                       // conn3 (conn1, conn2와 동일한 객체)의 count 값을 1 증가시킨다.
                                             // count = 3

        conn1.count();                 // conn1 (역시 유일한 Connection 객체)의 count 값을 1 증가시킨다.
                                   // count = 4

                                  // System.out.print(conn1.getCount());: conn1 (유일한 Connection 객체)의 최종 count 값을 출력한다.
        System.out.print(conn1.getCount());
    }
}

🚀 최종 출력 결과  
**4**


Connection.get()을 여러 번 호출하지만, 모든 conn1, conn2, conn3 변수는 결국 메모리 상의 동일한 Connection 객체를 참조하게 된다.

따라서 conn1.count(), conn2.count(), conn3.count(), conn1.count()는 모두 동일한 객체의 count 변수를 증가시킨다.

초기 count = 0

conn1.count() -> count = 1

conn2.count() -> count = 2

conn3.count() -> count = 3

conn1.count() -> count = 4

🚀 최종 출력 결과  
최종적으로 conn1.getCount()를 호출하면, 모든 count() 호출로 인해 증가된 최종 count 값인 4가 출력된다.

**4**


---------------------------------------------------------------------------------- 

## 📝 문제 19) Java 코드 출력 결과

### 문제 코드

class One {                     // 'One'이라는 부모 클래스를 정의한다.
    int a, b;               // 🚩 인스턴스 변수: 'a'와 'b'를 선언한다. One 클래스 객체의 고유한 상태를 나타낸다.

                                                      // public One(int a, int b): 'One' 클래스의 생성자다.
                                                      // 객체가 생성될 때 호출되며, 전달받은 'a'와 'b' 값으로 인스턴스 변수를 초기화한다.
    public One(int a, int int b) {
        this.a = a;                                     // 매개변수 a의 값을 인스턴스 변수 a에 할당한다.
        this.b = b;                                   // 매개변수 b의 값을 인스턴스 변수 b에 할당한다.
    }

                                                      // public void print(): 'print' 메서드다. a와 b를 더한 값을 출력한다.
    public void print() {
        System.out.println(a + b);
    }
}

class Two extends One {                               // 'Two' 클래스는 'One' 클래스를 상속받는다.
    int po = 3;                               // 🚩 인스턴스 변수: 'po'를 선언하고 3으로 초기화한다. Two 클래스 객체의 고유한 상태다.

                                                // public Two(int i): 'Two' 클래스의 생성자다.
    public Two(int i) {
                                                    // super(i, i + 1);: 💡 중요! 부모 클래스 'One'의 생성자를 호출한다.
                                                    // 이 때, 부모 One의 'a'는 전달받은 'i'로, 'b'는 'i + 1'로 초기화된다.
                                                    // 예: Two(10) 호출 시 -> super(10, 10 + 1) -> super(10, 11)
                                                    //    따라서 One 객체 부분의 a는 10, b는 11이 된다.
        super(i, i + 1);
    }

                                                // public void print(): 💡 개중요! 부모 클래스 One의 print() 메서드를 '오버라이딩(Overriding)'했다.
                                                // 오버라이딩: 부모 클래스가 가진 메서드와 '이름, 매개변수, 반환 타입'이 모두 같게 재정의하는 것을 말한다.
                                                // 이 메서드는 'po' 변수를 두 번 곱한 값(po * po)을 출력한다.
    public void print() {
        System.out.println(po * po);
    }

                                                              // public static void main(String[] args): 프로그램의 시작점이다.
    public static void main(String[] args) {
                                      // One one = new Two(10);: 💡 다형성(Polymorphism)!
                                      // 'One' 타입의 참조 변수 'one'이 'Two' 타입의 객체를 참조한다.
                                      // 즉, 'one'은 'Two' 객체를 가리키고 있지만, 
                                      // 'one'이 접근할 수 있는 메서드나 변수는 컴파일 시점의 타입인 'One'에 정의된 것들이다.
                                      // 하지만, 오버라이딩된 메서드는 런타임에 실제 객체 타입에 따라 호출된다 (동적 바인딩).
                                      // 여기서 Two(10) 생성자가 호출되므로,
                                      //   - 부모 One 객체 부분: a=10, b=11로 초기화된다.
                                      //   - 자식 Two 객체 부분: po=3으로 초기화된다.
        One one = new Two(10);

                                      // one.print();: 'one' 변수를 통해 'print()' 메서드를 호출한다.
                                      // 💡 핵심! 'one'의 선언된 타입은 'One'이지만, 실제 가리키는 객체는 'Two'다.
                                      // 'Two' 클래스에서 'print()' 메서드를 오버라이딩했기 때문에,
                                      // 런타임 시에 'Two' 클래스의 'print()' 메서드가 호출된다. (동적 바인딩)
                                      // Two의 print()는 'po * po'를 출력하므로, 3 * 3 = 9가 출력된다.
        System.out.println(one.print());
    }
}

답: 9

One one = new Two(10);: one은 One 타입으로 선언되었지만, 실제 객체는 Two야.

Two(10) 생성자 호출:
super(10, 11) -> 부모 One의 a = 10, b = 11

Two 자신의 po = 3
one.print();: 이 호출이 핵심이다. one이 Two 객체를 가리키고 있고, Two 클래스에서 print() 메서드를 오버라이딩했기 때문에 Two의 print() 메서드가 호출돼.
Two의 print()는 po * po를 출력하므로, 3 * 3 = 9가 출력된다.

🚀 최종 출력 결과
위의 실행 흐름에 따라 one.print()의 결과는 9이다.



---------------------------------------------------------------------------------- 
## 📝 문제 20) Python 코드 출력 결과

### 문제 코드

a = ["Seoul", "Kyeonggi", "Incheon", "Daejun", "Daegu", "Pusan"]   # 🚩 문자열 리스트 'a'를 정의한다.
str = "S"                                                         # 🚩 'str'이라는 변수를 초기 문자열 "S"로 시작한다.
                                                            # 이 변수에 각 도시 이름에서 뽑아낸 문자들이 계속 추가될 거다.

# for 루프: 리스트 'a'에 있는 각 요소를 'i'라는 변수에 하나씩 할당하면서 반복한다.
# 'i'는 "Seoul", "Kyeonggi", "Incheon" ... 순서로 문자열이 된다.

for i in a:
    # str = str + i[1]                               # 💡 핵심! 현재 'str' 변수에 'i' (각 도시 이름)의 두 번째 문자(인덱스 1)를 더해서 다시 'str'에 할당한다.
                                                     # 파이썬에서 문자열 인덱스는 0부터 시작한다.
                                                     # 'i[1]'은 각 도시 이름의 두 번째 글자를 의미한다.
    str = str + i[1]                                 # 예를 들어, "Seoul"에서 i[1]은 'e'가 된다.
                                                     # "Kyeonggi"에서 i[1]은 'y'가 된다.

print(str)                                             # 🚩 최종적으로 'str' 변수에 저장된 문자열을 출력한다.


🚀 최종 출력 결과  
Seynaau

🔍 실행 과정 추적  
str 변수가 어떻게 변하는지 단계별로 살펴보자.

초기 상태: str = "S"
첫 번째 루프 (i = "Seoul"):
i[1]은 'e'다.
str = "S" + "e" → str = "Se"

두 번째 루프 (i = "Kyeonggi"):
i[1]은 'y'다.
str = "Se" + "y" → str = "Sey"

세 번째 루프 (i = "Incheon"):
i[1]은 'n'이다.
str = "Sey" + "n" → str = "Seyn"

네 번째 루프 (i = "Daejun"):
i[1]은 'a'다.
str = "Seyn" + "a" → str = "Seyna"

다섯 번째 루프 (i = "Daegu"):
i[1]은 'a'다.
str = "Seyna" + "a" → str = "Seynaa"

여섯 번째 루프 (i = "Pusan"):
i[1]은 'u'다.
str = "Seynaa" + "u" → str = "Seynaau"

루프가 끝나고 print(str)을 호출한다.



