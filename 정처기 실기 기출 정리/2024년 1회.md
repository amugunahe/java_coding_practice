
### 문제 1)
아래 응집도와 관련하여 **응집도가 높은 순에서 낮은 순으로** 답안을 작성하시오.

1. 기능

2. 교환

3. 우연

4. 시간


### ✅ 정답  
**1 - 2 - 4 - 3**  
→ **기능 - 교환 - 시간 - 우연**


### 🔍 해설: 응집도(Cohesion)

응집도는 **모듈 내부의 요소들이 얼마나 밀접하게 관련되어 있는가를 나타내는 척도**입니다.  
응집도가 **높을수록 좋은 설계**이며, 낮을수록 유지보수성이 떨어집니다.

| 응집도 | 설명 | 품질 수준 |
|--------|------|-----------|
| 🟩 기능적 응집도 | 단일한 목적이나 기능만을 수행 | ✅ 가장 이상적 |
| 🟨 순차적 응집도 | 앞 작업의 출력이 다음 작업의 입력으로 사용됨 | 우수 |
| 🟨 통신적 응집도 | 동일한 입력과 출력 데이터를 사용 | 우수 |
| 🟨 절차적 응집도 | 특정 절차에 따라 수행되지만 목적이 다름 | 보통 |
| 🟧 시간적 응집도 | 동일 시간대에 처리되지만 목적은 다름 (ex. 초기화) | 낮음 |
| 🟥 논리적 응집도 | 유사한 성격의 작업이지만 선택적으로 실행 | 낮음 |
| 🟥 우연적 응집도 | 아무 관련 없는 작업들이 모여 있음 | ❌ 최악 |

※ 문제 보기의 '교환'은 `통신적 응집도`에 해당

---

### 🧠 정리: 응집도 순서 암기법

- **우논시절통순기**  
  → **우연 - 논리 - 시간 - 절차 - 통신 - 순차 - 기능**  
  → 왼쪽으로 갈수록 나쁘고, 오른쪽으로 갈수록 좋음

---

### 📌 결합도(Coupling) 참고 정리 (낮을수록 좋음)

| 결합도 | 설명 | 품질 |
|--------|------|------|
| 자료 결합도 | **값**만 전달 | ✅ 가장 낮은 결합도 |
| 스탬프 결합도 | 배열, 구조체 등 자료구조 전달 | 양호 |
| 제어 결합도 | 제어 플래그 전달 | 보통 |
| 외부 결합도 | 외부 변수 사용 | 낮음 |
| 공통 결합도 | 전역 변수 공유 | ❌ 나쁨 |
| 내용 결합도 | 다른 모듈 내부 직접 참조 | ❌ 최악 |

----------------------------------------------------------------------------------

## 📝 문제 2) 네트워크 용어 (영문 약어 작성)

### ❓ 문제
다음에서 설명하는 네트워크 용어를 **영문 약어**로 작성하시오.

> 다음은 인터넷 프로토콜 스위트의 데이터 교환을 위해 네트워크 장치 간의 정보를 배포하는 데 사용되는 **링크 상태 라우팅 프로토콜**이다.  
> 이 프로토콜은 **최단경로 우선 원칙**을 사용하여 라우팅 결정을 내리며, **리피터가 동일한 계층의 다른 라우터와 직접적으로 정보를 교환**할 수 있도록 한다.  
> 특히 **대규모 네트워크에서 효율적**이며, **라우팅 테이블을 최신 상태로 유지**하기 위해 자주 업데이트된다.  
> 라우터는 이 프로토콜을 사용하여 **네트워크 변경 사항에 신속하게 반응**하고, 네트워크의 각 세그먼트에서 정보를 **동기화하는 데 필요한 데이터**를 교환한다.



### ✅ 정답  
**OSPF**  
(Open Shortest Path First)



### 🔍 해설

- **OSPF (Open Shortest Path First)**는 링크 상태(Link-State) 라우팅 프로토콜이다.
- **최단경로 우선 알고리즘 (SPF, Dijkstra 알고리즘)**을 기반으로 경로를 계산함.
- 같은 계층 내의 라우터끼리 **Link-State Advertisement (LSA)**를 주고받아 전체 네트워크 토폴로지를 파악함.
- 라우팅 테이블은 변화가 생기면 즉시 재계산되어 반응 속도가 빠르고, 대규모 네트워크에서 매우 효율적임.
- **IGP(Interior Gateway Protocol)**에 속함.



### 📌 관련 개념 정리

#### 📎 라우팅 프로토콜 종류

1. **정적 라우팅 (Static Routing)**
   - 관리자가 수동으로 라우팅 경로 설정
   - 간단하고 예측 가능하지만 자동 대응 불가

2. **동적 라우팅 (Dynamic Routing)**
   - 라우터가 라우팅 정보를 자동으로 교환
   - **IGP**와 **EGP**로 구분됨



#### 📎 IGP (Interior Gateway Protocol)

| 유형 | 예시 | 특징 |
|------|------|------|
| 거리 벡터 알고리즘 | RIP (Routing Information Protocol) | 홉 수 기반, 최대 15홉, 느린 수렴 속도 |
| 링크 상태 알고리즘 | **OSPF** | 링크 상태 기반, 빠른 수렴, 대규모 네트워크에 적합 |


### 🧠 요약 암기

- **OSPF**: 링크 상태, SPF 알고리즘, 빠름, 대규모 네트워크, 동기화 잘 됨  
- **RIP**: 거리벡터, 홉 수 기반, 최대 15홉, 느림, 소규모 적합

----------------------------------------------------------------------------------

## 📝 문제 3) 애플리케이션 테스트 커버리지

### ❓ 문제
다음은 소프트웨어 테스팅에서 사용되는 **테스트 커버리지 기준** 중 하나이다.  
이 기준은 **각 결정점에서 모든 가능한 결정 결과를 최소 한 번 이상 실행**하도록 요구하며,  
모든 **조건식이 참(True)과 거짓(False)이 되도록** 만들어진다.  
이를 통해 개발자와 테스터는 **소프트웨어 내의 결정점에서 발생할 수 있는 다양한 조건 변경 사항들이 올바르게 처리되고 있는지** 검증할 수 있다.  
이러한 테스트 커버리지는 **조건의 모든 논리적 경로를 테스트**하여 **소프트웨어의 품질을 향상**시키는 데 중요한 역할을 한다.

---

### ✅ 정답  
**변경 조건/결정 커버리지**  
(Modified Condition / Decision Coverage, **MC/DC**)

---

### 🔍 해설

**변경 조건/결정 커버리지(MC/DC)**는 조건/결정 커버리지보다 더 엄격한 기준으로,  
다음의 사항을 충족해야 합니다.

- **각 개별 조건식은 참(True)과 거짓(False)이 최소 한 번 이상 실행**되어야 함  
- **각 조건식이 전체 결정 결과에 독립적으로 영향을 주는지** 테스트해야 함  
- 즉, **결정 포인트 내의 조건 변화가 결정 결과에 미치는 영향**을 검증

> MC/DC는 **항공, 군사, 의료 등 고신뢰성 소프트웨어에서 필수로 요구되는 테스트 방식**

---

### 📌 관련 개념: 테스트 커버리지 종류

| 커버리지 종류 | 설명 |
|----------------------|------|
| 구문 커버리지 | 소스 코드의 각 구문(statement)을 적어도 한 번은 실행 |
| 조건 커버리지 | 조건식 내 **각 개별 조건**이 true/false 되는지 확인 |
| 결정 커버리지 | if문 등 **분기문 결과(True/False)**가 모두 실행되었는지 확인 |
| 조건/결정 커버리지 | 결정 + 조건 커버리지 모두 만족 |
| **변경 조건/결정 커버리지 (MC/DC)** | **각 조건이 결정 결과에 미치는 영향까지 테스트** |
| 다중 조건 커버리지 | **모든 조건의 가능한 조합을 테스트** (100% 조합 커버) |

---

### 🧠 정리: 커버리지 계층 구조

1. **구문 커버리지** (가장 기본)  
2. **결정 커버리지**  
3. **조건 커버리지**  
4. **조건/결정 커버리지**  
5. **변경 조건/결정 커버리지 (MC/DC)**  
6. **다중 조건 커버리지** (가장 엄격)

----------------------------------------------------------------------------------
## 📝 문제 4) 보안 관련 악성 소프트웨어 용어

### ❓ 문제
다음은 컴퓨터 시스템 내에서 사용자의 허가 없이 **자신의 존재를 숨기고**,  
**관리자 레벨의 접근 권한을 얻기 위해 설계된 악성 소프트웨어의 한 유형**이다.  
이 소프트웨어는 시스템의 **기본적인 기능에 깊숙이 침투하여 활동을 감추며**,  
**다양한 보안 도구로부터 탐지를 피할 수 있다**.  
종종 **시스템 로그 파일을 수정하거나**, **키스트로크를 기록**하고,  
**비밀번호를 도용하는 등의 활동**을 포함할 수 있다.  
이러한 특성 때문에 보안 전문가들에게는 큰 위협이며, **제거가 매우 어렵다**.

---

### ✅ 정답  
**Rootkit (루트킷)**

---

### 🔍 해설

**루트킷(Rootkit)**은 시스템 관리자 권한(root 권한)을 탈취한 후,  
자신의 존재를 숨기고 다양한 악성 행위를 지속적으로 수행하는 **은폐형 악성 코드**입니다.

- 시스템 **핵심 영역에 깊숙이 침투**
- 자신을 탐지하지 못하도록 **로그/프로세스/파일/레지스트리 등을 조작**
- **키로깅, 백도어 설치, 암호 탈취, 시스템 제어** 등의 악성 행위 가능
- 백신 프로그램이나 보안 소프트웨어에 **탐지되지 않도록 설계됨**
- **제거가 매우 어렵고** 포맷 또는 클린 설치가 필요할 수 있음

---

### 📌 관련 개념 정리

#### ✅ 서비스 공격 (DoS/DDoS)의 주요 유형

| 공격명 | 설명 |
|--------|------|
| **Smurf Attack** | 공격자가 ICMP를 이용해 IP 스푸핑으로 브로드캐스트 패킷 전송 |
| **Ping of Death** | 너무 큰 ICMP 패킷 전송으로 시스템 다운 유도 |
| **Teardrop Attack** | IP 조각화를 악용하여 OS 충돌 유도 |
| **LAND Attack** | 출발지와 목적지 IP를 동일하게 설정한 패킷 전송 |
| **SYN Flooding** | TCP 3-way 핸드셰이크를 악용해 연결 요청 남발 |
| **UDP Flooding** | 대상의 모든 포트에 대량의 UDP 패킷 전송 |
| **Ping Flooding** | 대상에게 지속적으로 Ping 전송 (ICMP Echo Request 남발) |

---

### 📌 정보보안의 3요소 (CIA Triad)

| 요소 | 설명 |
|------|------|
| **기밀성 (Confidentiality)** | **암호화** 등을 통해 인가되지 않은 사용자로부터 정보 보호 |
| **무결성 (Integrity)** | 정보가 **변조되지 않도록** 보장 (예: 해시값, 접근제어) |
| **가용성 (Availability)** | 언제든지 **합법적인 접근이 가능하도록** 시스템 유지 (예: 고가용성 장비, 백업, 이중화) |


 ----------------------------------------------------------------------------------

## 📝 문제 5) 사이버 공격 유형

### ❓ 문제
다음은 **고도로 조직화된 공격자 그룹이 특정 대상에 대해 장기간에 걸쳐 은밀하게 수행하는 사이버 공격 방법**이다.  
이러한 공격은 대개 **국가의 지원을 받는 해커들에 의해 수행**되며,  
**특정 기업, 정부 기관, 또는 중요 인프라**를 목표로 한다.  
공격자들은 **네트워크 내부에 오랫동안 숨어 있으면서 데이터를 탈취하거나 시스템을 조작**하여  
심각한 피해를 입힐 수 있다.  
이러한 공격은 일반적인 사이버 위협과 **목적과 수행 방식 면에서 구별되며**,  
**매우 정교하고 지속적인 모니터링**이 요구된다.

---

### ✅ 정답  
**APT (Advanced Persistent Threat)**

---

### 🔍 해설

**APT (지능형 지속 위협)**는 다음과 같은 특징을 가진 **고도화된 사이버 공격**입니다:

- **Advanced (고급)**: 정교한 해킹 기술과 도구 사용  
- **Persistent (지속적)**: 장기적, 은밀하게 침투하여 오랜 시간 활동  
- **Threat (위협)**: 정보탈취, 시스템 조작, 핵심 인프라 마비 등 심각한 피해 유발  
- 대부분 **국가 또는 대규모 조직이 후원**하며, **표적(targeted) 공격** 형태로 수행됨  
- 공격자는 **탐지를 피하고 지속적으로 접근 권한을 유지**하기 위해 다양한 기법을 사용함  

> APT는 단순한 바이러스나 악성코드와 달리 **특정 목표에 맞춰 오랜 시간 준비하고 수행되는 사이버전 수준의 공격**으로 간주됨

---

### 📌 관련 공격 유형 정리

| 공격유형 | 설명 |
|-----------|------|
| **Worm** | 자가 복제 기능을 가진 악성코드. **네트워크로 전파**됨 |
| **Trojan Horse** | 유용한 소프트웨어로 **가장한 악성 프로그램** |
| **Backdoor** | 보안 우회를 통해 시스템에 **은밀히 접근** |
| **Virus** | 다른 프로그램에 자신을 **붙여넣어 감염**시키는 형태 |
| **Ransomware** | 파일을 암호화하고 **금전을 요구** |
| **Spyware** | 사용자 몰래 **정보를 수집**하는 프로그램 |
| **Adware** | **불필요한 광고**를 무분별하게 표시 |
| **APT** | **지속적이고 정교한 표적 공격**, 장기간 은밀히 침투 |
| **Zero-day Attack** | **발견되지 않은 소프트웨어 취약점**을 이용한 공격 |

---

### 🧠 기억 포인트

- APT는 **일반적인 해킹보다 훨씬 더 조직적이고 지속적인 공격**  
- **국가 기반 사이버전, 중요시설 공격**, 기업 정보 탈취 등이 목적  
- **탐지 회피 및 권한 유지 전략**이 포함됨



 ----------------------------------------------------------------------------------
## 📝 문제 6) 생성 디자인 패턴

### ❓ 문제
다음은 소프트웨어 공학에서 사용되는 **생성 디자인 패턴** 중 하나로,  
**관련 또는 의존하는 객체의 집합을 생성하기 위한 인터페이스**를 제공한다.  
이 패턴은 **구체적인 클래스를 지정하지 않고도 객체 생성을 캡슐화**하는 방법을 제공하여,  
**클라이언트 코드가 특정 클래스의 인스턴스에 직접 의존하지 않도록** 한다.  
이를 통해 클라이언트는 여러 제품군 중 필요한 제품을 선택하여 생성할 수 있으며,  
시스템의 **확장성과 유연성**이 증가된다.  
**다양한 환경에서 공통적으로 사용될 수 있는 제품군**을 생성하는 과정에서 특히 유용하다.

---
### ✅ 정답  
**Abstract Factory**  
(추상 팩토리 패턴)



### 🔍 해설

- **Abstract Factory 패턴**은 관련 있는 여러 객체들을 **하나의 제품군(Product Family)**으로 보고,  
  이들을 생성할 수 있는 **인터페이스를 제공**하는 생성 디자인 패턴이다.
- **객체 생성을 캡슐화**하여, 클라이언트가 객체의 구체적인 클래스에 의존하지 않도록 함.
- 구체적인 클래스 없이도 객체군을 생성할 수 있도록 하여 **제품군 간의 일관성을 유지**할 수 있다.
- 제품군 간의 의존성을 최소화하면서도 시스템을 유연하게 설계할 수 있음.
- GUI Toolkit, OS 독립 UI 등 다양한 환경에서 동일한 인터페이스로 객체를 생성할 때 자주 사용됨.



### 📌 관련 개념 정리

#### ✅ GoF 디자인 패턴 분류

| 분류 | 설명 | 대표 패턴 |
|------|------|------------|
| **생성 패턴** | 객체 생성 과정 추상화, 유연성 향상 | Singleton, Factory Method, **Abstract Factory**, Builder, Prototype |
| **구조 패턴** | 클래스나 객체의 조합을 통해 더 큰 구조 형성 | Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy |
| **행위 패턴** | 클래스나 객체 간 알고리즘 및 책임 분배 | Observer, Strategy, Command, State, Template Method 등 |



### 📌 객체지향 개념 요약

- **클래스**: 객체를 정의하는 설계도  
- **객체**: 클래스의 인스턴스  
- **속성**: 객체가 가진 데이터  
- **메서드**: 객체의 동작  
- **메시지**: 객체에게 특정 동작을 요청



### 📌 객체지향 설계 원칙 (SOLID)

| 원칙 | 설명 |
|------|------|
| **SRP** (단일 책임 원칙) | 하나의 클래스는 하나의 책임만 가져야 함 |
| **OCP** (개방-폐쇄 원칙) | 확장에는 열려 있고, 변경에는 닫혀 있어야 함 |
| **LSP** (리스코프 치환 원칙) | 자식 클래스는 부모 클래스를 대체할 수 있어야 함 |
| **ISP** (인터페이스 분리 원칙) | 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함 |
| **DIP** (의존 역전 원칙) | 고수준 모듈은 저수준 모듈에 의존하면 안 되고, 추상에 의존해야 함 |



 ----------------------------------------------------------------------------------
## 📝 문제 7) 서브넷 마스크 기반 IP 주소 할당

### ❓ 문제
아래 네트워크 구성에서 **2번, 4번, 6번 라우터에 할당 가능한 IP 주소**를 보기에서 찾아 작성하시오.

#### [적용된 IP 주소]

- 1번) `192.168.35.12/24`
- 3번) `129.200.10.16/22`
- 5번) `192.168.36.32/24`

#### [보기]
- A) `192.168.35.72`
- B) `129.200.8.249`
- C) `192.168.36.249`

---

### ✅ 정답  
- **2번:** `192.168.35.72`  
- **4번:** `129.200.8.249`  
- **6번:** `192.168.36.249`

---

### 🔍 해설

#### 🔹 1번 IP: `192.168.35.12/24`  
- **/24**는 서브넷 마스크 `255.255.255.0`  
- IP 범위: `192.168.35.0 ~ 192.168.35.255`  
✅ **`192.168.35.72`** → 같은 네트워크 → **2번 가능**

---

#### 🔹 3번 IP: `129.200.10.16/22`  
- **/22**는 서브넷 마스크 `255.255.252.0`  
- IP 범위 계산:
  - 22비트: 네트워크 부분 → 129.200.**8.0**
  - 블록 범위: `129.200.8.0 ~ 129.200.11.255`
✅ **`129.200.8.249`** → 같은 범위 → **4번 가능**

---

#### 🔹 5번 IP: `192.168.36.32/24`  
- 서브넷 범위: `192.168.36.0 ~ 192.168.36.255`
✅ **`192.168.36.249`** → 같은 범위 → **6번 가능**

---

### 📌 관련 개념: CIDR 및 서브넷 마스크

| CIDR 표기 | 서브넷 마스크 | 호스트 개수 | 주소 범위 예시 |
|-----------|----------------|--------------|----------------|
| /24       | 255.255.255.0  | 256 (254 usable) | x.x.x.0 ~ x.x.x.255 |
| /22       | 255.255.252.0  | 1024 (1022 usable) | x.x.8.0 ~ x.x.11.255 |

- 서브넷 마스크는 **네트워크와 호스트를 구분**하기 위한 비트 정보
- **CIDR**: Classless Inter-Domain Routing → 유연한 서브넷팅 가능

---

### ✅ 요약

| 라우터 번호 | 적용된 IP | 할당 가능한 IP (보기) | 서브넷 범위 확인 결과 |
|-------------|------------|------------------------|------------------------|
| 2번 | `192.168.35.12/24` | `192.168.35.72` | 동일 네트워크 |
| 4번 | `129.200.10.16/22` | `129.200.8.249` | 동일 네트워크 |
| 6번 | `192.168.36.32/24` | `192.168.36.249` | 동일 네트워크 |



-------------------------------------------------------------------------------------
## 📝 문제 8) SQL 조인(join) 종류

### ❓ 문제
다음은 **조인(join)**에 대한 설명이다.  
**괄호에 들어갈 알맞은 용어**를 작성하시오.

---

### ①  
두 테이블을 특정 조건을 기반으로 결합하는 조인 방법이다.  
이 조인은 조건이 `=`(동등)뿐만 아니라 `<`, `>`, `<=`, `>=`, `!=` 등의 **비교 연산자**를 사용할 수 있다.  
이 조인을 통해 다양한 조건을 기반으로 두 테이블 간의 관계를 정의하고,  
조건에 맞는 행을 결합하여 새로운 결과 집합을 만든다.  
> **정답: 세타 조인 (Theta Join)**

---

### ②  
두 테이블을 결합할 때, 조인 조건으로 `=`(동등) 연산자만을 사용하는 조인 방법이다.  
이 조인은 두 테이블의 특정 컬럼 값이 **동일한 행**들을 결합하여 결과 집합을 만든다.  
주로 **외래 키와 기본 키**를 매칭할 때 사용되며, **조건에 맞는 행만** 결과에 포함된다.  
> **정답: 동등 조인 (Equi Join)**

---

### ③  
두 테이블을 결합할 때, **동일한 이름의 컬럼**을 기반으로 동등 비교를 수행하여 조인하는 방법이다.  
이 조인은 **조인 조건을 명시하지 않아도**, 동일한 이름의 컬럼들을 자동으로 매칭하여 결합한다.  
결과 집합에는 **중복되는 컬럼이 하나만 포함**되며,  
두 테이블 간의 공통된 컬럼 값이 동일한 행들만 결합된다.  
> **정답: 자연 조인 (Natural Join)**

---

### ✅ 최종 정답 정리

| 번호 | 조인 유형 | 설명 |
|------|------------|-------|
| 1번 | **세타 조인** (Theta Join) | `=`, `<`, `>`, `<=`, `>=`, `!=` 등 **비교 연산자** 사용 가능 |
| 2번 | **동등 조인** (Equi Join) | **`=` 연산자**만 사용하는 조인 |
| 3번 | **자연 조인** (Natural Join) | **같은 이름의 컬럼**끼리 자동 매칭, **중복 제거** |

---

### 📌 관련 개념: 조인의 종류

| 조인 종류 | 설명 |
|-----------|------|
| **세타 조인 (Theta Join)** | 다양한 비교 연산자 사용 가능 (`=`, `!=`, `<`, `>`, 등) |
| **동등 조인 (Equi Join)** | `=` 연산자를 사용하여 동일한 값을 기준으로 조인 |
| **자연 조인 (Natural Join)** | 동일한 컬럼 이름 자동 매칭 + 중복 컬럼 제거 |
| **내부 조인 (Inner Join)** | 조건에 맞는 행만 결과로 반환 |
| **외부 조인 (Outer Join)** | 조건에 맞지 않더라도 **한쪽 테이블의 모든 행** 포함 |
| **자기 조인 (Self Join)** | 같은 테이블을 두 번 조인하여 비교 |

---

### 📌 데이터베이스 설계 3단계 요약

| 단계 | 설명 |
|------|------|
| **개념적 설계** | DBMS 독립적, **ER 다이어그램 작성**, 추상화 단계 |
| **논리적 설계** | DBMS 논리에 맞게 **정규화 수행**, 테이블 설계 |
| **물리적 설계** | **저장 구조, 인덱스, 접근 방식** 등 구현 수준 설계 |

 ----------------------------------------------------------------------------------

## 📝 문제 8) 페이지 교체 알고리즘 - LRU / LFU 부재 횟수 계산

### ❓ 문제
다음 **페이지 참조 순서**를 고려하여  
**LRU**(Least Recently Used)와 **LFU**(Least Frequently Used) 알고리즘에 따른 **페이지 부재 횟수**를 구하시오.

> 페이지 프레임 수: **3개**

#### 📌 페이지 참조 순서:
1, 2, 3, 1, 2, 4, 1, 2, 5, 7


---

### ✅ 정답

- **LRU:** `6`
- **LFU:** `6`

---

### 🔍 시뮬레이션 해설

#### ✅ LRU (가장 오랫동안 사용되지 않은 페이지 교체)

| Step | 참조 페이지 | 프레임 상태         | 페이지 부재(O/X) |
|------|-------------|----------------------|------------------|
| 1    | 1           | 1 - -                | O                |
| 2    | 2           | 1 2 -                | O                |
| 3    | 3           | 1 2 3                | O                |
| 4    | 1           | 2 3 1 (1 사용됨)     | X                |
| 5    | 2           | 3 1 2 (2 사용됨)     | X                |
| 6    | 4           | 1 2 4 (3 제거)       | O                |
| 7    | 1           | 2 4 1 (1 사용됨)     | X                |
| 8    | 2           | 4 1 2 (2 사용됨)     | X                |
| 9    | 5           | 1 2 5 (4 제거)       | O                |
| 10   | 7           | 2 5 7 (1 제거)       | O                |

- **총 부재 횟수:** `6`

---

#### ✅ LFU (가장 적게 사용된 페이지 교체)

| Step | 참조 | 프레임 상태 (카운트)         | 부재(O/X) | 교체 기준 |
|------|------|-------------------------------|-----------|------------|
| 1    | 1    | 1(1) - -                       | O         |            |
| 2    | 2    | 1(1) 2(1) -                    | O         |            |
| 3    | 3    | 1(1) 2(1) 3(1)                 | O         |            |
| 4    | 1    | 1(2) 2(1) 3(1)                 | X         |            |
| 5    | 2    | 1(2) 2(2) 3(1)                 | X         |            |
| 6    | 4    | 1(2) 2(2) 4(1) (3 제거)        | O         | 3이 최소   |
| 7    | 1    | 1(3) 2(2) 4(1)                 | X         |            |
| 8    | 2    | 1(3) 2(3) 4(1)                 | X         |            |
| 9    | 5    | 1(3) 2(3) 5(1) (4 제거)        | O         | 4이 최소   |
| 10   | 7    | 1(3) 2(3) 7(1) (5 제거)        | O         | 5가 최소   |

- **총 부재 횟수:** `6`

---

### 📌 관련 개념 요약

#### 🔹 페이지 교체 알고리즘 종류

| 알고리즘 | 설명 |
|----------|------|
| **FIFO** | 먼저 들어온 페이지를 먼저 제거 |
| **LRU** | 가장 오래 전에 사용된 페이지를 제거 |
| **LFU** | 가장 적게 사용된 페이지를 제거 |
| **OPT** | 앞으로 가장 오랫동안 사용되지 않을 페이지 제거 (이론상 최적) |
| **SCR (Second Chance)** | FIFO + 사용 비트 검사 |
| **NUR (Not Used Recently)** | 사용, 수정 비트 기반 교체 |

---

### 📌 프로세스 스케줄링 알고리즘

| 종류 | 기법 | 알고리즘 |
|------|------|-----------|
| **선점형** | CPU 강제 회수 | Round Robin, SRT, MLQ, MLFQ |
| **비선점형** | 스스로 종료 시까지 | FCFS, SJF, HRN, 우선순위, 기한부 |

---

### ✅ 핵심 요약

- **LRU**는 최근 사용 시간 기준
- **LFU**는 사용 횟수 기준
- 동일 횟수일 경우 **LFU는 먼저 들어온 페이지 제거** 가능
- 이 문제에서는 두 방식 모두 **부재 횟수 6회**
------------------------------------------------------------------
## ✅ 문제 10

> **다음 표에서 나타내고 있는 정규형을 쓰시오.**

| 학생 아이디 | 강좌명 | 담당 강사 |
|:-----------:|:------:|:---------:|
| 001         | 영어   | P001      |
| 002         | 한국사 | P002      |
| 003         | 영어   | P001      |
| 003         | 한국사 | P004      |
| 004         | 영어   | P003      |
| 004         | 한국사 | P004      |

---

## 🔎 정규화 분석

- **기본키 후보**: (학생 아이디, 강좌명)
- **함수 종속성**:
  - (학생 아이디, 강좌명) → 담당 강사
  - 강좌명 → 담당 강사 (**이행적 종속** 존재)

✅ **제2정규형(2NF)** 만족  
❌ **제3정규형(3NF)** 아님

> 이유: 비프라이머리 속성인 `담당 강사`가 키가 아닌 속성인 `강좌명`에 **이행적으로 종속**되어 있기 때문

---

## 💡 제3정규형으로 분해하면?

### 학생수강 테이블

| 학생 아이디 | 강좌명 |
|:-----------:|:------:|
| 001         | 영어   |
| 002         | 한국사 |
| 003         | 영어   |
| 003         | 한국사 |
| 004         | 영어   |
| 004         | 한국사 |

### 강좌 테이블

| 강좌명 | 담당 강사 |
|:------:|:----------:|
| 영어   | P001 / P003 |
| 한국사 | P002 / P004 |

> ⚠️ 주의: 영어, 한국사 각각 담당 강사가 여러 명인 것으로 보이므로, 정확한 정규화를 위해 추가 확인 필요

---

## ✅ 최종 정답

> **정규형**: **제2정규형 (2NF)**


  ----------------------------------------------------------------------------------

## 📝 문제 11) SQL 실행 결과 작성

### ❓ 문제
아래 SQL 문장을 수행하였을 때의 결과를 표로 작성하시오.

```sql
select b from t1
where c in
(
  select c from t2
  where d = 'k'
)
```

---

### 📋 테이블 정보

#### t1

| a | b | c |
|---|---|---|
| 1 | a | x |
| 2 | b | x |
| 1 | c | w |
| 3 | d | w |

#### t2

| c | d | e |
|---|---|---|
| x | k | 3 |
| y | k | 3 |
| z | s | 2 |

---

### ✅ 풀이 과정

1. **서브쿼리 실행**

```sql
select c from t2 where d = 'k'
```

→ 결과:

| c |
|---|
| x |
| y |

즉, c 값은 `'x'` 또는 `'y'`.

---

2. **외부 쿼리 실행**

```sql
select b from t1 where c in ('x', 'y')
```

t1에서 c가 `'x'` 또는 `'y'`인 레코드 찾기:

- t1에서 c = 'x'

| a | b | c |
|---|---|---|
| 1 | a | x |
| 2 | b | x |

- t1에서 c = 'y'

없음

---

### ✅ 최종 결과

| b |
|---|
| a |
| b |

---

### 📌 요약
- 서브쿼리에서 `d = 'k'`인 t2의 c 값 → `x`, `y`
- t1에서 c 값이 이 값들에 해당하는 행의 b 컬럼 출력
- 최종 결과는 **a**, **b**

  ---------------------------------------------------------------------------------- 

## 📝 문제 12) SQL 실행 결과 작성

### ❓ 문제
아래 SQL 문장을 수행하였을 때의 결과를 표로 작성하시오.

```sql
select
  count(*)
from table
where empno > 100
  and sal >= 3000
  or empno = 200
테이블 정보
empno	sal
100	1000
200	3000
300	1500

풀이 과정
조건식의 우선순위에 따라 해석한다.


where (empno > 100 and sal >= 3000) or (empno = 200)
각 행별 조건 평가:

empno	sal	조건 1: empno > 100 and sal >= 3000	조건 2: empno = 200	전체 조건 결과
100	1000	False (100 > 100? No)	False	False
200	3000	True (200 > 100 and 3000 >= 3000)	True	True
300	1500	False (1500 < 3000)	False	False

조건을 만족하는 행은 1개 (empno=200)

최종 결과
count(*)
1

📌 요약
조건은 괄호를 묵시적으로 나눌 때 AND가 OR보다 우선순위가 높음

따라서 empno > 100 and sal >= 3000 또는 empno = 200인 행을 찾음

결과는 1행

  ---------------------------------------------------------------------------------- 

## 📝 문제 13) C언어 코드 출력 결과

### ❓ 문제 코드

```c
#include <stdio.h>
int main(){
    int v1= 0, v2= 35, v3 =29;
    if(v1 > v2 ? v2 : v1){
        v2 = v2 << 2;
    } else {
        v3 = v3 << 2;
    }
    printf("%d", v2 + v3);
}

풀이 과정
조건식 if(v1 > v2 ? v2 : v1) 분석

삼항 연산자 (v1 > v2) ? v2 : v1

v1 = 0, v2 = 35 이므로 v1 > v2는 0 > 35 → false

따라서 조건식 결과는 v1 → 0

if 조건식 결과가 0 (거짓)이므로 else 블록 실행

c
v3 = v3 << 2;
v3 = 29 << 2 → 29 * 2^2 = 29 * 4 = 116

v2는 변경되지 않고 그대로 35

printf("%d", v2 + v3);

35 + 116 = 151 출력

최종 출력 결과
151

---------------------------------------------------------------------------------- 

## 📝 문제 14) C언어 코드 출력 결과

### ❓ 문제 코드

```c
#include <stdio.h>
#include <string.h>

void reverse(char* str) {
    int len = strlen(str);
    char* p1 = str;
    char* p2 = str + len - 1;
    while (p1 < p2) {
        char t = *p1;
        *p1 = *p2;
        *p2 = t;
        p1++;
        p2--;
    }
}

int main(int argc, char* argv[]) {
    char str[100] = "ABCDEFGH";
    reverse(str);
    int len = strlen(str);
    for (int i = 1; i < len; i += 2) {
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}

풀이 과정
초기 문자열: "ABCDEFGH"

reverse(str) 호출 후 문자열 반전:

반전된 문자열: "HGFEDCBA"

길이: 8

for문 i=1부터 i<len까지 2씩 증가하며 출력:

인덱스 1: G

인덱스 3: E

인덱스 5: C

인덱스 7: A

출력 결과: GECA

최종 출력 결과
GECA
---------------------------------------------------------------------------------- 

## 📝 문제 15) C언어 코드 출력 결과

### ❓ 문제 코드 (오류 및 누락 보완 포함)

```c
#include <stdio.h>

struct ACC {
    int accNum;
    double bal;
};

void init(struct ACC *acc, int x, double y) {
    acc->accNum = x;
    acc->bal = y;
}

// 복리 계산 함수 (year 파라미터 추가 및 수정)
double sim(double base, int year) {
    double r = 1.0;
    for (int i = 0; i < year; i++) {
        r *= base;
    }
    return r;
}

void xxx(struct ACC* acc, double en) {
    if (en > 0 && en < acc->bal) {
        acc->bal -= en;
    } else {
        acc->bal += en;
    }
}

void yyy(struct ACC* acc) {
    acc->bal *= sim(1.1, 3);
}

int main() {
    struct ACC acc;
    init(&acc, 9981, 2200.0);
    xxx(&acc, 100.0);
    yyy(&acc);
    printf("%d and %0.2f\n", acc.accNum, acc.bal);
    return 0;
}
풀이 과정
init 함수로 accNum = 9981, bal = 2200.0 초기화

xxx(&acc, 100.0) 호출

en = 100.0

조건 en > 0 && en < acc->bal → 100.0 > 0 그리고 100.0 < 2200.0 → 참

따라서 acc->bal = 2200.0 - 100.0 = 2100.0

yyy(&acc) 호출

sim(1.1, 3) 계산

1.1^3 = 1.1 * 1.1 * 1.1 = 1.331

acc->bal = 2100.0 * 1.331 = 2795.1

출력:

9981 and 2795.10
---------------------------------------------------------------------------------- 

## 📝 문제 16) C언어 코드 출력 결과

### ❓ 문제 코드 (오타 및 오류 수정 포함)

```c
#include <stdio.h>
#include <ctype.h>

int main() {
    char p[] = "It is 8";
    char result[20];
    int i;
    for (i = 0; p[i] != '\0'; i++) {
        if (isupper(p[i]))
            result[i] = (p[i] - 'A' + 5) % 26 + 'A';
        else if (islower(p[i]))
            result[i] = (p[i] - 'a' + 10) % 26 + 'a';
        else if (isdigit(p[i]))
            result[i] = (p[i] - '0' + 3) % 10 + '0';
        else
            result[i] = p[i];
    }
    result[i] = '\0';
    printf("%s\n", result);
    return 0;
}

풀이 과정
입력 문자열: "It is 8"

문자별 변환

문자	조건	변환 과정	결과 문자
'I'	대문자	('I' - 'A' + 5) % 26 + 'A' = (8 + 5)%26 + 65 = 13 + 65 = 'N'	'N'
't'	소문자	('t' - 'a' + 10) % 26 + 'a' = (19 + 10)%26 + 97 = 29%26+97=3+97='d'	'd'
' '	기타(공백)	그대로	' '
'i'	소문자	('i' - 'a' + 10) % 26 + 'a' = (8 +10)%26 + 97 = 18 + 97 = 's'	's'
's'	소문자	('s' - 'a' + 10) % 26 + 'a' = (18 +10)%26 + 97 = 28%26+97=2+97='c'	'c'
' '	기타(공백)	그대로	' '
'8'	숫자	('8' - '0' + 3) % 10 + '0' = (8 + 3)%10 + 48 = 11%10 + 48=1+48='1'	'1'

변환된 문자열: "Nd sc 1"

최종 출력 결과
Nd sc 1
---------------------------------------------------------------------------------- 
## 📝 문제 17) Java 코드 실행 순서

### ❓ 문제 코드 (오타 수정 및 구조 보완)

```java
class P {
    int x, y;

    P(int x, int y) {  // 생성자명은 클래스명과 같아야 하므로 'p' → 'P'로 수정
        this.x = x;
        this.y = y;
    }

    int getData() {
        return x * y;
    }
}

class C extends P {
    int x;

    C(int x) {
        super(x + 1, x);  // 부모 생성자 호출
        this.x = x;
    }

    int getData(int n) {
        return super.getData() + n;
    }

    public static void main(String[] args) {
        P p = new C(10);
        System.out.println(p.getData());
    }
}
실행 순서 설명
new C(10) → C 생성자 호출

C 생성자 내 super(x+1, x) → P(11, 10) 생성자 호출 → x=11, y=10 초기화

부모 생성자 종료 후 this.x = x; → C의 멤버 x = 10 설정

C 생성자 종료

p.getData() 호출 → p는 타입 P, 실제 객체는 C이지만 C에 getData() 오버라이딩 없으므로 P의 getData() 호출

P의 getData() 실행 → x * y → 부모 x=11, y=10 → 결과 110 출력

결론
객체 생성 시 생성자 호출 순서:
C() → P()(부모 생성자) → C() 멤버 초기화

메서드 호출 시 오버라이딩이 없으므로 부모 클래스 메서드 호출

요약된 실행 순서 번호 예시
번호	수행 내용
5	new C(10) 객체 생성
6	super(x+1, x) → 부모 생성자 호출
3	부모 생성자 내 this.x = x; this.y = y; 초기화
1	부모 생성자 종료
7	this.x = x; 자식 클래스 멤버 초기화
2	p.getData() 호출 및 출력

출력 결과
110
---------------------------------------------------------------------------------- 

## 📝 문제 18) Java 코드 출력 결과

### ❓ 문제 코드 (오타 및 수정 반영)

```java
class Connection {
    private static Connection _inst = null;
    private int count = 0;

    static public Connection get() {
        if (_inst == null) {
            _inst = new Connection();
            return _inst;
        }
        return _inst;
    }

    public void count() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) {
        Connection conn1 = Connection.get();
        conn1.count();
        Connection conn2 = Connection.get();
        conn2.count();
        Connection conn3 = Connection.get();
        conn3.count();
        conn1.count();

        System.out.print(conn1.getCount());
    }
}
실행 흐름 설명
Connection 클래스는 싱글톤 패턴으로 _inst 하나만 생성된다.

conn1, conn2, conn3 모두 동일한 Connection 인스턴스를 참조한다.

count() 메서드는 count 값을 1씩 증가시킨다.

메서드 호출과 count 값 변화
호출순서	호출한 객체	count 값 (호출 후)
1	conn1	1
2	conn2	2
3	conn3	3
4	conn1	4

최종 출력 값

4
---------------------------------------------------------------------------------- 

## 📝 문제 19) Java 코드 출력 결과

### 문제 코드

```java
class One {
    int a, b;
    public One(int a, int b) {
        this.a = a;
        this.b = b;
    }
    public void print() {
        System.out.println(a + b);
    }
}

class Two extends One {
    int po = 3;
    public Two(int i) {
        super(i, i + 1);
    }
    public void print() {
        System.out.println(po * po);
    }

    public static void main(String[] args) {
        One one = new Two(10);
        one.print();
    }
}
실행 흐름 설명
Two 클래스는 One을 상속하며 print() 메서드를 오버라이딩 함.

main에서 One 타입 변수 one에 Two(10) 객체를 할당.

one.print() 호출 시 실제 객체는 Two 타입이므로 오버라이딩 된 Two의 print()가 호출됨.

Two의 po 변수는 3이며, 출력은 3 * 3 = 9가 됨.

출력 결과

9
---------------------------------------------------------------------------------- 
## 📝 문제 20) Python 코드 출력 결과

### 문제 코드

```python
a = ["Seoul", "Kyeonggi", "Incheon", "Daejun", "Daegu", "Pusan"]
str = "S"
for i in a:
    str = str + i[1]
print(str)
코드 분석
초기 문자열 str 은 "S"

리스트 a 의 각 문자열에서 두 번째 문자(i[1])를 하나씩 더함

a 리스트의 각 원소 두 번째 문자:

"Seoul" → 'e'

"Kyeonggi" → 'y'

"Incheon" → 'n'

"Daejun" → 'a'

"Daegu" → 'a'

"Pusan" → 'u'

따라서 str = "S" + "e" + "y" + "n" + "a" + "a" + "u" = "Seynaau"

출력 결과
Seynaau


