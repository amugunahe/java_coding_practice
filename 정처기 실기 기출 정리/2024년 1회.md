
### 문제 1)
아래 응집도와 관련하여 **응집도가 높은 순에서 낮은 순으로** 답안을 작성하시오.

1. 기능

2. 교환

3. 우연

4. 시간


### ✅ 정답  
**1 - 2 - 4 - 3**  
→ **기능 - 교환 - 시간 - 우연**


# 🔧 응집도(Cohesion)란?

> 하나의 모듈(함수, 클래스 등) 안에서 **구성요소들이 얼마나 같은 목적을 향해 움직이느냐**를 나타내는 정도

- **응집도 높음 = 서로 밀접하게 연관된 일만 함 → 좋은 구조!**
- **응집도 낮음 = 잡다한 일 다 함 → 유지보수 어렵고 버그 유발**

---

## ✅ 응집도 수준별 정리 + 갓반인 예시

| 응집도 | 설명 | 품질 | 예시 (비유) |
|--------|------|------|-------------|
| 🟥 **우연적 응집도** | 그냥 막 모아둠 | ❌ 최악 | "한 파일에 계산, 프린터 설정, 로그인 코드 다 들어있음" |
| 🟥 **논리적 응집도** | 비슷한 작업을 조건에 따라 선택 | ❌ 나쁨 | "if문으로 작업 나눠서: 출력? 저장? 전송? 전부 있음" |
| 🟧 **시간적 응집도** | 비슷한 시점에 수행됨 | ⛔ 낮음 | "초기화 함수에 DB연결, 로그설정, 화면세팅 다 때려넣음" |
| 🟨 **절차적 응집도** | 순서 따라 하긴 하는데 목적이 다름 | ⚠ 보통 | "사용자 입력 받고 → 로깅하고 → 저장까지 하나에 있음" |
| 🟨 **통신적 응집도** | 같은 데이터를 다룸 | 👍 양호 | "같은 고객정보로 조회/수정/출력 수행" |
| 🟨 **순차적 응집도** | 앞 결과를 다음 작업에 사용 | 👍 양호 | "파일 읽고 → 파싱하고 → 출력하는 흐름" |
| 🟩 **기능적 응집도** | 한 가지 목적만! | ✅ 최고 | "파일 저장 기능만 깔끔하게 담당" |

---

### 🔑 요점 정리

- 👉 **응집도는 '내부끼리 얼마나 한 마음으로 일하느냐'**
- 👉 **높을수록 유지보수, 재사용성, 디버깅에 유리**
- 👉 암기 순서: `우논시절통순기` (우연 < 논리 < 시간 < 절차 < 통신 < 순차 < 기능)

---

# 🔗 결합도(Coupling)도 같이 보자!

> **모듈 간 연결성의 정도. 느슨할수록 좋음**

| 결합도 | 설명 | 품질 | 예시 (비유) |
|--------|------|------|-------------|
| 🟩 **자료 결합도** | 값만 주고받음 | ✅ 최고 | "함수에 숫자만 전달 (ex. sum(5, 7))" |
| 🟨 **스탬프 결합도** | 구조체 등 덩어리 전달 | 👍 양호 | "사용자 구조체 통째로 전달" |
| 🟨 **제어 결합도** | 실행 흐름 결정 플래그 전달 | ⚠ 보통 | "flag=true 넘겨서 내부 분기 처리" |
| 🟧 **외부 결합도** | 외부환경과 연결 | ⛔ 낮음 | "파일 포맷, 하드웨어에 직접 의존" |
| 🟥 **공통 결합도** | 전역변수 공유 | ❌ 나쁨 | "모든 함수가 global변수 쓰는 상황" |
| 🟥 **내용 결합도** | 다른 모듈의 내부까지 침범 | ❌ 최악 | "A모듈이 B모듈의 내부 변수나 코드에 접근" |

---

### 🔐 기억 포인트

- 응집도는 **높을수록 좋고**,  
- 결합도는 **낮을수록 좋다**

> ✅ **좋은 설계 = 높은 응집도 + 낮은 결합도**


----------------------------------------------------------------------------------

## 📝 문제 2) 네트워크 용어 (영문 약어 작성)

### ❓ 문제
다음에서 설명하는 네트워크 용어를 **영문 약어**로 작성하시오.

> 다음은 인터넷 프로토콜 스위트의 데이터 교환을 위해 네트워크 장치 간의 정보를 배포하는 데 사용되는 **링크 상태 라우팅 프로토콜**이다.  
> 이 프로토콜은 **최단경로 우선 원칙**을 사용하여 라우팅 결정을 내리며, **리피터가 동일한 계층의 다른 라우터와 직접적으로 정보를 교환**할 수 있도록 한다.  
> 특히 **대규모 네트워크에서 효율적**이며, **라우팅 테이블을 최신 상태로 유지**하기 위해 자주 업데이트된다.  
> 라우터는 이 프로토콜을 사용하여 **네트워크 변경 사항에 신속하게 반응**하고, 네트워크의 각 세그먼트에서 정보를 **동기화하는 데 필요한 데이터**를 교환한다.



### ✅ 정답  
**OSPF**  
(Open Shortest Path First)



# 🚦 OSPF (Open Shortest Path First) 해설

## ✅ 한 줄 요약
**OSPF는 네트워크 안에서 "가장 빠른 길"을 실시간 계산해서 알려주는 똑똑한 네비게이션 시스템**

---

## 🧠 핵심 특징

| 항목 | 설명 | 현실 비유 |
|------|------|-----------|
| 💡 라우팅 프로토콜 | 링크 상태 기반 (Link-State) | "각 지점 간 도로 상황(링크 상태)을 서로 공유" |
| 📌 알고리즘 | SPF (Dijkstra 알고리즘) | "내비게이션처럼 가장 빠른 길 계산" |
| 🔄 정보 교환 | LSA (Link-State Advertisement)로 주고받음 | "내 위치랑 도로 상황을 주변에 방송함" |
| ⚡ 반응 속도 | 변화 생기면 즉시 재계산 | "차 사고나면 바로 길 다시 안내해줌" |
| 🧭 사용 범위 | IGP 계열 (내부 라우팅용), 대규모 네트워크에 적합 | "회사 내부망에 사용하는 빠른 내비" |

---

## 🛣 라우팅 프로토콜 분류

### 📍 1. 정적 라우팅 (Static Routing)
- 사람이 직접 일일이 길 지정  
- 🔧 **직접 설정해야 해서 유연성은 낮지만**, 단순한 환경에서는 유리  
> 예: "네비 없이 지도로 길 외워서 다님"

---

### 📍 2. 동적 라우팅 (Dynamic Routing)
- 라우터끼리 **자동으로 경로 계산 및 교환**  
- 실시간으로 변화에 대응 가능  
- 두 종류로 나뉨:

| 분류 | 프로토콜 | 특징 |
|------|----------|------|
| **IGP (내부망용)** | RIP, OSPF 등 | 조직 내부에 적합 |
| **EGP (외부망용)** | BGP | ISP(인터넷 사업자) 간 연결 시 사용 |

---

## 🔄 IGP 내부 비교: RIP vs OSPF

| 항목 | **RIP** | **OSPF** |
|------|---------|-----------|
| 💡 알고리즘 | 거리 벡터 (Distance Vector) | 링크 상태 (Link-State) |
| 📏 기준 | 홉 수 (몇 번 거쳐가는지) | 실제 경로 비용 (속도, 지연 등) |
| 🐢 속도 | 느림 (수렴 느림) | 빠름 (즉시 재계산) |
| 🚧 한계 | 15홉 제한, 대규모 네트워크 부적합 | 대규모 네트워크에 최적 |
| 🤝 구조 | 단순, 설정 쉬움 | 조금 복잡하지만 효율적 |

---

## 🧠 암기 포인트 요약

- OSPF = **링크 상태 기반**, SPF 알고리즘, **빠른 반응**, 대규모에 강함  
- RIP = **홉 수 기반**, 느림, **소규모에서만 적합**  
- OSPF는 회사 내 **사내망 전용 고급 내비**, RIP은 **구식 노선버스 느낌**



----------------------------------------------------------------------------------

## 📝 문제 3) 애플리케이션 테스트 커버리지

### ❓ 문제
다음은 소프트웨어 테스팅에서 사용되는 **테스트 커버리지 기준** 중 하나이다.  
이 기준은 **각 결정점에서 모든 가능한 결정 결과를 최소 한 번 이상 실행**하도록 요구하며,  
모든 **조건식이 참(True)과 거짓(False)이 되도록** 만들어진다.  
이를 통해 개발자와 테스터는 **소프트웨어 내의 결정점에서 발생할 수 있는 다양한 조건 변경 사항들이 올바르게 처리되고 있는지** 검증할 수 있다.  
이러한 테스트 커버리지는 **조건의 모든 논리적 경로를 테스트**하여 **소프트웨어의 품질을 향상**시키는 데 중요한 역할을 한다.

---

# ✅ 변경 조건/결정 커버리지 (MC/DC)

## 🔍 한 줄 요약
**조건 하나만 바꿨을 때, 결과가 바뀌는지 보는 아주 정밀한 테스트 방식**

---

## 🧠 핵심 개념
- 여러 조건이 있는 `if문`에서,  
  → **각 조건이 결과에 독립적으로 영향을 주는지** 확인해야 함
- 조건이 True/False 되는 것만으로는 부족함  
  → **"결과에도 진짜 영향을 줬는가?"**가 포인트

---

## 📌 갓반인용 예시

# 🧠 갓반인 예시

```java
if (A || B) {
  실행
}


케이스	A	B	결과
①	      F	F	X
②	      T	F	O
③      	F	T	O

✅ 이렇게 A와 B가 각자 바뀌었을 때 결과도 바뀌면 → MC/DC 충족

# 🎯 왜 중요한가?

- 항공기, 자율주행, 의료기기처럼 **사람 생명에 관련된 시스템**에서는  
  단순히 “잘 실행됨”만으론 안 됨  
- → 조건 하나하나가 결과에 영향을 주는지 **입증해야 함**  
- → 그래서 **MC/DC는 필수 요건**

---

# 🪜 테스트 커버리지 비교

| 커버리지 종류         | 설명                              |
|----------------------|---------------------------------|
| 구문 커버리지         | 코드 한 줄 한 줄 다 실행해봄      |
| 조건 커버리지         | 조건 안의 각 항목이 True/False 되는지 확인 |
| 결정 커버리지         | if 전체 결과가 True/False 되는지 확인 |
| 조건/결정 커버리지    | 조건 커버리지와 결정 커버리지를 같이 만족 |
| MC/DC                 | 각 조건이 결과에 영향을 주는지 독립적으로 검증 |
| 다중 조건 커버리지    | 모든 조건 조합을 다 테스트 (비효율적) |

---

# 🧠 암기 포인트

- **MC/DC = 조건 하나 바꿔서 결과 바뀌는지 확인**  
- 단순 커버리지보다 한 단계 더 깊이 테스트  
- 생명/안전 관련 시스템에선 표준이자 의무 수준


----------------------------------------------------------------------------------
## 📝 문제 4) 보안 관련 악성 소프트웨어 용어

### ❓ 문제
다음은 컴퓨터 시스템 내에서 사용자의 허가 없이 **자신의 존재를 숨기고**,  
**관리자 레벨의 접근 권한을 얻기 위해 설계된 악성 소프트웨어의 한 유형**이다.  
이 소프트웨어는 시스템의 **기본적인 기능에 깊숙이 침투하여 활동을 감추며**,  
**다양한 보안 도구로부터 탐지를 피할 수 있다**.  
종종 **시스템 로그 파일을 수정하거나**, **키스트로크를 기록**하고,  
**비밀번호를 도용하는 등의 활동**을 포함할 수 있다.  
이러한 특성 때문에 보안 전문가들에게는 큰 위협이며, **제거가 매우 어렵다**.

---

### ✅ 정답  
**Rootkit (루트킷)**

---

### 🔍 해설

# 🧨 루트킷(Rootkit)

> 시스템 관리자 권한을 훔쳐서, **자기 존재를 숨긴 채**, 몰래 악성 행위를 계속하는 **은폐형 악성 코드**.

## 💣 한 줄 요약  
**“보안 시스템 눈속임하고 몰래 해킹을 지속하는 숨어있는 해커 도구”**

---

## ⚙️ 루트킷 특징

- **시스템 깊숙한 곳(운영체제 핵심)에 설치됨**
- 보안 프로그램, 관리자 눈에 **안 보이게 로그/파일/프로세스 조작**
- **키보드 입력 훔치기(키로깅), 백도어 심기, 비번 탈취, 원격제어** 등 가능
- 보안 소프트웨어가 **탐지도 제거도 잘 못함**
- **포맷이나 운영체제 재설치가 필요할 수도 있음**

---

## 📌 현실 예시

| 개념 | 현실 예시 |
|------|------------|
| **루트킷 설치** | 누가 내 PC에 몰래 침투해서 **‘작업 관리자’에도 안 뜨는 프로그램**을 심어놓음 |
| **로그 조작** | 나 몰래 들어와 놓고 **접속 기록, 에러 기록 다 지워버림** |
| **키로깅** | 내가 **인터넷뱅킹 로그인할 때 키보드 입력을 몰래 저장**함 |
| **백도어** | 내가 컴 꺼놔도 **외부에서 다시 몰래 접속할 수 있는 통로를 남겨둠** |
| **보안 프로그램 우회** | 백신이 아예 **그 프로그램 자체를 못 보게 만들어놓음** |

---

## 📌 서비스 공격(DoS/DDoS)의 대표 예시들

| 공격명 | 설명 | 갓반인용 예시 |
|--------|------|---------------|
| **Smurf Attack** | 공격자가 엉뚱한 IP로 ICMP 브로드캐스트 → 피해자가 ICMP 폭탄 맞음 | A한테 전화할 때 **발신자 번호를 B로 조작**해서 B한테 항의 전화가 쏟아지게 함 |
| **Ping of Death** | 비정상적으로 **큰 ICMP 패킷**을 보내 시스템 다운 | 누가 **1GB짜리 메모를 휴대폰 문자로 보냄 → 폰 먹통됨** |
| **Teardrop Attack** | IP 조각을 **이상하게 쪼개서**, 시스템이 조합 못 하게 함 | 퍼즐을 일부러 **안 맞게 잘라서 보냄 → 프로그램 충돌** |
| **LAND Attack** | 출발지/목적지 IP를 같게 해서 시스템 혼란 | 누가 자기한테 자기 번호로 문자 보냄 → 시스템 멘붕 |
| **SYN Flooding** | TCP 연결 요청만 계속하고 응답 안 받음 → 연결 큐 넘침 | 카페 입구에서 **계속 자리 예약만 하고 안 들어옴 → 대기열 폭발** |
| **UDP Flooding** | 대상의 여러 포트에 **무작위 UDP 패킷 대량 전송** | **무작위로 전화를 계속 걸어댐**. 받으면 아무 소리도 안 들림 |
| **Ping Flooding** | 계속 Ping만 날려서 대상 자원 과부하 | “야 있어?”, “야 있냐?”, “야야야야야야...” 계속 말 거는 애 |

---

## 📌 정보보안의 3요소 (CIA Triad)

| 요소 | 설명 | 현실 예시 |
|------|------|------------|
| **기밀성 (Confidentiality)** | 허가된 사람만 정보 접근 가능 | 회사 서버에 고객 정보가 있는데 **비밀번호 안 알면 접근 불가** |
| **무결성 (Integrity)** | 정보가 **원래대로 유지**되도록 보장 | 쇼핑몰에서 상품 가격이 갑자기 100만원 → 100원으로 바뀌면 안 됨 |
| **가용성 (Availability)** | 정보나 시스템에 **언제든 접근 가능** | 전산망 오류로 **ATM이 안 되면 가용성 깨진 것** |




 ----------------------------------------------------------------------------------

## 📝 문제 5) 사이버 공격 유형

### ❓ 문제
다음은 **고도로 조직화된 공격자 그룹이 특정 대상에 대해 장기간에 걸쳐 은밀하게 수행하는 사이버 공격 방법**이다.  
이러한 공격은 대개 **국가의 지원을 받는 해커들에 의해 수행**되며,  
**특정 기업, 정부 기관, 또는 중요 인프라**를 목표로 한다.  
공격자들은 **네트워크 내부에 오랫동안 숨어 있으면서 데이터를 탈취하거나 시스템을 조작**하여  
심각한 피해를 입힐 수 있다.  
이러한 공격은 일반적인 사이버 위협과 **목적과 수행 방식 면에서 구별되며**,  
**매우 정교하고 지속적인 모니터링**이 요구된다.

---

### ✅ 정답  
**APT (Advanced Persistent Threat)**

---

### 🔍 해설

# 🎯 APT (지능형 지속 위협, Advanced Persistent Threat)

## ✅ 한 줄 요약  
**“목표를 정하고 몰래 숨어들어, 장기간 정보를 빼내는 스파이 같은 해킹”**

---

## ⚙️ APT의 3요소

| 구성요소 | 의미 | 예시 |
|----------|------|------|
| **Advanced (고급)** | 보안 우회 기술, 전용 악성코드 사용 | 문서파일에 악성코드 심어 메일로 침투 |
| **Persistent (지속적)** | **오랜 시간 숨어서 활동** | 공격자는 들켰는지 감시하면서 몇 달, 몇 년도 존버 |
| **Threat (위협)** | 국가/기업 등에 **막대한 피해** | 기술 설계도 유출, 발전소 마비, 고객 정보 탈취 등 |

---

## 🕵️‍♀️ 현실 기반 예시

- 어떤 해커가 **“특정 방산업체”**를 목표로 삼음  
- 직원에게 **“급여 정산 안내”** 제목의 메일 발송 → **첨부파일 클릭 유도**  
- 감염되면 내부망으로 퍼짐, 중요한 서버에 **백도어 설치**  
- 수개월 동안 **기밀 문서, 설계도, 계약 정보** 빼냄  
- 보안팀은 거의 눈치 못 챔 → **나중에 털린 후 알게 됨**

---

## 🧨 APT와 관련 악성코드 종류 요약 (갓반인 해설 포함)

| 유형 | 설명 | 현실 비유 |
|------|------|-----------|
| **Worm** | 자가복제하며 네트워크 통해 퍼짐 | "단톡방에 걸린 링크 클릭 → 전부 감염됨" |
| **Trojan Horse** | 겉보기엔 정상, 내부는 악성 | "무료 게임 설치했는데 백그라운드에서 해킹함" |
| **Backdoor** | 몰래 들어오는 통로 | "도둑이 뒷문 따놓고 계속 드나듦" |
| **Virus** | 다른 파일에 붙어서 전염 | "한 엑셀파일 열었더니 전체 폴더가 감염됨" |
| **Ransomware** | 파일을 암호화하고 몸값 요구 | "회사 컴퓨터 파일 잠금 → 복호화하려면 돈 내라 함" |
| **Spyware** | 사용자 몰래 정보 수집 | "내 검색기록, 계좌번호 몰래 유출됨" |
| **Adware** | 광고 팝업, 리디렉션 | "브라우저 열 때마다 이상한 광고 사이트 뜸" |
| **APT** | 특정 목표에 맞춰 **장기적으로** 공격 | "특정 기업만 골라 몇 달 동안 해킹해서 설계도 빼감" |
| **Zero-day Attack** | 알려지지 않은 취약점 악용 | "보안패치 안 나온 허점을 미리 찔러 들어옴" |

---

## 🧠 갓반인을 위한 핵심 정리

- **APT는 단순한 해킹이 아님. 진짜 전쟁 수준임**
- 대부분 **국가 후원 or 산업 스파이** 성격 → 피해 규모가 엄청 큼
- **처음엔 이메일 한 통으로 시작 → 몇 개월 뒤 전사 해킹 완료됨**
- 탐지 어려움 + 퇴치도 어려움 → **사전 방어와 보안 교육이 핵심**

 ----------------------------------------------------------------------------------
## 📝 문제 6) 생성 디자인 패턴

### ❓ 문제
다음은 소프트웨어 공학에서 사용되는 **생성 디자인 패턴** 중 하나로,  
**관련 또는 의존하는 객체의 집합을 생성하기 위한 인터페이스**를 제공한다.  
이 패턴은 **구체적인 클래스를 지정하지 않고도 객체 생성을 캡슐화**하는 방법을 제공하여,  
**클라이언트 코드가 특정 클래스의 인스턴스에 직접 의존하지 않도록** 한다.  
이를 통해 클라이언트는 여러 제품군 중 필요한 제품을 선택하여 생성할 수 있으며,  
시스템의 **확장성과 유연성**이 증가된다.  
**다양한 환경에서 공통적으로 사용될 수 있는 제품군**을 생성하는 과정에서 특히 유용하다.

---
### ✅ 정답  
**Abstract Factory**  
(추상 팩토리 패턴)



# 🔍 Abstract Factory 패턴 쉽게 이해하기

## ✅ 한 줄 요약  
**“비슷한 종류 제품(객체) 묶음을 한 번에 만드는 공장 인터페이스”**

---

## 🧠 핵심 개념  
- 여러 관련 객체를 **제품군(Product Family)**으로 묶음  
- 이 제품군들을 만들 수 있는 **공장(Factory) 인터페이스를 제공**  
- 클라이언트는 구체적인 클래스 몰라도 제품군을 만들 수 있음  
- 제품군끼리 일관성 유지하면서 시스템 유연하게 설계 가능  
- 예) 윈도우용 버튼 + 체크박스, 맥용 버튼 + 체크박스 각각 다르게 만들 때 유용

---

## 📌 갓반인 예시

- 상상해봐:  
  **“가구 공장”**이 있어  
  - ‘모던 스타일’ 가구 세트 만들 공장  
  - ‘클래식 스타일’ 가구 세트 만들 공장  
- 각각 공장은 **의자, 소파, 테이블** 같은 제품군을 만들어 줌  
- 사용자는 그냥 “모던 가구 공장” 부르면 모던 의자, 모던 소파, 모던 테이블을 한꺼번에 받음  
- **어떤 스타일 공장(Concrete Factory)을 쓸지 몰라도** 항상 일관된 제품군을 받을 수 있음

---

## 📌 디자인 패턴 분류 관련  

| 분류    | 설명                            | 대표 패턴                          |
|---------|---------------------------------|-----------------------------------|
| 생성 패턴 | 객체 만드는 방법을 추상화          | Singleton, Factory Method, **Abstract Factory**, Builder, Prototype |
| 구조 패턴 | 클래스/객체 연결해 큰 구조 만듦    | Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy       |
| 행위 패턴 | 객체 간 역할 분배 및 알고리즘 관리 | Observer, Strategy, Command, State, Template Method 등                |

### 갓반인 예시  
- 생성 패턴: “새 제품 만드는 공장 설계도”  
- 구조 패턴: “레고 블록처럼 여러 부품을 조립”  
- 행위 패턴: “배달 음식 주문 처리, 누가 어떤 역할 할지 정함”

---

## 📌 객체지향 기본 개념  

| 개념   | 설명                   |
|--------|------------------------|
| 클래스 | 설계도 (객체 설계서)     |
| 객체   | 설계도로 만든 실체       |
| 속성   | 객체가 가진 데이터       |
| 메서드 | 객체가 할 수 있는 행동   |
| 메시지 | 객체에게 동작 요청하는 것 |

### 갓반인 예시  
- 클래스: 쿠키 틀  
- 객체: 틀로 찍어낸 쿠키  
- 속성: 쿠키 맛, 크기, 색깔  
- 메서드: 쿠키 굽기, 포장하기  
- 메시지: “굽기 시작해!”, “포장해줘!”

---

## 📌 SOLID 설계 원칙 간단 정리

| 원칙 | 뜻                  |
|------|---------------------|
| SRP  | 한 클래스는 한 가지 책임만 가져야 함 |
| OCP  | 확장에는 열려 있고, 변경에는 닫혀 있어야 함 |
| LSP  | 자식 클래스는 부모 대체 가능해야 함   |
| ISP  | 불필요한 인터페이스에 의존하지 말 것 |
| DIP  | 구체가 아니라 추상에 의존할 것        |

### 갓반인 예시  
- SRP: 주방 칼은 ‘자르기’만 담당, 청소는 청소 도구가 하게 하기  
- OCP: 새 요리법은 추가 가능, 기존 요리법은 바꾸지 않기  
- LSP: 초콜릿 케이크는 ‘케이크’로 바꿔 써도 문제 없어야 함  
- ISP: TV 리모컨에서 ‘라디오’ 버튼 빼고, 라디오 리모컨엔 ‘채널’ 버튼만 있게 하기  
- DIP: 전기 제품은 ‘전원’이란 추상에 연결, 콘센트 모양이 달라도 작동하게 하기


 ----------------------------------------------------------------------------------
## 📝 문제 7) 서브넷 마스크 기반 IP 주소 할당

### ❓ 문제  
아래 네트워크 구성에서 **2번, 4번, 6번 라우터에 할당 가능한 IP 주소**를 보기에서 찾아 작성하시오.

#### [적용된 IP 주소]  
- 1번) `192.168.35.12/24`  
- 3번) `129.200.10.16/22`  
- 5번) `192.168.36.32/24`  

#### [보기]  
- A) `192.168.35.72`  
- B) `129.200.8.249`  
- C) `192.168.36.249`  

---

### ✅ 정답  
- **2번:** `192.168.35.72`  
- **4번:** `129.200.8.249`  
- **6번:** `192.168.36.249`  

---

### 🔍 갓반인 해설  

#### 1) 2번 라우터 (192.168.35.12/24)  
- `/24`는 동네 경계가 `255.255.255.0` 이라서  
- ‘192.168.35.0’부터 ‘192.168.35.255’까지가 이 동네  
- ‘192.168.35.72’도 이 동네 안에 있으니  
→ 2번 라우터에 할당 가능!  

#### 2) 4번 라우터 (129.200.10.16/22)  
- `/22`는 동네 경계가 `255.255.252.0`이라  
- 네트워크가 4단위 블록으로 나뉘어 ‘129.200.8.0’부터 ‘129.200.11.255’까지  
- ‘129.200.10.16’은 10이니까 ‘8~11’ 사이 동네  
- ‘129.200.8.249’도 같은 동네 안!  
→ 4번 라우터에 할당 가능!  

#### 3) 6번 라우터 (192.168.36.32/24)  
- `/24`니까 동네 경계는 `255.255.255.0`  
- ‘192.168.36.0’부터 ‘192.168.36.255’까지  
- ‘192.168.36.249’도 같은 동네 안!  
→ 6번 라우터에 할당 가능!  

---

### 💡 쉽게 생각하기  
- IP 주소는 집 주소, 서브넷 마스크는 ‘동네 경계’  
- 같은 동네 사람들끼리만 소통 가능  
- /24는 작은 동네, /22는 좀 더 큰 동네 같은 느낌!
---

### 📌 관련 개념: CIDR 및 서브넷 마스크

| CIDR 표기 | 서브넷 마스크     | 호스트 개수           | 주소 범위 예시          |
|-----------|------------------|-----------------------|-------------------------|
| /24       | 255.255.255.0    | 256개 중 254개 사용 가능 | x.x.x.0 ~ x.x.x.255     |
| /22       | 255.255.252.0    | 1024개 중 1022개 사용 가능 | x.x.8.0 ~ x.x.11.255    |

- 서브넷 마스크는 IP 주소를 **네트워크 부분과 호스트 부분으로 나누는 표시**  
- **CIDR(씨더)**는 이걸 간단하게 표현하는 방법으로, 숫자가 클수록 네트워크 영역이 넓고, 작을수록 호스트 영역이 많음  
- 예를 들어, /24는 ‘마을’ 하나 크기, /22는 ‘큰 동네’ 크기라고 생각하면 쉽다  

---

### ✅ 갓반인 요약표

| 라우터 번호 | 적용된 IP           | 할당 가능한 IP         | 네트워크 확인 결과       |
|-------------|---------------------|------------------------|-------------------------|
| 2번         | 192.168.35.12/24    | 192.168.35.72          | “같은 마을(네트워크)”    |
| 4번         | 129.200.10.16/22    | 129.200.8.249          | “같은 큰 동네(네트워크)” |
| 6번         | 192.168.36.32/24    | 192.168.36.249         | “같은 마을(네트워크)”    |

---

### 🤔 쉽게 비유하자면

- IP 주소 = 집 주소  
- 서브넷 마스크 = ‘동네’ 경계선  
- CIDR 숫자 클수록 ‘동네’가 작아져서 같은 동네끼리만 서로 왕래 가능!  
- /24는 작은 동네, /22는 큰 동네 같은 개념임

-------------------------------------------------------------------------------------
## 📝 문제 8) SQL 조인(join) 종류

### ❓ 문제
다음은 **조인(join)**에 대한 설명이다.  
**괄호에 들어갈 알맞은 용어**를 작성하시오.

---

### ①  
두 테이블을 특정 조건을 기반으로 결합하는 조인 방법이다.  
이 조인은 조건이 `=`(동등)뿐만 아니라 `<`, `>`, `<=`, `>=`, `!=` 등의 **비교 연산자**를 사용할 수 있다.  
이 조인을 통해 다양한 조건을 기반으로 두 테이블 간의 관계를 정의하고,  
조건에 맞는 행을 결합하여 새로운 결과 집합을 만든다.  
> **정답: 세타 조인 (Theta Join)**

---

### ②  
두 테이블을 결합할 때, 조인 조건으로 `=`(동등) 연산자만을 사용하는 조인 방법이다.  
이 조인은 두 테이블의 특정 컬럼 값이 **동일한 행**들을 결합하여 결과 집합을 만든다.  
주로 **외래 키와 기본 키**를 매칭할 때 사용되며, **조건에 맞는 행만** 결과에 포함된다.  
> **정답: 동등 조인 (Equi Join)**

---

### ③  
두 테이블을 결합할 때, **동일한 이름의 컬럼**을 기반으로 동등 비교를 수행하여 조인하는 방법이다.  
이 조인은 **조인 조건을 명시하지 않아도**, 동일한 이름의 컬럼들을 자동으로 매칭하여 결합한다.  
결과 집합에는 **중복되는 컬럼이 하나만 포함**되며,  
두 테이블 간의 공통된 컬럼 값이 동일한 행들만 결합된다.  
> **정답: 자연 조인 (Natural Join)**

---

## ✅ 최종 정답 정리

| 번호 | 조인 유형             | 설명 |
|------|------------------------|------|
| 1번 | **세타 조인 (Theta Join)** | `=`, `<`, `>`, `<=`, `>=`, `!=` 등 **비교 연산자** 사용 가능 |
| 2번 | **동등 조인 (Equi Join)** | 오직 `=` 연산자만 사용 |
| 3번 | **자연 조인 (Natural Join)** | **같은 이름의 컬럼** 자동 매칭 + **중복 컬럼 제거**

---

## 📌 갓반인용 핵심 요약 + 예시

### 1️⃣ 세타 조인 (Theta Join)
- 📌 **모든 비교 연산자 사용 가능**
- 💬 예시 상황: "너 점수 80점 이상인 애들만 조인해줘!"
- 예시:
  ```sql
  SELECT * FROM A, B WHERE A.score >= B.cutline;

2️⃣ 동등 조인 (Equi Join)
📌 조건은 오직 = 하나만

💬 예시 상황: "학번이 같은 애들끼리 연결해!"

예시:

SELECT * FROM Student S, Score T WHERE S.id = T.id;


3️⃣ 자연 조인 (Natural Join)
📌 같은 이름 컬럼 자동 연결 + 중복 제거

💬 예시 상황: "같은 이름인 컬럼은 알아서 붙여줄게. 중복도 없앴어"

예시:
SELECT * FROM Student NATURAL JOIN Score;

### 📌 관련 개념: 조인의 종류

#### 📊 조인 한눈 요약

| 조인 종류     | 특징 |
|--------------|----------------------------------------------------|
| 세타 조인     | 다양한 연산자 비교 가능 (`=`, `<`, `>`, `!=` 등) |
| 동등 조인     | `=`만 사용 |
| 자연 조인     | 같은 컬럼 자동 연결 + 중복 제거 |
| 내부 조인     | 조건 맞는 것만 결과 |
| 외부 조인     | 조건 안 맞아도 한쪽 데이터는 전부 출력 |
| 자기 조인     | 같은 테이블을 두 번 불러서 비교 |

---

### 📌 데이터베이스 설계 3단계 요약

| 단계         | 설명 |
|--------------|-----------------------------|
| 개념적 설계  | ERD 그리는 단계 (DBMS 독립적) |
| 논리적 설계  | 정규화하고 테이블 설계 |
| 물리적 설계  | 실제 저장 방법, 인덱스 등 구현 관여 |


 ----------------------------------------------------------------------------------

## 📝 문제 8) 페이지 교체 알고리즘 - LRU / LFU 부재 횟수 계산

### ❓ 문제
다음 **페이지 참조 순서**를 고려하여  
**LRU**(Least Recently Used)와 **LFU**(Least Frequently Used) 알고리즘에 따른 **페이지 부재 횟수**를 구하시오.

> 페이지 프레임 수: **3개**

#### 📌 페이지 참조 순서:
1, 2, 3, 1, 2, 4, 1, 2, 5, 7


---

### ✅ 정답

- **LRU:** `6`
- **LFU:** `6`

---

### 🔍 시뮬레이션 해설

#### ✅ LRU (가장 오랫동안 사용되지 않은 페이지 교체)

| Step | 참조 페이지 | 프레임 상태         | 페이지 부재(O/X) |
|------|-------------|----------------------|------------------|
| 1    | 1           | 1 - -                | O                |
| 2    | 2           | 1 2 -                | O                |
| 3    | 3           | 1 2 3                | O                |
| 4    | 1           | 2 3 1 (1 사용됨)     | X                |
| 5    | 2           | 3 1 2 (2 사용됨)     | X                |
| 6    | 4           | 1 2 4 (3 제거)       | O                |
| 7    | 1           | 2 4 1 (1 사용됨)     | X                |
| 8    | 2           | 4 1 2 (2 사용됨)     | X                |
| 9    | 5           | 1 2 5 (4 제거)       | O                |
| 10   | 7           | 2 5 7 (1 제거)       | O                |

- **총 부재 횟수:** `6`

---

#### ✅ LFU (가장 적게 사용된 페이지 교체)

| Step | 참조 | 프레임 상태 (카운트)         | 부재(O/X) | 교체 기준 |
|------|------|-------------------------------|-----------|------------|
| 1    | 1    | 1(1) - -                       | O         |            |
| 2    | 2    | 1(1) 2(1) -                    | O         |            |
| 3    | 3    | 1(1) 2(1) 3(1)                 | O         |            |
| 4    | 1    | 1(2) 2(1) 3(1)                 | X         |            |
| 5    | 2    | 1(2) 2(2) 3(1)                 | X         |            |
| 6    | 4    | 1(2) 2(2) 4(1) (3 제거)        | O         | 3이 최소   |
| 7    | 1    | 1(3) 2(2) 4(1)                 | X         |            |
| 8    | 2    | 1(3) 2(3) 4(1)                 | X         |            |
| 9    | 5    | 1(3) 2(3) 5(1) (4 제거)        | O         | 4이 최소   |
| 10   | 7    | 1(3) 2(3) 7(1) (5 제거)        | O         | 5가 최소   |

- **총 부재 횟수:** `6`


### 📌 페이지 교체 알고리즘 요약

| 알고리즘 | 뜻 | 동작 방식 | 갓반인 예시 |
|----------|-----|-----------|--------------|
| **LRU**  | Least Recently Used | 가장 오래 전에 사용된 페이지를 교체 | 오래 전에 꺼낸 도시락부터 버리는 느낌 |
| **LFU**  | Least Frequently Used | 사용 횟수가 가장 적은 페이지를 교체 | 거의 안 쓰는 물건부터 버리는 느낌 |

---

### ✅ 핵심 차이
- **LRU**: **"언제 마지막으로 썼는지"**에 집중  
  → 최근에 안 쓴 애를 교체  
- **LFU**: **"얼마나 자주 썼는지"**에 집중  
  → 사용 횟수 적은 애를 교체

---

### 🧠 요약 암기
- **LRU** = "오래 안 쓴 거 out"
- **LFU** = "잘 안 쓰는 거 out"
---

### 📌 관련 개념 요약

#### 🔹 페이지 교체 알고리즘 종류

| 알고리즘 | 설명 | 갓반인 비유 |
|----------|------|-------------|
| **FIFO** | 먼저 들어온 페이지 제거 | 줄 먼저 선 애부터 퇴장 |
| **LRU** | 가장 오래 전에 사용된 페이지 제거 | 도시락 오래 안 먹은 애 버림 |
| **LFU** | 가장 적게 사용된 페이지 제거 | 거의 안 쓰는 앱부터 삭제 |
| **OPT** | 앞으로 가장 오랫동안 사용 안 될 페이지 제거 (이론상 최적) | 미래 예지해서 안 쓸 거 버림 |
| **SCR (Second Chance)** | FIFO + 사용 여부 확인 | 한 번 기회 주고 다시 FIFO |
| **NUR** | 사용/수정 비트 기반 교체 | 최근 안 쓴 & 안 고친 애부터 교체 |

---

### 📌 프로세스 스케줄링 알고리즘

| 구분 | 설명 | 대표 알고리즘 |
|------|------|----------------|
| **선점형** | CPU를 뺏어올 수 있음 | Round Robin, SRT, MLFQ |
| **비선점형** | CPU를 끝날 때까지 줌 | FCFS, SJF, HRN, 우선순위 |

---

### ✅ 핵심 요약

- **LRU** → "시간 기준" (언제 마지막으로 썼는지)
- **LFU** → "횟수 기준" (얼마나 자주 썼는지)
- **같은 횟수일 경우** → LFU는 먼저 들어온 페이지 제거 가능
- 문제 기준: 두 방식 모두 **페이지 부재 6회**

------------------------------------------------------------------
## ✅ 문제 10

> **다음 표에서 나타내고 있는 정규형을 쓰시오.**

| 학생 아이디 | 강좌명 | 담당 강사 |
|:-----------:|:------:|:---------:|
| 001         | 영어   | P001      |
| 002         | 한국사 | P002      |
| 003         | 영어   | P001      |
| 003         | 한국사 | P004      |
| 004         | 영어   | P003      |
| 004         | 한국사 | P004      |

---
## 🔎 정규화 분석 (정답: 제2정규형)

| 항목 | 내용 |
|------|------|
| 📌 기본키 후보 | (학생 아이디, 강좌명) |
| 🔄 함수 종속성 | (학생 아이디, 강좌명) → 담당 강사 <br> 강좌명 → 담당 강사 (👉 **이행적 종속**) |
| ✅ 제2정규형(2NF) | **부분 함수 종속 없음** |
| ❌ 제3정규형(3NF) 아님 | **비프라이머리 속성(담당 강사)**이 **기본키 아닌 속성(강좌명)**에 종속됨 |

🧠 **쉽게 말하면**  
- "담당 강사"는 "강좌명"만 알면 정해진다  
- 근데 "강좌명"은 기본키가 아님 → 이행적 종속!  
- 그래서 **3NF 아님**, 아직 **2NF 단계**임

---

## 💡 제3정규형으로 바꾸기 (분해)

### 학생수강 테이블 (학생이 어떤 과목 들었는지)

| 학생 아이디 | 강좌명 |
|-------------|--------|
| 001         | 영어   |
| 002         | 한국사 |
| 003         | 영어   |
| 003         | 한국사 |
| 004         | 영어   |
| 004         | 한국사 |

### 강좌 테이블 (과목별 강사 매핑)

| 강좌명 | 담당 강사 |
|--------|------------|
| 영어   | P001 / P003 |
| 한국사 | P002 / P004 |

⚠️ **주의!**  
한 과목에 **여러 명의 강사**가 있을 수도 있어서  
"1:N 관계인지", "강사별 시간표가 다른 건지" 등은 **추가 분석 필요**!

---

## ✅ 최종 정답: **제2정규형(2NF)**

🎯 **암기 포인트 요약**

| 정규형 | 핵심 조건 | 예시 비유 |
|--------|-----------|-----------|
| 1NF | 셀마다 원자값 | 셀에 값 여러 개 넣지 마! |
| 2NF | **부분 함수 종속 없음** | 전체 키로만 결정되게 |
| 3NF | **이행적 종속 없음** | A → B → C 형태 금지 (B는 키 아니면 안 돼!) |


  ----------------------------------------------------------------------------------

## 📝 문제 11) SQL 실행 결과 작성

### ❓ 문제
아래 SQL 문장을 수행하였을 때의 결과를 표로 작성하시오.


select b from t1
where c in
(
  select c from t2
  where d = 'k'
)
```

---

### 📋 테이블 정보

#### t1

| a | b | c |
|---|---|---|
| 1 | a | x |
| 2 | b | x |
| 1 | c | w |
| 3 | d | w |

#### t2

| c | d | e |
|---|---|---|
| x | k | 3 |
| y | k | 3 |
| z | s | 2 |

---

### ✅ 풀이 과정

1. **서브쿼리 실행**

select c from t2 where d = 'k'
```

→ 결과:

| c |
|---|
| x |
| y |

즉, c 값은 `'x'` 또는 `'y'`.

---

2. **외부 쿼리 실행**

select b from t1 where c in ('x', 'y')
```

t1에서 c가 `'x'` 또는 `'y'`인 레코드 찾기:

- t1에서 c = 'x'

| a | b | c |
|---|---|---|
| 1 | a | x |
| 2 | b | x |

- t1에서 c = 'y'

없음

---

### ✅ 최종 결과

| b |
|---|
| a |
| b |

---

### 📌 요약
- 서브쿼리에서 `d = 'k'`인 t2의 c 값 → `x`, `y`
- t1에서 c 값이 이 값들에 해당하는 행의 b 컬럼 출력
- 최종 결과는 **a**, **b**

  ---------------------------------------------------------------------------------- 
## 📝 문제

❓ 문제  
아래 SQL 문장을 수행하였을 때의 결과를 표로 작성하시오.

```sql
select
  count(*)
from table
where empno > 100
  and sal >= 3000
  or empno = 200
```

---

### 📋 테이블 정보

| empno | sal  |
|-------|------|
| 100   | 1000 |
| 200   | 3000 |
| 300   | 1500 |

---

### ✅ 풀이 과정

조건식을 괄호로 구분하면 아래와 같다:

```
(empno > 100 AND sal >= 3000) OR (empno = 200)
```

행별 조건 평가:

| empno | sal  | 조건 1: empno > 100 AND sal >= 3000 | 조건 2: empno = 200 | 전체 조건 결과 |
|-------|------|------------------------------------|----------------------|-----------------|
| 100   | 1000 | False (100 > 100 ? No)             | False                | False           |
| 200   | 3000 | True (200 > 100 AND 3000 ≥ 3000)   | True                 | True            |
| 300   | 1500 | False (1500 < 3000)                | False                | False           |

- 조건을 만족하는 행은 **empno = 200** 한 건 뿐

---

### ✅ 최종 결과

| count(*) |
|----------|
| 1        |

---

### 📌 요약

- AND 연산이 OR보다 우선순위가 높음
- 조건은 아래처럼 해석됨:
  - `(empno > 100 AND sal >= 3000) OR (empno = 200)`
- 조건을 만족하는 것은 **empno = 200** 한 건
- 최종 결과는 `count(*) = 1`


  ---------------------------------------------------------------------------------- 

## 📝 문제 13) C언어 코드 출력 결과

### ❓ 문제 코드

#include <stdio.h>

int main(){
    int v1 = 0, v2 = 35, v3 = 29;           // v1=0, v2=35, v3=29으로 초기화
    
                                                    // 조건문 (삼항 연산자): v1 > v2 ? v2 : v1
                                                    // v1(0) > v2(35) 는 거짓(false) 이므로, v1의 값인 0이 반환된다.
                                                    // 따라서 if(0) 이 된다.
    if (v1 > v2 ? v2 : v1) {                           // if (0) 이므로 이 블록은 실행되지 않는다.
        v2 = v2 << 2;                                 // << 는 왼쪽 비트 시프트 연산자. 숫자를 2의 제곱만큼 곱하는 것과 같다.
    } else {                                         // if 조건이 거짓(0)이므로 else 블록이 실행된다.
        v3 = v3 << 2;                                 // v3의 값을 왼쪽으로 2비트 시프트한다.
                                                    // 29를 왼쪽으로 2비트 시프트하면 29 * (2^2) = 29 * 4 = 116이 된다.
                                                    // 따라서 v3는 116이 된다.
    }
                                                    
                                                    // printf("%d", v2 + v3);
                                                    // v2는 여전히 35이고, v3는 116이다.
                                                    // 35 + 116 = 151
    printf("%d", v2 + v3);
}


### ✅ C 코드 실행 흐름 설명 (그대로 마크다운)

변수 초기값: v1 = 0, v2 = 35, v3 = 29로 시작한다.

조건문 계산: if (v1 > v2 ? v2 : v1) 이 부분은 if (0 > 35 ? 35 : 0) 이 된다.  
0 > 35는 당연히 거짓(false) 이지?  
그럼 ? 뒤에 : 다음에 오는 0이 선택된다.  
결국 if (0) 이 된다.

if (0)은 거짓: C언어에서 0은 거짓을 의미한다.  
그래서 if 블록(v2 = v2 << 2;)은 실행 안 되고,  
else 블록(v3 = v3 << 2;)이 실행된다.

---

### 🧠 v3 = v3 << 2; 이게 뭔데?

이게 핵심인데, `<<` 이건 '비트 시프트' 연산자다.  
쉽게 말해서 숫자를 2의 거듭제곱만큼 곱하는 거랑 똑같다고 보면 된다.

v3는 처음에 29였지?

v3 << 2는 29를 왼쪽으로 2비트 옮기는 거야.  
이건 `29 * (2의 2승)` 이랑 같아.

2의 2승은 4니까, 결국 `29 * 4`가 된다.  
29 * 4 = 116이다.  
그래서 v3는 이제 116이 되는 거지.

---

### ✅ 최종 결과

- v1은 계속 0.  
- v2는 if 블록을 안 탔으니 초기값 그대로 35.  
- v3는 else 블록에서 116으로 바뀌었다.

마지막 줄 `printf("%d", v2 + v3);` 는  
v2와 v3를 더해서 출력하라는 거잖아?

**35 + 116 = 151**

---------------------------------------------------------------------------------- 

## 📝 문제 14) C언어 코드 출력 결과

### ❓ 문제 코드

#include <stdio.h>
#include <string.h>

void reverse(char* str) {
    int len = strlen(str);
    char* p1 = str;
    char* p2 = str + len - 1;
    while (p1 < p2) {
        char t = *p1;
        *p1 = *p2;
        *p2 = t;
        p1++;
        p2--;
    }
}

int main(int argc, char* argv[]) {
    char str[100] = "ABCDEFGH";
    reverse(str);
    int len = strlen(str);
    for (int i = 1; i < len; i += 2) {
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}

답: GECA


main 함수에서 str 초기화: "ABCDEFGH" 이건 다 알 거고.

reverse(str) 호출: 여기가 핵심이지.
reverse 함수는 문자열을 뒤집어주는 기능을 한다.

p1은 문자열의 맨 앞에서 시작하고, p2는 맨 뒤에서 시작한다.

while (p1 < p2) 루프를 돌면서 *p1이랑 *p2의 값을 바꿔치기 하는 거야.

p1은 한 칸씩 앞으로 가고, p2는 한 칸씩 뒤로 오면서 가운데까지 만날 때까지 계속 바꾼다.

결과적으로 "ABCDEFGH"는 **"HGFEDCBA"**가 된다.

len = strlen(str): 이제 뒤집힌 문자열 HGFEDCBA의 길이를 잰다. 당연히 길이는 8이다.

for 루프 돌면서 출력:

for (int i = 1; i < len; i += 2) 이 부분을 잘 봐야 한다.
i는 1부터 시작한다.
len(8)보다 작을 때까지 돈다.
i는 2씩 증가한다.
그러니까 인덱스가 1, 3, 5, 7 이렇게 뽑히는 거지.

str[1]은 'G'
str[3]은 'E'
str[5]은 'C'
str[7]은 'A'

printf("\n"): 마지막에 줄바꿈 해주는 거고.

결과적으로 GECA가 맞다!

---------------------------------------------------------------------------------- 

## 📝 문제 15) C언어 코드 출력 결과

### ❓ 문제 코드 (오류 및 누락 보완 포함)

#include <stdio.h>

struct ACC {
    int accNum;
    double bal;
};

void init(struct ACC *acc, int x, double y) {
    acc->accNum = x;
    acc->bal = y;
}
                                                      // 복리 계산 함수 (year 파라미터 추가 및 수정)
double sim(double base, int year) {
    double r = 1.0;
    for (int i = 0; i < year; i++) {
        r *= base;
    }
    return r;
}

void xxx(struct ACC* acc, double en) {
    if (en > 0 && en < acc->bal) {
        acc->bal -= en;
    } else {
        acc->bal += en;
    }
}

void yyy(struct ACC* acc) {
    acc->bal *= sim(1.1, 3);
}

int main() {
    struct ACC acc;
    init(&acc, 9981, 2200.0);
    xxx(&acc, 100.0);
    yyy(&acc);
    printf("%d and %0.2f\n", acc.accNum, acc.bal);
    return 0;
}


코드 분석:  
main 함수 시작:

- `struct ACC acc;` : ACC 구조체 타입의 acc라는 변수를 만든다.
- 이 안에 accNum (계좌 번호)랑 bal (잔액)이 들어간다.

- `init(&acc, 9981, 2200.0);` 호출:  
  init 함수는 계좌를 초기화하는 함수다.  
  acc.accNum은 9981로, acc.bal은 2200.0으로 세팅된다.

- `xxx(&acc, 100.0);` 호출:  
  xxx 함수는 돈을 넣거나 빼는 함수인데, 좀 특이하게 동작한다.  
  en 값은 100.0이다.  
  `if (en > 0 && en < acc->bal)` 이 조건식을 봐라.  
  100.0 > 0 (참) 이고 100.0 < 2200.0 (참) 이다.  
  둘 다 참이니까 if 블록 안의 코드가 실행된다.  
  `acc->bal -= en;` : 잔액에서 en 값을 뺀다.  
  acc.bal은 2200.0 - 100.0 = 2100.0이 된다.

- `yyy(&acc);` 호출:  
  yyy 함수는 잔액에 sim 함수의 결과를 곱한다.  
  `sim(1.1, 3)` 계산:  
  sim 함수는 base를 year번 곱하는 함수다. (쉽게 말해 base의 year 제곱)  
  1.1을 3번 곱하니까 1.1 * 1.1 * 1.1 = 1.331이 된다.  
  `acc->bal *= 1.331;` : 현재 잔액에 1.331을 곱한다.  
  acc.bal은 2100.0 * 1.331 = 2795.1이 된다.

- `printf("%d and %0.2f\n", acc.accNum, acc.bal);` :  
  최종적으로 acc.accNum (9981)과 acc.bal (2795.10)을 출력한다.  
  %.2f는 소수점 둘째 자리까지 표시하라는 뜻이다.

---

최종 출력 결과:  
**9981 and 2795.10**

---------------------------------------------------------------------------------- 

## 📝 문제 16) C언어 코드 출력 결과

### ❓ 문제 코드 (오타 및 오류 수정 포함)


#include <stdio.h>
#include <ctype.h>

int main() {
    char p[] = "It is 8";
    char result[20];
    int i;
    for (i = 0; p[i] != '\0'; i++) {
        if (isupper(p[i]))
            result[i] = (p[i] - 'A' + 5) % 26 + 'A';
        else if (islower(p[i]))
            result[i] = (p[i] - 'a' + 10) % 26 + 'a';
        else if (isdigit(p[i]))
            result[i] = (p[i] - '0' + 3) % 10 + '0';
        else
            result[i] = p[i];
    }
    result[i] = '\0';
    printf("%s\n", result);
    return 0;
}


### main 함수 초기화:

- `char p[] = "It is 8";`: 원본 문자열 "It is 8"을 p 배열에 저장한다.  
- `char result[20];`: 변환된 문자를 저장할 result 배열을 만든다.  
- `int i;`: 루프를 돌릴 변수 i를 초기화한다.

---

### for 루프 시작 (`for (i = 0; p[i] != '\0'; i++)`):

- p 배열의 각 문자를 처음부터 끝(`\0`, 널 문자)까지 하나씩 돈다.

---

### 문자별 변환 규칙:

- **대문자인 경우 (`isupper(p[i])`)**:  
  `('I' - 'A' + 5) % 26 + 'A'`  
  'I'는 'A'로부터 8번째 문자다. 8 + 5 = 13.  
  13 % 26 = 13 (26으로 나눈 나머지)  
  13 + 'A'는 'A'로부터 13번째 문자, 즉 'N'이 된다.

- **소문자인 경우 (`islower(p[i])`)**:  
  `('t' - 'a' + 10) % 26 + 'a'`  
  't'는 'a'로부터 19번째 문자다. 19 + 10 = 29.  
  29 % 26 = 3 (29를 26으로 나누면 나머지가 3)  
  3 + 'a'는 'a'로부터 3번째 문자, 즉 'd'가 된다.  

  나머지 'i'는 (8+10)%26 + 'a' = 18 + 'a' = 's'  
  's'는 (18+10)%26 + 'a' = 28%26 + 'a' = 2 + 'a' = 'c'

- **숫자인 경우 (`isdigit(p[i])`)**:  
  `('8' - '0' + 3) % 10 + '0'`  
  '8'은 숫자 8이다. 8 + 3 = 11.  
  11 % 10 = 1 (11을 10으로 나눈 나머지)  
  1 + '0'은 숫자 1, 즉 '1'이 된다.

- **그 외 (공백이나 기타 문자)**:  
  변환 없이 그대로 result에 복사된다. 공백은 공백으로 유지.

---

### 문자열 마무리 및 출력

- `result[i] = '\0';`:  
  루프가 끝나면 result 문자열의 끝에 `\0` (널 문자)를 붙여서 문자열의 끝을 표시한다. 이게 없으면 쓰레기 값이 출력될 수 있다.

- `printf("%s\n", result);`:  
  최종적으로 result 배열에 저장된 문자열을 출력한다.

---

### 최종 출력 결과:  
**Nd sc 1**
Nd sc 1
---------------------------------------------------------------------------------- 
## 📝 문제 17) Java 코드 실행 순서

### ❓ 문제 코드 (오타 수정 및 구조 보완)


class P {
    int x, y;

    P(int x, int y) {  // 생성자명은 클래스명과 같아야 하므로 'p' → 'P'로 수정
        this.x = x;
        this.y = y;
    }

    int getData() {
        return x * y;
    }
}

class C extends P {
    int x;

    C(int x) {
        super(x + 1, x);  // 부모 생성자 호출
        this.x = x;
    }

    int getData(int n) {
        return super.getData() + n;
    }

    public static void main(String[] args) {
        P p = new C(10);
        System.out.println(p.getData());
    }
}

답: 110

코드 분석:  
이 코드는 **상속(Inheritance)**이랑 메서드 오버로딩/오버라이딩 개념이 섞여 있는 문제다. 핵심만 짚어줄게.

---

### P 클래스 (부모):

- x, y라는 멤버 변수가 있다.  
- `P(int x, int y)`: 생성자다. 얘로 x랑 y를 초기화한다.  
- `int getData()`: x * y를 반환하는 메서드다.

---

### C 클래스 (자식):

- P를 `extends` (상속) 받는다.  
- `int x;`: 중요! 부모 P에도 x가 있지만, 자식 C도 똑같은 이름의 x를 가지고 있다.
- 이건 따로 존재하는 변수다. (이걸 변수 섀도잉이라고 부른다.)  
- `C(int x)`: 생성자다.  
- `super(x + 1, x);`: 이게 제일 중요! 자식 클래스 생성자에서는 반드시 부모 클래스의 생성자를 먼저 호출해야 한다.
- 여기서 `C(10)`으로 호출되면 `super(10 + 1, 10)`이니까 `super(11, 10)`이 된다.  
- 그러면 부모 P의 생성자가 호출되면서, 부모 P의 x는 11이 되고, y는 10이 된다.  
- `this.x = x;`: 부모 생성자가 끝난 후, 자식 C의 x 멤버 변수에 생성자로 넘어온 값인 10이 할당된다.  
- `int getData(int n)`: P 클래스의 `getData()`와 이름은 같지만, 매개변수가 다르다.
- (`int n`이 추가됨) 이건 오버로딩이지, 오버라이딩이 아니다.  
- `super.getData() + n;`: 부모 P의 `getData()`를 호출하고 n을 더한다.

---

### main 함수 실행 흐름:

- `P p = new C(10);`:  
- `new C(10)`: C 클래스의 객체를 생성한다.  
- `C(10)` 생성자가 호출되면 `super(10+1, 10)` 즉 `super(11, 10)`이 먼저 호출된다.  
- 부모 P의 멤버 x는 11, y는 10이 된다.  
- 부모 생성자 호출이 끝나면, 자식 C의 생성자 코드가 실행된다.
- `this.x = 10;` 이 실행되어 자식 C의 멤버 x는 10이 된다. (부모의 x와는 별개다!)  
- `P p = ...;`: 이렇게 만들어진 C 객체를 부모 P 타입의 참조 변수 p에 할당한다. 이걸 다형성(Polymorphism) 이라고 부른다.
- 
- `System.out.println(p.getData());`:  
- p는 실제로는 C 타입의 객체지만, 선언된 타입은 P다.  
- `p.getData()`를 호출하면, 자바는 런타임에 실제 객체(C 객체)에 정의된 메서드를 찾는다.  
- C 클래스에는 매개변수 없는 `getData()` 메서드가 없다. (매개변수 있는 `getData(int n)`만 있다.)  
- 따라서 C 객체지만 P 타입으로 선언되었기 때문에, P 클래스의 `getData()` 메서드가 호출된다.
- (만약 C에 매개변수 없는 `getData()`가 오버라이딩 되어 있었다면, C의 메서드가 호출됐을 거다.)  
- P 클래스의 `getData()`는 `return x * y;` 인데, 여기서 x와 y는 부모 P의 멤버 변수다.  
- 아까 `super(11, 10)`으로 초기화됐으니, P의 x는 11, y는 10이다.  
- 11 * 10 = 110이 된다.

---

### 최종 출력 결과:  
`110`

---------------------------------------------------------------------------------- 

## 📝 문제 18) Java 코드 출력 결과

### ❓ 문제 코드 (오타 및 수정 반영)


class Connection {
    private static Connection _inst = null;
    private int count = 0;

    static public Connection get() {
        if (_inst == null) {
            _inst = new Connection();
            return _inst;
        }
        return _inst;
    }

    public void count() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class Main {
    public static void main(String[] args) {
        Connection conn1 = Connection.get();
        conn1.count();
        Connection conn2 = Connection.get();
        conn2.count();
        Connection conn3 = Connection.get();
        conn3.count();
        conn1.count();

        System.out.print(conn1.getCount());
    }
}

답 : 4

코드 분석:  
이 코드는 **싱글톤 패턴(Singleton Pattern)**을 이해하는 게 핵심이다.

**Connection 클래스 (싱글톤):**

- `private static Connection _inst = null;`  
  _inst라는 정적(static) 변수를 만든다. static은 이 변수가 클래스에 딱 하나만 존재한다는 뜻이다.  
  _inst는 Connection 객체가 처음 생성될 때 그 객체를 저장할 공간이다. 처음엔 null로 비워둔다.

- `private int count = 0;`  
  이 Connection 객체가 몇 번 사용됐는지 셀 인스턴스 변수다.

- `static public Connection get()`  
  이게 싱글톤의 핵심 메서드다.  
  - 만약 `_inst == null` (즉, Connection 객체가 한 번도 만들어지지 않았다면),  
    `_inst = new Connection();` 으로 딱 한 번만 객체를 생성해 _inst에 저장한다.  
  - 이미 만들어져 있다면 새 객체를 만들지 않고 기존 객체를 반환한다.  
  → 결론: `get()` 메서드를 아무리 많이 호출해도 Connection 객체는 메모리에 딱 하나만 존재한다.

- `public void count()`  
  count 값을 1 증가시킨다.

- `public int getCount()`  
  count 값을 반환한다.

---

**Main 클래스 실행 흐름:**

- `Connection conn1 = Connection.get();`  
  첫 호출, 객체 생성 및 반환, count = 0.

- `conn1.count();`  
  count = 1.

- `Connection conn2 = Connection.get();`  
  기존 객체 반환, count = 1 유지.

- `conn2.count();`  
  count = 2.

- `Connection conn3 = Connection.get();`  
  기존 객체 반환, count = 2 유지.

- `conn3.count();`  
  count = 3.

- `conn1.count();`  
  count = 4.

- `System.out.print(conn1.getCount());`  
  최종 count 출력 → 4.

---

---------------------------------------------------------------------------------- 

## 📝 문제 19) Java 코드 출력 결과

### 문제 코드

class One {
    int a, b;
    public One(int a, int b) {
        this.a = a;
        this.b = b;
    }
    public void print() {
        System.out.println(a + b);
    }
}

class Two extends One {
    int po = 3;
    public Two(int i) {
        super(i, i + 1);
    }
    public void print() {
        System.out.println(po * po);
    }

    public static void main(String[] args) {
        One one = new Two(10);
        one.print();
    }
}

답: 9

코드 분석:  
이 문제는 **메서드 오버라이딩(Method Overriding)**과 **다형성(Polymorphism)**의 기본을 묻는 거다. 핵심만 짚어줄게.

---

### One 클래스 (부모):

- `int a, b;`  
  두 개의 정수형 멤버 변수가 있다.

- `public One(int a, int b)`  
  생성자로 a와 b를 초기화한다.

- `public void print()`  
  a + b를 출력하는 메서드다.

---

### Two 클래스 (자식):

- `extends One`  
  One 클래스를 상속받는다.

- `int po = 3;`  
  po라는 정수형 멤버 변수가 있고, 기본값은 3이다.

- `public Two(int i)`  
  생성자다.

- `super(i, i + 1);`  
  부모 One 클래스의 생성자를 호출한다. 여기서 i는 10이니까, `super(10, 11)`이 호출된다.  
  결과적으로 부모 One의 a는 10, b는 11이 된다.

- `public void print()`  
  이게 핵심이다! 부모 One에 있는 print() 메서드와 이름, 반환 타입, 매개변수가 모두 똑같다.  
  이건 부모의 print()를 오버라이딩(재정의) 한 거다.  
  이 메서드는 po * po를 출력한다. po는 3이므로 3 * 3 = 9가 출력될 거다.

---

### main 함수 실행 흐름:

- `One one = new Two(10);`  
  `new Two(10)`은 Two 클래스 객체를 생성한다.  
  생성자 내부에서 `super(10, 11)`이 호출되어 부모 One의 a=10, b=11로 초기화되고, 자식 Two의 po는 3이다.  
  부모 타입 One 변수 `one`에 Two 객체를 참조하게 하는 다형성이다.

- `one.print();`  
  `one`은 One 타입으로 선언됐지만 실제 객체는 Two 타입이다.  
  자바는 동적 바인딩(Dynamic Binding)으로 실행 시점에 실제 객체 타입의 메서드를 호출한다.  
  따라서 Two 클래스의 오버라이딩된 print()가 호출되고, 3 * 3 = 9가 출력된다.

---

### 최종 출력 결과:  9

---------------------------------------------------------------------------------- 
## 📝 문제 20) Python 코드 출력 결과

### 문제 코드

a = ["Seoul", "Kyeonggi", "Incheon", "Daejun", "Daegu", "Pusan"]
str = "S"
for i in a:
    str = str + i[1]
print(str)

출력 결과
Seynaau

코드 분석:  
이 코드는 파이썬의 **리스트(List)**와 문자열(String) 인덱싱 그리고 **반복문(for loop)**을 쓰는 아주 기본적인 문제다.

---

### 초기화:

- `a = ["Seoul", "Kyeonggi", "Incheon", "Daejun", "Daegu", "Pusan"]`  
  여러 도시 이름이 담긴 리스트 a를 만든다.

- `str = "S"`  
  str이라는 문자열 변수를 만들고, 초기값을 "S"로 설정한다. 여기에 나중에 문자들이 계속 추가될 거다.

---

### for 루프:

- `for i in a:`  
  a 리스트의 각 요소를 하나씩 i에 넣어가면서 반복한다.

- 각 반복마다 `str = str + i[1]` 수행  
  여기서 `i[1]`은 현재 i가 가리키는 문자열의 두 번째 문자이다. (인덱스는 0부터 시작)

---

### 각 반복 결과

| 반복 순서 | i 값      | i[1] | str 누적 값     |
|----------|-----------|-------|----------------|
| 1        | Seoul     | e     | "S" + "e" = "Se"   |
| 2        | Kyeonggi  | y     | "Se" + "y" = "Sey"  |
| 3        | Incheon   | n     | "Sey" + "n" = "Seyn" |
| 4        | Daejun    | a     | "Seyn" + "a" = "Seyna"|
| 5        | Daegu     | a     | "Seyna" + "a" = "Seynaa"|
| 6        | Pusan     | u     | "Seynaa" + "u" = "Seynaau"|

---

### 최종 출력:
Seynaau


