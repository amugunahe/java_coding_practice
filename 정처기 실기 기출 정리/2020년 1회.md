💾 **비정규화 (반정규화, 역정규화)**  
**답:** 성능 향상을 위해 정규화 기법을 깨부수는 거다.  


**알잘딱깔센 설명:**  
야, 정규화 이거 좋긴 좋다. 데이터 중복도 줄이고 깔끔하게 관리하게 해주니까.  
근데 말이야, 그거 너무 FM대로 하다 보면 테이블 존나 쪼개져서 조인 연산이 늘어나고, 결과적으로 조회 속도가 떡락하는 수가 있어.  
이럴 때 쓰는 게 바로 비정규화다. 이론적으로는 "야, 이거 정규화 규칙 깼네?" 소리 들을 수 있는데,  
실전에서는 성능 존나게 땡기려고 일부러 데이터 중복도 좀 허용하고 테이블 합치고 하는 기술이다 이 말이야.  
딱 보면 성능 향상에 미친 놈들이 만든 거지.

📝 **데이터베이스 설계 단계 (중요하니까 훑어봐라)**  
- 개념적 설계: 데이터베이스 설계의 첫 단추다. 뭘 저장할지, 얘네들끼리 어떻게 엮여있는지 대충 그림 그리는 단계다. 보통 ERD(Entity Relationship Diagram) 같은 걸로 그려본다.  
- 논리적 설계: 이제 어떤 DBMS(데이터베이스 관리 시스템) 쓸지 정하고, 개념적 설계를 바탕으로 실제로 테이블을 만들 준비를 하는 단계다. 여기서 정규화 작업도 같이 해준다.  
- 물리적 설계: 실제 서버에 데이터를 쑤셔 넣을 준비하는 최종 단계다. 성능을 극대화하려고 파티션, 클러스터, 인덱스 같은 걸 설계하고 배치한다.

🪜 **정규화 단계 (이거 다 외우면 네가 독하다!)**  
- 1정규형 (1NF): 데이터 필드에 원자값(Atomic Value), 즉 더 이상 쪼갤 수 없는 값만 넣어라. "이름1,이름2" 이런 거 안 된다는 말이다.  
- 2정규형 (2NF): 부분 함수 종속을 제거해라. 기본키의 일부에만 종속되는 속성은 따로 빼서 테이블을 나눠라 이말이야. 안 그러면 데이터 중복 오진다.  
- 3정규형 (3NF): 이행 함수 종속을 제거해라. 기본키가 아닌 속성이 다른 기본키가 아닌 속성을 결정하는 관계를 없애버리는 거다. 예: 학생 테이블에 학과명, 학과전화번호가 있으면 학과정보는 따로 테이블로 빼는 식.  
- BCNF: 결정자이면서 후보키가 아닌 놈 있으면 다 조져라. 3정규형보다 좀 더 빡센 규칙.  
- 4정규형 (4NF): 다치 종속을 제거해라. 하나의 기본키에 대해 여러 개의 독립적인 다치 종속성이 있으면 따로 테이블로 분리.  
- 5정규형 (5NF): 조인 종속을 제거해라. 조인 연산을 통해서만 복원 가능한 종속성이 있다면 그것도 따로 테이블로 빼버림.

-----------------------------------------------------------------------------------------------------------------------------------------------
## 📜 마크업 언어

**문제)**  
다음 빈칸에 들어갈 알맞은 마크업 언어를 쓰시오.

- () : SGML의 단순화된 부분 집합, 다른 많은 종류의 데이터를 기술하는데 사용할 수 있음.  
- () : 주로 다른 종류 시스템, 인터넷에 연결된 시스템끼리 데이터를 쉽게 주고 받을 수 있게 하여 HTML 한계를 극복할 목적으로 만들어짐  
- () : 텍스트 데이터 형식으로 유니코드 사용해 전세계 언어를 지원함

✅ **정답: XML**

---

### 💬 알잘딱깔센 설명

야, XML(eXtensible Markup Language) 이거 요즘 **데이터 주고받을 때 존나 많이 쓰는 놈**이다.  
원래 **SGML(Standard Generalized Markup Language)**이라는 **복잡한 조상님**이 있었는데,  
그걸 좀 쉽게 만든 거라고 보면 된다.  

데이터의 **구조랑 의미를 표현**하려고 태어난 **텍스트 기반 형식**이다.  
웹페이지 표시에 특화된 HTML이랑 다르게, **XML은 데이터 자체를 기술하고 전송**하는 데 존나게 초점이 맞춰져 있다.

**시스템끼리 데이터 주고받을 때 특히 빛을 발**하고,  
**유니코드 지원**해서 **전 세계 모든 언어** 표현 가능.  
이쯤 되면 글로벌 스타 아니겠노?

---

### 📚 마크업 언어 종류 요약

| 이름 | 설명 |
|------|------|
| **HTML** | 웹 페이지의 뼈대랑 내용 담당. 네가 지금 보고 있는 이 페이지도 HTML로 만들어진 거다. |
| **SGML** | 존나 복잡해서 실생활에서는 잘 안 씀. XML의 할아버지라고 보면 됨. |
| **XML** | SGML을 쉽게 만든 확장형 마크업 언어. 데이터 구조 만들고 주고받을 때 존나 편하다. |
| **JSON** | 키-값 쌍으로 이루어진 경량 데이터 교환 형식. 요즘 XML 대신 많이 쓰는 추세. 더 가볍고 JS랑 궁합이 존나 좋음. |
| **TXT** | 그냥 단순한 텍스트 파일. 메모장 파일이 이거다. |
| **YAML** | 사람에게 읽히기 쉬운 데이터 표현 방식. 설정 파일 같은 데서 자주 보인다. |



-----------------------------------------------------------------------------------------------------------------------------------------------
## 🚫 살충제 패러독스 (Pesticide Paradox)

**✅ 정의**  
동일한 테스트 케이스로 동일한 절차를 반복 수행하면 **새로운 결함을 찾을 수 없다**는 소프트웨어 테스트의 한계.

---

### 💬 알잘딱깔센 설명

이름부터 **살충제 패러독스** 아니노?

농부가 똑같은 살충제만 계속 뿌리면 벌레들이 내성 생겨서 나중엔 끄떡도 안 하잖아?  
**소프트웨어 테스트도 똑같다.**  
맨날 **똑같은 테스트 케이스**랑 **똑같은 절차**만 돌리면, 새로운 버그는 절대 못 찾는다.  
기존 버그는 잡겠지만, **다른 숨은 버그들**은 계속 살아남는다는 말이다.

테스트 케이스를 **주기적으로 업데이트**하고,  
테스트 방법도 **존나게 다양하게 바꿔줘야**  
**새로운 결함을 발견할 수 있다.**

안 그럼 버그들이 너한테 **빅엿을 선물할 거다.**

---

## 💻 소프트웨어 테스트 종류 정리

| 테스트 종류 | 설명 |
|-------------|------|
| **단위 테스트** | 개별 모듈이나 함수 단위로 잘 작동하는지 확인 (개발자가 직접 수행) |
| **정적 테스트** | 코드를 실행하지 않고 리뷰나 분석 도구로 검토 (코드 리뷰, 정적 분석 도구) |
| **동적 테스트** | 코드를 직접 실행해서 기능 이상 여부를 확인 |
| **통합 테스트** | 여러 단위 모듈이 잘 연동되는지 확인. **팀워크 테스트** |
| **하향식 테스트** | 상위 모듈부터 테스트, 하위는 **스텁(Stub)** 으로 대체 |
| **상향식 테스트** | 하위 모듈부터 테스트, 상위는 **드라이버(Driver)** 로 대체 |
| **빅뱅 테스트** | 모든 모듈을 한꺼번에 합쳐서 테스트. 문제 생기면 디버깅 개헬 |
| **시스템 테스트** | 시스템 전체를 사용자 요구사항에 맞춰 최종 점검 |
| **기능 테스트** | 시스템이 기능 요구사항을 잘 수행하는지 검증 |
| **비기능 테스트** | 성능, 보안, 안정성, 사용성 등 기능 외적인 요소 검증 |
| **인수 테스트** | 고객이 직접 테스트해보고 OK 사인 내리는 단계 |
| **알파 테스트** | 개발자가 옆에서 지켜보며 내부 테스트 |
| **베타 테스트** | 실제 사용자 환경에서 개발자 없이 테스트 수행 |

---

## 📈 파레토 법칙 (Pareto Principle)

**80 대 20 법칙**:  
전체 오류의 약 **80%**가 전체 코드의 **20% 핵심 모듈**에서 발생한다.

👉 중요한 모듈을 **더 빡세게 테스트해야 한다** 이말이야.

---

## 🧙‍♂️ 테스트 오라클 (Test Oracle)

테스트 결과가 **맞는지 판단해주는 정답지 역할**을 하는 기준.

| 오라클 종류 | 설명 |
|-------------|------|
| **참 오라클** | 완전하고 정확한 정답지 |
| **샘플 오라클** | 일부 예시 데이터로 결과 판단 |
| **휴리스틱 오라클** | 경험 기반으로 대충 판단 |
| **일관성 검사 오라클** | 여러 번 실행해서 결과가 일관적인지 확인 |



-----------------------------------------------------------------------------------------------------------------------------------------------
## 🖇️ 모듈의 독립성을 판단하는 두 가지 지표

### ✅ 답:
(1) **결합도(Coupling)**  
(2) **응집도(Cohesion)**

---

### 💬 알잘딱깔센 설명

소프트웨어 모듈은 사람으로 치면 '전문가' 같은 존재다.  
자기 일만 잘하고, 남한테 휘둘리지 않아야 **좋은 모듈**이다.

#### 🔹 결합도 (Coupling)
- 모듈과 모듈끼리 얼마나 **서로 얽혀 있는지** 나타내는 지표
- **낮을수록 좋다** → 독립성이 높아짐
- 결합도가 낮으면 한 모듈을 수정해도 다른 모듈에 영향이 적어 유지보수 편함
- 👉 남남이 최고다. 신경 꺼야 덜 싸운다

#### 🔹 응집도 (Cohesion)
- 한 모듈 내부의 구성 요소들이 **얼마나 똘똘 뭉쳐 하나의 목적**을 수행하느냐
- **높을수록 좋다** → 모듈의 기능이 명확하고 일관됨
- 👉 패밀리 으리! 팀워크 만렙이면 모듈 관리도 쉬워진다

---

## 📈 응집도의 종류 (높을수록 좋음)

| 수준 | 설명 |
|------|------|
| 우연적 응집 | 🚫 최악. 관련 없는 기능들이 우연히 모여 있음 |
| 논리적 응집 | 유사한 기능들을 모아놨지만 실제 목적은 다름 |
| 시간적 응집 | 특정 시간대에 같이 실행되는 기능들 모음 |
| 절차적 응집 | 일정한 순서로 수행되는 기능들 모음 |
| 통신적 응집 | 동일한 입력/출력을 사용하는 기능들 모음 |
| 순차적 응집 | 하나의 출력이 다음 기능의 입력으로 연결 |
| 기능적 응집 | ✅ 최고. 오직 하나의 명확한 기능만 수행 |

---

## 📉 결합도의 종류 (낮을수록 좋음)

| 수준 | 설명 |
|------|------|
| 데이터 결합 | ✅ 최고. 단순 데이터(값)만 주고받음 |
| 스탬프 결합 | 구조체나 배열처럼 복합 데이터 전달. 과한 정보 포함 위험 |
| 제어 결합 | 처리 방식까지 전달. 받는 쪽 로직이 외부에 의존 |
| 외부 결합 | 외부 모듈의 데이터 참조. 의존성↑ |
| 공통 결합 | 전역 변수 공유. 누가 뭘 바꿨는지 추적 어렵고 위험함 |
| 내용 결합 | 🚫 최악. 다른 모듈의 내부까지 직접 조작 |

---

## 🔄 재공학 vs 역공학 vs 재사용

| 개념 | 설명 |
|------|------|
| **재공학 (Re-engineering)** | 기존 시스템을 고쳐서 개선하거나 재활용하는 작업 (리모델링 느낌) |
| **역공학 (Reverse Engineering)** | 완성된 코드로부터 설계도나 명세서를 역으로 추출 |
| **재사용 (Reuse)** | 이미 만들어진 모듈을 반복 사용해 개발 시간/비용을 아낌 |

---

### 📌 정리 핵심

- **결합도는 낮게!**
- **응집도는 높게!**
- 이게 바로 **국룰**이자, 유지보수와 품질의 핵심 포인트다.

-----------------------------------------------------------------------------------------------------------------------------------------------
## 📊 Fan-in, Fan-out 수 구하기

---

### ✅ 답:

- **Fan-in**: 해당 모듈을 **호출하는 모듈의 수**
- **Fan-out**: 해당 모듈이 **호출하는 모듈의 수**

---

### 💬 알잘딱깔센 설명

Fan-in과 Fan-out은 **소프트웨어 모듈 간의 관계**를 나타내는 대표적인 지표다.

#### 🔹 Fan-in (들어오는 제어 수)
- 특정 모듈을 **몇 개의 다른 모듈이 호출하는지**를 나타냄
- 📌 Fan-in 값이 높다? → 재사용성이 높고 인기 많은 모듈!
- ✔️ 핵심 기능이나 공통 유틸성 기능일수록 Fan-in 값이 높음
- 🔧 예시: 유효성 검사 모듈, 공통 계산기 모듈

#### 🔹 Fan-out (나가는 제어 수)
- 특정 모듈이 **몇 개의 다른 모듈을 호출하는지**를 나타냄
- 📌 Fan-out 값이 높다? → 다른 모듈에 **많이 의존**하는 모듈!
- ❗ 수정 시 파급효과가 클 수 있으니 신중하게 관리해야 함
- 🔧 예시: 업무 로직을 여러 하위 모듈로 분산 호출하는 메인 로직 모듈

---

### 📌 Fan-in / Fan-out 시각적 비유

```text
        [ M1 ] <--- Fan-in (3개 모듈이 호출)
        [ M2 ]
        [ M3 ]

        [ A ] ---> [ B ] ---> [ C ] ---> [ D ]
                    ↑               ↑
                   Fan-out(2)    Fan-in(1)

📈 개발 설계에서의 활용 팁
Fan-in은 높을수록 재사용성이 높고, 설계가 잘 되어 있는 모듈임을 나타냄

Fan-out은 낮을수록 좋음, 지나친 의존성은 유지보수 시 복잡도를 증가시킴

소프트웨어 품질을 고려할 때 Fan-in은 증가, Fan-out은 감소하는 방향이 바람직함

🧠 정리 한 줄 요약
Fan-in은 인기도, Fan-out은 의존도다.

-----------------------------------------------------------------------------------------------------------------------------------------------

## 🌐 JavaScript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷

---

### ✅ 답: JSON

---

### 💬 알잘딱깔센 설명

요즘 웹에서 데이터 주고받을 때 **XML을 대체하는 슈퍼스타**, 바로 **JSON (JavaScript Object Notation)** 이다.

- JavaScript 객체 문법을 기반으로 한 **문자 기반의 데이터 표현 형식**
- 사람과 기계 모두 **읽기 쉽고 이해하기 쉬움**
- **용량이 작고, 처리 속도가 빠름**
- 주로 **웹 API, 프론트-백엔드 간 데이터 통신, 모바일 앱 등**에서 자주 사용됨

```json
{
  "이름": "홍길동",
  "나이": 30,
  "주소": "서울특별시"
}
위처럼 { "key": "value" } 형태로 표현됨

데이터는 "이름-값 쌍(key-value pair)" 으로 구성됨

프로그래밍 문법은 아님, 단순히 데이터를 표현하는 방식임

📌 JSON의 장점
✔️ 사람도 읽기 쉬운 구조 (가독성 GOOD)

✔️ XML보다 간결한 표현

✔️ 다양한 언어에서 파싱이 쉬움

✔️ JavaScript와 궁합이 매우 좋음 (원래 JS 객체 문법이니까)

# 📚 관련 개념 (같은 듯 다른 것들 정리)

| 용어         | 설명                                                             |
|--------------|------------------------------------------------------------------|
| JSON         | 데이터를 표현하는 단순한 포맷. `{ "key": "value" }` 형식         |
| XML          | 태그 기반 데이터 표현. 무겁고 복잡                                |
| API          | 기능을 외부에 공개하는 '문 열어주는 설명서'. 시스템 간 인터페이스 |
| 라이브러리   | 네가 직접 불러서 사용하는 '기능 묶음'                             |
| 프레임워크   | 이미 짜여진 틀 속에서 네 코드를 넣어 쓰는 구조. 규칙이 더 엄격    |


# 🔁 XML vs JSON 비교

| 항목         | XML                     | JSON                              |
|--------------|--------------------------|------------------------------------|
| 문법         | 태그 기반               | 객체 기반                         |
| 용량         | 큼                      | 작음                              |
| 가독성       | 낮음                    | 높음                              |
| 파싱 속도    | 느림                    | 빠름                              |
| 주 사용처    | 과거의 웹, 문서 중심 통신 | 현대 웹, 모바일 앱, REST API 등 |


🧠 한 줄 요약
JSON은 웹 시대의 데이터 운반책, 간단하고 빠르고 가볍다. 이제 XML은 빠이✋
-----------------------------------------------------------------------------------------------------------------------------------------------

## 📈 애플리케이션 성능 측정을 위한 지표 정리

(1): 일정 시간 내에 애플리케이션이 처리하는 일의 양  
(2): 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간  
(3): 애플리케이션에 요청을 전달한 시간부터 처리가 완료될 때까지 걸린 시간  
자원 사용률: 애플리케이션이 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률


### ✅ 답
- (1): **처리량 (Throughput)**
- (2): **응답시간 (Response Time)**
- (3): **반환시간 (Turn Around Time)**

---

### 💬 알잘딱깔센 설명

앱이나 시스템이 얼마나 빠르고 효율적으로 돌아가는지를 측정할 때 사용하는 핵심 지표들이다. 아래 설명 잘 봐라, 면접에서도 자주 나오는 주제다.

---

### (1) 처리량 (Throughput)
- 의미: **단위 시간당 처리되는 작업량**
- 예시: 초당 100개의 요청 처리 → 처리량 = 100 TPS(Transaction per Second)
- 특징: **숫자 클수록 좋다**. 서버가 많은 요청을 얼마나 감당할 수 있는지를 보여준다.
- 비유: 음식점에서 1시간에 몇 명 손님을 받을 수 있는가?

---

### (2) 응답시간 (Response Time)
- 의미: **요청을 보낸 시점부터 첫 응답이 도착할 때까지 걸리는 시간**
- 특징: **사용자가 체감하는 지연시간**이다. 이게 짧을수록 UX가 좋다.
- 비유: 음식점에서 주문했을 때, 서빙이 내 테이블까지 오는데 걸리는 시간

---

### (3) 반환시간 (Turn Around Time)
- 의미: **요청을 보낸 시점부터 작업이 완전히 끝날 때까지 걸린 전체 시간**
- 특징: 내부 처리시간까지 모두 포함된다.
- 비유: 음식점에서 주문부터 음식 다 먹고 계산까지 완료되기까지 걸리는 시간

---

### 🔧 자원 사용률 (Resource Utilization)
- 정의: **CPU, 메모리, 디스크 I/O, 네트워크 등 자원을 얼마나 사용하는가**
- 의미: 자원이 **과도하게 사용되면** 성능 저하의 원인이 될 수 있다
- 비유: 음식점에서 주방이 얼마나 바쁜가, 종업원이 몇 명인가, 좌석 점유율은 얼마나 되는가 등

---

### 📊 성능 지표 요약 표

| 지표 | 설명 | 핵심 포인트 |
|------|------|--------------|
| 처리량 (Throughput) | 일정 시간 동안 처리한 작업 수 | **많을수록 좋음** |
| 응답시간 (Response Time) | 요청 → 첫 응답까지 걸린 시간 | **짧을수록 좋음** |
| 반환시간 (Turn Around Time) | 요청 → 작업 완료까지 걸린 전체 시간 | **짧을수록 좋음** |
| 자원 사용률 | CPU, 메모리 등 시스템 리소스 사용량 | **과도하면 문제** |

---

### 🧠 성능 최적화 팁

- 응답시간을 줄이기 위해 캐싱 도입, 로직 개선
- 처리량을 높이기 위해 병렬 처리, 로드 밸런싱 적용
- 반환시간 단축을 위해 비동기 처리, 작업 분할 적용
- 자원 사용률을 모니터링하고 병목 구간 제거

---

### 🔁 참고용 용어 비교

| 용어 | 관점 | 예시 |
|------|------|------|
| 처리량 | 시스템 입장에서 얼마나 처리했냐 | 초당 100건 |
| 응답시간 | 사용자 입장에서 얼마나 기다렸냐 | 0.3초 |
| 반환시간 | 전체 흐름이 얼마나 걸렸냐 | 1분 30초 |

---

> 결국 성능은 숫자로 말한다. 응답시간 빠르고 처리량 높고 자원 적게 쓰면 최고다. 🎯


-----------------------------------------------------------------------------------------------------------------------------------------------

## 🔢 학생(STUDENT) 테이블 튜플 수 구하기 문제

---

### 문제  
학생(STUDENT) 테이블에 전자과 50명, 전기과 100명, 건축과 50명 정보가 저장되어 있을 때 튜플 수를 쓰시오  
(DEPT 컬럼은 학과명)

---

### 쿼리와 답변

| 쿼리 | 설명 | 결과(튜플 수) |
|-------|-------|---------------|
| (1) `SELECT DEPT FROM STUDENT;` | DEPT 컬럼 전체 데이터 모두 출력 (중복 포함) | 200 |
| (2) `SELECT DISTINCT DEPT FROM STUDENT;` | DEPT 컬럼의 중복 제거 후 유일한 값만 출력 | 3 |
| (3) `SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '건축과';` | 건축과 학생들 중 DEPT의 중복 제거 후 개수 카운트 | 1 |

---

### 💬 알잘딱깔센 설명

- STUDENT 테이블에 총 학생 수는  
  전자과 50명 + 전기과 100명 + 건축과 50명 = **200명**  
- 튜플은 테이블의 **한 행(row)** 을 의미한다.  
- (1)번 쿼리는 DEPT 컬럼의 모든 값(중복 포함)을 가져오므로 200개의 행이 반환된다.  
- (2)번 쿼리는 중복을 제거하고 유일한 학과명만 가져오므로 전자과, 전기과, 건축과 3개가 나온다.  
- (3)번 쿼리는 '건축과' 학생만 필터링 후 DISTINCT로 중복된 학과명을 제거하고 카운트하므로 항상 1이 나온다.


-----------------------------------------------------------------------------------------------------------------------------------------------

## 💣 네트워크 공격 유형

---

### 문제  
출발지 IP와 목적지 IP가 같은 패킷을 만들어 보내는 공격  
수신자가 응답을 보낼 때 목적지 주소가 자기 자신이므로 SYN 신호가 계속 자신의 서버를 돌게 되어 서버의 자원을 고갈시켜 가용성을 파괴한다  
방화벽에서 출발지와 목적지가 같은 패킷은 모두 제거하여 대응

---

### 답  
**Land attack**

---

### 💬 알잘딱깔센 설명  
**Land Attack(랜드 어택)**은 IP 헤더의 출발지 IP 주소와 목적지 IP 주소를 똑같이 설정하여 공격하는 악질적인 네트워크 공격이다.  

이 패킷을 받은 서버는 응답을 자기 자신에게 보내게 되면서 무한 루프가 발생한다.  
서버 자원(CPU, 메모리, 네트워크 대역폭)이 소진되어 결국 서비스 거부(DoS) 상태에 빠진다.

**대응 방법**은 방화벽이나 라우터에서 출발지와 목적지 IP가 같은 패킷을 발견 즉시 차단하는 것이다.

---

### 💥 서비스 거부 공격 (DoS, Denial of Service) 유형

| 공격 유형           | 설명                                                         | 쉬운 예시                                                   |
|----------------------|--------------------------------------------------------------|--------------------------------------------------------------|
| **DoS**              | 자원/대역폭을 소모시켜 정상 서비스 방해                     | 식당에 혼자 와서 테이블 100개 예약 걸어놓고 아무도 안 옴      |
| **Smurf Attack**     | 브로드캐스트+ICMP로 응답 폭주 유도                          | "야 다같이 얘한테 인사해!" 해서 수백 명이 한 명한테 소리침   |
| **SYN flooding**     | 접속 요청만 하고 연결 안 해서 대기열을 가득 채움            | 식당에서 계속 예약 전화만 하고 실제론 안 감                   |
| **UDP 플러딩**       | 쓸데없는 요청을 무작위 포트로 보내 시스템 바쁨               | 회사 전화기에 이상한 전화 수천 통 걸어 일 못 하게 만들기      |
| **Ping 플러딩**      | Ping만 엄청나게 보내 네트워크 자원 고갈                     | 누가 초인종을 초당 100번 누르면서 도망감                      |
| **Ping of Death**    | 너무 큰 Ping을 보내 시스템 오류 유발                         | 택배 박스에 폭탄 넣어서 초인종 누르고 박스 던지는 느낌       |
| **Teardrop Attack**  | 재조립 불가능한 조각난 패킷 전송해 시스템 혼란 유발         | 퍼즐 조각을 일부러 엉망으로 잘라서 맞추다 멘붕 오게 하기     |

---

-----------------------------------------------------------------------------------------------------------------------------------------------

🗣️ 통신 프로토콜의 기본 요소 3가지  
통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고받는 양식과 규칙의 체계이다. 통신 프로토콜의 기본 요소 3가지를 쓰시오.

답:  
- 구문(Syntax)  
- 타이밍(Timing)  
- 의미(Semantic)  

알잘딱깔센 설명:  
야, 컴퓨터랑 통신 장비들이 서로 말 제대로 하려면 약속된 룰이 꼭 필요하다. 그게 바로 통신 프로토콜인데, 이게 잘 작동하려면 기본적으로 세 가지 요소가 있어야 해.

1. **구문(Syntax)**: 메시지가 어떻게 생겨야 하는지, 데이터가 어떤 순서와 형태로 와야 하는지를 정하는 규칙이다.  
   예를 들어, 사람이 말할 때 문장 구조나 단어 순서 같은 거라 보면 돼. "이렇게 말해야 알아듣는다"는 걸 정하는 거지.

2. **타이밍(Timing)**: 언제, 얼마나 빠르게 메시지를 주고받을지 정하는 규칙이다.  
   말하자면, "네가 말 끝날 때까지 기다려라", "1초 안에 대답해라" 같은 시간 약속 같은 거야. 타이밍 안 맞으면 소통 안 된다.

3. **의미(Semantic)**: 메시지가 어떤 뜻인지, 신호가 무슨 행동을 의미하는지 정하는 규칙이다.  
   예컨대, "안녕"이 단순 인사인지, 친근함인지, 경고인지 명확하게 정하는 거야. 그래야 헷갈리지 않고 제대로 반응하지.

이 세 가지만 잘 맞춰져도 컴퓨터끼리 헷갈리지 않고 척척 데이터 주고받을 수 있다는 얘기야.  


-----------------------------------------------------------------------------------------------------------------------------------------------

⏱️ HRN(Highest Response-ratio Next) 우선 순위를 결정하는 계산식

답:  
(대기시간 + 서비스시간) / 서비스시간



### 🧠 HRN(Highest Response-ratio Next): 똑똑한 스케줄링

**HRN(Highest Response-ratio Next)**은 프로세스 스케줄링 기법 중 하나인데,  
다른 놈들이랑 다르게 존나 똑똑하게 우선순위를 매긴다.

그냥 **대기 시간만 보거나**, **짧은 작업만 우대**하는 게 아니라,  
**대기 시간 + 앞으로 처리할 시간(서비스 시간)**을 **비율**로 계산해서 결정한다.

> 우선순위 = (대기 시간 + 서비스 시간) / 서비스 시간

📌 이 공식에서 보면:
- **기다리는 시간이 길수록** 👉 우선순위 ⬆️  
- **서비스 시간이 짧을수록** 👉 우선순위 ⬆️  

> 예시:  
> 사람들이 음식점에서 주문 기다리는 중.  
> 갑자기 어떤 손님은 오래 기다렸고, 주문도 짧음.  
> 사장: “와 이 손님은 오래 기다렸는데 주문도 간단하네? 먼저 해줘야지!”  
> → 이게 HRN임. 기다림도 봐주고, 처리 시간도 봐줌. 똑똑하지 않노?

👉 이런 계산 덕분에 **기아 현상(Starvation)**,  
즉 **계속 뒤로 밀려서 영원히 실행 못 하는 좆같은 상황**을 잘 방지할 수 있음.  

---

### 🏃‍♂️ 프로세스 스케줄링 종류  
> (나눠서 봐라, 시험에 자주 나온다!)

#### ⚡ 선점 스케줄링  
→ 실행 중인 애를 강제로 멈추고 다른 애가 실행될 수 있음.  
긴급한 상황 들어오면 “잠깐 나와봐!” 하고 치워버림.

| 기법 | 설명 | 쉬운 예시 |
|------|------|-----------|
| **SRT** (Shortest Remaining Time) | 남은 시간이 가장 짧은 놈에게 CPU 줌 | 시험 칠 때 “제일 빨리 끝낼 애 먼저 풀어!” |
| **RR** (Round Robin) | 정해진 시간만 쓰고 다음 차례로 넘김 | 노래방 타이머처럼 1곡 부르면 다음 사람 |
| **MLQ** (Multi-Level Queue) | 큐가 여러 개, 이동 불가 | 병원 접수창구: 응급실, 외과, 내과 따로 대기열 있음 |
| **MFQ** (Multi-Level Feedback Queue) | 큐 이동 가능 | 게임 매칭 시스템: 자주 대기한 사람은 상위 큐로 이동 |

---

#### 🧘 비선점 스케줄링  
→ 한 번 CPU 잡으면 끝날 때까지 놔두는 방식. “자리가 곧 내 몸이다” 마인드.

| 기법 | 설명 | 쉬운 예시 |
|------|------|-----------|
| **FCFS** (First Come First Served) | 먼저 온 놈부터 처리 | 줄 서서 차례 기다리는 순대국밥집 |
| **SJF** (Shortest Job First) | 짧은 작업 먼저 처리 | 설거지할 때 작은 컵부터 쓱쓱 |
| **HRN** (Highest Response-ratio Next) | 대기 + 서비스 시간 고려해 계산 | 오래 기다렸고 간단한 주문이면 먼저 처리 (갓기능!) |

---

### 🛠 기타 스케줄링  

| 기법 | 설명 | 쉬운 예시 |
|------|------|-----------|
| **기한부 스케줄링** | 마감기한 있는 작업부터 처리 | "레포트 오늘까지인 애 먼저 프린트 해줄게!" |
| **우선순위 스케줄링** | 지정된 우선순위 높은 애부터 처리 | VIP 손님 먼저 입장시키기 |

---

### 👴 기아 현상(Starvation) & 에이징(Aging)

- **기아 현상(Starvation)**  
  너무 우선순위가 낮아서 **계속 뒤로 밀려** CPU 못 받는 현상  
  > 예시: 줄서서 밥 먹는데 계속 VIP만 끼어들어서 넌 하루종일 못 먹는 상황

  주의할 알고리즘:  
  SJF, 우선순위 스케줄링, SRT, MLQ 등에서 자주 발생함  

- **에이징(Aging)**  
  기아 방지 기술. **기다리는 시간이 길면** 자동으로 우선순위 올려줌  
  > 예시: “쟤 너무 오래 기다렸네… 앞으로 땡겨주자!”

  적용 알고리즘:  
  MFQ, HRN 등



-----------------------------------------------------------------------------------------------------------------------------------------------
🔒 트랜잭션 주요 특성 4가지 (ACID)

(1): 트랜잭션의 가장 기본적인 특성으로 트랜잭션 내에 연산은 반드시 모두 수행되어야 하며, 그렇지 못한 경우 모두 수행되지 않아야 함  
일관성(consistency): 트랜잭션이 정상적으로 완료된 후 언제나 일관성 있는 데이터베이스 상태가 되어야 하며, 결과에 모순이 생겨서는 안 됨  
(2): 하나의 트랜잭션이 수행 중에는 다른 트랜잭션이 접근할 수 없고 각각의 트랜잭션은 독립적이어야 함  
영속성(Durablity): 지속성이라고 하며, 트랜잭션이 성공적으로 완료된 후 결과는 지속적으로 유지되어야 함


답:  
(1) 원자성(Atomicity)  
(2) 격리성(Isolation)  

알잘딱깔센 설명:  
트랜잭션은 데이터베이스에서 데이터 무결성과 신뢰성을 보장하는 핵심 개념이다.  
돈 거래를 생각해봐라. 돈이 한 계좌에서 빠져나가고 다른 계좌에 입금되어야 거래가 완성된다.  
만약 중간에 돈만 빠져나가고 입금이 안 되면? 완전 꼬이는 거다. 이때 ACID 원칙이 데이터 꼬임을 막아준다.  

- **A (Atomicity, 원자성)**:  
  트랜잭션 내 모든 작업은 하나의 단위처럼 완전 실행되거나 전혀 실행되지 않아야 한다.  
  즉, "All or Nothing!" 이게 핵심이다. 실패 시 처음 상태로 롤백한다.  

- **C (Consistency, 일관성)**:  
  트랜잭션 완료 후에도 데이터베이스 상태가 항상 일관되고 유효해야 한다.  
  데이터베이스 규칙(제약 조건)을 위반하면 안 된다.  

- **I (Isolation, 격리성)**:  
  여러 트랜잭션이 동시에 실행될 때 서로 간섭 없이 독립적으로 실행되는 것처럼 보여야 한다.  
  미완료 트랜잭션의 중간 결과를 다른 트랜잭션이 볼 수 없다. 각자 자기 일만 하는 상태.  

- **D (Durability, 영속성)**:  
  트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 반영된다.  
  시스템 오류가 발생해도 결과는 손실되지 않고 유지된다.  

-----------------------------------------------------------------------------------------------------------------------------------------------

### 📡 OSI 7계층 중 물리계층 (Physical Layer)

**답: 물리계층 (1계층)**  
OSI 7계층 중 **제일 밑바닥**, 말 그대로 "물리"적으로 데이터를 **보내는 선이나 신호**를 다루는 층이다.

---

#### 🧠 알잘딱깔센 설명

- OSI 7계층은 네트워크 통신 과정을 **7단계로 쪼개서 정리한 모델**  
- 그중 물리계층은 **1계층**, 맨 아래임. 기초 중의 기초.

💡 **물리계층 하는 일:**
- 데이터(비트)를 **전기 신호로 바꿔서** 쏴버림. (내용은 신경 안 씀)
- **"0과 1"**을 **"on/off 전기 신호"**로 변환
- **전선, 광케이블, 무선 신호** 이런 거 다 여기에 해당

> 👶 **존나 쉬운 예시**:
> - A가 “010101”이라는 데이터를 보냄 → 물리계층은 그걸 전기 on/off로 바꿔서 케이블에 흘려보냄
> - 뭔 말인지 못 알아들어도 괜찮음. **"신호만 보내면 내 일은 끝났다"**는 마인드

📦 **통신 단위**: **비트(Bit)**  
🛠 **대표 장비**:  
- NIC (네트워크 카드)  
- 허브(Hub)  
- 리피터(Repeater)  
→ 전기 신호를 받아서 그대로 쏘는 애들

---

### 🧱 OSI 7계층 요약 (밑에서부터 위로 올라가며 암기해라!)

| 계층 | 이름         | 역할 설명                             | 예시/장비                           |
|------|--------------|----------------------------------------|--------------------------------------|
| 7    | 응용 계층     | 사용자 프로그램과 네트워크 연결        | HTTP, FTP, 웹 브라우저              |
| 6    | 표현 계층     | 데이터 압축, 암호화, 인코딩           | JPEG, MPEG, SSL                     |
| 5    | 세션 계층     | 세션 연결/유지/종료                  | 로그인, 스트리밍 연결 유지         |
| 4    | 전송 계층     | 신뢰성 있는 데이터 전송               | TCP, UDP                            |
| 3    | 네트워크 계층 | IP 주소 기반 경로 선택 (라우팅)       | IP, 라우터(Router)                  |
| 2    | 데이터링크 계층| MAC 주소 기반 전송, 오류검출          | 스위치, 브리지                      |
| 1    | 물리 계층     | 비트 → 전기/광 신호로 변환하여 전송   | NIC, 허브, 리피터                   |

---

### 🧠 스위치 종류 한방 정리

| 종류       | 작동 계층       | 설명                                       |
|------------|------------------|--------------------------------------------|
| L2 스위치  | 2계층 (데이터링크)| MAC 주소 보고 전송                         |
| L3 스위치  | 3계층 (네트워크)  | IP 주소 보고 라우팅                         |
| L4 스위치  | 4계층 (전송)      | 포트 번호 기준으로 로드밸런싱               |
| L7 스위치  | 7계층 (응용)      | HTTP, URL, 쿠키 등 분석해서 정교하게 분산 |

---

### 🤯 진짜 쉬운 비유로 기억하자

> 🧵 물리 계층 = 전깃줄 깔고, 전기 켜는 애  
> 📦 데이터링크 계층 = 택배상자에 주소(MAC) 붙이는 애  
> 🧭 네트워크 계층 = 길 찾아가는 애 (IP)  
> 🛵 전송 계층 = 배달 중 문제가 없도록 체크하는 애 (TCP/UDP)  
> 🚪 세션 계층 = 문 여닫고 대화 시작/종료 관리  
> 🔒 표현 계층 = 암호화, 번역, 압축 담당 (이메일 인코딩 등)  
> 🙋‍♀️ 응용 계층 = 우리 눈앞에 보이는 앱 (웹, 메신저 등)


-----------------------------------------------------------------------------------------------------------------------------------------------

📝 릴리즈 노트 작성 항목 중 문서 이름(릴리스 노트 이름), 제품 이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등을 기술하는 작성 항목은?

답: 헤더(Header)

알잘딱깔센 설명:  
릴리즈 노트는 소프트웨어나 시스템 새 버전이 나왔을 때, 사용자나 개발자에게 “이번에 뭐가 바뀌었는지 알려줄게!”라고 알려주는 문서다.  
버그 수정, 개선 사항, 새 기능 같은 내용을 기록한다.

이 문서에서 맨 위에 위치하는 기본 정보들을 **헤더(Header)**라고 한다.  
헤더에는 문서 이름, 제품 이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등 문서의 ‘신분증’ 같은 메타데이터가 들어간다.  
이후에는 변경사항(Change Log), 알려진 문제(Known Issues), 설치 방법 등 세부 내용이 나온다.

쉽게 말해, 릴리즈 노트의 ‘이름표’ 역할을 하는 부분이다.

-----------------------------------------------------------------------------------------------------------------------------------------------
### 📊 데이터 마이닝의 개념

**답:**  
대규모 저장된 데이터 안에서 **체계적이고 자동적으로 통계적 규칙이나 패턴**을 찾아내는 것

---

### 🧠 알잘딱깔센 설명

**데이터 마이닝(Data Mining)** =  
데이터라는 광산에서 **쓸모 있는 정보(보석)**를 **자동으로 캐내는 기술**이다.

- **대량의 데이터** 속에서
- **숨어 있는 패턴이나 규칙**을
- **알아서 똑똑하게 찾아냄**

> 👶 예시:
> - 수많은 고객 구매 데이터를 분석해서  
>   "A를 산 사람은 B도 잘 사더라"는 규칙을 자동으로 찾아냄  
> - 카드 결제 패턴을 분석해 “이건 평소와 달라, 혹시 사기?”라고 탐지  
> - 병원 데이터에서 “이 증상 조합은 고위험군이다” 같은 걸 예측

💡 즉, **데이터 속에 숨겨진 의미 있는 '패턴'을 발굴**해서  
마케팅 전략, 사기 탐지, 질병 예측 등에 **실제로 써먹을 수 있게** 해준다.  
(→ 단순 저장 아님! **예측 + 의사결정 도우미**)

---

### 📚 데이터 관련 개념 (같이 외우면 개이득)

| 용어                    | 알잘딱깔센 요약 설명                                                                 |
|-------------------------|--------------------------------------------------------------------------------------|
| **데이터 웨어하우스**   | 회사 전체 데이터를 한 군데에 몰아넣은 중앙 창고. 분석용으로 정리돼 있음              |
| **데이터 마트**         | 웨어하우스에서 부서별로 잘라서 만든 작은 창고 (예: 마케팅 전용 데이터 마트)          |
| **OLAP**                | 다차원 데이터 분석툴. “작년 3분기 서울지역 매출 어떻게 돼?” 같은 질문 뚝딱 해줌       |

---

### 🎯 기억 꿀팁 요약

- **데이터 마이닝**: 보석 찾기 (패턴, 규칙 자동 추출)
- **데이터 웨어하우스**: 창고 (전체 데이터 모음)
- **데이터 마트**: 부서별 소분 창고
- **OLAP**: 데이터 보고서 마법사 (빠르고 똑똑하게 분석해줌)

---

### 🔎 진짜 쉬운 비유로 끝장정리

> 🍚 **데이터 웨어하우스**: 커다란 쌀 창고  
> 🍱 **데이터 마트**: 그 쌀로 만든 도시락 (마케팅팀 도시락, 영업팀 도시락)  
> 🍳 **OLAP**: 도시락 뚜껑 열고 뭐 들었는지 분석하는 도구  
> 🧑‍🌾 **데이터 마이닝**: 쌀 속에서 보석 찾기 (숨겨진 인사이트 발굴)



-----------------------------------------------------------------------------------------------------------------------------------------------


🔑 1990년 R.Rivert가 MD4를 일방향 해시 함수로 개선한 알고리즘으로 임의의 길이의 값을 입력받아서 128비트 길이의 해시값을 출력하는 알고리즘은 무엇인가

답: MD5

### 🔐 MD5와 암호화 알고리즘 총정리

---

### 💡 MD5란?

**MD5(Message-Digest Algorithm 5)** =  
입력이 얼마나 길든지 간에, 항상 **128비트(고정 길이)** 해시값을 만들어주는 **일방향 해시 함수**

- ✔️ **한 방향**: 해시값만 보고는 원본 복원 불가능  
- ✔️ **무결성 검사에 사용**: 파일이 바뀌었는지 검사  
- ❌ **요즘은 잘 안 씀**: 충돌(Collision) 잘 일어남 → 같은 해시값 나올 수 있음 → 보안에 위험

> 👶 쉬운 예시:  
> - 너가 쓴 **편지를 압축해서 숫자 하나(해시값)로 만든다**  
> - 근데 **그 숫자로 원래 편지를 다시는 못 만든다**  
> - 다른 사람이 편지 바꾸면 해시값이 달라지니까 “뭔가 바뀌었네?” 하고 알 수 있음  
> - 문제는 가끔 **다른 편지인데도 같은 숫자가 나올 수 있음(MD5 충돌)** → 보안에 치명적

→ 그래서 요즘은 **SHA-256** 같은 더 튼튼한 놈 씀

---

### 📦 암호화 알고리즘 종류 (이거 무조건 정리해라)

| 종류 | 설명 | 대표 알고리즘 | 쉬운 예시 |
|------|------|----------------|------------|
| **대칭키 암호화**<br>(비밀키) | 암호화와 복호화에 **같은 키** 사용 | DES, AES, ARIA, SEED, LEA 등 | 같은 열쇠로 자물쇠 잠그고 여는 느낌 |
| **비대칭키 암호화**<br>(공개키) | 암호화와 복호화에 **다른 키** 사용<br>공개키(잠금), 개인키(열쇠) | RSA, DSA, Diffie-Hellman, ECC 등 | 누구나 잠글 수 있지만, 주인만 열 수 있음 |
| **해시 함수**<br>(일방향 암호화) | **고정 길이의 해시값 생성**, 복원 불가능 | MD5, SHA-1, SHA-256, HAS-160 | 원본을 압축한 손도장. 복사 불가 |

---

### 🛡️ 해시 알고리즘 취약점과 방어법

| 공격 방식 | 설명 | 방어법 | 예시 |
|------------|------|--------|------|
| **레인보우 테이블** | 미리 계산된 해시-원본 쌍으로 역추적 | **Salting**: 랜덤 문자 추가 | “1234” → “1234@K8” |
| **무차별 대입 (Brute-force)** | 가능한 모든 조합 시도해서 해시 일치 확인 | **Key Stretching**: 연산 수만 번 반복 | 비번 하나 해석하려고 몇 년 걸리게 만듦 |

---

### 📈 해시 함수 3대 특성 (암기 필수)

| 특성 이름 | 설명 | 쉬운 비유 |
|-----------|------|----------|
| **역상 저항성**<br>(Preimage Resistance) | 해시값만으로 원본 입력을 찾기 어려움 | 손도장만 보고 누구 손인지 알아내기 어려움 |
| **제2 역상 저항성**<br>(Second Preimage Resistance) | 특정 입력과 같은 해시값을 만드는 **다른 입력** 찾기 어려움 | 같은 도장을 가진 다른 사람 만들기 힘듦 |
| **충돌 저항성**<br>(Collision Resistance) | 서로 다른 두 입력이 **같은 해시값** 갖기 어려움 | 두 사람이 **같은 손도장** 갖는 건 매우 희박해야 함 → MD5는 이게 깨졌음! |

---

### ⚠️ 그래서 MD5 왜 안 써?

- 🔓 **충돌 쉽게 나서 보안에 뚫림**  
- 🔍 요즘은 **SHA-256, SHA-3, BLAKE2** 같은 더 안전한 해시 함수 씀

---

### 🤖 요약 마무리 암기

- **MD5**: 옛날엔 좋았지만 지금은 보안에 취약  
- **SHA-256**: 요즘 표준, 보안용 해시  
- **대칭키**: 빠름, 키 분배가 문제  
- **비대칭키**: 느림, 보안 좋음  
- **해시함수**: 압축 + 복원 불가, 주로 무결성 확인에 씀  

-----------------------------------------------------------------------------------------------------------------------------------------------
📏 LOC 기법으로 개발 소요 기간 구하기

LOC기법에 의해 예측된 총라인수가 30,000라인일 경우 개발에 투입될 프로그래머 수가 5명이고,  
프로그래머들의 평균 생산성이 월당 300라인일 때, 개발에 소요되는 기간을 구하는 계산식과 기간을 구하여 쓰시오.


답:  
계산식:  
총 라인 수 ÷ (프로그래머 1인당 월 생산성 × 투입 프로그래머 수) = 개발 소요 기간  
30,000 라인 ÷ (300 라인/월 × 5명) = 30,000 ÷ 1500 = 20개월

개발 소요 기간: 20개월

알잘딱깔센 설명:  
LOC(Line of Code) 기법은 개발할 소프트웨어의 총 코드 라인 수를 기준으로 개발 기간이나 비용을 대략 예측하는 방법이다.  
간단하게 코드 수÷(프로그래머 1명당 월 생산성 × 투입 인원 수) 하면 기간이 나온다.

여기선  
- 총 코드 라인 수: 30,000라인  
- 프로그래머 1명당 월 생산성: 300라인  
- 투입 프로그래머 수: 5명  

그래서, 30,000 ÷ (300 × 5) = 20개월 이다.  

이론적으로는 딱 떨어지지만 현실에선 변수가 많아 변동이 심하다.  

### 🗓️ 일정 산정 기법 (이것도 꼭 봐라!)

| 기법 이름 | 설명 | 존나 쉬운 예시 |
|-----------|------|----------------|
| **WBS**<br>(Work Breakdown Structure) | 프로젝트를 **작은 작업 단위로 쪼개서** 나무처럼 구조화 | 피자 만들기 → 반죽 → 토핑 올리기 → 오븐 굽기 식으로 단계별 쪼개기 |
| **PERT/CPM** | 작업들 간 **선후 관계 + 소요 시간 분석**해서 전체 일정 계산<br>특히 **임계경로(Critical Path)** 찾음 | 마라톤 중 "가장 오래 걸리는 구간"이 전체 시간 결정함 |
| **간트 차트**<br>(Gantt Chart) | 각 작업을 **막대그래프**로 보여줘서 시각적으로 일정 파악 쉽게 함 | “이 작업은 3일 걸리고, 저건 5일 걸리고, 겹치면 어떻게 되는지 한눈에 보기” |

> 📌 기억 꿀팁:  
> - **WBS**: 뭐뭐 해야 되는지 리스트 뽑는 구조  
> - **PERT/CPM**: 언제 뭐 먼저 하고 얼마나 걸리는지 계산  
> - **간트 차트**: 그걸 **눈으로 예쁘게 보기**  

---

### 💰 비용 산정 기법

| 기법 이름 | 설명 | 존나 쉬운 예시 |
|-----------|------|----------------|
| **상향식 산정**<br>(Bottom-Up) | **작업 하나하나 비용 다 따져서** 전체 비용 계산. 가장 정확 | 노가다식으로 “이건 만 원, 저건 오천 원…” 다 더함 (LOC, FP 방식) |
| **하향식 산정**<br>(Top-Down) | **전체 프로젝트 규모 감잡고 대략 뽑는 방식**. 경험 기반 | 전문가가 “이거 비슷한 프로젝트 1억 들었으니 이건 한 8천?” 감잡고 결정 |
| **수학적 모델 기반** | 과거 데이터 + 수식으로 예측 | COCOMO, Putnam 모델 등<br>“지난번 비슷한 거 평균 계산 때리자” |

📌 자주 나오는 대표 모델:
- **COCOMO**: 개발 규모, 복잡도에 따라 **노력 인력(M/M)** 예측  
- **Function Point (FP)**: **기능 개수**에 따라 비용 계산  
- **Putnam 모델**: 프로젝트 생산성, 노력 시간 등을 반영한 수학 공식

---

### 🤯 한줄 요약 암기 팁

- **WBS**: 작업 리스트 쪼개기  
- **PERT/CPM**: 순서+시간+임계경로  
- **간트 차트**: 일정 그래프 시각화  
- **상향식**: 밑에서부터 다 더함 (정확)  
- **하향식**: 위에서 대충 감으로 (빠름)  
- **모델 기반**: 수식 돌려서 자동 계산 (근거 있음)

---

### 🍕 진짜 쉬운 비유 전체 요약

> 너가 친구랑 **피자집 오픈**한다고 치면:

- **WBS**: 피자 만들기 과정 쪼갬 (도우 만들기, 토핑 올리기, 굽기 등)
- **PERT/CPM**: 뭐 먼저 해야 하고, 얼마나 걸리는지 계산 (→ 배달 시간 예측)
- **간트 차트**: 피자 제작부터 배달까지 **시간표 그리기**

- **상향식 산정**: 재료비 하나하나 전부 계산함 (도우 1천, 치즈 2천, 인건비 5천…)
- **하향식 산정**: 전체 피자 1판 만드는 데 대충 1만 원쯤 들겠지~ 경험으로 감잡음
- **COCOMO 모델**: “이 피자 만드는 시간은 지난번 데이터 기반으로 30분이면 된다” 수학적으로 계산



-----------------------------------------------------------------------------------------------------------------------------------------------
📜 버블 정렬 예제 코드 및 해설

✅ 코드 (C)

```c
#include <stdio.h>                                         // 표준 입출력 함수 (예: printf)를 사용하기 위해 필요한 헤더 파일

int main() {
    int a[] = {95, 75, 85, 100, 50};                                 // 초기 정수 배열 선언 및 초기화
    int i, j, temp;                                                  // 반복문 변수와 값 교환을 위한 임시 변수
    int n = 5;                                                               // 배열의 크기

                                                                            // 버블 정렬(Bubble Sort) 알고리즘 구현
                                                                            // 외부 루프: 총 n-1번 회전한다. (배열 크기가 n이면 n-1번의 '패스'가 필요하다.)
                                                                            // 각 패스마다 가장 큰(또는 작은) 원소가 배열의 끝으로 '거품처럼' 올라간다.
    for (i = 0; i < n - 1; i++) {
                                                                                        // 내부 루프: 현재 패스에서 인접한 원소들을 비교하고 교환한다.
                                                                                        // 비교 범위는 (n - 1) - i 로 점점 줄어든다.
                                                                                        // 이는 각 패스마다 가장 큰 원소가 이미 배열의 끝으로 정렬되었으므로,
                                                                                        // 그 부분은 다시 비교할 필요가 없기 때문이다.
        for (j = 0; j < (n - 1) - i; j++) {
                                                                                                    // 인접한 두 원소를 비교한다.
            if (a[j] > a[j + 1]) { // 현재 원소가 다음 원소보다 크면 (오름차순 정렬)
                                                                                                // 두 원소의 위치를 서로 교환(swap)한다.
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
                                                                                                // 각 i번째 외부 루프(패스)가 끝날 때마다 배열의 상태를 추적해보자.
                                                                                                // 초기 배열: {95, 75, 85, 100, 50}
                                                                                                //
                                                                                                // i = 0 (첫 번째 패스): n-1-i = 4번 비교 (j=0,1,2,3)
                                                                                                //   j=0: (95 > 75) T -> {75, 95, 85, 100, 50}
                                                                                                //   j=1: (95 > 85) T -> {75, 85, 95, 100, 50}
                                                                                                //   j=2: (95 > 100) F
                                                                                                //   j=3: (100 > 50) T -> {75, 85, 95, 50, 100}
                                                                                                //   --> i=0 패스 종료 후 배열: {75, 85, 95, 50, 100} (가장 큰 100이 맨 끝으로)
                                                                                                //
                                                                                                // i = 1 (두 번째 패스): n-1-i = 3번 비교 (j=0,1,2)
                                                                                                //   j=0: (75 > 85) F
                                                                                                //   j=1: (85 > 95) F
                                                                                                //   j=2: (95 > 50) T -> {75, 85, 50, 95, 100}
                                                                                                //   --> i=1 패스 종료 후 배열: {75, 85, 50, 95, 100} (두 번째 큰 95가 끝에서 두 번째로)
                                                                                                //
                                                                                                // i = 2 (세 번째 패스): n-1-i = 2번 비교 (j=0,1)
                                                                                                //   j=0: (75 > 85) F
                                                                                                //   j=1: (85 > 50) T -> {75, 50, 85, 95, 100}
                                                                                                //   --> i=2 패스 종료 후 배열: {75, 50, 85, 95, 100} (세 번째 큰 85가 끝에서 세 번째로)
                                                                                                //
                                                                                                // i = 3 (네 번째 패스): n-1-i = 1번 비교 (j=0)
                                                                                                //   j=0: (75 > 50) T -> {50, 75, 85, 95, 100}
                                                                                                //   --> i=3 패스 종료 후 배열: {50, 75, 85, 95, 100} (네 번째 큰 75가 끝에서 네 번째로)
                                                                                                //
                                                                                                // 루프 종료. 배열은 완전히 정렬되었다.
    }

                                                                                                    // 정렬된 배열을 순서대로 출력한다.
    for (i = 0; i < 5; i++) {
        printf("%d", a[i]);                                                                                 // 각 정수를 연달아 출력한다.
    }

    return 0;                                                                                         // 프로그램 성공 종료.
}

✅ 최종 정렬 결과 출력: 50758595100

🔍 해설

버블 정렬은 가장 간단한 정렬 알고리즘 중 하나로,
큰 값이 마치 물속 거품처럼 차례로 맨 뒤로 ‘떠오르는’ 방식이다.

-----------------------------------------------------------------------------------------------------------------------------------------------

☕ Java로 작성된 프로그램이다. 결과를 쓰시오.

✅ 코드
```java
public class Main {

    public static int[] makeArray(int n) {                         // makeArray 함수 정의: 정수 n을 인자로 받는다.
        int[] t = new int[n];                                         // n 크기의 정수 배열 t를 새로 만든다. (예: n이 4면, 크기 4짜리 배열 생성)
        for (int i = 0; i < n; i++) {                                 // i는 0부터 n-1까지 1씩 증가하면서 반복한다.
            t[i] = i;                                                 // 배열 t의 i번째 칸에 i 값을 저장한다. (예: t[0]=0, t[1]=1, ...)
        }
        return t;                                                         // 모든 값을 채운 배열 t를 돌려준다.
    }

    public static void main(String[] args) {                                 // 메인 함수: 프로그램이 여기서부터 시작한다.
        int[] a = makeArray(4);                                                 // makeArray(4) 함수를 호출한다. 이 함수가 [0, 1, 2, 3] 배열을 만들어서 반환하면,
                                                                                       // 그 배열이 'a'라는 이름의 배열 변수에 저장된다.
        for (int i = 0; i < a.length; i++)                                         // 배열 'a'의 길이(a.length는 4)만큼 반복한다. i는 0, 1, 2, 3이 된다.
            System.out.print(a[i] + "");                                                 // 배열 'a'의 각 요소(a[0], a[1], ...)를 화면에 출력한다.
                                                                                       // System.out.print는 줄 바꿈 없이 내용을 이어서 출력하는 명령어다.
    }
}

✅ 실행 결과:
0123


-----------------------------------------------------------------------------------------------------------------------------------------------

📘 **문제**  
**문제 20)** 다음은 Java로 작성된 프로그램이다. 실행 결과를 쓰시오.

```java
int i = 3, c = 1;                                 // 변수 i는 3으로, c는 1로 초기화된다.
switch(i){                                         // switch 문: 변수 i의 값에 따라 실행할 case를 선택한다.
    case 1: c++;                                 // i가 1일 경우, c를 1 증가시킨다. (break 없음에 주의!)
    case 2: c += 3;                                 // i가 2일 경우, c에 3을 더한다. (break 없음에 주의!)
    case 3: c = 0;                                 // i가 3일 경우, c를 0으로 만든다. (여기서부터 실행 시작!)
    case 4: c += 3;                                 // i가 4일 경우, c에 3을 더한다. (break 없음에 주의!)
    case 5: c -= 10;                                 // i가 5일 경우, c에서 10을 뺀다. (break 없음에 주의!)
    default: c--;                                         // 위에 어떤 case도 해당하지 않을 경우, c를 1 감소시킨다.
}
System.out.print(c);                                 // 최종 c의 값을 화면에 출력한다.

🔹 최종 출력
System.out.print(c);
→ 출력값: -8
