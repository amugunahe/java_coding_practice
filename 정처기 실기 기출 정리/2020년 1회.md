💾 **비정규화 (반정규화, 역정규화)**  
**답:** 성능 향상을 위해 정규화 기법을 깨부수는 거다.  
**알잘딱깔센 설명:**  
야, 정규화 이거 좋긴 좋다. 데이터 중복도 줄이고 깔끔하게 관리하게 해주니까.  
근데 말이야, 그거 너무 FM대로 하다 보면 테이블 존나 쪼개져서 조인 연산이 늘어나고, 결과적으로 조회 속도가 떡락하는 수가 있어.  
이럴 때 쓰는 게 바로 비정규화다. 이론적으로는 "야, 이거 정규화 규칙 깼네?" 소리 들을 수 있는데,  
실전에서는 성능 존나게 땡기려고 일부러 데이터 중복도 좀 허용하고 테이블 합치고 하는 기술이다 이 말이야.  
딱 보면 성능 향상에 미친 놈들이 만든 거지.

📝 **데이터베이스 설계 단계 (중요하니까 훑어봐라)**  
- 개념적 설계: 데이터베이스 설계의 첫 단추다. 뭘 저장할지, 얘네들끼리 어떻게 엮여있는지 대충 그림 그리는 단계다. 보통 ERD(Entity Relationship Diagram) 같은 걸로 그려본다.  
- 논리적 설계: 이제 어떤 DBMS(데이터베이스 관리 시스템) 쓸지 정하고, 개념적 설계를 바탕으로 실제로 테이블을 만들 준비를 하는 단계다. 여기서 정규화 작업도 같이 해준다.  
- 물리적 설계: 실제 서버에 데이터를 쑤셔 넣을 준비하는 최종 단계다. 성능을 극대화하려고 파티션, 클러스터, 인덱스 같은 걸 설계하고 배치한다.

🪜 **정규화 단계 (이거 다 외우면 네가 독하다!)**  
- 1정규형 (1NF): 데이터 필드에 원자값(Atomic Value), 즉 더 이상 쪼갤 수 없는 값만 넣어라. "이름1,이름2" 이런 거 안 된다는 말이다.  
- 2정규형 (2NF): 부분 함수 종속을 제거해라. 기본키의 일부에만 종속되는 속성은 따로 빼서 테이블을 나눠라 이말이야. 안 그러면 데이터 중복 오진다.  
- 3정규형 (3NF): 이행 함수 종속을 제거해라. 기본키가 아닌 속성이 다른 기본키가 아닌 속성을 결정하는 관계를 없애버리는 거다. 예: 학생 테이블에 학과명, 학과전화번호가 있으면 학과정보는 따로 테이블로 빼는 식.  
- BCNF: 결정자이면서 후보키가 아닌 놈 있으면 다 조져라. 3정규형보다 좀 더 빡센 규칙.  
- 4정규형 (4NF): 다치 종속을 제거해라. 하나의 기본키에 대해 여러 개의 독립적인 다치 종속성이 있으면 따로 테이블로 분리.  
- 5정규형 (5NF): 조인 종속을 제거해라. 조인 연산을 통해서만 복원 가능한 종속성이 있다면 그것도 따로 테이블로 빼버림.

-----------------------------------------------------------------------------------------------------------------------------------------------
📜 마크업 언어
() : SGML의 단순화된 부분 집합, 다른 많은 종류의 데이터를 기술하는데 사용할 수 있음.
() : 주로 다른 종류 시스템, 인터넷에 연결된 시스템끼리 데이터를 쉽게 주고 받을 수 있게 하여 HTML 한계를 극복할 목적으로 만들어짐
() : 텍스트 데이터 형식으로 유니코드 사용해 전세계 언어를 지원함

답: XML

알잘딱깔센 설명:
야, XML(eXtensible Markup Language) 이거 요즘 데이터 주고받을 때 존나 많이 쓰는 놈이다. 원래 **SGML(Standard Generalized Markup Language)**이라는 복잡한 조상님이 있었는데, 그걸 좀 쉽게 만든 거라고 보면 된다. 데이터의 구조랑 의미를 표현하려고 태어난 텍스트 기반 형식이다.

웹페이지 표시에 특화된 HTML이랑 다르게, XML은 데이터 자체를 기술하고 전송하는 데 존나게 초점이 맞춰져 있다.

시스템끼리 데이터 주고받을 때 특히 빛을 발하고, 유니코드를 지원해서 전 세계 모든 언어를 표현할 수 있다는 게 존나 강점이다. 이쯤 되면 글로벌 스타 아니겠노?

📚 마크업 언어 종류 (간단히 봐라, 다 알면 좋고!)
HTML: 웹 페이지의 뼈대랑 내용 담당. 네가 지금 보고 있는 이 페이지도 HTML로 만들어진 거다.
SGML: 존나 복잡해서 실생활에서는 잘 안 쓴다. XML의 할아버지라고 보면 됨.
XML: SGML을 쉽게 만든 확장형 마크업 언어. 데이터 구조 만들고 주고받을 때 존나 편하다.
JSON: 키-값 쌍으로 이루어진 경량 데이터 교환 형식. 요즘 XML 대신 많이 쓰는 추세다. 더 가볍고 JS랑 궁합이 존나 좋음.
TXT: 그냥 단순한 텍스트 파일. 메모장 파일이 이거다.
YAML: 사람에게 읽히기 쉬운 데이터 표현 방식. 설정 파일 같은 데서 자주 보인다.

-----------------------------------------------------------------------------------------------------------------------------------------------
🚫 살충제 패러독스 개념 간략 설명
답: 동일한 테스트 케이스로 동일한 절차를 반복 수행하면 새로운 결함을 찾을 수 없음

알잘딱깔센 설명:
이름부터 살충제 패러독스 아니노? 농부가 똑같은 살충제만 계속 뿌리면 벌레들이 내성 생겨서 나중엔 끄떡도 안 하잖아? 소프트웨어 테스트도 똑같다.
맨날 똑같은 테스트 케이스랑 똑같은 절차만 돌리면, 새로운 버그는 절대 못 찾는다. 기존 버그는 잡겠지만, 다른 숨은 버그들은 계속 살아남는다는 말이다.
테스트 케이스를 주기적으로 업데이트하고, 테스트 방법도 존나게 다양하게 바꿔줘야 새로운 결함을 발견할 수 있다. 안 그럼 버그들이 너한테 빅엿을 선물할 거다.

💻 소프트웨어 테스트 종류 (테스트는 존나 중요하니까 대충 봐라)
단위 테스트: 코드 덩어리 하나하나, 즉 개별 모듈이나 함수가 제대로 작동하는지 검증한다. 개발자가 주로 한다.
정적 테스트: 코드를 실행 안 하고 직접 검토하거나 자동화 도구로 분석한다. (코드 리뷰, 정적 분석 도구)
동적 테스트: 코드를 직접 실행하면서 기능이 제대로 동작하는지 검증한다.
통합 테스트: 단위 테스트를 마친 모듈들을 합쳐서, 얘네들이 서로 잘 연동되는지 확인한다. 팀워크 테스트라고 보면 됨.
하향식 테스트: 위쪽 모듈부터 테스트하고, 아직 안 만들어진 아래쪽 모듈은 **스텁(Stub)**이라는 가짜 모듈로 대체한다.
상향식 테스트: 아래쪽 모듈부터 테스트하고, 아직 안 만들어진 위쪽 모듈은 **드라이버(Driver)**라는 가짜 모듈로 대체한다.
빅뱅 테스트: 모든 모듈을 한꺼번에 다 합쳐서 테스트한다. 문제 생기면 어디가 문제인지 찾기 존나 힘들어서 비추한다.
시스템 테스트: 개발된 시스템 전체가 사용자 요구사항이랑 기능, 성능 등 모든 조건을 만족하는지 검증한다. 거의 최종 점검이다.

기능 테스트: 시스템이 요구된 기능들을 제대로 수행하는지 확인한다.
비기능 테스트: 성능, 보안, 안정성, 사용성 등 기능 외적인 부분들을 검증한다.
인수 테스트: 최종 사용자가 실제로 시스템을 써보고 "이거 쓸 만하네" 하고 OK 사인 내리는 테스트다.

알파 테스트: 개발자가 옆에서 지켜보는 상태로, 개발 환경에서 내부적으로 테스트한다.
베타 테스트: 개발자 없이 실제 사용자 환경에서 테스트한다. "이거 써보고 버그 있으면 제보 좀" 하는 방식이다.

📈 파레토 법칙 (Pareto Principle)
일명 '80 대 20 법칙' 알제? 소프트웨어 오류도 마찬가지다. 전체 오류의 약 80%가 시스템의 핵심 모듈 20%에서 발생한다는 법칙이다. 그러니까 중요한 모듈을 더 빡세게 테스트해야 한다 이말이야.

🧙‍♂️ 테스트 오라클 (Test Oracle)
테스트 결과가 올바른지 아닌지 판단하기 위한 '정답지' 역할을 하는 놈이다.
참 오라클: 가장 정확한 결과를 제공하는 완벽한 정답지.
샘플 오라클: 일부 예시 데이터만 가지고 판단하는 정답지.
휴리스틱 오라클: 경험이나 추론을 기반으로 대충 판단하는 정답지.
일관성 검사 오라클: 여러 번 실행했을 때 결과가 일관적인지 점검해서 판단하는 정답지.

-----------------------------------------------------------------------------------------------------------------------------------------------
🖇️ 모듈의 독립성을 판단하는 두가지 지표
모듈의 독립성을 판단하는 두가지 지표 **(1)**는 모듈과 모듈간의 상호의존 정도,
**(2)**는 모듈 내부의 기능적인 집중 정도
모듈의 독립성을 높이기 위해서는 모듈간의 상호 의존 정도를 나타내는 **(1)**를 낮추고 모듈이 독립적으로 자체 기능만을 수행하도록 **(2)**를 높여야 함

답:
(1) 결합도
(2) 응집도

알잘딱깔센 설명:
좋은 소프트웨어 설계를 위한 모듈의 독립성을 나타내는 핵심 지표 두 가지다. 소프트웨어 모듈은 사람으로 치면 '전문가' 같은 거다. 자기 일만 잘하고 남한테 휘둘리지 않아야 좋지 않겠노?
결합도 (Coupling): 모듈과 모듈끼리 얼마나 끈끈하게, 상호 의존적으로 엮여있는지를 나타내는 척도다. 이게 낮을수록 모듈 간 독립성이 커져서, 한 모듈을 바꿔도 다른 모듈에 영향이 적다. 
                    그래서 유지보수나 기능 확장하기가 존나 편해진다. (남남이 최고, 서로 신경 끄고 살아야 편함)
응집도 (Cohesion): 한 모듈 안에 있는 기능들이 얼마나 지들끼리 똘똘 뭉쳐있고, 하나의 목적을 위해 집중되어 있는지를 나타내는 척도다. 
                        이게 높을수록 모듈 내부 구성 요소들이 밀접하게 관련되어 있어서, 모듈의 기능을 이해하고 관리하기가 존나 용이해진다. (패밀리 으리! 한 몸처럼 움직여야 함)
결론적으로, 좋은 소프트웨어 설계를 하려면 결합도는 낮게, 응집도는 높게 가져가야 한다. 이게 국룰이다.

📈 응집도 (높을수록 좋음, 기능적 응집이 최고!)
우연적 응집: 가장 낮음. 모듈 안에 아무 상관 없는 기능들이 그냥 우연히 모여있다. 개판 5분 전이다.
논리적 응집: 비슷한 종류의 기능을 모아놨지만, 실제로는 다른 기능을 수행할 수도 있다. (예: 모든 출력 관련 함수를 모아놓은 모듈)
시간적 응집: 특정 시간에 함께 실행되는 기능들을 모아놨다. (예: 초기화 관련 함수들)
절차적 응집: 순차적인 처리 절차에 따라 기능들을 모아놨다.
통신적 응집: 동일한 입력이나 출력을 사용하는 기능들을 모아놨다.
순차적 응집: 한 기능의 출력이 다음 기능의 입력으로 사용된다.
기능적 응집: 가장 좋음. 모듈이 단일하고 명확한 기능 하나만 수행한다. 완벽주의자 모듈이라고 보면 된다.

📉 결합도 (낮을수록 좋음, 데이터 결합이 최고!)
데이터 결합: 가장 낮음. 모듈끼리 단순한 값(기본 자료형 데이터)만 딱딱 주고받는다. 깔끔하다.
스탬프 결합: 배열이나 구조체 같은 복합 데이터를 전달한다. 데이터 전체를 보내니 필요 없는 정보까지 넘어갈 수 있다.
제어 결합: 모듈이 다른 모듈에게 '이렇게 해라' 하고 제어 정보(플래그 등)를 전달한다. 명령받는 모듈의 로직이 바뀌는 거라 좋지 않다.
외부 결합: 다른 모듈이 선언한 데이터에 직접 의존한다. 의존성이 높다.
공통 결합: 전역 변수 같은 공통 영역의 데이터를 여러 모듈이 공유한다. 누가 뭘 건드렸는지 알기 힘들어서 위험하다.
내용 결합: 가장 높음. 다른 모듈의 내부 내용에 직접 접근해서 조작한다. 이건 뭐... 개민폐다. 서로의 속을 다 아는 수준이라 한쪽이 바뀌면 다른 쪽도 작살난다.

⚙️ 재공학 & 역공학 (이것도 가끔 나온다)
재공학: 이미 만들어진 소프트웨어를 개선하거나, 재사용하기 위해 고치거나 다시 만드는 활동이다. 리모델링 같은 거다.
역공학: 소스 코드 같은 완성된 결과물로부터 설계 문서나 명세서 같은 원래의 개념을 추출하는 작업이다. 설계도를 역으로 만들어내는 거지.
재사용: 이미 잘 만들어진 모듈이나 컴포넌트를 다시 가져다 쓰는 것. 개발 시간과 비용을 아껴주는 효자다.

-----------------------------------------------------------------------------------------------------------------------------------------------
📊 Fan-in, Fan-out 수 구하기
Fan-in과 Fan-out은 소프트웨어 모듈 간의 관계를 나타내는 지표
Fan-in: 특정 모듈로 들어오는 제어의 수, 즉 몇 개의 모듈이 해당 모듈을 호출하는지를 나타냄
Fan-out: 특정 모듈에서 나가는 제어의 수, 즉 해당 모듈이 몇 개의 모듈을 호출하는지를 나타냄

답:
Fan-in: 해당 모듈을 호출하는 모듈의 수
Fan-out: 해당 모듈이 호출하는 모듈의 수

알잘딱깔센 설명:
모듈 간의 **'인기도'와 '의존도'**를 보여주는 지표라고 보면 된다.

Fan-in (들어오는 화살표 수): 특정 모듈을 몇 개의 다른 모듈이 호출하는지 나타낸다. Fan-in 값이 높다는 건 이 모듈이 여러 군데에서 재사용되고 있는 존나 인기 많은 모듈이라는 뜻이다. 핵심 기능이 많거나 유틸성 기능이 많을 때 높게 나온다.

Fan-out (나가는 화살표 수): 특정 모듈이 몇 개의 다른 모듈을 호출하는지 나타낸다. Fan-out 값이 높다는 건 해당 모듈이 다른 모듈에 존나게 의존하고 있다는 뜻이다. 이 모듈을 수정했을 때 다른 모듈에 미치는 파급 효과가 클 수 있다는 걸 의미한다.

-----------------------------------------------------------------------------------------------------------------------------------------------

🌐 JavaScript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷
JavaScript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷
() 표현식은 사람과 기계 모두 이해하기 쉬우며 용량이 작아서, 최근에는 () XML을 대체해서 데이터 전송 등에 많이 사용
프로그래밍 문법이 아닌 단순히 데이터를 표시하는 표현 방법 뿐 () 데이터는 이름과 값의 쌍으로 이루어짐

답: JSON

알잘딱깔센 설명:
요즘 웹에서 데이터 주고받을 때 XML 킬러로 떠오른 슈퍼스타다. 바로 **JSON(JavaScript Object Notation)**이다. JavaScript 객체 문법을 기반으로 한 텍스트 형식의 데이터 표현 방법이다.

사람이 읽고 쓰기 쉽고, 기계도 분석하고 생성하기 존나 용이하다. 가독성도 좋고 처리 속도도 빠르다.

XML에 비해 용량이 작고 구조가 단순해서, 웹 API나 모바일 앱 등 데이터 전송에 압도적으로 많이 사용된다. 요즘 웹 개발하면 JSON이랑 밥 먹듯이 만날 거다.

프로그래밍 문법이 아니라 그냥 데이터를 표시하는 표현 방법일 뿐이다. 데이터는 { "이름": "값" } 이런 식으로 키(key)와 값(value)의 쌍으로 이루어져 있다.

📚 관련 개념 (헷갈리지 마라, 다들 비슷하게 생김)
프레임워크: 개발할 때 사용할 수 있는 미리 만들어진 큰 틀이나 기반을 제공하는 반제품 소프트웨어. 너는 그 틀 안에서 코딩만 하면 된다. (예: Java의 Spring Framework, 웹 개발의 Vue.js, React 등)

라이브러리: 네가 필요할 때 가져다 쓸 수 있는 재사용 가능한 코드 집합. 특정 기능을 수행하는 도구 모음이라고 보면 된다. (예: jQuery, lodash 등)

API: 라이브러리나 프레임워크의 기능을 어떻게 사용할지 설명하는 문서이자, 다른 프로그램이나 시스템이 특정 기능에 접근할 수 있도록 하는 규칙이나 인터페이스다. 쉽게 말해 '이거 어떻게 써?' 하는 사용 설명서이자 문 열어주는 역할이다.

-----------------------------------------------------------------------------------------------------------------------------------------------

📈 애플리케이션 성능 측정을 위한 지표
(1): 일정 시간 내에 애플리케이션이 처리하는 일의 양
(2): 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간
(3): 애플리케이션에 요청을 전달한 시간부터 처리가 완료될 때까지 걸린 시간
자원 사용률: 애플리케이션이 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률

답:
(1) 처리량 (Throughput)
(2) 응답시간 (Response Time)
(3) 반환시간 (Turn Around Time)

알잘딱깔센 설명:
앱 성능을 평가할 때 꼭 봐야 할 지표들이다. 이거 모르면 폰으로 겜할 때 렉 걸리는 이유도 모른다.

(1) 처리량 (Throughput): 단위 시간당 애플리케이션이 처리하는 작업의 양이다. "초당 몇 건의 요청을 처리할 수 있나?" 같은 거다. 시스템의 처리 성능을 나타내는 지표로, 이게 높을수록 좋다.

(2) 응답시간 (Response Time): 사용자가 요청을 보낸 시간부터 첫 번째 응답이 도착할 때까지 걸린 시간이다. 이건 사용자가 직접 체감하는 성능이라 존나 중요하다. 빠를수록 사용자가 만족한다.

(3) 반환시간 (Turn Around Time): 애플리케이션에 요청을 전달한 시간부터 해당 요청의 처리가 완전히 완료되어 최종 결과가 반환될 때까지 걸린 전체 시간이다. 배치 작업이나 전체 시스템 성능을 측정할 때 주로 쓴다.

자원 사용률: 애플리케이션이 돌아갈 때 CPU, 메모리, 네트워크 같은 시스템 자원을 얼마나 쓰고 있는지를 나타낸다. 이게 너무 높으면 시스템에 과부하가 걸렸다는 뜻이니, 성능 최적화나 병목 현상 분석에 활용된다.

-----------------------------------------------------------------------------------------------------------------------------------------------

🔢 학생(STUDENT) 테이블 튜플 수 구하기
학생(STUDENT)테이블에 전자과 50명, 전기과 100명, 건축과 50명 정보가 저장되어 있을 때 튜플 수를 쓰시오 (DEPT 컬럼은 학과명)

(1) SELECT DEPT FROM STUDENT;
(2) SELECT DISTINCT DEPT FROM STUDENT;
(3) SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '건축과';

답:
(1) 200
(2) 3
(3) 1

알잘딱깔센 설명:
SQL 기본 중의 기본 문제다. 테이블에 총 학생은 전자과 50명 + 전기과 100명 + 건축과 50명 = 총 200명이다. 튜플은 테이블의 '행'을 말하는 거다.

(1) SELECT DEPT FROM STUDENT;

이 쿼리는 STUDENT 테이블에서 DEPT 컬럼에 있는 모든 데이터를 가져오라는 명령어다. 중복이고 뭐고 따지지 않고 다 가져온다 이 말이야. 그러니까 전체 학생 수인 200개 튜플이 반환된다.

(2) SELECT DISTINCT DEPT FROM STUDENT;

DISTINCT 키워드는 중복되는 값을 제거하고 유일한 값만 가져오라는 뜻이다. 학과명은 전자과, 전기과, 건축과 이렇게 딱 3가지 종류밖에 없지? 그래서 3개 튜플이 반환된다.

(3) SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '건축과';

먼저 WHERE DEPT = '건축과' 조건으로 '건축과' 학생들만 필터링한다.

그 다음 **COUNT(DISTINCT DEPT)**는 중복을 제거한 DEPT 컬럼의 개수를 세는 함수다. '건축과'라는 학과명은 하나밖에 없으니, 결과는 1이 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------

💣 네트워크 공격 유형
출발지 IP와 목적지 IP가 같은 패킷을 만들어 보내는 공격
수신자가 응답을 보낼 때 목적지 주소가 자기 자신이므로 SYN 신호가 계속 자신의 서버를 돌게 되어 서버의 자원을 고갈시켜 가용성을 파괴한다
방화벽에서 출발지와 목적지가 같은 패킷은 모두 제거하여 대응

답: Land attack

알잘딱깔센 설명:
**Land Attack(랜드 어택)**은 존나 악질적인 네트워크 공격 중 하나다. 이건 IP 헤더에 출발지 IP 주소와 목적지 IP 주소를 똑같게 만들어서 패킷을 보내는 방식이다.

이 공격을 받은 서버는 응답 패킷을 자기 자신한테 보내게 된다. 그럼 그 응답이 다시 서버한테 오고, 서버는 또 지한테 응답을 보내는 무한 루프에 빠진다 이 말이야.

이런 병신 같은 짓을 계속 반복하다 보면 서버의 자원(CPU, 메모리, 네트워크 대역폭)이 바닥나서 결국 서버가 맛탱이 가서 서비스가 안 되는(서비스 거부, DoS) 상태에 이르게 된다.

대응 방법은 간단하다. 방화벽이나 라우터에서 출발지 IP랑 목적지 IP가 똑같은 패킷은 발견하는 즉시 차단해버리면 된다.

💥 서비스 거부 공격 (DoS, Denial of Service) 유형 (이것도 자주 나온다)
DoS: 하나의 공격자가 시스템의 자원을 마비시키거나 네트워크 대역폭을 고갈시켜 정상적인 서비스 제공을 방해하는 공격이다.
Smurf Attack: IP 브로드캐스트와 ICMP 프로토콜을 이용해서 대량의 응답 패킷을 특정 서버로 집중시켜 마비시키는 공격이다.
SYN flooding: 서버에 SYN 패킷(연결 요청)을 존나게 많이 보내서 서버의 연결 대기 큐를 가득 채워버린다. 그러면 정상적인 사용자들이 서버에 접속을 못 하게 된다.
UDP 플러딩: UDP 패킷을 대량으로 전송해서 서버의 네트워크 자원을 고갈시키거나 응용 프로그램을 마비시킨다.
Ping 플러딩: Ping(ICMP echo request) 패킷을 엄청나게 많이 보내서 네트워크 대역폭을 소모시키고 서버의 자원을 마비시킨다.
Ping of Death: 규정된 크기(65,535바이트) 이상의 거대한 Ping 패킷을 전송해서 목표 시스템의 버퍼 오버플로우를 유발하거나 다운시키는 공격이다.
Teardrop Attack: IP 패킷을 조각내서 보내는데, 재조립할 수 없는 형태로 조작해서 보내는 공격이다. 목표 시스템이 이 조각들을 재조립하려다 오류가 발생하면서 시스템 오작동이나 다운을 초래한다.

-----------------------------------------------------------------------------------------------------------------------------------------------

🗣️ 통신 프로토콜의 기본 요소 3가지
통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고받는 양식과 규칙의 체계이다 통신 프로토콜의 기본 요소 3가지를 쓰시오

답:
구문(Syntax)
타이밍(Timing)
의미(Semantic)

알잘딱깔센 설명:
야, 컴퓨터들이나 통신 장비들이 서로 알아듣고 얘기하려면 약속된 규칙이 있어야 할 거 아니냐? 그게 바로 통신 프로토콜이다. 이 프로토콜에는 크게 세 가지 기본 요소가 있다. 마치 사람끼리 대화할 때처럼 말이야.

구문(Syntax): 메시지의 형식, 구조, 데이터의 표현 방법을 정의한다. "야, 메시지는 이렇게 생겨야 돼. 데이터는 이 순서로 넣어." 하는 규칙이다.
                (예: 주어-동사-목적어 순서, 한글로 말할지 영어로 말할지)
타이밍(Timing): 메시지를 언제 보내고 언제 받을지, 얼마나 빨리 보낼지, 어떤 순서로 보낼지 등을 규정한다. "내 말 끝나고 얘기해라", "1초 안에 대답해라" 같은 규칙이다.
의미(Semantic): 메시지의 내용이 뭘 의미하는지, 각 신호가 어떤 행동을 나타내는지를 정의한다. "안녕"이라고 했을 때, 그게 '인사'를 뜻하는 건지 '시비 거는' 건지 명확히 해주는 거다.

이 세 가지 요소가 명확해야 서로 오해 없이 데이터 주고받고 통신이 원활하게 된다.

-----------------------------------------------------------------------------------------------------------------------------------------------

⏱️ HRN(Highest Response-ratio Next) 우선 순위를 결정하는 계산식을 쓰시오
답: (대기시간+서비스시간)/서비스시간

알잘딱깔센 설명:
**HRN(Highest Response-ratio Next)**은 프로세스 스케줄링 기법 중 하나인데, 다른 놈들이랑 다르게 존나 똑똑하게 우선순위를 매긴다.
그냥 대기 시간만 보거나 짧은 작업만 보는 게 아니라, 대기 시간과 앞으로 처리할 시간(서비스 시간)을 모두 고려해서 우선순위 비율을 계산한다.

이 공식을 보면 알겠지만, 기다리는 시간이 길어질수록, 또는 서비스 시간이 짧을수록 우선순위가 높아진다.

이런 식으로 계산하면 기아 현상(Starvation), 즉 특정 프로세스가 계속 뒤로 밀려서 영원히 실행되지 못하는 좆같은 상황을 효과적으로 방지할 수 있다. 똑똑하지 않노?

🏃‍♂️ 프로세스 스케줄링 종류 (나눠서 봐라, 시험에 자주 나온다!)
선점 스케줄링: 현재 실행 중인 프로세스를 강제로 중단시키고 다른 프로세스를 실행할 수 있는 방식이다. 긴급한 작업이 들어오면 하던 거 잠시 멈추고 걔부터 처리하는 거다.
SRT (Shortest Remaining Time first): 남은 실행 시간이 가장 짧은 프로세스에게 CPU를 할당한다.
RR (Round Robin): 각 프로세스에게 정해진 시간 할당량(Time Slice)을 주고, 이 시간이 지나면 다음 프로세스로 CPU를 넘겨주는 순환 방식이다.
MLQ (Multi-Level Queue): 여러 개의 준비 큐를 사용하고, 각 큐마다 다른 스케줄링 방식을 적용한다. 큐 사이의 이동은 불가능하다.
MFQ (Multi-Level Feedback Queue): MLQ와 비슷하지만, 프로세스가 큐 사이를 이동할 수 있게 해서 유연성을 높인다. (기아 현상 방지에 좋음)


비선점 스케줄링: 한번 실행된 프로세스는 스스로 종료되거나 대기 상태로 전환될 때까지 CPU를 계속 점유하는 방식이다. 중간에 빼앗기지 않는다.
FCFS (First Come First Served): 먼저 온 놈이 먼저 처리된다. 선착순이다.
SJF (Shortest Job First): 실행 시간이 가장 짧은 프로세스부터 처리한다. 최단 시간을 보장하지만, 긴 작업은 기아 현상에 빠질 수 있다.
HRN (Highest Response-ratio Next): 이 문제의 주인공이다. 대기 시간과 서비스 시간을 고려해서 우선순위를 결정한다.
기한부 스케줄링: 정해진 기한(Deadline) 내에 완료되어야 하는 프로세스에게 우선순위를 준다.
우선순위 스케줄링: 각 프로세스에 부여된 우선순위에 따라 처리한다. (우선순위가 낮은 프로세스는 기아 현상에 빠질 수 있음)

👴 기아 현상 (Starvation) & 에이징 (Aging)
기아 현상: 특정 프로세스가 너무 낮은 우선순위 때문에 계속 뒤로 밀리거나, CPU를 할당받지 못해서 무한정 기다리는 현상이다. (SJF, 우선순위 스케줄링, SRT, MLQ에서 발생하기 쉽다.)

에이징 (Aging): 기아 현상을 방지하기 위한 기법 중 하나다. 프로세스가 CPU를 기다리는 시간이 길어질수록, 그 프로세스의 우선순위를 점진적으로 높여준다. (MFQ, HRN에서 적용하는 방식이다.)

-----------------------------------------------------------------------------------------------------------------------------------------------

🔒 트랜잭션 주요 특성 4가지 (ACID)
(1): 트랜잭션의 가장 기본적인 특성으로 트랜잭션 내에 연산은 반드시 모두 수행되어야 하며, 그렇지 못한 경우 모두 수행되지 않아야 함
일관성(consistency): 트랜잭션이 정상적으로 완료된 후 언제나 일관성 있는 데이터베이스 상태가 되어야 하며, 결과에 모순이 생겨서는 안 됨
(2): 하나의 트랜잭션이 수행 중에는 다른 트랜잭션이 접근할 수 없고 각각의 트랜잭션은 독립적이어야 함
영속성(Durablity): 지속성이라고 하며, 트랜잭션이 성공적으로 완료된 후 결과는 지속적으로 유지되어야 함

답:
(1) 원자성(Atomicity)
(2) 격리성(Isolation)

알잘딱깔센 설명:
트랜잭션은 데이터베이스에서 데이터의 무결성과 신뢰성을 보장하는 핵심 개념이다. 돈 거래한다고 생각해봐라. 돈이 통장에서 빠져나가고 다른 통장으로 들어가야 하나의 거래가 완료되는 거잖아? 중간에 돈만 빠져나가고 입금이 안 되면 좆되는 거다. 이럴 때 데이터베이스가 꼬이지 않게 지켜주는 4가지 원칙을 ACID 원칙이라고 한다.

A (Atomicity, 원자성): 트랜잭션 내의 모든 작업은 하나의 단위처럼 통째로 실행되거나, 아니면 아예 실행되지 않거나(롤백) 둘 중 하나여야 한다
                        "All or Nothing!" 이게 핵심이다. 중간에 실패하면 처음 상태로 다 되돌려놓는다.

C (Consistency, 일관성): 트랜잭션이 성공적으로 완료된 후에도 데이터베이스는 항상 일관되고 유효한 상태를 유지해야 한다. 
                        즉, 데이터베이스에 정의된 모든 규칙(제약 조건)을 위반하면 안 된다.

I (Isolation, 격리성): 여러 트랜잭션이 동시에 실행될 때, 서로 간섭하지 않고 독립적으로 실행되는 것처럼 보여야 한다. 
                        한 트랜잭션이 아직 완료되지 않은 다른 트랜잭션의 중간 결과를 보거나 수정할 수 없다. 각자 자기 일만 하는 거다.

D (Durability, 영속성): 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 반영되어야 한다. 
                        시스템 오류(전원 고장 등)가 발생해도 이 결과는 손실되지 않고 보존된다.

-----------------------------------------------------------------------------------------------------------------------------------------------

📡 OSI 7 참고 모델 중 다음 설명하는 계층은?
전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송
통신 단위는 비트이며 1과 0으로 나타내어지는, 전기적으로 on, off 상태
데이터를 전달할 뿐 데이터가 무엇인지 어떤 에러가 있는지 신경 쓰지 않음

답: 물리계층

알잘딱깔센 설명:
OSI 7계층 모델은 네트워크 통신 과정을 7단계로 나눈 표준 모델인데, 이 문제에 나오는 계층은 제일 밑바닥인 1계층, 물리 계층이다. 얘는 말 그대로 물리적인 연결과 신호 전송을 담당한다.

전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블이나 무선 신호 같은 물리 매체를 통해 데이터를 전송한다.

통신 단위는 가장 작은 단위인 **비트(Bit)**다. 1과 0으로 이루어진 전기적 신호(On/Off 상태)를 주고받는다.

얘는 데이터 내용이 뭔지, 에러가 났는지 같은 건 전혀 신경 안 쓴다. 그냥 **'비트를 전기 신호로 바꿔서 무조건 보내기'**가 임무다. 우편 배달부가 편지 내용을 안 보는 거랑 비슷하다.

네트워크 인터페이스 카드(NIC), 허브, 리피터 같은 장비들이 이 계층에서 작동한다.

🏢 OSI 7계층 (위에부터 중요하게 봐라, 층별 역할 구분 필수!)
7. 응용 계층 (Application Layer): 사용자가 직접 쓰는 프로그램(웹 브라우저, 이메일 클라이언트, 메신저 등)에 네트워크 서비스를 제공한다. HTTP, FTP, SMTP 같은 프로토콜이 여기에 속한다.
6. 표현 계층 (Presentation Layer): 데이터의 형식을 변환(인코딩), 압축, 암호화/복호화 등을 담당하여 응용 계층이 이해할 수 있는 형태로 만든다. (JPEG, MPEG 같은 형식)
5. 세션 계층 (Session Layer): 응용 프로세스 간의 연결(세션)을 설정, 유지, 종료하고 통신 순서를 관리한다. 대화의 시작, 끝을 조절하는 문지기라고 보면 된다.
4. 전송 계층 (Transport Layer): 양 종단(End-to-End) 간에 신뢰성 있는 데이터 전송을 보장한다. 데이터는 세그먼트 단위로 쪼개지며, TCP(신뢰성)와 UDP(속도) 프로토콜이 여기에 있다. 포트 번호를 사용한다.
3. 네트워크 계층 (Network Layer): **데이터를 목적지까지 안전하고 효율적으로 전달하기 위한 경로를 설정(라우팅)**한다. IP 주소를 사용하며, 데이터 단위는 패킷이다. 라우터가 이 계층에서 작동한다.
2. 데이터 링크 계층 (Data Link Layer): 인접한 두 노드(장치) 간에 신뢰성 있는 데이터 전송을 제공한다. MAC 주소를 사용하며, 데이터 단위는 프레임이다. 스위치, 브릿지가 여기에 속한다. 오류 검출 및 재전송 기능도 일부 제공한다.
1. 물리 계층 (Physical Layer): 비트 단위의 데이터를 물리 매체(케이블, 무선 신호 등)를 통해 전송하는 역할을 한다. NIC, 허브, 리피터 같은 장비가 속한다.

📡 스위치 종류 (이것도 종종 나온다)
L2 스위치: 데이터 링크 계층(2계층)에서 작동하며, MAC 주소(물리 주소)를 기반으로 패킷을 전달한다.
L3 스위치 (라우터 기능 포함): 네트워크 계층(3계층)에서 작동하며, IP 주소를 기반으로 패킷의 경로를 설정(라우팅)한다.
L4 스위치 (로드밸런서 기능 포함): 전송 계층(4계층)에서 작동하며, 포트 번호 등을 기반으로 서버 트래픽을 분산(로드밸런싱)한다.
L7 스위치 (방화벽, 로드밸런서 기능 포함): 응용 계층(7계층)에서 작동하며, HTTP 헤더, URL, 쿠키 등 애플리케이션의 내용까지 분석하여 트래픽을 제어하거나 분산한다. 방화벽이나 웹 가속기 역할도 한다.

-----------------------------------------------------------------------------------------------------------------------------------------------


📝 릴리즈 노트 작성 항목 중 문서 이름(릴리스 노트 이름), 제품 이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등을 기술하는 작성 항목은?
답: 헤더(Header)

알잘딱깔센 설명:
릴리즈 노트는 소프트웨어나 시스템의 새 버전이 나올 때, 사용자나 개발자들한테 "야, 이번에 뭐가 바뀌었는지 알려줄게!" 하고 써주는 문서다. 변경된 내용, 버그 고친 거, 개선된 점 같은 걸 적어놓는다 이 말이야.

그 문서의 맨 위에 들어가는 기본 정보들이 바로 **헤더(Header)**다.
문서 이름, 제품 이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 같은 문서의 메타데이터가 여기에 다 들어간다. 사람으로 치면 이름, 생년월일 같은 신분증 정보라고 보면 된다.
헤더 외에는 변경사항(Change Log), 알려진 문제(Known Issues), 설치 방법 같은 내용들이 이어진다.

-----------------------------------------------------------------------------------------------------------------------------------------------

📊 데이터 마이닝의 개념을 간략히 서술하시오
답: 대규모 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 것

알잘딱깔센 설명:
**데이터 마이닝(Data Mining)**은 말 그대로 '데이터 광산'에서 '정보 보물'을 캐내는 기술이다. 존나게 쌓여있는 대규모 데이터 안에서 숨겨져 있는 유의미한 패턴, 규칙, 추세 등을 자동으로 찾아내는 것이다. 
이걸로 뭘 하냐고? 고객 행동 예측해서 마케팅 전략 짜거나, 사기 탐지하거나, 질병 예측 같은 거 하는 데 써먹는다. 데이터에서 가치 있는 정보를 뽑아내서 의사결정에 도움을 주는 기술이다 이 말이야.

📚 데이터 관련 개념 (세트로 알아두면 좋다)
데이터 웨어하우스 (Data Warehouse): 기업 전반에 걸쳐 흩어져 있는 데이터를 한곳에 모아놓은 대규모 중앙 집중식 데이터 저장소다.
                                                얘는 주로 분석용으로 쓰기 좋게 통합된 형태로 관리된다. 기업의 모든 데이터를 모아놓은 거대한 창고라고 보면 된다.
데이터 마트 (Data Mart): 특정 부서나 특정 목적을 위한 소규모 데이터 저장소다. 데이터 웨어하우스에서 필요한 부분만 뽑아와서 만든다. 예를 들어, '영업 부서용 데이터 마트', '마케팅 부서용 데이터 마트' 같은 식이다.
OLAP (Online Analytical Processing): 다차원 데이터베이스 시스템에서 복잡한 분석 및 조회를 쉽게 할 수 있도록 하는 기술이다. 데이터를 여러 관점(차원)에서 쪼개고 분석해서 통찰력을 얻는 데 사용된다. 
                                     "작년 분기별 지역별 매출 추이" 같은 복잡한 쿼리를 빠르게 처리하는 데 특화돼 있다.
데이터 마이닝은 이러한 데이터 저장소(데이터 웨어하우스, 데이터 마트 등)에 쌓인 방대한 데이터에서 숨겨진 유의미한 패턴이나 규칙을 자동으로 발견해서 예측하고 의사결정에 활용하는 기술인 거다.

-----------------------------------------------------------------------------------------------------------------------------------------------


🔑 1990년 R.Rivert가 MD4를 일방향 해시 함수로 개선한 알고리즘으로 임의의 길이의 값을 입력받아서 128비트 길이의 해시값을 출력하는 알고리즘은 무엇인가
답: MD5

알잘딱깔센 설명:
**MD5(Message-Digest Algorithm 5)**는 **임의의 길이의 입력 데이터를 받아서 128비트(고정된 길이)의 해시값(메시지 다이제스트)을 출력하는 '일방향 해시 함수'**다.
일방향 해시 함수라는 건, 해시값만 가지고는 원래의 데이터를 절대로 복원할 수 없다는 특징을 가진다는 거다.
원래는 파일의 무결성(데이터가 변조되지 않았는지)을 검사하거나, 비밀번호를 저장할 때 암호화 용도로 많이 썼다.
하지만 지금은 **'충돌 취약점'**이 발견되어서(다른 입력값이 같은 해시값을 생성할 가능성) 보안이 중요한 용도로는 잘 사용되지 않는다.
요즘은 SHA-256 같은 더 튼튼한 해시 알고리즘을 쓴다.

🔐 암호화 알고리즘 종류 (중요하니까 봐라)
대칭키 알고리즘 (비밀키 알고리즘): 암호화할 때랑 복호화할 때 똑같은 키를 사용한다. 키를 주고받는 게 좀 문제지만, 대량의 데이터를 존나 빠르게 암호화할 수 있다는 장점이 있다.

예시: DES, AES, ARIA, SEED, IDEA, LEA, JKIPJACK (이름 정도는 눈에 익혀둬라)

비대칭키 알고리즘 (공개키 알고리즘): 암호화할 때 쓰는 **'공개키'**랑 복호화할 때 쓰는 **'개인키'**가 서로 다르다. 키 분배 문제가 없고 보안성이 존나 높지만, 속도가 느리고 키 길이가 존나 길다.
소인수 분해 기반: RSA, Rabin
이산대수 기반: Diffie-Hellman, DSA, ElGamal
타원곡선 기반: ECC (요즘 많이 쓴다)
해시 알고리즘 (단방향 해시 함수): 원본 데이터를 고정된 길이의 해시값으로 변환하는데, 원본을 복원할 수는 없다. 주로 데이터 무결성 검증이나 비밀번호 저장에 쓰인다.
예시: SHA 계열(SHA-256, SHA-512 등), MD5, HAS-160

🛡️ 해시 알고리즘의 취약점과 대응 (방어법은 알아둬야지)
레인보우 테이블 공격: 미리 계산된 존나 많은 해시값과 그에 해당하는 원본 값 쌍을 저장해둔 테이블을 이용해서 비밀번호를 찾아내는 공격이다. 
이걸 막으려면 솔팅(Salting)으로 대응한다. (패스워드에 임의의 '소금(Salt)' 값을 덧붙여서 해시값을 계산하는 방식. 똑같은 비밀번호라도 솔트 값 때문에 해시값이 달라진다.)

무차별 대입 공격 (Brute-force Attack): 가능한 모든 문자 조합을 하나씩 다 시도해서 비밀번호를 찾아내는 공격이다. 이걸 막으려면 키 스트레칭(Key Stretching)으로 대응한다. (해시 연산을 수만, 수십만 번 반복해서 해시값을 계산하는 데 시간이 존나 오래 걸리게 만드는 방식이다.)

📈 해시 함수의 주요 특성 (꼭 기억해라, 기본적인 성질이다)
역상 저항성 (Preimage resistance): 해시값만으로는 원래의 입력 데이터를 찾아내기가 존나 어려워야 한다.
제2 역상 저항성 (Second preimage resistance): 원본 데이터가 주어졌을 때, 같은 해시값을 가지는 '다른' 입력 데이터를 찾아내기가 존나 어려워야 한다.
충돌 저항성 (Collision resistance): 서로 다른 두 개의 입력 데이터가 '같은' 해시값을 가지는 경우를 찾아내기가 존나 어려워야 한다. (MD5의 취약점이 바로 이 부분이다.)

📏 LOC 기법으로 개발 소요 기간 구하기
LOC기법에 의해 예측된 총라인수가 30,000라인일 경우 개발에 투입될 프로그래머 수가 5명이고, 프로그래머들의 평균 생산성이 월당 300라인일 때, 개발에 소요되는 기간을 구하는 계산식과 기간을 구하여 쓰시오

답:
계산식: 30000
div300
div5=20
text(개월)
개발 소요 기간: 20개월

알잘딱깔센 설명:
LOC(Line of Code) 기법은 개발할 소프트웨어의 코드 라인 수를 기준으로 개발 비용이나 기간을 대충 산정하는 방법이다. 말 그대로 '코드 라인'으로 때려 맞추는 거지. 이 문제는 그냥 산수 문제다.

총 필요한 코드 라인 수: 30,000 라인

프로그래머 1인당 한 달에 생산하는 코드 라인: 300 라인

총 투입될 프로그래머 수: 5명

계산식은 이렇게 된다:

총 라인 수÷(프로그래머 1인당 월 생산성×투입 프로그래머 수)=개발 소요 기간
30,000 라인÷(300 라인/월×5명)=30,000÷1500=20개월

존나 쉽지? 현실은 시궁창이라 이렇게 딱 떨어지는 경우가 잘 없긴 하지만, 이론은 이렇다 이 말이야.

🗓️ 일정 산정 기법 (이것도 중요하니까 봐라)
WBS (Work Breakdown Structure): 프로젝트의 모든 작업을 계층적으로 잘게 쪼개서 구조화하는 거다. 마치 나무처럼 큰 줄기에서 잔가지로 뻗어 나가는 식이다.

PERT/CPM (Program Evaluation and Review Technique / Critical Path Method): 프로젝트의 각 작업들이 서로 어떻게 연결되어 있고, 각 작업에 얼마나 시간이 걸리는지 파악해서 가장 긴 시간이 걸리는 경로(임계 경로)를 찾아낸다. 이걸로 전체 프로젝트 기간을 예측하고, 어떤 작업이 늦어지면 프로젝트 전체가 늦어지는지 파악할 수 있다.

간트 차트 (Gantt Chart): 막대 그래프 형태로 각 작업의 시작일, 종료일, 기간을 시각적으로 보여주는 일정 관리 도구다. 프로젝트 진행 상황을 한눈에 파악하기 좋다.

💰 비용 산정 기법 (LOC 말고 다른 것도 있다)
상향식 산정: 가장 작은 단위 작업부터 비용을 하나하나 산정한 다음, 그걸 다 합쳐서 전체 프로젝트 비용을 구하는 방식이다. LOC 기법이 대표적인 상향식 산정 기법이다.
하향식 산정: 전체 시스템의 규모나 복잡도를 먼저 파악하고, 그걸 기준으로 대략적인 전체 비용을 먼저 산정하는 방식이다. (예: 전문가 판단, 델파이 기법)
수학적 모델: 과거 프로젝트 데이터나 경험을 바탕으로 미리 만들어진 **수학적 공식(모델)**을 사용해서 비용을 예측한다. (예: COCOMO 모델, Putnam 모델, Function Point(FP) 기법 등)

📜 버블 정렬 예제 코드 및 해설


✅ 코드

C

#include <stdio.h> // 표준 입출력 함수를 사용하기 위한 헤더 파일 포함

int main() {
    int a[] = {95, 75, 85, 100, 50}; // 정수 배열 a를 초기화한다.
    int i, j, temp; // 반복문 변수 i, j와 값 교환을 위한 임시 변수 temp 선언
    // int n = sizeof(a)/sizeof(int); // 배열의 실제 크기를 계산하는 방법이지만,
    int n = 5; // 이 문제에서는 배열의 크기를 5로 고정했다.

    // 바깥쪽 for문: 총 n-1번의 '회전'을 수행한다.
    // 각 회전마다 가장 큰(또는 작은) 값이 배열의 끝으로 이동하여 정렬된다.
    for (i = 0; i < n - 1; i++) {
        // 안쪽 for문: 현재 회전에서 비교할 범위다.
        // 이미 정렬이 완료된 뒷부분은 비교할 필요가 없으므로 (n-1)-i 만큼 비교 범위가 줄어든다.
        for (j = 0; j < (n - 1) - i; j++) {
            // 인접한 두 원소 a[j]와 a[j+1]을 비교한다.
            if (a[j] > a[j + 1]) { // 앞의 숫자가 뒤의 숫자보다 크면 (오름차순 정렬 기준)
                // 두 원소의 자리를 바꾼다 (Swap).
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }

    // 정렬이 완료된 배열의 모든 원소를 출력한다.
    for (i = 0; i < 5; i++) {
        printf("%d", a[i]); // 숫자를 붙여서 출력한다. (예: 5075)
    }

    return 0; // 프로그램 정상 종료
}


🔍 해설
이 코드는 a 배열에 있는 숫자들을 버블 정렬(Bubble Sort) 방식으로 오름차순 정렬하는 프로그램이다.
초기 배열 상태: {95, 75, 85, 100, 50}

알잘딱깔센 설명:
버블 정렬은 정렬 알고리즘 중에서 가장 쉽고 직관적이다. 
이름 그대로 물속의 거품(Bubble)이 큰 게 위로 떠오르듯이, 가장 큰(또는 가장 작은) 원소를 옆에 있는 놈이랑 계속 비교해서 배열의 한쪽 끝으로 밀어내는 방식이다.

바깥쪽 for문 (i): 이 루프는 총 몇 번의 '큰 회전'을 수행할지 결정한다. 배열의 크기가 n일 때, n-1번의 회전이 필요하다. 
왜냐? 한 번 회전이 끝날 때마다 가장 큰(또는 작은) 원소가 제자리를 찾아 맨 뒤(또는 앞)에 고정되기 때문이다. 그럼 정렬해야 할 범위가 하나씩 줄어든다.

안쪽 for문 (j): 이 루프는 각 회전마다 실제로 인접한 원소들을 비교하고 교환하는 작업을 한다. 
j번째 원소와 j+1번째 원소를 비교하는데, i가 증가할수록 이미 정렬된 뒷부분은 더 이상 비교할 필요가 없으니 비교 범위가 (n-1) - i로 점점 줄어든다.

if (a[j] > a[j + 1]): 여기가 핵심이다. 만약 앞의 원소(a[j])가 뒤의 원소(a[j+1])보다 크다면 (우리가 오름차순으로 정렬하고 있으니까), 이 둘의 자리를 바꿔준다(Swap). temp라는 임시 변수를 써서 깔끔하게 바꾼다.

정렬 과정 요약 (이걸 눈으로 따라가 보면 이해 팍 온다!)

초기 상태: {95, 75, 85, 100, 50}

1회전 (i=0):

95, 75 비교 -> {75, 95}, 85, 100, 50
95, 85 비교 -> {75, 85, 95}, 100, 50
95, 100 비교 -> {75, 85, 95, 100}, 50
100, 50 비교 -> {75, 85, 95, 50, 100} (가장 큰 100이 맨 뒤로 확정!)

2회전 (i=1): (이제 100은 정렬됐으니 비교 범위에서 제외)

75, 85 비교 -> {75, 85, 95, 50, 100} (변동 없음)
85, 50 비교 -> {75, 50, 85, 95, 100}
85, 95 비교 -> {75, 50, 85, 95, 100} (변동 없음) (두 번째로 큰 95가 그 다음 뒤로 확정!)

3회전 (i=2): (이제 95, 100은 정렬됐으니 비교 범위에서 제외)

75, 50 비교 -> {50, 75, 85, 95, 100}
75, 85 비교 -> {50, 75, 85, 95, 100} (변동 없음) (세 번째로 큰 85가 그 다음 뒤로 확정!)

4회전 (i=3): (이제 85, 95, 100은 정렬됐으니 비교 범위에서 제외)

50, 75 비교 -> {50, 75, 85, 95, 100} (변동 없음) (네 번째로 큰 75가 그 다음 뒤로 확정! 50은 자동으로 맨 앞에 확정!)

✅ 최종 출력 결과: 50758595100

-----------------------------------------------------------------------------------------------------------------------------------------------


☕ Java로 작성된 프로그램이다. 결과를 쓰시오.
✅ 코드
Java

public class Main {

    public static int[] makeArray(int n) { // makeArray 함수 정의: 정수 n을 인자로 받는다.
        int[] t = new int[n]; // n 크기의 정수 배열 t를 새로 만든다. (예: n이 4면, 크기 4짜리 배열 생성)
        for (int i = 0; i < n; i++) { // i는 0부터 n-1까지 1씩 증가하면서 반복한다.
            t[i] = i; // 배열 t의 i번째 칸에 i 값을 저장한다. (예: t[0]=0, t[1]=1, ...)
        }
        return t; // 모든 값을 채운 배열 t를 돌려준다.
    }

    public static void main(String[] args) { // 메인 함수: 프로그램이 여기서부터 시작한다.
        int[] a = makeArray(4); // makeArray(4) 함수를 호출한다. 이 함수가 [0, 1, 2, 3] 배열을 만들어서 반환하면,
                               // 그 배열이 'a'라는 이름의 배열 변수에 저장된다.
        for (int i = 0; i < a.length; i++) // 배열 'a'의 길이(a.length는 4)만큼 반복한다. i는 0, 1, 2, 3이 된다.
            System.out.print(a[i] + ""); // 배열 'a'의 각 요소(a[0], a[1], ...)를 화면에 출력한다.
                                       // System.out.print는 줄 바꿈 없이 내용을 이어서 출력하는 명령어다.
    }
}


알잘딱깔센 설명:
이 자바 코드는 아주 간단한 배열을 만들고 그 내용을 출력하는 예제다. 코딩 초보자들도 한눈에 딱 들어오게 설명해줄게.

makeArray(int n) 메서드: 이 함수는 n이라는 숫자를 받아서 뭘 하냐면, 딱 그 n개의 칸을 가진 정수 배열을 하나 만든다. 그리고 신기하게도, 각 칸에 자기 인덱스(순서) 번호랑 똑같은 숫자를 채워 넣는다.
예를 들어 makeArray(4)를 호출하면 0, 1, 2, 3 이렇게 숫자가 채워진 배열 [0, 1, 2, 3]이 뿅 하고 만들어져서 리턴된다.

main 메서드: 여기가 바로 프로그램의 심장, 시작점이다.

int[] a = makeArray(4); 이 줄에서 우리가 만든 makeArray(4) 함수를 호출한다. 그럼 아까 위에서 설명했듯이 [0, 1, 2, 3] 배열이 만들어져서 a라는 이름의 배열 변수에 쏙 들어간다.

그 다음 for 루프를 봐라. a.length는 배열 a의 크기(칸 개수)를 알려주는데, 지금은 4다. 그러니까 i는 0, 1, 2, 3 이렇게 네 번 돌게 된다.

System.out.print(a[i] + ""); 이 명령어가 실제 출력하는 부분이다. a[i]는 배열 a의 i번째 칸에 있는 값을 말한다. 
System.out.print는 줄 바꿈 없이 내용을 바로 옆에 이어서 출력하는 거다. 그래서 0 출력하고 바로 옆에 1 출력하고… 이런 식이다.

✅ 실행 결과: 0123

-----------------------------------------------------------------------------------------------------------------------------------------------

📘 **문제**  
**문제 20)** 다음은 Java로 작성된 프로그램이다. 실행 결과를 쓰시오.

```java
int i = 3, c = 1; // 변수 i는 3으로, c는 1로 초기화된다.
switch(i){ // switch 문: 변수 i의 값에 따라 실행할 case를 선택한다.
    case 1: c++; // i가 1일 경우, c를 1 증가시킨다. (break 없음에 주의!)
    case 2: c += 3; // i가 2일 경우, c에 3을 더한다. (break 없음에 주의!)
    case 3: c = 0; // i가 3일 경우, c를 0으로 만든다. (여기서부터 실행 시작!)
    case 4: c += 3; // i가 4일 경우, c에 3을 더한다. (break 없음에 주의!)
    case 5: c -= 10; // i가 5일 경우, c에서 10을 뺀다. (break 없음에 주의!)
    default: c--; // 위에 어떤 case도 해당하지 않을 경우, c를 1 감소시킨다.
}
System.out.print(c); // 최종 c의 값을 화면에 출력한다.
🧠 해설

🔹 초기값

java
복사
편집
int i = 3, c = 1;
프로그램이 시작될 때, 변수 i는 3이라는 값을 가지고, 변수 c는 1이라는 값을 가진다.

🔹 switch문 실행 흐름

switch(i): i의 값이 3이므로, switch 문은 case 3: 레이블부터 코드 실행을 시작한다.

case 3: c = 0; → c는 0으로 설정된다.

break 없음 → fall-through 발생

case 4: c += 3; → c = 0 + 3 = 3

break 없음 → fall-through 발생

case 5: c -= 10; → c = 3 - 10 = -7

break 없음 → fall-through 발생

default: c--; → c = -7 - 1 = -8

🔹 최종 출력

java
복사
편집
System.out.print(c);
→ 출력값: -8
