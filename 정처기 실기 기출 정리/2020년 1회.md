💾 **비정규화 (반정규화, 역정규화)**  
**답:** 성능 향상을 위해 정규화 기법을 깨부수는 거다.  


**알잘딱깔센 설명:**  
야, 정규화 이거 좋긴 좋다. 데이터 중복도 줄이고 깔끔하게 관리하게 해주니까.  
근데 말이야, 그거 너무 FM대로 하다 보면 테이블 존나 쪼개져서 조인 연산이 늘어나고, 결과적으로 조회 속도가 떡락하는 수가 있어.  
이럴 때 쓰는 게 바로 비정규화다. 이론적으로는 "야, 이거 정규화 규칙 깼네?" 소리 들을 수 있는데,  
실전에서는 성능 존나게 땡기려고 일부러 데이터 중복도 좀 허용하고 테이블 합치고 하는 기술이다 이 말이야.  
딱 보면 성능 향상에 미친 놈들이 만든 거지.

📝 **데이터베이스 설계 단계 (중요하니까 훑어봐라)**  
- 개념적 설계: 데이터베이스 설계의 첫 단추다. 뭘 저장할지, 얘네들끼리 어떻게 엮여있는지 대충 그림 그리는 단계다. 보통 ERD(Entity Relationship Diagram) 같은 걸로 그려본다.  
- 논리적 설계: 이제 어떤 DBMS(데이터베이스 관리 시스템) 쓸지 정하고, 개념적 설계를 바탕으로 실제로 테이블을 만들 준비를 하는 단계다. 여기서 정규화 작업도 같이 해준다.  
- 물리적 설계: 실제 서버에 데이터를 쑤셔 넣을 준비하는 최종 단계다. 성능을 극대화하려고 파티션, 클러스터, 인덱스 같은 걸 설계하고 배치한다.

🪜 **정규화 단계 (이거 다 외우면 네가 독하다!)**  
- 1정규형 (1NF): 데이터 필드에 원자값(Atomic Value), 즉 더 이상 쪼갤 수 없는 값만 넣어라. "이름1,이름2" 이런 거 안 된다는 말이다.  
- 2정규형 (2NF): 부분 함수 종속을 제거해라. 기본키의 일부에만 종속되는 속성은 따로 빼서 테이블을 나눠라 이말이야. 안 그러면 데이터 중복 오진다.  
- 3정규형 (3NF): 이행 함수 종속을 제거해라. 기본키가 아닌 속성이 다른 기본키가 아닌 속성을 결정하는 관계를 없애버리는 거다. 예: 학생 테이블에 학과명, 학과전화번호가 있으면 학과정보는 따로 테이블로 빼는 식.  
- BCNF: 결정자이면서 후보키가 아닌 놈 있으면 다 조져라. 3정규형보다 좀 더 빡센 규칙.  
- 4정규형 (4NF): 다치 종속을 제거해라. 하나의 기본키에 대해 여러 개의 독립적인 다치 종속성이 있으면 따로 테이블로 분리.  
- 5정규형 (5NF): 조인 종속을 제거해라. 조인 연산을 통해서만 복원 가능한 종속성이 있다면 그것도 따로 테이블로 빼버림.

-----------------------------------------------------------------------------------------------------------------------------------------------
## 📜 마크업 언어

**문제)**  
다음 빈칸에 들어갈 알맞은 마크업 언어를 쓰시오.

- () : SGML의 단순화된 부분 집합, 다른 많은 종류의 데이터를 기술하는데 사용할 수 있음.  
- () : 주로 다른 종류 시스템, 인터넷에 연결된 시스템끼리 데이터를 쉽게 주고 받을 수 있게 하여 HTML 한계를 극복할 목적으로 만들어짐  
- () : 텍스트 데이터 형식으로 유니코드 사용해 전세계 언어를 지원함

✅ **정답: XML**

---

### 💬 알잘딱깔센 설명

야, XML(eXtensible Markup Language) 이거 요즘 **데이터 주고받을 때 존나 많이 쓰는 놈**이다.  
원래 **SGML(Standard Generalized Markup Language)**이라는 **복잡한 조상님**이 있었는데,  
그걸 좀 쉽게 만든 거라고 보면 된다.  

데이터의 **구조랑 의미를 표현**하려고 태어난 **텍스트 기반 형식**이다.  
웹페이지 표시에 특화된 HTML이랑 다르게, **XML은 데이터 자체를 기술하고 전송**하는 데 존나게 초점이 맞춰져 있다.

**시스템끼리 데이터 주고받을 때 특히 빛을 발**하고,  
**유니코드 지원**해서 **전 세계 모든 언어** 표현 가능.  
이쯤 되면 글로벌 스타 아니겠노?

---

### 📚 마크업 언어 종류 요약

| 이름 | 설명 |
|------|------|
| **HTML** | 웹 페이지의 뼈대랑 내용 담당. 네가 지금 보고 있는 이 페이지도 HTML로 만들어진 거다. |
| **SGML** | 존나 복잡해서 실생활에서는 잘 안 씀. XML의 할아버지라고 보면 됨. |
| **XML** | SGML을 쉽게 만든 확장형 마크업 언어. 데이터 구조 만들고 주고받을 때 존나 편하다. |
| **JSON** | 키-값 쌍으로 이루어진 경량 데이터 교환 형식. 요즘 XML 대신 많이 쓰는 추세. 더 가볍고 JS랑 궁합이 존나 좋음. |
| **TXT** | 그냥 단순한 텍스트 파일. 메모장 파일이 이거다. |
| **YAML** | 사람에게 읽히기 쉬운 데이터 표현 방식. 설정 파일 같은 데서 자주 보인다. |



-----------------------------------------------------------------------------------------------------------------------------------------------
## 🚫 살충제 패러독스 (Pesticide Paradox)

**✅ 정의**  
동일한 테스트 케이스로 동일한 절차를 반복 수행하면 **새로운 결함을 찾을 수 없다**는 소프트웨어 테스트의 한계.

---

### 💬 알잘딱깔센 설명

이름부터 **살충제 패러독스** 아니노?

농부가 똑같은 살충제만 계속 뿌리면 벌레들이 내성 생겨서 나중엔 끄떡도 안 하잖아?  
**소프트웨어 테스트도 똑같다.**  
맨날 **똑같은 테스트 케이스**랑 **똑같은 절차**만 돌리면, 새로운 버그는 절대 못 찾는다.  
기존 버그는 잡겠지만, **다른 숨은 버그들**은 계속 살아남는다는 말이다.

테스트 케이스를 **주기적으로 업데이트**하고,  
테스트 방법도 **존나게 다양하게 바꿔줘야**  
**새로운 결함을 발견할 수 있다.**

안 그럼 버그들이 너한테 **빅엿을 선물할 거다.**

---

## 💻 소프트웨어 테스트 종류 정리

| 테스트 종류 | 설명 |
|-------------|------|
| **단위 테스트** | 개별 모듈이나 함수 단위로 잘 작동하는지 확인 (개발자가 직접 수행) |
| **정적 테스트** | 코드를 실행하지 않고 리뷰나 분석 도구로 검토 (코드 리뷰, 정적 분석 도구) |
| **동적 테스트** | 코드를 직접 실행해서 기능 이상 여부를 확인 |
| **통합 테스트** | 여러 단위 모듈이 잘 연동되는지 확인. **팀워크 테스트** |
| **하향식 테스트** | 상위 모듈부터 테스트, 하위는 **스텁(Stub)** 으로 대체 |
| **상향식 테스트** | 하위 모듈부터 테스트, 상위는 **드라이버(Driver)** 로 대체 |
| **빅뱅 테스트** | 모든 모듈을 한꺼번에 합쳐서 테스트. 문제 생기면 디버깅 개헬 |
| **시스템 테스트** | 시스템 전체를 사용자 요구사항에 맞춰 최종 점검 |
| **기능 테스트** | 시스템이 기능 요구사항을 잘 수행하는지 검증 |
| **비기능 테스트** | 성능, 보안, 안정성, 사용성 등 기능 외적인 요소 검증 |
| **인수 테스트** | 고객이 직접 테스트해보고 OK 사인 내리는 단계 |
| **알파 테스트** | 개발자가 옆에서 지켜보며 내부 테스트 |
| **베타 테스트** | 실제 사용자 환경에서 개발자 없이 테스트 수행 |

---

## 📈 파레토 법칙 (Pareto Principle)

**80 대 20 법칙**:  
전체 오류의 약 **80%**가 전체 코드의 **20% 핵심 모듈**에서 발생한다.

👉 중요한 모듈을 **더 빡세게 테스트해야 한다** 이말이야.

---

## 🧙‍♂️ 테스트 오라클 (Test Oracle)

테스트 결과가 **맞는지 판단해주는 정답지 역할**을 하는 기준.

| 오라클 종류 | 설명 |
|-------------|------|
| **참 오라클** | 완전하고 정확한 정답지 |
| **샘플 오라클** | 일부 예시 데이터로 결과 판단 |
| **휴리스틱 오라클** | 경험 기반으로 대충 판단 |
| **일관성 검사 오라클** | 여러 번 실행해서 결과가 일관적인지 확인 |



-----------------------------------------------------------------------------------------------------------------------------------------------
## 🖇️ 모듈의 독립성을 판단하는 두 가지 지표

### ✅ 답:
(1) **결합도(Coupling)**  
(2) **응집도(Cohesion)**

---

### 💬 알잘딱깔센 설명

소프트웨어 모듈은 사람으로 치면 '전문가' 같은 존재다.  
자기 일만 잘하고, 남한테 휘둘리지 않아야 **좋은 모듈**이다.

#### 🔹 결합도 (Coupling)
- 모듈과 모듈끼리 얼마나 **서로 얽혀 있는지** 나타내는 지표
- **낮을수록 좋다** → 독립성이 높아짐
- 결합도가 낮으면 한 모듈을 수정해도 다른 모듈에 영향이 적어 유지보수 편함
- 👉 남남이 최고다. 신경 꺼야 덜 싸운다

#### 🔹 응집도 (Cohesion)
- 한 모듈 내부의 구성 요소들이 **얼마나 똘똘 뭉쳐 하나의 목적**을 수행하느냐
- **높을수록 좋다** → 모듈의 기능이 명확하고 일관됨
- 👉 패밀리 으리! 팀워크 만렙이면 모듈 관리도 쉬워진다

---

## 📈 응집도의 종류 (높을수록 좋음)

| 수준 | 설명 |
|------|------|
| 우연적 응집 | 🚫 최악. 관련 없는 기능들이 우연히 모여 있음 |
| 논리적 응집 | 유사한 기능들을 모아놨지만 실제 목적은 다름 |
| 시간적 응집 | 특정 시간대에 같이 실행되는 기능들 모음 |
| 절차적 응집 | 일정한 순서로 수행되는 기능들 모음 |
| 통신적 응집 | 동일한 입력/출력을 사용하는 기능들 모음 |
| 순차적 응집 | 하나의 출력이 다음 기능의 입력으로 연결 |
| 기능적 응집 | ✅ 최고. 오직 하나의 명확한 기능만 수행 |

---

## 📉 결합도의 종류 (낮을수록 좋음)

| 수준 | 설명 |
|------|------|
| 데이터 결합 | ✅ 최고. 단순 데이터(값)만 주고받음 |
| 스탬프 결합 | 구조체나 배열처럼 복합 데이터 전달. 과한 정보 포함 위험 |
| 제어 결합 | 처리 방식까지 전달. 받는 쪽 로직이 외부에 의존 |
| 외부 결합 | 외부 모듈의 데이터 참조. 의존성↑ |
| 공통 결합 | 전역 변수 공유. 누가 뭘 바꿨는지 추적 어렵고 위험함 |
| 내용 결합 | 🚫 최악. 다른 모듈의 내부까지 직접 조작 |

---

## 🔄 재공학 vs 역공학 vs 재사용

| 개념 | 설명 |
|------|------|
| **재공학 (Re-engineering)** | 기존 시스템을 고쳐서 개선하거나 재활용하는 작업 (리모델링 느낌) |
| **역공학 (Reverse Engineering)** | 완성된 코드로부터 설계도나 명세서를 역으로 추출 |
| **재사용 (Reuse)** | 이미 만들어진 모듈을 반복 사용해 개발 시간/비용을 아낌 |

---

### 📌 정리 핵심

- **결합도는 낮게!**
- **응집도는 높게!**
- 이게 바로 **국룰**이자, 유지보수와 품질의 핵심 포인트다.

-----------------------------------------------------------------------------------------------------------------------------------------------
## 📊 Fan-in, Fan-out 수 구하기

---

### ✅ 답:

- **Fan-in**: 해당 모듈을 **호출하는 모듈의 수**
- **Fan-out**: 해당 모듈이 **호출하는 모듈의 수**

---

### 💬 알잘딱깔센 설명

Fan-in과 Fan-out은 **소프트웨어 모듈 간의 관계**를 나타내는 대표적인 지표다.

#### 🔹 Fan-in (들어오는 제어 수)
- 특정 모듈을 **몇 개의 다른 모듈이 호출하는지**를 나타냄
- 📌 Fan-in 값이 높다? → 재사용성이 높고 인기 많은 모듈!
- ✔️ 핵심 기능이나 공통 유틸성 기능일수록 Fan-in 값이 높음
- 🔧 예시: 유효성 검사 모듈, 공통 계산기 모듈

#### 🔹 Fan-out (나가는 제어 수)
- 특정 모듈이 **몇 개의 다른 모듈을 호출하는지**를 나타냄
- 📌 Fan-out 값이 높다? → 다른 모듈에 **많이 의존**하는 모듈!
- ❗ 수정 시 파급효과가 클 수 있으니 신중하게 관리해야 함
- 🔧 예시: 업무 로직을 여러 하위 모듈로 분산 호출하는 메인 로직 모듈

---

### 📌 Fan-in / Fan-out 시각적 비유

```text
        [ M1 ] <--- Fan-in (3개 모듈이 호출)
        [ M2 ]
        [ M3 ]

        [ A ] ---> [ B ] ---> [ C ] ---> [ D ]
                    ↑               ↑
                   Fan-out(2)    Fan-in(1)

📈 개발 설계에서의 활용 팁
Fan-in은 높을수록 재사용성이 높고, 설계가 잘 되어 있는 모듈임을 나타냄

Fan-out은 낮을수록 좋음, 지나친 의존성은 유지보수 시 복잡도를 증가시킴

소프트웨어 품질을 고려할 때 Fan-in은 증가, Fan-out은 감소하는 방향이 바람직함

🧠 정리 한 줄 요약
Fan-in은 인기도, Fan-out은 의존도다.

-----------------------------------------------------------------------------------------------------------------------------------------------

## 🌐 JavaScript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷

---

### ✅ 답: JSON

---

### 💬 알잘딱깔센 설명

요즘 웹에서 데이터 주고받을 때 **XML을 대체하는 슈퍼스타**, 바로 **JSON (JavaScript Object Notation)** 이다.

- JavaScript 객체 문법을 기반으로 한 **문자 기반의 데이터 표현 형식**
- 사람과 기계 모두 **읽기 쉽고 이해하기 쉬움**
- **용량이 작고, 처리 속도가 빠름**
- 주로 **웹 API, 프론트-백엔드 간 데이터 통신, 모바일 앱 등**에서 자주 사용됨

```json
{
  "이름": "홍길동",
  "나이": 30,
  "주소": "서울특별시"
}
위처럼 { "key": "value" } 형태로 표현됨

데이터는 "이름-값 쌍(key-value pair)" 으로 구성됨

프로그래밍 문법은 아님, 단순히 데이터를 표현하는 방식임

📌 JSON의 장점
✔️ 사람도 읽기 쉬운 구조 (가독성 GOOD)

✔️ XML보다 간결한 표현

✔️ 다양한 언어에서 파싱이 쉬움

✔️ JavaScript와 궁합이 매우 좋음 (원래 JS 객체 문법이니까)

📚 관련 개념 (같은 듯 다른 것들 정리)
용어	설명
JSON	데이터를 표현하는 단순한 포맷. { "key": "value" } 형식
XML	태그 기반 데이터 표현. 무겁고 복잡
API	기능을 외부에 공개하는 '문 열어주는 설명서'. 시스템 간 인터페이스
라이브러리	네가 직접 불러서 사용하는 '기능 묶음'
프레임워크	이미 짜여진 틀 속에서 네 코드를 넣어 쓰는 구조. 규칙이 더 엄격

🔁 XML vs JSON 비교
항목	XML	JSON
문법	태그 기반	객체 기반
용량	큼	작음
가독성	낮음	높음
파싱 속도	느림	빠름
주 사용처	과거의 웹, 문서 중심 통신	현대 웹, 모바일 앱, REST API 등

🧠 한 줄 요약
JSON은 웹 시대의 데이터 운반책, 간단하고 빠르고 가볍다. 이제 XML은 빠이✋
-----------------------------------------------------------------------------------------------------------------------------------------------

## 📈 애플리케이션 성능 측정을 위한 지표 정리

---

### ✅ 답
- (1): **처리량 (Throughput)**
- (2): **응답시간 (Response Time)**
- (3): **반환시간 (Turn Around Time)**

---

### 💬 알잘딱깔센 설명

앱이나 시스템이 얼마나 빠르고 효율적으로 돌아가는지를 측정할 때 사용하는 핵심 지표들이다. 아래 설명 잘 봐라, 면접에서도 자주 나오는 주제다.

---

### (1) 처리량 (Throughput)
- 의미: **단위 시간당 처리되는 작업량**
- 예시: 초당 100개의 요청 처리 → 처리량 = 100 TPS(Transaction per Second)
- 특징: **숫자 클수록 좋다**. 서버가 많은 요청을 얼마나 감당할 수 있는지를 보여준다.
- 비유: 음식점에서 1시간에 몇 명 손님을 받을 수 있는가?

---

### (2) 응답시간 (Response Time)
- 의미: **요청을 보낸 시점부터 첫 응답이 도착할 때까지 걸리는 시간**
- 특징: **사용자가 체감하는 지연시간**이다. 이게 짧을수록 UX가 좋다.
- 비유: 음식점에서 주문했을 때, 서빙이 내 테이블까지 오는데 걸리는 시간

---

### (3) 반환시간 (Turn Around Time)
- 의미: **요청을 보낸 시점부터 작업이 완전히 끝날 때까지 걸린 전체 시간**
- 특징: 내부 처리시간까지 모두 포함된다.
- 비유: 음식점에서 주문부터 음식 다 먹고 계산까지 완료되기까지 걸리는 시간

---

### 🔧 자원 사용률 (Resource Utilization)
- 정의: **CPU, 메모리, 디스크 I/O, 네트워크 등 자원을 얼마나 사용하는가**
- 의미: 자원이 **과도하게 사용되면** 성능 저하의 원인이 될 수 있다
- 비유: 음식점에서 주방이 얼마나 바쁜가, 종업원이 몇 명인가, 좌석 점유율은 얼마나 되는가 등

---

### 📊 성능 지표 요약 표

| 지표 | 설명 | 핵심 포인트 |
|------|------|--------------|
| 처리량 (Throughput) | 일정 시간 동안 처리한 작업 수 | **많을수록 좋음** |
| 응답시간 (Response Time) | 요청 → 첫 응답까지 걸린 시간 | **짧을수록 좋음** |
| 반환시간 (Turn Around Time) | 요청 → 작업 완료까지 걸린 전체 시간 | **짧을수록 좋음** |
| 자원 사용률 | CPU, 메모리 등 시스템 리소스 사용량 | **과도하면 문제** |

---

### 🧠 성능 최적화 팁

- 응답시간을 줄이기 위해 캐싱 도입, 로직 개선
- 처리량을 높이기 위해 병렬 처리, 로드 밸런싱 적용
- 반환시간 단축을 위해 비동기 처리, 작업 분할 적용
- 자원 사용률을 모니터링하고 병목 구간 제거

---

### 🔁 참고용 용어 비교

| 용어 | 관점 | 예시 |
|------|------|------|
| 처리량 | 시스템 입장에서 얼마나 처리했냐 | 초당 100건 |
| 응답시간 | 사용자 입장에서 얼마나 기다렸냐 | 0.3초 |
| 반환시간 | 전체 흐름이 얼마나 걸렸냐 | 1분 30초 |

---

> 결국 성능은 숫자로 말한다. 응답시간 빠르고 처리량 높고 자원 적게 쓰면 최고다. 🎯


-----------------------------------------------------------------------------------------------------------------------------------------------

## 🔢 학생(STUDENT) 테이블 튜플 수 구하기 문제

---

### 문제  
학생(STUDENT) 테이블에 전자과 50명, 전기과 100명, 건축과 50명 정보가 저장되어 있을 때 튜플 수를 쓰시오  
(DEPT 컬럼은 학과명)

---

### 쿼리와 답변

| 쿼리 | 설명 | 결과(튜플 수) |
|-------|-------|---------------|
| (1) `SELECT DEPT FROM STUDENT;` | DEPT 컬럼 전체 데이터 모두 출력 (중복 포함) | 200 |
| (2) `SELECT DISTINCT DEPT FROM STUDENT;` | DEPT 컬럼의 중복 제거 후 유일한 값만 출력 | 3 |
| (3) `SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = '건축과';` | 건축과 학생들 중 DEPT의 중복 제거 후 개수 카운트 | 1 |

---

### 💬 알잘딱깔센 설명

- STUDENT 테이블에 총 학생 수는  
  전자과 50명 + 전기과 100명 + 건축과 50명 = **200명**  
- 튜플은 테이블의 **한 행(row)** 을 의미한다.  
- (1)번 쿼리는 DEPT 컬럼의 모든 값(중복 포함)을 가져오므로 200개의 행이 반환된다.  
- (2)번 쿼리는 중복을 제거하고 유일한 학과명만 가져오므로 전자과, 전기과, 건축과 3개가 나온다.  
- (3)번 쿼리는 '건축과' 학생만 필터링 후 DISTINCT로 중복된 학과명을 제거하고 카운트하므로 항상 1이 나온다.


-----------------------------------------------------------------------------------------------------------------------------------------------

## 💣 네트워크 공격 유형

---

### 문제  
출발지 IP와 목적지 IP가 같은 패킷을 만들어 보내는 공격  
수신자가 응답을 보낼 때 목적지 주소가 자기 자신이므로 SYN 신호가 계속 자신의 서버를 돌게 되어 서버의 자원을 고갈시켜 가용성을 파괴한다  
방화벽에서 출발지와 목적지가 같은 패킷은 모두 제거하여 대응

---

### 답  
**Land attack**

---

### 💬 알잘딱깔센 설명  
**Land Attack(랜드 어택)**은 IP 헤더의 출발지 IP 주소와 목적지 IP 주소를 똑같이 설정하여 공격하는 악질적인 네트워크 공격이다.  

이 패킷을 받은 서버는 응답을 자기 자신에게 보내게 되면서 무한 루프가 발생한다.  
서버 자원(CPU, 메모리, 네트워크 대역폭)이 소진되어 결국 서비스 거부(DoS) 상태에 빠진다.

**대응 방법**은 방화벽이나 라우터에서 출발지와 목적지 IP가 같은 패킷을 발견 즉시 차단하는 것이다.

---

### 💥 서비스 거부 공격 (DoS, Denial of Service) 유형  
- **DoS**: 자원 고갈 또는 대역폭 고갈로 정상 서비스 방해  
- **Smurf Attack**: IP 브로드캐스트 + ICMP를 이용한 대량 응답 폭주  
- **SYN flooding**: 연결 요청 패킷 폭주로 서버 연결 큐 포화  
- **UDP 플러딩**: UDP 패킷 대량 전송으로 자원 고갈  
- **Ping 플러딩**: Ping 패킷 폭주로 네트워크 소모  
- **Ping of Death**: 과도하게 큰 Ping 패킷으로 버퍼 오버플로우 유발  
- **Teardrop Attack**: 재조립 불가능한 IP 패킷 조각 전송으로 시스템 다운  

---

-----------------------------------------------------------------------------------------------------------------------------------------------

🗣️ 통신 프로토콜의 기본 요소 3가지  
통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고받는 양식과 규칙의 체계이다. 통신 프로토콜의 기본 요소 3가지를 쓰시오.

답:  
- 구문(Syntax)  
- 타이밍(Timing)  
- 의미(Semantic)  

알잘딱깔센 설명:  
야, 컴퓨터랑 통신 장비들이 서로 말 제대로 하려면 약속된 룰이 꼭 필요하다. 그게 바로 통신 프로토콜인데, 이게 잘 작동하려면 기본적으로 세 가지 요소가 있어야 해.

1. **구문(Syntax)**: 메시지가 어떻게 생겨야 하는지, 데이터가 어떤 순서와 형태로 와야 하는지를 정하는 규칙이다.  
   예를 들어, 사람이 말할 때 문장 구조나 단어 순서 같은 거라 보면 돼. "이렇게 말해야 알아듣는다"는 걸 정하는 거지.

2. **타이밍(Timing)**: 언제, 얼마나 빠르게 메시지를 주고받을지 정하는 규칙이다.  
   말하자면, "네가 말 끝날 때까지 기다려라", "1초 안에 대답해라" 같은 시간 약속 같은 거야. 타이밍 안 맞으면 소통 안 된다.

3. **의미(Semantic)**: 메시지가 어떤 뜻인지, 신호가 무슨 행동을 의미하는지 정하는 규칙이다.  
   예컨대, "안녕"이 단순 인사인지, 친근함인지, 경고인지 명확하게 정하는 거야. 그래야 헷갈리지 않고 제대로 반응하지.

이 세 가지만 잘 맞춰져도 컴퓨터끼리 헷갈리지 않고 척척 데이터 주고받을 수 있다는 얘기야.  


-----------------------------------------------------------------------------------------------------------------------------------------------

⏱️ HRN(Highest Response-ratio Next) 우선 순위를 결정하는 계산식

답:  
(대기시간 + 서비스시간) / 서비스시간



알잘딱깔센 설명:  
**HRN(Highest Response-ratio Next)**은 프로세스 스케줄링 기법 중 하나인데, 다른 놈들이랑 다르게 존나 똑똑하게 우선순위를 매긴다.  
그냥 대기 시간만 보거나 짧은 작업만 보는 게 아니라, 대기 시간과 앞으로 처리할 시간(서비스 시간)을 모두 고려해서 우선순위 비율을 계산한다.  

이 공식을 보면 알겠지만, 기다리는 시간이 길어질수록, 또는 서비스 시간이 짧을수록 우선순위가 높아진다.  

이런 식으로 계산하면 기아 현상(Starvation), 즉 특정 프로세스가 계속 뒤로 밀려서 영원히 실행되지 못하는 좆같은 상황을 효과적으로 방지할 수 있다. 똑똑하지 않노?  

🏃‍♂️ 프로세스 스케줄링 종류 (나눠서 봐라, 시험에 자주 나온다!)  
- **선점 스케줄링**: 현재 실행 중인 프로세스를 강제로 중단시키고 다른 프로세스를 실행할 수 있는 방식이다. 긴급한 작업이 들어오면 하던 거 잠시 멈추고 걔부터 처리하는 거다.  
  - SRT (Shortest Remaining Time first): 남은 실행 시간이 가장 짧은 프로세스에게 CPU를 할당한다.  
  - RR (Round Robin): 각 프로세스에게 정해진 시간 할당량(Time Slice)을 주고, 이 시간이 지나면 다음 프로세스로 CPU를 넘겨주는 순환 방식이다.  
  - MLQ (Multi-Level Queue): 여러 개의 준비 큐를 사용하고, 각 큐마다 다른 스케줄링 방식을 적용한다. 큐 사이의 이동은 불가능하다.  
  - MFQ (Multi-Level Feedback Queue): MLQ와 비슷하지만, 프로세스가 큐 사이를 이동할 수 있게 해서 유연성을 높인다. (기아 현상 방지에 좋음)  

- **비선점 스케줄링**: 한번 실행된 프로세스는 스스로 종료되거나 대기 상태로 전환될 때까지 CPU를 계속 점유하는 방식이다. 중간에 빼앗기지 않는다.  
  - FCFS (First Come First Served): 먼저 온 놈이 먼저 처리된다. 선착순이다.  
  - SJF (Shortest Job First): 실행 시간이 가장 짧은 프로세스부터 처리한다. 최단 시간을 보장하지만, 긴 작업은 기아 현상에 빠질 수 있다.  
  - HRN (Highest Response-ratio Next): 이 문제의 주인공이다. 대기 시간과 서비스 시간을 고려해서 우선순위를 결정한다.  

- **기타 스케줄링**  
  - 기한부 스케줄링: 정해진 기한(Deadline) 내에 완료되어야 하는 프로세스에게 우선순위를 준다.  
  - 우선순위 스케줄링: 각 프로세스에 부여된 우선순위에 따라 처리한다. (우선순위가 낮은 프로세스는 기아 현상에 빠질 수 있음)  

👴 기아 현상 (Starvation) & 에이징 (Aging)  
- 기아 현상(Starvation): 특정 프로세스가 너무 낮은 우선순위 때문에 계속 뒤로 밀리거나, CPU를 할당받지 못해서 무한정 기다리는 현상이다.
                                  (SJF, 우선순위 스케줄링, SRT, MLQ에서 발생하기 쉽다.)  
- 에이징(Aging): 기아 현상을 방지하기 위한 기법 중 하나다. 프로세스가 CPU를 기다리는 시간이 길어질수록, 그 프로세스의 우선순위를 점진적으로 높여준다.
                   (MFQ, HRN에서 적용하는 방식이다.)  



-----------------------------------------------------------------------------------------------------------------------------------------------
🔒 트랜잭션 주요 특성 4가지 (ACID)

답:  
(1) 원자성(Atomicity)  
(2) 격리성(Isolation)  

알잘딱깔센 설명:  
트랜잭션은 데이터베이스에서 데이터 무결성과 신뢰성을 보장하는 핵심 개념이다.  
돈 거래를 생각해봐라. 돈이 한 계좌에서 빠져나가고 다른 계좌에 입금되어야 거래가 완성된다.  
만약 중간에 돈만 빠져나가고 입금이 안 되면? 완전 꼬이는 거다. 이때 ACID 원칙이 데이터 꼬임을 막아준다.  

- **A (Atomicity, 원자성)**:  
  트랜잭션 내 모든 작업은 하나의 단위처럼 완전 실행되거나 전혀 실행되지 않아야 한다.  
  즉, "All or Nothing!" 이게 핵심이다. 실패 시 처음 상태로 롤백한다.  

- **C (Consistency, 일관성)**:  
  트랜잭션 완료 후에도 데이터베이스 상태가 항상 일관되고 유효해야 한다.  
  데이터베이스 규칙(제약 조건)을 위반하면 안 된다.  

- **I (Isolation, 격리성)**:  
  여러 트랜잭션이 동시에 실행될 때 서로 간섭 없이 독립적으로 실행되는 것처럼 보여야 한다.  
  미완료 트랜잭션의 중간 결과를 다른 트랜잭션이 볼 수 없다. 각자 자기 일만 하는 상태.  

- **D (Durability, 영속성)**:  
  트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 반영된다.  
  시스템 오류가 발생해도 결과는 손실되지 않고 유지된다.  

-----------------------------------------------------------------------------------------------------------------------------------------------

📡 OSI 7 참고 모델 중 다음 설명하는 계층은?

답: 물리계층 (Physical Layer)

알잘딱깔센 설명:  
OSI 7계층 모델은 네트워크 통신을 7단계로 나눈 표준 모델인데, 문제에서 설명하는 계층은 맨 밑바닥인 1계층, 물리계층이다.  
이 계층은 통신 케이블, 무선 등 물리 매체를 통해 데이터를 전기적 신호로 변환해 전송하는 역할을 맡는다.

- 전기적, 기계적, 기능적인 특성을 이용해 비트 단위 데이터를 전달한다.  
- 통신 단위는 비트(Bit)이며, 1과 0으로 표현되는 전기적 on/off 신호를 주고받는다.  
- 데이터 내용이나 에러 여부는 전혀 신경 쓰지 않는다. 그냥 ‘비트를 전기 신호로 바꿔서 무조건 보내기’가 임무다.  
- NIC(Network Interface Card), 허브, 리피터 등이 이 계층에서 작동한다.  

OSI 7계층 간단 요약 (아래부터 위로 올라가며 역할 구분 필수!):  
7. 응용 계층: 사용자 프로그램과 네트워크 연결 (HTTP, FTP 등)  
6. 표현 계층: 데이터 인코딩, 압축, 암호화  
5. 세션 계층: 세션 설정 및 관리  
4. 전송 계층: 신뢰성 있는 데이터 전송 (TCP, UDP)  
3. 네트워크 계층: 라우팅 및 IP 주소 사용 (라우터)  
2. 데이터 링크 계층: 인접 노드 간 신뢰성 전송, MAC 주소 사용 (스위치, 브릿지)  
1. 물리 계층: 비트 단위 데이터 전송, 전기 신호 변환 (NIC, 허브, 리피터)  

📡 스위치 종류 참고:  
- L2 스위치: 데이터 링크 계층에서 MAC 주소 기반 전달  
- L3 스위치: 네트워크 계층에서 IP 기반 라우팅  
- L4 스위치: 전송 계층에서 포트 번호 기반 로드밸런싱  
- L7 스위치: 응용 계층에서 HTTP 헤더 등 분석해 제어/분산 (방화벽, 웹 가속기 역할)  
-----------------------------------------------------------------------------------------------------------------------------------------------

📝 릴리즈 노트 작성 항목 중 문서 이름(릴리스 노트 이름), 제품 이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등을 기술하는 작성 항목은?

답: 헤더(Header)

알잘딱깔센 설명:  
릴리즈 노트는 소프트웨어나 시스템 새 버전이 나왔을 때, 사용자나 개발자에게 “이번에 뭐가 바뀌었는지 알려줄게!”라고 알려주는 문서다.  
버그 수정, 개선 사항, 새 기능 같은 내용을 기록한다.

이 문서에서 맨 위에 위치하는 기본 정보들을 **헤더(Header)**라고 한다.  
헤더에는 문서 이름, 제품 이름, 버전 번호, 릴리즈 날짜, 참고 날짜, 노트 버전 등 문서의 ‘신분증’ 같은 메타데이터가 들어간다.  
이후에는 변경사항(Change Log), 알려진 문제(Known Issues), 설치 방법 등 세부 내용이 나온다.

쉽게 말해, 릴리즈 노트의 ‘이름표’ 역할을 하는 부분이다.

-----------------------------------------------------------------------------------------------------------------------------------------------
📊 데이터 마이닝의 개념을 간략히 서술하시오

답: 대규모 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 것

알잘딱깔센 설명:  
**데이터 마이닝(Data Mining)**은 말 그대로 '데이터 광산'에서 '정보 보물'을 캐내는 기술이다.  
엄청 쌓여있는 대규모 데이터에서 숨겨진 유의미한 패턴, 규칙, 추세 등을 자동으로 찾아낸다.  

이걸로 뭘 하냐면, 고객 행동 예측해서 마케팅 전략 짜거나, 사기 탐지, 질병 예측 등 가치 있는 의사결정을 돕는다.  
데이터에서 보석 같은 정보를 뽑아내는 과정이라고 보면 된다.

📚 데이터 관련 개념 (함께 알면 좋은 세트)  
- **데이터 웨어하우스(Data Warehouse)**: 기업 전반의 데이터를 한곳에 모아놓은 거대한 중앙 집중식 저장소.  
  분석 용도로 통합·관리한다.  
- **데이터 마트(Data Mart)**: 특정 부서나 목적을 위해 데이터 웨어하우스에서 일부만 뽑아 만든 소규모 저장소.  
- **OLAP(Online Analytical Processing)**: 다차원 데이터베이스에서 복잡한 조회·분석을 빠르고 쉽게 처리하는 기술.  
  예: “작년 분기별 지역별 매출 추이” 같은 분석.

데이터 마이닝은 이렇게 쌓인 방대한 데이터에서 규칙과 패턴을 찾아내서,  
예측 및 의사결정에 활용하는 똑똑한 기술이다.


-----------------------------------------------------------------------------------------------------------------------------------------------


🔑 1990년 R.Rivert가 MD4를 일방향 해시 함수로 개선한 알고리즘으로 임의의 길이의 값을 입력받아서 128비트 길이의 해시값을 출력하는 알고리즘은 무엇인가

답: MD5

알잘딱깔센 설명:  
**MD5(Message-Digest Algorithm 5)**는 임의 길이의 입력 데이터를 받아서 128비트(고정 길이) 해시값을 출력하는 ‘일방향 해시 함수’다.  
일방향 해시 함수란, 해시값만 보고는 원래 데이터를 절대 복원할 수 없는 특징이 있다.  
원래는 파일 무결성 검사나 비밀번호 저장 같은 암호화 목적으로 많이 썼는데, 지금은 충돌 취약점이 발견돼 보안용으론 잘 안 쓴다.  
요즘은 SHA-256 같은 더 튼튼한 해시 알고리즘을 쓴다.

🔐 암호화 알고리즘 종류 (중요!)  
- **대칭키 알고리즘(비밀키)**: 암호화와 복호화에 같은 키를 사용한다. 키 분배가 문제지만, 속도가 빠르다.  
  (예: DES, AES, ARIA, SEED, IDEA, LEA, JIKPJACK)  
- **비대칭키 알고리즘(공개키)**: 암호화용 공개키와 복호화용 개인키가 다르다. 보안성 높지만 느리다.  
  - 소인수 분해 기반: RSA, Rabin  
  - 이산대수 기반: Diffie-Hellman, DSA, ElGamal  
  - 타원곡선 기반: ECC (최근 많이 씀)  
- **해시 알고리즘(단방향 해시 함수)**: 원본 데이터를 고정 길이 해시값으로 바꾸지만 복원은 불가.  
  (예: SHA 계열, MD5, HAS-160)

🛡️ 해시 알고리즘 취약점과 방어법  
- **레인보우 테이블 공격**: 미리 계산해둔 해시-원본 쌍 테이블로 비밀번호 찾기. → 솔팅(Salting)으로 대응 (비밀번호에 랜덤 ‘소금’ 덧붙여 해시값 달라지게)  
- **무차별 대입 공격 (Brute-force)**: 모든 조합을 다 시도해서 비밀번호 찾기. → 키 스트레칭(Key Stretching)으로 대응 (해시 연산을 수만~수십만 번 반복해 느리게 만듦)

📈 해시 함수 주요 특성 (꼭 기억!)  
- **역상 저항성 (Preimage resistance)**: 해시값만으로 원본 입력 찾기 어려움  
- **제2 역상 저항성 (Second preimage resistance)**: 주어진 원본과 같은 해시값을 내는 다른 입력 찾기 어려움  
- **충돌 저항성 (Collision resistance)**: 서로 다른 두 입력이 같은 해시값 가지기 어려움 (MD5는 여기서 취약함)  

-----------------------------------------------------------------------------------------------------------------------------------------------
📏 LOC 기법으로 개발 소요 기간 구하기

답:  
계산식:  
\[
\frac{30,000}{300 \times 5} = \frac{30,000}{1,500} = 20 \text{ (개월)}
\]  
개발 소요 기간: 20개월

알잘딱깔센 설명:  
LOC(Line of Code) 기법은 개발할 소프트웨어의 총 코드 라인 수를 기준으로 개발 기간이나 비용을 대략 예측하는 방법이다.  
간단하게 코드 수÷(프로그래머 1명당 월 생산성 × 투입 인원 수) 하면 기간이 나온다.

여기선  
- 총 코드 라인 수: 30,000라인  
- 프로그래머 1명당 월 생산성: 300라인  
- 투입 프로그래머 수: 5명  

그래서, 30,000 ÷ (300 × 5) = 20개월 이다.  

이론적으로는 딱 떨어지지만 현실에선 변수가 많아 변동이 심하다.  

🗓️ 일정 산정 기법 (이것도 꼭 봐라!)  
- **WBS (Work Breakdown Structure)**: 프로젝트를 세부 작업 단위로 쪼개서 구조화한다.  
- **PERT/CPM**: 작업들 간 선후 관계와 소요 시간을 분석해 임계 경로(프로젝트 전체 기간 결정)를 찾는다.  
- **간트 차트(Gantt Chart)**: 각 작업의 기간을 막대그래프로 시각화해 일정 관리에 용이하다.  

💰 비용 산정 기법 (LOC 외에도 있음)  
- **상향식 산정**: 작은 단위 작업 비용을 합산하는 방식. LOC가 대표적이다.  
- **하향식 산정**: 전체 시스템 규모 기준으로 대략 비용 산정. 전문가 판단이나 델파이 기법이 있다.  
- **수학적 모델**: 과거 데이터 기반 공식(예: COCOMO, Putnam, Function Point)으로 비용 예측.


-----------------------------------------------------------------------------------------------------------------------------------------------
📜 버블 정렬 예제 코드 및 해설

✅ 코드 (C)

```c
#include <stdio.h> // 표준 입출력 함수 헤더

int main() {
    int a[] = {95, 75, 85, 100, 50}; // 초기 배열
    int i, j, temp;
    int n = 5; // 배열 크기

    // 총 n-1번 회전
    for (i = 0; i < n - 1; i++) {
        // 비교 범위는 (n-1) - i 로 점점 줄어든다
        for (j = 0; j < (n - 1) - i; j++) {
            if (a[j] > a[j + 1]) { // 인접한 원소 비교 후 교환
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }

    // 정렬된 배열 출력
    for (i = 0; i < 5; i++) {
        printf("%d", a[i]); // 예: 50758595100
    }

    return 0;
}
🔍 해설

버블 정렬은 가장 간단한 정렬 알고리즘 중 하나로,
큰 값이 마치 물속 거품처럼 차례로 맨 뒤로 ‘떠오르는’ 방식이다.

바깥 for문(i): 전체 몇 번 회전할지 정한다. 배열 크기 n일 때, n-1회전 필요.

안쪽 for문(j): 각 회전마다 인접 원소 쌍을 비교하여 크면 자리 바꿈(스왑).

if문 조건 a[j] > a[j + 1]가 핵심으로, 오름차순 정렬 기준이다.

📌 정렬 과정 예시 (초기 배열: {95, 75, 85, 100, 50})

1회전(i=0):
95,75 → {75,95}, 85 → {75,85,95}, 100 → {75,85,95,100}, 50 → {75,85,95,50,100}
가장 큰 100이 맨 끝으로 확정!

2회전(i=1):
75,85 → 유지, 85,50 → 자리 바꿈 {75,50,85,95,100}, 85,95 → 유지
두 번째 큰 95가 뒤에서 두 번째 확정!

3회전(i=2):
75,50 → 자리 바꿈 {50,75,85,95,100}, 75,85 → 유지
세 번째 큰 85가 뒤에서 세 번째 확정!

4회전(i=3):
50,75 → 유지
네 번째 큰 75가 확정, 50은 자동으로 맨 앞 확정!

✅ 최종 정렬 결과 출력: 50758595100
-----------------------------------------------------------------------------------------------------------------------------------------------

☕ Java로 작성된 프로그램이다. 결과를 쓰시오.

✅ 코드
```java
public class Main {

    public static int[] makeArray(int n) { // makeArray 함수 정의: 정수 n을 인자로 받는다.
        int[] t = new int[n]; // n 크기의 정수 배열 t를 새로 만든다. (예: n이 4면, 크기 4짜리 배열 생성)
        for (int i = 0; i < n; i++) { // i는 0부터 n-1까지 1씩 증가하면서 반복한다.
            t[i] = i; // 배열 t의 i번째 칸에 i 값을 저장한다. (예: t[0]=0, t[1]=1, ...)
        }
        return t; // 모든 값을 채운 배열 t를 돌려준다.
    }

    public static void main(String[] args) { // 메인 함수: 프로그램이 여기서부터 시작한다.
        int[] a = makeArray(4); // makeArray(4) 함수를 호출한다. 이 함수가 [0, 1, 2, 3] 배열을 만들어서 반환하면,
                               // 그 배열이 'a'라는 이름의 배열 변수에 저장된다.
        for (int i = 0; i < a.length; i++) // 배열 'a'의 길이(a.length는 4)만큼 반복한다. i는 0, 1, 2, 3이 된다.
            System.out.print(a[i] + ""); // 배열 'a'의 각 요소(a[0], a[1], ...)를 화면에 출력한다.
                                       // System.out.print는 줄 바꿈 없이 내용을 이어서 출력하는 명령어다.
    }
}

🔍 해설
이 자바 코드는 아주 간단한 배열을 만들고 그 내용을 출력하는 예제다. 코딩 초보자들도 한눈에 딱 들어오게 설명해줄게.

makeArray(int n) 메서드: 이 함수는 n이라는 숫자를 받아서 뭘 하냐면, 딱 그 n개의 칸을 가진 정수 배열을 하나 만든다. 그리고 신기하게도, 각 칸에 자기 인덱스(순서) 번호랑 똑같은 숫자를 채워 넣는다.
예를 들어 makeArray(4)를 호출하면 0, 1, 2, 3 이렇게 숫자가 채워진 배열 [0, 1, 2, 3]이 뿅 하고 만들어져서 리턴된다.

main 메서드: 여기가 바로 프로그램의 심장, 시작점이다.

int[] a = makeArray(4); 이 줄에서 우리가 만든 makeArray(4) 함수를 호출한다. 그럼 아까 위에서 설명했듯이 [0, 1, 2, 3] 배열이 만들어져서 a라는 이름의 배열 변수에 쏙 들어간다.

그 다음 for 루프를 봐라. a.length는 배열 a의 크기(칸 개수)를 알려주는데, 지금은 4다. 그러니까 i는 0, 1, 2, 3 이렇게 네 번 돌게 된다.

System.out.print(a[i] + ""); 이 명령어가 실제 출력하는 부분이다. a[i]는 배열 a의 i번째 칸에 있는 값을 말한다.
System.out.print는 줄 바꿈 없이 내용을 바로 옆에 이어서 출력하는 거다. 그래서 0 출력하고 바로 옆에 1 출력하고… 이런 식이다.


✅ 실행 결과:
0123

-----------------------------------------------------------------------------------------------------------------------------------------------

📘 **문제**  
**문제 20)** 다음은 Java로 작성된 프로그램이다. 실행 결과를 쓰시오.

```java
int i = 3, c = 1; // 변수 i는 3으로, c는 1로 초기화된다.
switch(i){ // switch 문: 변수 i의 값에 따라 실행할 case를 선택한다.
    case 1: c++; // i가 1일 경우, c를 1 증가시킨다. (break 없음에 주의!)
    case 2: c += 3; // i가 2일 경우, c에 3을 더한다. (break 없음에 주의!)
    case 3: c = 0; // i가 3일 경우, c를 0으로 만든다. (여기서부터 실행 시작!)
    case 4: c += 3; // i가 4일 경우, c에 3을 더한다. (break 없음에 주의!)
    case 5: c -= 10; // i가 5일 경우, c에서 10을 뺀다. (break 없음에 주의!)
    default: c--; // 위에 어떤 case도 해당하지 않을 경우, c를 1 감소시킨다.
}
System.out.print(c); // 최종 c의 값을 화면에 출력한다.

🧠 해설

🔹 초기값

int i = 3, c = 1;
프로그램이 시작될 때, 변수 i는 3이라는 값을 가지고, 변수 c는 1이라는 값을 가진다.

🔹 switch문 실행 흐름

switch(i): i의 값이 3이므로, switch 문은 case 3: 레이블부터 코드 실행을 시작한다.

case 3: c = 0; → c는 0으로 설정된다.

break 없음 → fall-through 발생

case 4: c += 3; → c = 0 + 3 = 3

break 없음 → fall-through 발생

case 5: c -= 10; → c = 3 - 10 = -7

break 없음 → fall-through 발생

default: c--; → c = -7 - 1 = -8

🔹 최종 출력
System.out.print(c);
→ 출력값: -8
