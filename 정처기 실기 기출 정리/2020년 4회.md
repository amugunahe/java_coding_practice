### 📘 문제 1) 다음은 디자인패턴에 대한 설명이다. 빈칸 안에 들어갈 가장 적합한 용어를 쓰시오

- 디자인 패턴은 객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들에 대해 재사용할 수 있도록 만들어 놓은 패턴들의 모음이다.  
- 에리히 감마, 리차드 헬름, 랄프 존슨, 존 블리시디스에 의해 개발영역에서 디자인 패턴을 구체화하고 체계화 시켰다.  
- GOF의 디자인 패턴은 생성, 구조, **( )** 의 3가지로 분류한다.  

**답:** 행위  

**해설:**  
GOF(Gang of Four)가 정의한 디자인 패턴은 객체지향 설계에서 반복적으로 발생하는 문제에 대한 해결책으로, 아래의 세 가지 범주로 분류된다.  
- **생성(Creational) 패턴**: 객체 생성에 관련된 패턴 (예: Singleton, Factory Method)  
- **구조(Structural) 패턴**: 클래스나 객체를 조합하여 더 큰 구조를 만들기 위한 패턴 (예: Adapter, Composite)  
- **행위(Behavioral) 패턴**: 객체나 클래스 사이의 알고리즘과 책임 분배 관련 패턴 (예: Observer, Strategy)  

📌 **관련 개념 설명:**

- **GOF(Gang of Four):** 디자인 패턴 개념을 체계화한 4명의 개발자 그룹.  
  에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vlissides)  
- 이들은 『Design Patterns: Elements of Reusable Object-Oriented Software』라는 책을 통해 디자인 패턴을 정립함.

- **디자인 패턴의 주요 목적:**  
  소프트웨어 개발에서 재사용성, 유지보수성, 확장성을 높이고, 설계 문제에 대한 검증된 해결책을 제공하는 것.

----------------------------------------------------------------------------------
### 📘 문제 2) UML을 이용한 다이어그램 중 아래 그림에 해당하는 다이어그램을 쓰시오

인터넷서점
├── 결제
│ └── 계좌이체
│ └── 카드
└── 장바구니


**답:** 패키지 다이어그램  

---

**해설:**  
주어진 구조는 "인터넷서점"이라는 하나의 상위 구성요소 아래에 "결제", "장바구니", 그리고 결제 아래에 "계좌이체", "카드"가 **계층적(모듈별) 구성**으로 표현된 형태입니다.  
이는 시스템을 **패키지 단위로 분류하고, 이들 사이의 의존성/관계**를 나타내는 **패키지 다이어그램**의 특징과 일치합니다.

---

📌 **관련 개념 설명:**

## ✅ UML(Unified Modeling Language)
UML은 시스템을 설계, 분석, 구현, 문서화하는 데 사용되는 **표준화된 모델링 언어**로, 다음과 같은 특징을 가집니다:

- **가시화 언어**: 시스템 구조를 시각적으로 표현  
- **명세화 언어**: 시스템 요소의 의미와 관계를 명확히 표현  
- **구축 언어**: 설계에서 실제 시스템 구현으로 이어지게 함  
- **문서화 언어**: 설계를 문서로 체계화  

---

## 📂 UML의 다이어그램 분류

### 🧱 구조적 다이어그램  / 클객컴배복패
| 다이어그램 종류 | 설명 |
|----------------|------|
| **클래스 다이어그램** | 시스템의 클래스와 이들 간의 관계 표현 |
| **패키지 다이어그램** | 시스템을 패키지 단위로 나누고, 패키지 간의 의존 관계 표현 |
| **복합체 구조 다이어그램** | 클래스 내부 구조 및 구성요소 표현 |
| **객체 다이어그램** | 시스템 내 객체들과 그 관계 표현 |
| **컴포넌트 다이어그램** | 시스템의 물리적 구성요소와 상호작용 표현 |
| **배치 다이어그램** | 시스템의 실행 환경 및 물리적 배치 표현 |

---

### 🔄 행위 다이어그램/ 유순커상활상타 
| 다이어그램 종류 | 설명 | 
|----------------|------|
| **유스케이스 다이어그램** | 사용자와 시스템 간의 상호작용 표현 |
| **순차 다이어그램** | 객체 간 메시지 흐름을 시간 순으로 표현 |
| **커뮤니케이션 다이어그램** | 객체 간 상호작용과 통신 표현 |
| **상태 다이어그램** | 객체의 상태 변화 표현 |
| **활동 다이어그램** | 프로세스 흐름 및 워크플로우 표현 |
| **상호작용 개요 다이어그램** | 고수준 상호작용 흐름 표현 |
| **타이밍 다이어그램** | 시간에 따른 객체의 상태 및 메시지 흐름 표현 |

---

📌 **정리 포인트:**
- 주어진 그림은 시스템 내 하위 구성요소 간의 구조적 관계를 나타낸 것으로, **패키지 간의 포함(의존)** 구조를 보여주는 **패키지 다이어그램**이다.
- **패키지 다이어그램**은 보통 모듈 간 구조나 종속성을 설계할 때 사용된다. 
----------------------------------------------------------------------------------

### 📘 문제 3) 일반, 업무용, 게임, 오락 등의 일반적인 업무에 사용하는 테스트 오라클로 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클을 쓰시오.

**답:** 샘플링 오라클  

---

**해설:**  
**샘플링 오라클(Sampling Oracle)**은 전체 입력값에 대해 기대 결과를 알 수 없는 경우, **일부(샘플) 입력값에 대해서만 결과를 예측하고 검증**할 수 있도록 하는 테스트 오라클이다.  
일반적인 응용프로그램(업무용, 게임, 오락 등)처럼 **모든 입력 케이스에 대해 예상 결과를 정하기 어려운 시스템**에서 활용된다.

---

📌 **관련 개념 설명:**

### ✅ 테스트 오라클(Test Oracle)  
테스트 오라클이란 **소프트웨어 테스트에서 실제 결과와 기대 결과를 비교하여 결함 유무를 판단할 수 있도록 해주는 메커니즘 또는 참조 수단**을 말한다.

#### 🔸 테스트 오라클의 유형

| 오라클 유형 | 설명 |
|-------------|------|
| **참 오라클 (True Oracle)** | 모든 입력값에 대해 정확한 기대 결과를 제공. 이상적인 오라클이나 현실적으로 구현 어려움. |
| **샘플링 오라클 (Sampling Oracle)** | 일부 샘플 입력값에 대해서만 기대 결과를 제공. 일반적인 응용 프로그램에서 주로 사용. |
| **휴리스틱 오라클 (Heuristic Oracle)** | 휴리스틱(경험적 판단 기준)을 이용하여 결과의 타당성을 검토. |
| **일관성 오라클 (Consistency Oracle)** | 동일한 입력에 대해 반복된 실행 결과의 일관성 여부로 판단. |
| **무결성 오라클 (Integrity Oracle)** | 테스트 중 데이터 손상, 시스템 상태 변화 등 무결성 여부를 기준으로 판단. |

---

📌 **추가 예시:**  
- 게임 시스템에서 일부 기능만 정확한 기대값을 설정할 수 있는 경우  
- 업무용 응용 프로그램에서 복잡한 비즈니스 로직 중 일부 계산에 대해서만 결과가 예측 가능한 경우  

➡️ 이처럼 전체 기능에 대한 기대 결과를 명확히 정의할 수 없을 때, **샘플링 오라클**이 적절하게 사용된다.

----------------------------------------------------------------------------------

### 📘 문제 4) 테스트 기법 중 다음과 같이 입력값을 넣고, 출력값을 비교하는 테스트 기법을 쓰시오.

| 테스트 케이스     | 1   | 2     | 3     | 4     |
|------------------|-----|-------|-------|-------|
| 구간             | 0~59 | 60~79 | 80~89 | 90~99 |
| 테스트 데이터     | 45  | 70    | 85    | 95    |
| 예측값           | F   | C     | B     | A     |
| 결과값           | F   | C     | B     | A     |

**답:** 동등분할 테스트  

---

**해설:**  
테스트 케이스가 **입력 값의 범위(0~59, 60~79, 80~89, 90~99)** 별로 나뉘어 있고,  
각 범위마다 **대표값(예: 45, 70 등)을 선택하여 예측값과 비교**하고 있는 형태이다.  
이는 명확히 **입력 자료의 유효한 구간을 나누고 그 범주마다 대표값을 선택하여 테스트**하는  
**동등 분할 테스트(Equal Partitioning Test)** 기법에 해당한다.

---

📌 **관련 개념 설명:**

## ✅ 블랙박스 테스트 기법 (Black Box Testing)

블랙박스 테스트는 **시스템 내부 로직을 고려하지 않고, 입력과 출력값만을 기준으로 테스트**하는 방법이다.  
주로 요구사항 명세 기반으로 테스트 케이스를 도출한다.

### 🔹 주요 블랙박스 테스트 기법/ 동경원오비

| 테스트 기법 | 설명 |
|-------------|------|
| **동등 분할 기법 (Equivalence Partitioning)** | 입력 값을 유사한 성질의 **유효/무효 클래스**로 나누고, 각 클래스에서 대표값을 테스트 케이스로 선택하는 기법 |
| **경계값 분석 기법 (Boundary Value Analysis)** | **입력의 최소값, 최대값, 경계선 바로 안/밖의 값** 등을 중심으로 테스트하는 기법 |
| **원인-효과 그래프 기법** | 입력 조건(원인)과 출력 조건(효과) 간의 관계를 논리적으로 도출하여 테스트 케이스를 작성하는 기법 |
| **오류 예측 기법** | 과거 경험이나 직관을 바탕으로 **에러가 발생할 가능성이 높은 입력을 선택하여 테스트**하는 기법 |
| **비교 검사 기법 (Comparison Testing)** | **여러 버전**의 프로그램에 같은 데이터를 입력하고 결과를 비교하여 이상 여부를 검증하는 기법 |

---

📌 **정리 포인트:**
- 제시된 표는 입력 범위별로 테스트 데이터를 구간화하고, 각 구간의 **대표값만 테스트**한다는 점에서 **동등분할 테스트**이다.
- 만약 범위의 **경계값(예: 59, 60, 89, 90 등)**을 포함하여 테스트했다면, **경계값 분석 기법**에 해당했을 것이다.


----------------------------------------------------------------------------------

### 📘 문제 5) `<학생>` 테이블을 대상으로 `<요구사항>`을 적용하여 아래 `<결과>`와 같이 출력하는 SQL 문을 작성하시오.

---

#### 🗃️ <학생> 테이블

| 학번     | 이름 | 학과   | 성적 | 주소 |
|----------|------|--------|------|------|
| 2020021  | 철수 | 전기   | 90   | 서울 |
| 2020001  | 민수 | 컴퓨터 | 70   | 대전 |
| 2021022  | 영희 | 건축   | 85   | 서울 |
| 2022013  | 민호 | 건축   | 95   | 원주 |
| 2020007  | 병희 | 컴퓨터 | 100  | 울산 |

---

#### 🎯 <결과>

| 학과   | 학과별 튜플수 |
|--------|---------------|
| 전기   | 1             |
| 컴퓨터 | 2             |
| 건축   | 2             |

---

#### 📌 <요구사항>
1. **WHERE** 구문을 사용하지 않고 SQL문을 작성하시오.  
2. **GROUP BY 구문과 집계 함수**를 반드시 사용하시오.  
3. 인용문구 사용 시 작은따옴표(`'`) 사용 가능.  
4. **AS 구문은 반드시 사용**하여 작성하시오.  

---

### ✅ 답안 SQL

```sql
SELECT 학과, COUNT(*) AS 학과별튜플수
FROM 학생
GROUP BY 학과;

----------------------------------------------------------------------------------
### 📘 문제 6) 스니핑에 대하여 간략히 서술하시오.

**답:**  
네트워크상에 통과되는 패킷들의 내용을 엿보는 행위이다.

---

### 📌 관련 개념 설명

- **스니핑(Sniffing)**  
  네트워크 통신 중에 주고받는 데이터 패킷을 가로채서 분석하거나 도청하는 행위를 말한다.  
  주로 네트워크 관리자나 보안 전문가가 네트워크 문제 해결과 모니터링을 위해 사용하지만,  
  악의적인 공격자가 정보를 탈취하는 데에도 사용될 수 있다.

- **스니핑의 주요 특징**  
  - 네트워크 트래픽을 실시간으로 감시  
  - 비인가자의 정보 탈취 위험 존재  
  - 주로 패킷 스니퍼(Packet Sniffer)라는 도구를 사용함  

- **예시 도구**  
  - Wireshark  
  - tcpdump  

- **대응 방안**  
  - 데이터 암호화 (예: HTTPS, VPN)  
  - 네트워크 접근 제어  
  - 이상 트래픽 탐지 시스템 운영


----------------------------------------------------------------------------------

### 📘 문제 7) 정보보안의 3요소 중 가용성에 대해 서술하시오.

**답:**  
인가된 사용자가 정보를 요구할 때 적시에 제공되어야 하는 원칙이다.

---

### 📌 관련 개념 설명

## 정보보안 3요소 (CIA Triad)

| 요소   | 설명                                                       | 예시 및 대책                      |
|--------|------------------------------------------------------------|----------------------------------|
| **기밀성 (Confidentiality)** | 인가된 사용자만 정보 자산에 접근할 수 있도록 보호하는 원칙 | 방화벽, 암호화, 접근 제어        |
| **무결성 (Integrity)**       | 시스템 내의 정보가 인가된 사용자에 의해 인가된 방법으로만 수정되도록 보장 | 체크섬, 디지털 서명, 변경 관리  |
| **가용성 (Availability)**    | 인가된 사용자가 필요할 때 정보 및 자원에 접근할 수 있도록 하는 능력 및 원칙 | 장애 대비, 백업, 네트워크 안정성|

---

### 가용성(Availability) 세부 설명  
- 사용자가 정보에 **필요한 시점에 지체 없이 접근 가능**해야 함  
- 시스템 다운, 서비스 거부(DoS) 공격, 하드웨어 고장 등으로부터 보호  
- 신속한 복구와 장애 대응 체계가 중요  

---

📌 **요약:**  
가용성은 정보 시스템이 안정적이고 지속적으로 운영되어 인가된 사용자가 언제든지 필요한 데이터를 적시에 이용할 수 있도록 보장하는 정보보안의 핵심 원칙입니다.


----------------------------------------------------------------------------------

### 📘 문제 8) 데이터베이스의 이상의 종류를 3가지 쓰시오.

**답:**  
- 삽입 이상 (Insertion Anomaly)  
- 삭제 이상 (Deletion Anomaly)  
- 갱신 이상 (Update Anomaly)  

---

### 📌 관련 개념 설명

- **이상(Anomaly)** 이란 데이터베이스에서 데이터의 삽입, 삭제, 갱신 작업 중 발생할 수 있는 문제점을 의미한다.

1. **삽입 이상 (Insertion Anomaly)**  
   - 새로운 데이터를 추가할 때 불필요하거나 부적절한 정보까지 같이 입력해야 하는 문제  
   - 예: 학생이 아직 수강하는 과목이 없는데도 과목 정보를 입력해야 하는 경우

2. **삭제 이상 (Deletion Anomaly)**  
   - 데이터 삭제 시 관련된 다른 중요한 데이터까지 함께 삭제되어버리는 문제  
   - 예: 학생 정보 삭제 시 해당 학생의 성적 정보도 함께 없어지는 경우

3. **갱신 이상 (Update Anomaly)**  
   - 동일한 데이터가 여러 곳에 중복 저장되어 있어, 일부만 갱신하면 데이터 불일치가 발생하는 문제  
   - 예: 학생 주소가 여러 테이블에 있을 때 한 곳만 변경하면 불일치가 발생

---

이상을 방지하기 위해 **정규화(Normalization)** 과정을 거쳐 데이터베이스 구조를 설계한다.

---------------------------------------------------------------------------------- 

### 📘 문제 9) 데이터베이스 회복 기법에 관련된 설명에서 괄호에 들어갈 가장 알맞은 용어를 쓰시오.

---

다양한 데이터 회복 기법 중  
() 회복 기법은 로그를 이용한 회복기법으로 데이터베이스에 대한 갱신 로그를 저장함으로서 회복에 대비한다.  
() 회복 기법은 트랜잭션이 실행 상태에서 변경되는 내용을 그때그때 바로 데이터베이스에 적용하는 기법이다.  
() 회복 기법은 장애가 발생하면 로그 파일에 기록된 내용을 참조하여, 장애 발생 시점에 따라 REDO나 UNDO를 실행하여 데이터베이스를 복구한다.

---

**답:**  
1. 즉시 회복 (즉시 갱신)  
2. 즉시 갱신 (정확히는 즉시 적용 기법)  
3. ARIES 회복 기법  

---

### 📌 관련 개념 설명

#### 1. 로그 기반 회복 기법  
- 데이터베이스의 모든 변경 사항을 로그에 기록하여 장애 시 로그를 참고해 복구  
- 대표적 기법으로 **즉시 회복(즉시 갱신)**과 **지연 회복(지연 갱신)**이 있음  

#### 2. 즉시 갱신 (Immediate Update)  
- 트랜잭션이 변경한 내용을 즉시 데이터베이스에 반영  
- 장애 발생 시 로그의 UNDO, REDO 연산을 통해 복구  
- 트랜잭션 수행 중에도 변경 내용이 데이터베이스에 반영되어 있으므로, 더 많은 관리 필요

#### 3. ARIES 회복 기법  
- 분석(Analysis), 재실행(REDO), 되돌리기(UNDO)의 3단계로 복구를 수행  
- 효율적이고 신뢰성 있는 로그 기반 회복 기법으로 널리 사용됨

---

### 추가 참고: 병행 제어 (Concurrency Control)

- 병행제어가 없으면 발생하는 문제:  
  - 갱신 분실(Lost Update)  
  - 비완료 의존성(Uncommitted Dependency)  
  - 모순성(Inconsistency)  
  - 연쇄복귀(Cascading Rollback)

- 병행제어 기법 종류:  
  - 로킹(Locking)  
  - 2단계 로킹(Two-Phase Locking)  
  - 타임스탬프 기반 기법  
  - 낙관적 병행제어(Optimistic Concurrency Control)  
  - 다중 버전 병행 제어(Multi-Version Concurrency Control)


----------------------------------------------------------------------------------

### 📘 문제 10) 다음 프로세스 상태 전이도의 빈칸 1~3에 알맞은 프로세스 상태를 각각 쓰시오.


         DISPATCH
생성 → (1) → (2) → 종료
↖ ← ↙ BLOCK
TIME RUN OUT
WAKE UP (3)

---

**답:**  
- (1) 준비 (Ready)  
- (2) 실행 (Running)  
- (3) 대기 (Blocked / Waiting)  

---

### 📌 관련 개념 설명

- **프로세스 상태 전이도(Process State Transition Diagram)**  
  운영체제에서 프로세스는 여러 상태를 거치면서 실행된다.  
  주요 상태는 다음과 같다.

| 상태       | 설명                                      |
|------------|-------------------------------------------|
| 생성 (New) | 프로세스가 생성된 상태                     |
| 준비 (Ready) | CPU 할당을 기다리며 대기하는 상태          |
| 실행 (Running) | CPU를 할당받아 실제 작업을 수행 중인 상태   |
| 대기 (Blocked / Waiting) | 입출력 등 이벤트가 완료되기를 기다리는 상태 |
| 종료 (Terminated) | 프로세스가 종료된 상태                   |

- **상태 전이 설명**  
  - **생성 → 준비**: 프로세스가 생성되어 CPU 할당 대기 큐에 들어감  
  - **준비 → 실행**: DISPATCH 이벤트로 CPU 할당받음  
  - **실행 → 종료**: 프로세스가 종료됨  
  - **실행 → 대기**: 입출력 등 이벤트를 기다려 BLOCK 상태로 전이  
  - **대기 → 준비**: 이벤트 완료되어 WAKE UP되어 준비 상태로 전이  
  - **실행 → 준비**: TIME RUN OUT(시간 할당 종료)되어 다시 준비 상태로 전이  

----------------------------------------------------------------------------------

### 📘 문제 11) 다음 설명에 해당하는 용어를 쓰시오.

- IPv4의 주소 고갈 문제를 해결하기 위하여 기존의 IPv4 주소 체계를 128비트 크기로 확장한 차세대 인터넷 프로토콜 주소  
- 헤더의 내용을 확인하는데 소요되는 오버헤드를 최소화하도록 설계  
- 16비트씩 8부분, 총 128비트로 구성되며, 콜론(:)으로 구분한다.  
- 주소 분류로 유니캐스트, 멀티캐스트, 애니캐스트를 사용한다.

---

### IPv4 / IPv6 전환 기술  
- **듀얼 스택(Dual Stack)**: IPv4와 IPv6를 동시에 지원하여 두 프로토콜 패킷을 주고받을 수 있음  
- **터널링(Tunneling)**: 두 IPv6 네트워크 간 터널을 이용, IPv6 패킷을 IPv4 패킷에 캡슐화하여 전송  
- **주소 변환(Address Translation)**: IPv4와 IPv6 간 주소 변환으로 두 버전 연동

---

### 답: IPv6 (Internet Protocol Version 6)

---

### 📌 관련 개념 설명

- **IPv4**  
  - 32비트 주소 체계, 약 43억 개 주소 제공  
  - 주소 고갈 문제 발생  

- **IPv6**  
  - 128비트 주소 체계로 확장  
  - 훨씬 더 많은 주소 제공 (약 3.4×10^38개)  
  - 헤더 구조 단순화로 처리 효율성 증가  
  - 주소 표기법: 16비트 8개 블록을 콜론(:)으로 구분 (예: 2001:0db8:85a3::8a2e:0370:7334)  
  - 새로운 주소 유형: 유니캐스트, 멀티캐스트, 애니캐스트 지원  
  - 향상된 보안 기능과 자동 구성 기능 포함

- **IPv4/IPv6 전환 기술**  
  - 기존 IPv4 네트워크와 IPv6 네트워크가 공존하는 동안 호환성을 위한 기술  
  - 듀얼 스택, 터널링, 주소 변환 등이 주요 방법  

---

----------------------------------------------------------------------------------

### 📘 문제 12) 다음 설명에 해당하는 운영체제를 적으시오.

- 1960년대 말 벨 연구소에서 개발된 운영체제로 다중 사용자, 멀티태스킹 운영체제이다.  
- 대부분 C언어로 작성되어 있어 이식성이 높다.  
- 트리 구조의 파일 시스템을 갖는다.

---

### 답: 유닉스 (UNIX)

---

### 📌 관련 개념 설명

- **유닉스(UNIX)**  
  - 1969년 AT&T 벨 연구소에서 개발  
  - 다중 사용자(Multi-user) 및 다중 작업(Multitasking)을 지원하는 운영체제  
  - 대부분 C 언어로 개발되어, 다양한 하드웨어로 쉽게 이식 가능  
  - 트리 구조의 계층적 파일 시스템 제공  
  - 쉘(Shell)과 다양한 유틸리티 프로그램을 통해 강력한 명령어 인터페이스 제공  
  - 현대 운영체제(리눅스, macOS 등)의 기반이 됨  



----------------------------------------------------------------------------------
### 📘 문제 13) 다음 설명에 해당하는 용어를 쓰시오.

- 정형 데이터 및 사진, 영상 등의 비정형 데이터를 효과적으로 처리하는 오픈소스 빅데이터 솔루션이다.  
- 많은 양의 데이터를 여러 대의 범용 컴퓨터에 나눠서 저장하고 처리한다.  
- 더그 커팅(Doug Cutting)과 마이크 캐퍼랠라(Mike Cafarella)가 개발했으며, 구글의 맵리듀스(MapReduce) 엔진을 사용한다.

---

### 답: Hadoop

---

### 📌 빅데이터 관련 용어 설명

- **빅데이터 (Big Data)**  
  대량의 정형 또는 비정형 데이터 집합 및 이러한 데이터로부터 가치를 추출하고 결과를 분석하는 기술

- **Hadoop**  
  오픈소스 기반 분산 컴퓨팅 기술  
  정형 및 비정형 빅데이터 분석에 가장 선호되는 솔루션  
  - 분산 저장(HDFS: Hadoop Distributed File System)  
  - 분산 처리(MapReduce)  
  - 확장성과 내결함성 지원  

- **NoSQL**  
  전통적인 관계형 데이터베이스(RDBMS)와 다르게 설계된 비관계형 데이터베이스  
  대규모 유연한 데이터 처리를 위해 적합  

- **데이터 마이닝 (Data Mining)**  
  대규모 저장 데이터에서 통계적 규칙이나 패턴을 체계적, 자동적으로 찾아내는 과정  

- **데이터 웨어하우스 (Data Warehouse)**  
  기간 시스템 데이터베이스의 데이터를 공통 형식으로 변환해 관리하는 데이터베이스  

- **데이터 마트 (Data Mart)**  
  데이터 웨어하우스의 하위 집합으로, 특정 사용자 관심 데이터 중심의 소규모 데이터베이스  

- **OLAP (Online Analytical Processing)**  
  사용자가 직접 데이터베이스를 검색, 분석해 문제점이나 해결책을 찾는 분석형 애플리케이션  

- **매시업 (Mashup)**  
  웹에서 제공하는 정보 및 서비스를 조합해 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술  

----------------------------------------------------------------------------------
### 📘 문제 14) 다음 설명에 해당하는 용어를 쓰시오.

관리 대상 데이터를 '블록'이라고 하는 소규모 데이터 단위로 나누어, P2P(peer-to-peer) 방식을 기반으로 생성된 체인 형태의 연결고리 기반 분산 데이터 저장 환경에 저장한다.  
누구라도 임의로 수정할 수 없고, 누구나 변경 결과를 열람할 수 있는 분산 컴퓨팅 기술 기반의 원장 관리 기술이다.

---

### 답: 블록체인 (Blockchain)

---

### 📌 관련 개념 설명

- **블록체인(Blockchain)**  
  - 데이터를 '블록' 단위로 묶어, 각 블록을 체인 형태로 연결하여 분산 저장  
  - P2P 네트워크에서 참여자 모두가 원장을 공유하고 검증  
  - 탈중앙화된 구조로 데이터 위변조가 사실상 불가능  
  - 트랜잭션 기록이 투명하게 공개되어 신뢰성 확보  
  - 암호화 기법과 합의 알고리즘(예: 작업증명, 지분증명 등)을 사용하여 보안 유지  
  - 암호화폐, 스마트 계약, 금융, 물류 등 다양한 분야에서 활용  

---

----------------------------------------------------------------------------------

### 📘 문제 15) 다음을 설명하는 용어를 쓰시오.

- 우리나라 말로 번역하면 '네트워크 주소 변환'이라는 의미  
- 내부에서 사용하는 사설 IP 주소와 외부로 보여지는 공인 IP 주소 간의 IP 주소 변환 방식을 말한다.  
- 한정된 공인 IP를 여러 개의 내부 사설 IP로 변환하기 위해 사용하는 기술  

---

### 답: NAT (Network Address Translation)

---

### 📌 관련 개념 설명

- **NAT (Network Address Translation)**  
  - 사설 네트워크 내의 여러 기기가 하나 또는 소수의 공인 IP 주소를 공유하여 인터넷에 접속할 수 있도록 IP 주소를 변환하는 기술  
  - 사설 IP 주소를 공인 IP 주소로 매핑하여 내부 네트워크와 외부 인터넷 간의 통신을 중개  
  - IPv4 주소 부족 문제 완화에 기여  
  - 종류  
    - Static NAT: 사설 IP와 공인 IP를 1:1로 매핑  
    - Dynamic NAT: 사설 IP를 사용 가능한 공인 IP 풀 중 하나에 매핑  
    - PAT (Port Address Translation, 또는 NAT Overload): 하나의 공인 IP를 여러 사설 IP가 포트 번호를 달리하여 공유  

---

필요하시면 다음 문제도 마크다운 형식으로 정리해 드리겠습니다!

----------------------------------------------------------------------------------

### 📘 문제 16) 다음은 C언어로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```c
void main()
{
    char *p = "KOREA";
    printf("%s\n", p);
    printf("%s\n", p+3);
    printf("%c\n", *p);
    printf("%c\n", *(p+3));
    printf("%c\n", *p + 2);
}

답
KOREA
EA
K
E
M

📌 해설
p는 문자열 "KOREA"의 시작 주소를 가리킨다.

printf("%s\n", p);
문자열 전체 출력 → "KOREA"

printf("%s\n", p+3);
p+3은 문자열의 4번째 문자부터 시작, 즉 "E A" 중 'E'부터 → "EA"

printf("%c\n", *p);
*p는 첫 문자 'K' 출력

printf("%c\n", *(p+3));
*(p+3)는 4번째 문자 'E' 출력

printf("%c\n", *p + 2);
*p는 'K'의 ASCII 코드 75 + 2 = 77 → 문자 'M' 출력

----------------------------------------------------------------------------------
### 📘 문제 17) 다음 JAVA 프로그램을 분석하여 빈칸 1~2에 들어갈 내용을 각각 쓰시오.

```java
public static void main(String[] args) {
    int[][] arry = new int[(1)][(2)];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 5; j++) {
            arry[i][j] = j * 3 + (i + 1);
            System.out.print(arry[i][j] + "");
        }
        System.out.println();
    }
}

답
(1) 3

(2) 5

📌 해설
int[][] arry = new int[(1)][(2)];에서 arry는 2차원 배열로서, 첫 번째 차원의 크기가 3, 두 번째 차원의 크기가 5여야 한다.

그 이유는 다음 for문에서 i가 0부터 2까지(총 3회) 반복하고, j가 0부터 4까지(총 5회) 반복하면서 arry[i][j]에 값을 할당하기 때문이다.

따라서 배열 선언 시 new int[3][5]가 되어야 IndexOutOfBoundsException이 발생하지 않는다.
----------------------------------------------------------------------------------

### 📘 문제 18) 아래 <처리 결과>처럼 10진수를 2진수로 변환해주는 프로그램이다.  
java 프로그램의 빈칸 1~2에 들어갈 java 구문을 쓰시오.

---

#### <처리 결과>  
00001010

---

#### 문제 코드 일부

```java
int a[] = new int[8];
int i = 0, n = 10;
while (1) {
    a[i++] = (2);
    n /= 2;
}
for (i = 7; i >= 0; i--)
    System.out.printf("%d", a[i]);


답
(1) i < a.length

(2) n % 2

📌 해설
while 루프의 조건 i < a.length는 배열 a의 크기만큼 반복하기 위한 조건이다.

a[i++] = n % 2;는 n을 2로 나눈 나머지(즉, 2진수의 한 자리)를 배열에 저장한다.

n /= 2;는 n을 2로 나누어 다음 자리수를 구하기 위한 준비다.

마지막 for문은 배열에 저장된 2진수를 역순으로 출력해 2진수 형태로 보여준다.
 ----------------------------------------------------------------------------------

### 📘 문제 19) 다음은 java로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```java
class Parent {
    int com(int num) {
        if (num <= 1)
            return num;
        return com(num - 1) + com(num - 2);
    }
}

class Child extends Parent {
    int com(int num) {
        if (num <= 1)
            return num;
        return com(num - 1) + com(num - 3);
    }
}

Parent obj = new Child();
System.out.print(obj.com(4));
답: 5

📌 해설
오타 수정 및 코드 이해

compute → com으로 메서드명 통일

Child 클래스에 중괄호 {} 추가

Parent obj = new Child(); 로 다형성 사용

메서드 호출 방식:

obj 타입은 Parent지만 실제 인스턴스는 Child이므로 오버라이딩된 com 메서드가 호출된다.

Child 클래스의 com 함수 정의:


int com(int num) {
    if (num <= 1)
        return num;
    return com(num - 1) + com(num - 3);
}
obj.com(4) 호출 흐름:


com(4) = com(3) + com(1)
com(3) = com(2) + com(0)
com(2) = com(1) + com(-1)
com(1) = 1  // base case
com(0) = 0  // base case, num <=1
com(-1) = -1 <=1 이므로 return -1 (주로 0으로 처리하는 게 일반적이나 여기서는 num <=1 반환 num 그대로임)
실제 계산:


com(1) = 1
com(0) = 0
com(-1) = -1 (이 경우 음수일 때 리턴 num 그대로)

com(2) = com(1) + com(-1) = 1 + (-1) = 0
com(3) = com(2) + com(0) = 0 + 0 = 0
com(4) = com(3) + com(1) = 0 + 1 = 1
따라서 출력 결과는 1이다.

----------------------------------------------------------------------------------
### 📘 문제 20) 다음은 Python 언어로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```python
lol = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
print(lol[0])
print(lol[2][1])
for sub in lol:
    for item in sub:
        print(item, end=" ")
    print()

답

[1, 2, 3]
7
1 2 3 
4 5 
6 7 8 9 

📌 해설
lol[0]은 리스트의 첫 번째 요소인 [1, 2, 3]을 출력한다.

lol[2][1]은 세 번째 리스트 [6,7,8,9]의 두 번째 요소인 7을 출력한다.

중첩된 for문은 각 서브 리스트의 요소들을 순서대로 출력하며, 각 요소 사이에 공백을 넣고 각 서브 리스트가 끝나면 줄바꿈을 한다.


