### 📘 문제 1) 다음은 디자인패턴에 대한 설명이다. 빈칸 안에 들어갈 가장 적합한 용어를 쓰시오

- 디자인 패턴은 객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들에 대해 재사용할 수 있도록 만들어 놓은 패턴들의 모음이다.  
- 에리히 감마, 리차드 헬름, 랄프 존슨, 존 블리시디스에 의해 개발영역에서 디자인 패턴을 구체화하고 체계화 시켰다.  
- GOF의 디자인 패턴은 생성, 구조, **( )** 의 3가지로 분류한다.  

**답:** 행위  

존나 쉽고 직관적이고 갓반인도 알아듣는 예시로

---

**해설:**  
GOF(Gang of Four)가 정의한 디자인 패턴은 객체지향 설계에서 자주 반복되는 문제에 대한 해결책임.  
주요 세 가지 범주로 나눠볼 수 있음:

- **생성(Creational) 패턴**: 객체 만드는 방법에 관한 패턴  
  예) Singleton (딱 하나만 만드는 것), Factory Method (객체 만드는 공장 역할)  
- **구조(Structural) 패턴**: 여러 클래스나 객체를 이어붙여 큰 구조를 만드는 방법  
  예) Adapter (호환 안 맞는 걸 연결해줌), Composite (나무 구조처럼 묶음 처리)  
- **행위(Behavioral) 패턴**: 객체 간 역할과 소통 방법을 정하는 패턴  
  예) Observer (누가 변하면 알려주는), Strategy (방법을 바꾸면서 실행)

---

📌 **관련 개념 설명:**

- **GOF(Gang of Four)**  
  디자인 패턴을 체계적으로 정리한 4명의 개발자 그룹 이름  
  - 에리히 감마, 리차드 헬름, 랄프 존슨, 존 블리시디스  
- 『Design Patterns: Elements of Reusable Object-Oriented Software』라는 책을 통해 디자인 패턴 개념을 정립함

- **디자인 패턴의 주요 목적:**  
  자주 나오는 문제들을 검증된 방법으로 쉽게 해결하고, 코드 재사용성과 유지보수성을 높임

---

💡 쉽게 말하면,  
"코딩할 때 흔히 겪는 문제들을 미리 해결해놓은 꿀팁 모음" 같은 거임!


----------------------------------------------------------------------------------
### 📘 문제 2) UML을 이용한 다이어그램 중 아래 그림에 해당하는 다이어그램을 쓰시오

인터넷서점
├── 결제
│ └── 계좌이체
│ └── 카드
└── 장바구니


**답:** 패키지 다이어그램  

---

**해설:**  
주어진 구조는 "인터넷서점"이라는 큰 상자 안에 "결제", "장바구니"가 있고,  
결제 안에는 다시 "계좌이체"와 "카드"가 들어있는 모습이야.  
이런 계층적, 모듈별 구성을 보여주는 그림은 **패키지 다이어그램**이라는 UML 다이어그램이야.  
즉, 시스템을 큰 덩어리(패키지)로 나누고, 이 덩어리들끼리 어떻게 연결되어 있는지를 표현한 거지.

---

📌 **관련 개념 설명:**

## ✅ UML(Unified Modeling Language)  
컴퓨터 프로그램이나 시스템을 눈에 보이게 설계하고 문서화하는 표준 언어야.  
- **눈에 보이는 그림**으로 시스템을 설명  
- 설계 내용이 **명확하게 전달**되도록 함  
- 실제 코드로 만들기 전 단계에서 유용해  

---

## 📂 UML 다이어그램 종류  

### 🧱 구조적 다이어그램 (시스템 구성 중심)  
| 다이어그램 종류     | 설명                            |
|------------------|-------------------------------|
| 클래스 다이어그램     | 시스템의 클래스와 관계 표현          |
| 패키지 다이어그램     | 모듈(패키지) 단위로 나누고 의존 관계 표현  |
| 객체 다이어그램       | 프로그램 실행 중 객체와 관계 표현       |
| 컴포넌트 다이어그램    | 시스템 부품과 연결 관계 표현           |
| 배치 다이어그램       | 프로그램이 실제 돌아가는 환경 표현      |

---

### 🔄 행위 다이어그램 (시스템 동작/흐름 중심)  
| 다이어그램 종류       | 설명                            |
|--------------------|-------------------------------|
| 유스케이스 다이어그램   | 사용자와 시스템 상호작용 표현       |
| 순차 다이어그램       | 메시지 흐름을 시간 순서대로 표현      |
| 상태 다이어그램       | 객체 상태 변화 표현               |
| 활동 다이어그램       | 작업 흐름 및 프로세스 표현          |

---

💡 쉽게 말하면,  
> 인터넷서점이라는 큰 상자 안에 여러 기능들이 박스처럼 들어있고,  
> 각 기능들이 어떻게 연결되어 있는지 보여주는 그림 = **패키지 다이어그램**!

---

📌 **정리:**  
- 계층적 구조 + 모듈별 관계를 나타내고 싶을 때  
- 시스템을 큰 덩어리(패키지)로 나눠서 설계하고 싶을 때  
- 바로 이 **패키지 다이어그램**을 쓰면 끝!

----------------------------------------------------------------------------------

### 📘 문제 3) 일반, 업무용, 게임, 오락 등의 일반적인 업무에 사용하는 테스트 오라클로 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해주는 오라클을 쓰시오.

**답:** 샘플링 오라클  

---

**해설:**  
샘플링 오라클(Sampling Oracle)은 프로그램 테스트할 때, 모든 입력값에 대한 결과를 다 알기 어려울 때  
일부 대표적인 입력값(샘플)만 골라서 그 결과가 맞는지 확인하는 방법이야.  
즉, '이 전체 퍼즐을 다 맞추기 어렵지만, 몇 조각만 골라서 맞는지 확인해보자!' 같은 거지.

---

📌 **관련 개념 설명:**

### ✅ 테스트 오라클(Test Oracle)이란?  
테스트할 때 "이 결과가 맞아?" 하고 판단해주는 기준 또는 기준 도구 같은 거야.

#### 🔸 테스트 오라클 종류

| 오라클 종류          | 설명                                  |
|---------------------|-------------------------------------|
| **참 오라클 (True Oracle)**    | 모든 입력값에 대해 정확한 정답을 알려줌. 이상적이지만 현실에선 거의 불가능함. |
| **샘플링 오라클 (Sampling Oracle)** | 일부 입력값만 골라서 결과가 맞는지 확인함. 보통 많이 쓰임.           |
| **휴리스틱 오라클 (Heuristic Oracle)** | 경험이나 감으로 결과가 이상한지 판단함.                            |
| **일관성 오라클 (Consistency Oracle)** | 같은 입력에 대해 계속 같은 결과가 나오는지 체크함.                   |
| **무결성 오라클 (Integrity Oracle)** | 데이터나 시스템 상태가 깨지지 않았는지 확인함.                       |

---

💡 쉽게 말하면,  
> 엄청 큰 시험 문제집을 다 맞추기 어려우니까,  
> 중요한 문제 몇 개만 골라서 제대로 풀었는지 확인하는 거야.  
> 이게 바로 샘플링 오라클 방식!

---

📌 **예시:**  
- 게임에서 모든 상황 결과를 다 예상할 수 없으니까, 주요 기능 몇 가지만 테스트  
- 복잡한 회사 프로그램에서 전체 계산이 어려우니 핵심 부분 몇 가지만 결과 확인  

이럴 때 샘플링 오라클이 딱 좋은 선택이야.


----------------------------------------------------------------------------------

### 📘 문제 4) 테스트 기법 중 다음과 같이 입력값을 넣고, 출력값을 비교하는 테스트 기법을 쓰시오.

| 테스트 케이스     | 1   | 2     | 3     | 4     |
|------------------|-----|-------|-------|-------|
| 구간             | 0~59 | 60~79 | 80~89 | 90~99 |
| 테스트 데이터     | 45  | 70    | 85    | 95    |
| 예측값           | F   | C     | B     | A     |
| 결과값           | F   | C     | B     | A     |

**답:** 동등분할 테스트  

---

**해설:**  
이 테스트는 입력값을 몇 개 구간(예: 0~59, 60~79, 80~89, 90~99)으로 나눈 다음,  
각 구간에서 대표 숫자(예: 45, 70 등)만 골라서 결과가 맞는지 확인하고 있어.  
즉, "입력값 전체를 다 테스트하기 어렵지만, 비슷한 그룹 중 한 개씩만 딱 뽑아서 확인하자!" 하는 방식이야.  
이게 바로 **동등 분할 테스트(Equal Partitioning Test)** 라고 불려.

---

📌 **관련 개념 설명:**

## ✅ 블랙박스 테스트 (Black Box Testing)  
- 프로그램 내부는 몰라도, 입력과 출력 결과만 보고 테스트하는 방법  
- 주로 요구사항에 맞춰서 케이스를 만듦

### 🔹 주요 블랙박스 테스트 기법 (동경원오비)  

| 테스트 기법             | 설명                                              |
|------------------------|---------------------------------------------------|
| **동등 분할 기법**       | 입력을 ‘유효’ 또는 ‘무효’ 같은 비슷한 그룹으로 나누고, 각 그룹에서 대표값만 테스트함 |
| **경계값 분석 기법**     | 입력값의 최소, 최대, 경계 바로 안팎 값을 집중 테스트함            |
| **원인-효과 그래프 기법** | 입력 조건과 출력 조건 간 논리 관계를 분석해 테스트 케이스 생성       |
| **오류 예측 기법**       | 경험과 직관으로 에러 발생 가능성이 높은 입력값을 집중 테스트함       |
| **비교 검사 기법**       | 여러 버전 프로그램에 같은 입력을 주고 결과를 비교해 이상 여부 확인   |

---

💡 쉽게 말하면,  
> 시험 공부할 때 모든 문제를 다 풀기 힘드니까, 비슷한 문제 유형에서 한 문제씩 골라서 푸는 것과 같아!  
> 이게 바로 동등 분할 테스트 방식이야.

---

📌 **추가 팁:**  
- 만약 경계(예: 59, 60, 79, 80 등) 주변 숫자를 집중적으로 테스트하면, 그건 경계값 분석 기법임!



----------------------------------------------------------------------------------

### 📘 문제 5) `<학생>` 테이블을 대상으로 `<요구사항>`을 적용하여 아래 `<결과>`와 같이 출력하는 SQL 문을 작성하시오.

---

#### 🗃️ <학생> 테이블

| 학번     | 이름 | 학과   | 성적 | 주소 |
|----------|------|--------|------|------|
| 2020021  | 철수 | 전기   | 90   | 서울 |
| 2020001  | 민수 | 컴퓨터 | 70   | 대전 |
| 2021022  | 영희 | 건축   | 85   | 서울 |
| 2022013  | 민호 | 건축   | 95   | 원주 |
| 2020007  | 병희 | 컴퓨터 | 100  | 울산 |

---

#### 🎯 <결과>

| 학과   | 학과별 튜플수 |
|--------|---------------|
| 전기   | 1             |
| 컴퓨터 | 2             |
| 건축   | 2             |

---

#### 📌 <요구사항>
1. **WHERE** 구문을 사용하지 않고 SQL문을 작성하시오.  
2. **GROUP BY 구문과 집계 함수**를 반드시 사용하시오.  
3. 인용문구 사용 시 작은따옴표(`'`) 사용 가능.  
4. **AS 구문은 반드시 사용**하여 작성하시오.  

---

### ✅ 답안 SQL

```sql
SELECT 학과, COUNT(*) AS 학과별튜플수
FROM 학생
GROUP BY 학과;

### 답안 해설:

- 문제에서 **WHERE 절을 쓰지 말라**고 했으니, 조건 없이 전체 데이터를 대상으로 해야 함.

- 대신 **GROUP BY 구문과 집계 함수**를 써야 하니까,  
  학생 테이블에서 `학과`별로 데이터를 묶고(`GROUP BY 학과`),  
  각 학과에 몇 명이 있는지 세는 함수인 `COUNT(*)`를 썼어.

- `COUNT(*) AS 학과별튜플수`는 각 학과별 학생 수를 "학과별튜플수"라는 이름으로 보여준다는 뜻.

---

### 쉽게 이해하자면:  
- "학생들 중에서 학과별로 몇 명씩 있는지 알려줘!"라는 질문을 한 거야.  
- 조건 없이 그냥 전부 다 보고, 학과별로 그룹 묶고 학생 수 세는 거지.  
- WHERE가 없으니까 조건을 걸지는 않았고, GROUP BY와 COUNT가 핵심!  
- AS는 결과에 멋진 이름(별칭)을 붙여서 더 보기 쉽게 해준 것뿐임.

---

### 한 문장 요약:  
> 학생들을 학과별로 묶어서 각 학과에 몇 명이 있는지 세는 SQL 문이다.


----------------------------------------------------------------------------------
### 📘 문제 6) 스니핑에 대하여 간략히 서술하시오.

**답:**  
네트워크상에 통과되는 패킷들의 내용을 엿보는 행위이다.

---

### 📌 관련 개념 설명

### 존나 쉽고 직관적인 스니핑 설명

- **스니핑이 뭐냐면?**  
  네트워크에서 오가는 데이터들을 몰래 엿보는 거야.  
  마치 길거리에서 누가 주고받는 쪽지를 몰래 보는 것과 같아.

- **누가 해?**  
  - 네트워크 관리자나 보안 전문가: 문제를 찾거나 네트워크 상태를 확인하려고  
  - 나쁜 놈(해커): 중요한 정보(비밀번호, 개인정보)를 훔치려고

- **주로 쓰는 도구**  
  - 와이어샤크(Wireshark): 네트워크 속 데이터 쪼개서 보여줌  
  - tcpdump: 커맨드라인에서 빠르게 스니핑 가능

- **왜 위험하냐?**  
  비밀번호나 중요한 데이터가 암호화 없이 흘러다니면, 해커가 쉽게 훔칠 수 있음.

- **어떻게 막아?**  
  - 데이터 암호화(HTTPS, VPN 등) → 쪽지를 암호로 써서 엿보여도 못 읽게  
  - 네트워크에 허락받은 사람만 들어오게 막기  
  - 이상한 트래픽 있으면 바로 감지하는 시스템 운영

---

### 쉽게 비유하자면  
> 길에서 친구가 쪽지로 이야기하는데, 스니핑은 그 쪽지를 몰래 훔쳐보고 읽는 행위다.  
> 그래서 중요한 쪽지는 암호로 써서 아무도 못 읽게 하는 거지!


----------------------------------------------------------------------------------

### 📘 문제 7) 정보보안의 3요소 중 가용성에 대해 서술하시오.

**답:**  
인가된 사용자가 정보를 요구할 때 적시에 제공되어야 하는 원칙이다.

---
### 존나 쉽고 직관적인 정보보안 3요소 (CIA Triad) 설명

| 요소        | 쉽게 말하면                            | 예시 및 대책                        |
|-------------|-------------------------------------|------------------------------------|
| **기밀성**   | 내 정보는 내 것, 아무나 못 보게 막는 것 | 비밀번호, 암호화, 출입통제 (방화벽) |
| **무결성**   | 내 정보가 누가 멋대로 안 바꾸게 지키는 것 | 파일 변조 방지, 디지털 서명, 변경 기록 관리 |
| **가용성**   | 내가 필요할 때 언제든지 내 정보 쓸 수 있게 하는 것 | 서버 다운 방지, 백업, 장애 빠른 복구 |

---

### 가용성(Availability)을 쉽게 이해하면?

- 내 컴퓨터나 서비스가 갑자기 멈추거나 못 쓰면 답답하잖아?  
- 가용성은 바로 그런 상황이 안 생기도록 하는 거야.  
- 예를 들어, 인터넷이 끊기거나 서버가 죽으면 안 되니까  
  장애 대비, 공격 막기, 빠른 복구 시스템을 둬서 언제나 쓸 수 있게 만드는 원칙임.

---

### 한 줄 정리  
> 내 정보가 안전하게 보호되는 건 기본,  
> 필요한 순간에 바로 쓸 수 있어야 진짜 ‘안전한’ 정보다!


----------------------------------------------------------------------------------

### 📘 문제 8) 데이터베이스의 이상의 종류를 3가지 쓰시오.

**답:**  
- 삽입 이상 (Insertion Anomaly)  
- 삭제 이상 (Deletion Anomaly)  
- 갱신 이상 (Update Anomaly)  

---

### 📌 관련 개념 설명

- **이상(Anomaly)** 은 데이터 저장할 때 발생할 수 있는 골치 아픈 문제들이야.

---

1. **삽입 이상 (Insertion Anomaly)**  
   - 새 데이터 넣을 때 쓸데없는 정보도 같이 넣어야 해서 귀찮고 헷갈리는 상황  
   - 예) 학생이 아직 수강 과목 없는데도 과목 정보를 억지로 입력해야 할 때

2. **삭제 이상 (Deletion Anomaly)**  
   - 필요 없는 데이터를 지우다가 중요한 정보까지 같이 날아가 버리는 상황  
   - 예) 학생 정보를 지우면 그 학생 성적도 같이 없어져서 곤란할 때

3. **갱신 이상 (Update Anomaly)**  
   - 같은 정보가 여러 군데 저장돼 있는데, 한 군데만 바꾸면 나머지는 안 바뀌어 엉망이 되는 상황  
   - 예) 학생 주소를 한 군데만 바꿨는데 다른 테이블 주소는 안 바뀌어서 이상할 때

---

### 이상을 막으려면?

- **정규화(Normalization)** 라는 깔끔한 정리 작업을 해서  
- 데이터가 중복 안 되고, 헷갈리지 않게 테이블을 잘 나누는 게 중요해.

---

### 한 줄 요약  
> 데이터 꼬이지 않고 깔끔하게 관리하려면 이상 문제 꼭 피해야 한다!

---------------------------------------------------------------------------------- 

### 📘 문제 9) 데이터베이스 회복 기법에 관련된 설명에서 괄호에 들어갈 가장 알맞은 용어를 쓰시오.

---

다양한 데이터 회복 기법 중  
() 회복 기법은 로그를 이용한 회복기법으로 데이터베이스에 대한 갱신 로그를 저장함으로서 회복에 대비한다.  
() 회복 기법은 트랜잭션이 실행 상태에서 변경되는 내용을 그때그때 바로 데이터베이스에 적용하는 기법이다.  
() 회복 기법은 장애가 발생하면 로그 파일에 기록된 내용을 참조하여, 장애 발생 시점에 따라 REDO나 UNDO를 실행하여 데이터베이스를 복구한다.

---

**답:**  
1. 즉시 회복 (즉시 갱신)  
2. 즉시 갱신 (정확히는 즉시 적용 기법)  
3. ARIES 회복 기법  

---

### 📌 관련 개념 설명

### 존나 쉽고 직관적인 로그 기반 회복 & 병행 제어 설명 (업데이트)

---

#### 1. 로그 기반 회복 기법  
- 데이터베이스가 바뀔 때마다 **무조건 기록(로그)** 남김  
- 문제가 생기면 이 로그를 보고 **되돌리거나 다시 적용해서 복구**함  
- 대표적으로 두 가지 방식 있음:  
  - **즉시 갱신**: 바꾸자마자 바로 DB에 반영  
  - **지연 갱신**: 나중에 한꺼번에 DB에 반영  

---

#### 2. 즉시 갱신 (Immediate Update)  
- 변경 즉시 DB에 적용해서 실시간으로 반영됨  
- 문제 생기면 로그를 보고, 이미 적용한 내용은 되돌리고 안 된 건 다시 적용하는 방식으로 복구  
- 중간에 변경된 내용도 DB에 있으니까 관리가 좀 더 복잡함  

---

#### 3. ARIES 회복 기법  
- **분석(Analysis) → 재실행(REDO) → 되돌리기(UNDO)** 순으로 복구함  
- 엄청 믿을 만하고 효율적인 방법이라 많이 씀  

---

### 추가로 알아야 할 병행 제어(Concurrency Control)

- 여러 작업이 동시에 DB를 바꿀 때 생기는 문제를 막아줌  
- 문제 예시:  
  - **갱신 분실**: 누군가 변경한 내용을 덮어버림  
  - **비완료 의존성**: 아직 끝나지 않은 작업 결과에 의존함  
  - **모순성**: 데이터 일관성 깨짐  
  - **연쇄복귀**: 하나 문제가 생겨 여러 작업이 다 취소됨  

- 병행제어 방법 종류:  
  - **로킹**: 자물쇠 걸어서 한 번에 한 명만 작업하게 함  
  - **2단계 로킹**: 잠금 걸고 푸는 시점 조절해서 문제 최소화  
  - **타임스탬프**: 작업 순서 시간으로 정해서 처리  
  - **낙관적 제어**: 충돌 없을 거라 믿고 그냥 진행 후 문제 생기면 해결  
  - **다중 버전 병행 제어 (Multi-Version Concurrency Control, MVCC)**:  
    - 데이터의 여러 버전을 동시에 관리해서, 읽기 작업은 락 없이 과거 버전 참조  
    - 쓰기 작업은 새 버전 생성, 충돌 최소화하며 동시성 향상  

---

### 한 줄 요약  
> 로그에 다 기록해놓고, 문제 생기면 로그 보고 안전하게 복구!  
> 그리고 여러 작업이 겹치지 않게 조심조심 관리하는 게 병행 제어야!  
> MVCC 덕분에 읽을 땐 락 안 걸려서 더 빠르고 부드럽게 돌아간다!



----------------------------------------------------------------------------------

### 📘 문제 10) 다음 프로세스 상태 전이도의 빈칸 1~3에 알맞은 프로세스 상태를 각각 쓰시오.


         DISPATCH
생성 → (1) → (2) → 종료
↖ ← ↙ BLOCK
TIME RUN OUT
WAKE UP (3)

---

**답:**  
- (1) 준비 (Ready)  
- (2) 실행 (Running)  
- (3) 대기 (Blocked / Waiting)  

---

### 📌 관련 개념 설명

### 존나 쉽고 직관적인 프로세스 상태 전이도 설명

---

- 컴퓨터에서 프로그램이 실제로 **작업하는 과정**을 상태별로 나누어 생각하는 거야.

| 상태         | 쉽게 말하면 이런 상태야!                      |
|--------------|-------------------------------------------|
| **생성 (New)**     | "야, 나 시작할 거야!" 하고 프로그램이 만들어진 상태          |
| **준비 (Ready)**   | CPU 차례 기다리면서 대기하는 상태, 줄 서 있는 거랑 비슷해       |
| **실행 (Running)** | CPU를 받아서 실제로 일하는 중, 일하는 시간!                   |
| **대기 (Blocked)** | 입출력 같은 작업이 끝나길 기다리는 상태, 잠시 쉬는 타임         |
| **종료 (Terminated)** | 일 다 끝내고 프로그램이 완전히 끝난 상태                   |

---

- **상태 이동 쉽게 이해하기**

  - **생성 → 준비**: 새 프로그램이 만들어져서 CPU 받을 준비를 함  
  - **준비 → 실행**: CPU 차례가 되어 일 시작함  
  - **실행 → 종료**: 작업 다 끝나서 프로그램 종료  
  - **실행 → 대기**: 프린터 출력이나 파일 읽기 같은 입출력 작업 때문에 잠깐 쉼  
  - **대기 → 준비**: 입출력 끝나서 다시 CPU 차례 기다림  
  - **실행 → 준비**: 정해진 시간 다 써서 잠깐 멈추고, 다시 CPU 받을 준비  

---

### 한 줄 요약  
> 프로그램은 '만들어짐 → 줄 서서 대기 → 일함 → 잠깐 쉬거나 → 다시 줄 서거나 → 끝남' 이렇게 움직인다고 보면 됨!


----------------------------------------------------------------------------------

### 📘 문제 11) 다음 설명에 해당하는 용어를 쓰시오.

- IPv4의 주소 고갈 문제를 해결하기 위하여 기존의 IPv4 주소 체계를 128비트 크기로 확장한 차세대 인터넷 프로토콜 주소  
- 헤더의 내용을 확인하는데 소요되는 오버헤드를 최소화하도록 설계  
- 16비트씩 8부분, 총 128비트로 구성되며, 콜론(:)으로 구분한다.  
- 주소 분류로 유니캐스트, 멀티캐스트, 애니캐스트를 사용한다.

---

### IPv4 / IPv6 전환 기술  
- **듀얼 스택(Dual Stack)**: IPv4와 IPv6를 동시에 지원하여 두 프로토콜 패킷을 주고받을 수 있음  
- **터널링(Tunneling)**: 두 IPv6 네트워크 간 터널을 이용, IPv6 패킷을 IPv4 패킷에 캡슐화하여 전송  
- **주소 변환(Address Translation)**: IPv4와 IPv6 간 주소 변환으로 두 버전 연동

---

### 답: IPv6 (Internet Protocol Version 6)

---

### 📌 관련 개념 설명

### 존나 쉽고 직관적인 IPv4 vs IPv6 설명

---

- **IPv4**  
  - 주소가 32비트라 약 43억 개 정도만 주소를 만들 수 있어.  
  - 그래서 점점 주소가 모자라지는 문제 발생!  
  - 예) 192.168.0.1 같은 숫자 조합

- **IPv6**  
  - 주소 길이가 128비트로 훨씬 길어서 엄청 많은 주소를 만들 수 있어 (약 3.4×10^38개!)  
  - 주소 표기는 16비트씩 8개 블록을 콜론(:)으로 구분함  
  - 예) 2001:0db8:85a3::8a2e:0370:7334  
  - 더 빠르고 효율적 처리, 보안 기능도 강화됨  
  - 유니캐스트(한 명에게), 멀티캐스트(특정 그룹에게), 애니캐스트(가장 가까운 한 명에게) 주소 지원

- **IPv4와 IPv6 공존할 때 쓰는 기술**  
  - **듀얼 스택**: 한 장비에 IPv4, IPv6 둘 다 켜놓기  
  - **터널링**: IPv6 데이터를 IPv4 네트워크 안으로 포장해 보내기  
  - **주소 변환**: IPv4 주소를 IPv6 주소로 바꾸거나 반대로 바꾸기  

---

### 한 줄 요약  
> IPv4는 주소가 모자라서 IPv6로 업그레이드했고, 둘이 같이 쓸 때 문제 없게 하는 여러 기술도 있다!


---

----------------------------------------------------------------------------------

### 📘 문제 12) 다음 설명에 해당하는 운영체제를 적으시오.

- 1960년대 말 벨 연구소에서 개발된 운영체제로 다중 사용자, 멀티태스킹 운영체제이다.  
- 대부분 C언어로 작성되어 있어 이식성이 높다.  
- 트리 구조의 파일 시스템을 갖는다.

---

### 답: 유닉스 (UNIX)

---

### 📌 관련 개념 설명

### 존나 쉽고 직관적인 UNIX 설명

---

- **유닉스(UNIX)**는 1969년에 AT&T 벨 연구소에서 만들어진 운영체제야.  
- 여러 사람이 동시에 쓸 수 있고(다중 사용자), 여러 작업을 한꺼번에 처리할 수 있어(다중 작업).  
- 대부분 C언어로 만들어져서, 여러 종류의 컴퓨터에 쉽게 옮겨 쓸 수 있어.  
- 파일이 폴더 속 폴더처럼 트리 구조로 정리되어 있어서 찾기 편해.  
- ‘쉘(Shell)’이라는 명령어 창과 여러 유틸리티 프로그램으로 컴퓨터를 편하게 조작할 수 있어.  
- 지금 우리가 쓰는 리눅스, 맥OS 같은 운영체제들의 뿌리가 바로 이 UNIX임!

---

### 한 줄 요약  
> UNIX는 여러 사람이 동시에 편하게 쓸 수 있게 만든 강력한 운영체제의 원조다!



----------------------------------------------------------------------------------
### 📘 문제 13) 다음 설명에 해당하는 용어를 쓰시오.

- 정형 데이터 및 사진, 영상 등의 비정형 데이터를 효과적으로 처리하는 오픈소스 빅데이터 솔루션이다.  
- 많은 양의 데이터를 여러 대의 범용 컴퓨터에 나눠서 저장하고 처리한다.  
- 더그 커팅(Doug Cutting)과 마이크 캐퍼랠라(Mike Cafarella)가 개발했으며, 구글의 맵리듀스(MapReduce) 엔진을 사용한다.

---

### 답: Hadoop

---

### 📌 빅데이터 관련 용어 설명

--

- **빅데이터 (Big Data)**  
  엄청나게 많은 데이터 덩어리! 정형이든 비정형이든 모아서 의미 있는 정보를 뽑아내는 기술.

- **Hadoop**  
  빅데이터 처리할 때 쓰는 오픈소스 기술.  
  여러 컴퓨터에 데이터를 나눠 저장하고, 동시에 처리하는 멋진 시스템.  
  - HDFS: 데이터 저장소  
  - MapReduce: 데이터 처리 방법  
  - 문제 생겨도 걱정 끝, 튼튼하고 확장 잘됨.

- **NoSQL**  
  기존 관계형 DB랑 다르게 자유롭게 데이터를 저장하고 다룰 수 있는 DB.  
  대량 데이터랑 비정형 데이터에 딱 맞음.

- **데이터 마이닝 (Data Mining)**  
  데이터 속에 숨은 규칙이나 패턴을 컴퓨터가 쏙쏙 찾아내는 과정.

- **데이터 웨어하우스 (Data Warehouse)**  
  여러 시스템에서 모은 데이터를 한 곳에 모아서 정리한 큰 데이터 창고.

- **데이터 마트 (Data Mart)**  
  데이터 웨어하우스에서 필요한 부분만 쏙 뽑아 만든 작은 데이터 창고.

- **OLAP (Online Analytical Processing)**  
  사용자가 직접 데이터를 뒤져보고 분석해 문제점이나 답을 찾는 똑똑한 도구.

- **매시업 (Mashup)**  
  여러 웹 서비스나 정보를 섞어서 새로운 서비스나 앱을 만들어내는 기술.

---

### 한 줄 요약  
> 빅데이터는 엄청난 데이터를 잘 모으고, 빠르게 분석해서 유용한 정보로 바꾸는 모든 기술과 도구들의 집합이다!


----------------------------------------------------------------------------------
### 📘 문제 14) 다음 설명에 해당하는 용어를 쓰시오.

관리 대상 데이터를 '블록'이라고 하는 소규모 데이터 단위로 나누어, P2P(peer-to-peer) 방식을 기반으로 생성된 체인 형태의 연결고리 기반 분산 데이터 저장 환경에 저장한다.  
누구라도 임의로 수정할 수 없고, 누구나 변경 결과를 열람할 수 있는 분산 컴퓨팅 기술 기반의 원장 관리 기술이다.

---

### 답: 블록체인 (Blockchain)

---

### 📌 관련 개념 설명

### 존나 쉽고 직관적인 블록체인 개념 설명

- **블록체인(Blockchain)**  
  데이터를 작은 상자(블록)로 나눠서 줄줄이 연결(체인)한 분산 저장 방식임.  
- 이 상자들은 P2P 네트워크에 참여하는 모두가 함께 가지고 있어서,  
  아무도 몰래 바꿀 수 없고, 다 같이 내용이 맞는지 확인함.  
- 중앙 관리자 없이 모두가 신뢰하는 투명한 장부 같은 시스템임.  
- 암호 기술과 합의 규칙(예: 작업증명, 지분증명)을 써서 안전하게 지킴.  
- 암호화폐(비트코인 등), 스마트 계약, 금융, 물류 등 여러 곳에서 쓰임.

---

### 한줄 요약  
> 블록체인은 모두가 공유하는 안전한 디지털 장부로, 속임수 없이 데이터를 기록하고 관리하는 기술이다!

----------------------------------------------------------------------------------

### 📘 문제 15) 다음을 설명하는 용어를 쓰시오.

- 우리나라 말로 번역하면 '네트워크 주소 변환'이라는 의미  
- 내부에서 사용하는 사설 IP 주소와 외부로 보여지는 공인 IP 주소 간의 IP 주소 변환 방식을 말한다.  
- 한정된 공인 IP를 여러 개의 내부 사설 IP로 변환하기 위해 사용하는 기술  

---

### 답: NAT (Network Address Translation)

---

### 📌 관련 개념 설명

- **NAT (Network Address Translation)**  
  - 사설 네트워크 내의 여러 기기가 하나 또는 소수의 공인 IP 주소를 공유하여 인터넷에 접속할 수 있도록 IP 주소를 변환하는 기술  
  - 사설 IP 주소를 공인 IP 주소로 매핑하여 내부 네트워크와 외부 인터넷 간의 통신을 중개  
  - IPv4 주소 부족 문제 완화에 기여  
  - 종류  
    - Static NAT: 사설 IP와 공인 IP를 1:1로 매핑  
    - Dynamic NAT: 사설 IP를 사용 가능한 공인 IP 풀 중 하나에 매핑  
    - PAT (Port Address Translation, 또는 NAT Overload): 하나의 공인 IP를 여러 사설 IP가 포트 번호를 달리하여 공유  

### 존나 쉽고 직관적인 NAT 예시

- 집에서 여러 명이 각자 컴퓨터나 스마트폰을 쓰는데,  
- 집 밖에 나가면 우리 집 주소(공인 IP)는 한 개뿐이야.  
- NAT는 마치 집 주소 한 개로 여러 명의 내부 방(사설 IP)에서 나오는 편지를 구분해서 배달해주는 우체국 같은 역할이야.  
- 각 방에서 보낸 편지에 특별한 방 번호(포트 번호)를 붙여서, 외부에선 집 주소 하나지만 누가 보냈는지 알 수 있지!  
- 덕분에 IP 주소가 부족한 세상에서 많은 기기가 인터넷을 쓸 수 있어.

---

### 한 줄 요약  
> NAT는 집 주소 한 개로 여러 방에서 온 편지를 구분해주는 똑똑한 우체국이다!



----------------------------------------------------------------------------------

### 📘 문제 16) 다음은 C언어로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

void main()
{
    char *p = "KOREA";                   // char 포인터 p에 문자열 "KOREA"의 첫 글자 주소를 저장.
                                               // 쉽게 말해 p는 'K'를 가리키고 있음. 문자열은 배열처럼 연속적으로 저장됨.

    printf("%s\n", p);                     // p가 가리키는 곳부터 널 문자('\0')를 만날 때까지 문자열을 출력.
                                           // p는 "KOREA"의 시작이니까, "KOREA" 전체가 나옴.
                                                       // 출력: KOREA

    printf("%s\n", p+3);                       // p에서 3칸 뒤로 이동한 주소부터 문자열을 출력.
                                                  // p는 'K'를 가리키고, p+1은 'O', p+2는 'R', p+3은 'E'를 가리킴.
                                                    // 'E'부터 널 문자까지니까 "EA"가 나옴.
                                                      // 출력: EA

    printf("%c\n", *p);                         // p가 가리키는 곳의 '값'을 문자 하나로 출력.
                                               // p는 'K'를 가리키니까 'K'가 나옴.
                                                   // 출력: K

    printf("%c\n", *(p+3));                               // p에서 3칸 뒤로 이동한 곳의 '값'을 문자 하나로 출력.
                                                           // p+3은 'E'를 가리키니까 'E'가 나옴.
                                                             // 출력: E

    printf("%c\n", *p + 2);                                   // p가 가리키는 곳의 '값'('K')에 2를 더한 후 문자로 출력.
                                                             // 아스키 코드에서 'K'는 75임. 여기에 2를 더하면 77이 되고,
                                                                 // 아스키 코드 77은 'M'을 나타냄.
                                                                 // 출력: M
}

📌 해설
p는 문자열 "KOREA"의 시작 주소를 가리킨다.

printf("%s\n", p);
문자열 전체 출력 → "KOREA"

printf("%s\n", p+3);
p+3은 문자열의 4번째 문자부터 시작, 즉 "E A" 중 'E'부터 → "EA"

printf("%c\n", *p);
*p는 첫 문자 'K' 출력

printf("%c\n", *(p+3));
*(p+3)는 4번째 문자 'E' 출력

printf("%c\n", *p + 2);
*p는 'K'의 ASCII 코드 75 + 2 = 77 → 문자 'M' 출력

### 핵심 정리

- 이 문제는 포인터 연산이랑 문자열/문자 출력 방식, 그리고 아스키 코드 개념을 다 알고 있냐고 물어보는 거였어.

- `%s`와 `%c`: 각각 문자열과 단일 문자를 출력할 때 쓴다는 거.

- `p`와 `*p`: `p`는 주소(어디를 가리키는지), `*p`는 그 주소에 있는 값(무엇을 가리키는지)이라는 거.

- 포인터에 정수 더하기: `p+3`처럼 포인터에 숫자를 더하면 그 데이터 타입 크기만큼 주소가 이동한다는 거 (여기선 char니까 1바이트씩 이동).

- 문자와 정수 연산: 문자에 정수를 더하면 아스키 코드 값으로 변환돼서 연산되고, 다시 문자로 출력된다는 거.


----------------------------------------------------------------------------------
### 📘 문제 17) 다음 JAVA 프로그램을 분석하여 빈칸 1~2에 들어갈 내용을 각각 쓰시오.

public static void main(String[] args) {
    int[][] arry = new int[(1)][(2)];                                     // 여기 (1)과 (2) 빈칸
    for (int i = 0; i < 3; i++) {                                     // i는 0, 1, 2까지 돈다. 즉, 3개의 행이 필요
        for (int j = 0; j < 5; j++) {                         // j는 0, 1, 2, 3, 4까지 돈다. 즉, 5개의 열이 필요
            arry[i][j] = j * 3 + (i + 1);
            System.out.print(arry[i][j] + "");
        }
        System.out.println();
    }
}

답
(1) 3

(2) 5

📌 해설
for (int i = 0; i < 3; i++) 이 부분 때문에 i는 0, 1, 2까지 총 3번 반복해.  
배열의 인덱스는 0부터 시작하니까, arry[0], arry[1], arry[2]까지 있어야 안전하게 접근할 수 있어.  
따라서 **행의 개수(첫 번째 빈칸)**는 최소한 3이 필요하다.

for (int j = 0; j < 5; j++) 이 부분 때문에 j는 0, 1, 2, 3, 4까지 총 5번 반복해.  
마찬가지로 배열의 인덱스는 0부터 시작하니까, arry[i][0]부터 arry[i][4]까지 있어야 해.  
따라서 **열의 개수(두 번째 빈칸)**는 최소한 5가 필요하다.

✅ 최종 답안  
그러니 빈칸에는 다음과 같이 들어가야 코드가 에러 없이 잘 돌아간다.

(1) 3

(2) 5

이렇게 바꾸면 new int[3][5] 배열이 만들어지고, 3행 5열의 크기로 for 문 안에서 모든 인덱스에 접근 가능해진다.

----------------------------------------------------------------------------------

### 📘 문제 18) 아래 <처리 결과>처럼 10진수를 2진수로 변환해주는 프로그램이다.  
java 프로그램의 빈칸 1~2에 들어갈 java 구문을 쓰시오.

---

#### <처리 결과>  
00001010

---

#### 문제 코드 일부

public class DecimalToBinary {
    public static void main(String[] args) {
        int a[] = new int[8];                                                 // 2진수 8자리를 저장할 배열을 만든다.
        int i = 0, n = 10;                                                // i는 배열 인덱스, n은 10진수 값 (여기서는 10)

        while (i < a.length) {                                                 // (1) 여기에 'i < a.length'가 들어가야 됨.
                                                                               // 배열의 끝(a.length, 즉 8)에 도달할 때까지 반복하라는 조건이다.
                                                                               // 10진수를 2진수로 변환할 때 보통 8비트를 기준으로 하니, 8번 반복해야겠지.
                                                                               // 아니면 'n이 0이 될 때까지' 반복하는 것도 가능하지만, 여기서는 배열에 채우는 거니 'i < a.length'가 더 적절하다.
            a[i++] = n % 2;                                                // (2) 여기에 'n % 2'가 들어가야 됨.
                                                                               // 10진수를 2진수로 바꿀 때, 해당 숫자를 2로 나눈 '나머지'가 2진수의 각 자리가 된다.
                                                                               // 예를 들어 10을 2로 나누면 나머지가 0, 몫이 5.
                                                                               // 5를 2로 나누면 나머지가 1, 몫이 2.
                                                                               // 이런 식으로 반복해서 2진수를 얻는 거지.
                                                                               // 'i++'는 값을 넣고 나서 i를 1 증가시키는 거다.
            n /= 2;                                                            // 다음 계산을 위해 n을 2로 나눈 몫으로 업데이트한다.
        }
                                                                      
                                                                              // 배열 a에 저장된 값:
                                                                              // n=10: a[0] = 10 % 2 = 0
                                                                              // n=5 : a[1] = 5 % 2 = 1
                                                                              // n=2 : a[2] = 2 % 2 = 0
                                                                              // n=1 : a[3] = 1 % 2 = 1
                                                                              // n=0 : a[4] = 0 % 2 = 0
                                                                              // n=0 : a[5] = 0 % 2 = 0
                                                                              // n=0 : a[6] = 0 % 2 = 0
                                                                              // n=0 : a[7] = 0 % 2 = 0
                                                                              // 최종적으로 배열 a는 [0, 1, 0, 1, 0, 0, 0, 0]이 된다. (인덱스 순서)

        for (i = 7; i >= 0; i--)                                                 // 배열을 역순으로 돌면서 출력한다.
                                                                     // 2진수는 나머지를 역순으로 읽어야 제대로 된 값이 나오거든.
                                                                     // 10진수 10의 2진수는 1010인데, 위에서 저장된 순서는 0101이니까 역순으로 출력해야 함.
            System.out.printf("%d", a[i]);                           // 각 자릿수를 출력한다.
                                                                    // 출력: 00001010
    }

📌 해설
최종 정리  
빈칸 (1) i < a.length: while문의 반복 조건으로, 배열 a의 모든 8칸을 채울 때까지 루프를 돌게 해준다.
무한 루프를 막고 배열 인덱스 범위를 넘지 않게 하는 중요한 부분이지.

빈칸 (2) n % 2: 10진수를 2진수로 변환하는 핵심 로직이야.
 숫자를 2로 나눈 나머지가 2진수의 각 비트가 된다는 걸 이용한 거다.

덕분에 10진수 10이 2진수 00001010으로 깔끔하게 변환되는 것을 볼 수 있음. 완벽하다!

 ----------------------------------------------------------------------------------

### 📘 문제 19) 다음은 java로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

class Parent {                                                 // 부모 클래스 Parent
    int com(int num) {                                   // Parent 클래스의 com 메소드 (피보나치 수열 형태)
        if (num <= 1)
            return num;
        return com(num - 1) + com(num - 2);                                               // F(n) = F(n-1) + F(n-2)
    }
}

class Child extends Parent {                                                                 // 자식 클래스 Child. Parent를 상속받았다.
    @Override                                                                   // 이거 붙으면 부모 메소드를 재정의했다는 뜻.
    int com(int num) {                                               // Child 클래스도 com 메소드를 가지고 있지만, 내용은 부모랑 다르다.
        if (num <= 1)
            return num;
        return com(num - 1) + com(num - 3);                                               // 여기가 핵심! 계산식이 다르다.
                                                                                            // F(n) = F(n-1) + F(n-3)
    }
}

// ---- main 메소드 안의 실행 부분 ----
Parent obj = new Child();                                       // 이 부분이 제일 중요함!
                                                                // 'obj'는 'Parent' 타입으로 선언됐지만, 실제로 만들어진 객체는 'Child'다.
                                                                // 이걸 '다형성'이라고 부른다.
                                                                // 즉, obj는 Parent처럼 보이지만 실제로는 Child의 기능을 쓴다는 거지.

System.out.print(obj.com(4));                             // obj.com(4)를 호출할 때, obj가 Child 객체이기 때문에
                                                        // Child 클래스에 **오버라이딩**된 com 메소드가 실행된다.

답: 1



📌 해설

obj.com(4) 계산 과정 (Child 클래스 로직으로)  
이제 Child 클래스의 com(int num) 메소드 로직을 이용해서 com(4)를 계산해보자.  
Child 클래스의 com 메소드는  
```java
if (num <= 1) return num;
return com(num - 1) + com(num - 3);
이다.

com(4) 호출
com(4) = com(3) + com(1)

com(1) 계산
num이 1이므로, if (num <= 1) 조건에 맞아 return num (즉, 1)을 반환한다.

com(3) 계산
com(3) = com(2) + com(0)

com(0) 계산
num이 0이므로, if (num <= 1) 조건에 맞아 return num (즉, 0)을 반환한다.

com(2) 계산
com(2) = com(1) + com(-1)

com(1) (재계산) & com(-1) 계산
com(1)은 위에서 봤듯이 num이 1이므로, return num (즉, 1)을 반환한다.
com(-1)은 num이 -1이므로, if (num <= 1) 조건에 맞아 return num (즉, -1)을 반환한다.
(참고: 보통 이런 재귀 함수에서 음수 인덱스는 0으로 처리하는 경우가 많지만, 이 문제에서는 num <= 1일 때 num을 그대로 반환한다고 명시했으니 그대로 따른다.)

모든 값 합치기
com(2) = com(1) + com(-1) = 1 + (-1) = 0
com(3) = com(2) + com(0) = 0 + 0 = 0
com(4) = com(3) + com(1) = 0 + 1 = 1

최종 결과
따라서 System.out.print(obj.com(4));를 실행하면 1이 출력된다.

이 문제는 자바의 다형성 덕분에 부모 타입의 참조 변수(Parent obj)를 쓰더라도,
실제 객체(new Child())가 무엇인지에 따라 호출되는 메소드가 달라진다는 점을 잘 보여준다.
그리고 재귀 함수의 로직을 정확하게 추적하는 능력을 요구하는 문제였다.

----------------------------------------------------------------------------------
### 📘 문제 20) 다음은 Python 언어로 작성된 프로그램이다. 이를 실행한 출력 결과를 쓰시오.

```python
lol = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
print(lol[0])
print(lol[2][1])
for sub in lol:
    for item in sub:
        print(item, end=" ")
    print()

답

[1, 2, 3]
7
1 2 3 
4 5 
6 7 8 9


📌 해설
lol = [[1, 2, 3], [4, 5], [6, 7, 8, 9]] # lol은 3개의 서브 리스트를 가진 리스트임.
                                        # lol[0]은 [1, 2, 3]
                                        # lol[1]은 [4, 5]
                                        # lol[2]는 [6, 7, 8, 9]

print(lol[0])

- `lol[0]`은 `lol` 리스트의 첫 번째 요소를 뜻한다.  
- 첫 번째 요소는 `[1, 2, 3]`이라는 또 다른 리스트다.  
- 그래서 `[1, 2, 3]`이 그대로 출력된다.

---

print(lol[2][1])

- 이건 2차원 인덱싱이라고 부른다.  
- `lol[2]`는 `lol` 리스트의 세 번째 요소를 의미한다. 세 번째 요소는 `[6, 7, 8, 9]`라는 리스트다.  
- 그 다음에 붙은 `[1]`은 그 `[6, 7, 8, 9]` 리스트의 두 번째 요소를 뜻한다.  
- 6이 첫 번째(인덱스 0), 7이 두 번째(인덱스 1)다.  
- 그래서 **7**이 출력된다.

---

for sub in lol:  
  for item in sub:  
    print(item, end=" ")  
print()

- 이 코드는 중첩 반복문이다. 중첩 리스트의 모든 요소를 하나씩 꺼내서 출력할 때 쓰는 방식이다.

- 바깥 for 문 (`for sub in lol:`)은 `lol` 리스트를 하나씩 순회한다.  
  - 첫 번째 반복: `sub`는 `[1, 2, 3]`이 된다.  
  - 두 번째 반복: `sub`는 `[4, 5]`가 된다.  
  - 세 번째 반복: `sub`는 `[6, 7, 8, 9]`가 된다.

- 안쪽 for 문 (`for item in sub:`)은 현재 `sub` 리스트의 각 `item`을 하나씩 순회한다.  
- `print(item, end=" ")`: `item`을 출력하고, 기본 줄 바꿈 대신 공백 한 칸을 넣어 같은 줄에 이어서 출력한다.  
- `print()`: 안쪽 for 문이 끝나면 (즉, 하나의 서브 리스트 출력이 끝나면) 줄 바꿈을 한다.

- 이 과정이 반복되면서 다음과 같이 출력된다.


