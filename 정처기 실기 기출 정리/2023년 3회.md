\## 문제 1


\### 문제

아래에서 설명하는 용어를 보기에서 골라 답안을 작성하시오.


> 인터넷 사용자가 웹사이트나 애플리케이션에 비밀번호를 공개하지 않고도 정보를 다른 웹사이트에서 안전하게 접근할 수 있도록 허용하는 개방형 표준이다.  
> 예를 들어 한 웹사이트에서 다른 서비스에 로그인할 때 사용자의 비밀번호를 직접 입력하지 않고도 서비스 간에 안전하게 권한을 부여할 수 있다.
> 서드파티 애플리케이션이 사용자의 비밀번호에 접근하지 않고도 서비스 간에 데이터를 안전하게 공유할 수 있도록 한다.  
> 소셜 미디어 로그인, 데이터 공유 API, 클라우드 서비스 등 다양한 분야에서 널리 사용되고 있다.



\### 답:

\*\*OAuth\*\*


\### 📌 관련 개념 설명

#### ✅ OAuth (Open Authorization)
- **개방형 표준**으로, 제3자(서드파티) 애플리케이션이 **사용자의 비밀번호를 직접 알지 않고도** 자원에 제한된 접근 권한을 부여받을 수 있도록 한다.
-  대표적인 예: **페이스북/구글 로그인**, **카카오/네이버 로그인**
-  
- **토큰 기반 인증** 방식으로, 액세스 토큰(access token)을 이용해 사용자의 자원에 접근한다. 보통 다음의 흐름으로 동작:  
  1. 사용자가 서비스 A(서드파티 앱)에서 서비스 B(자원 소유 서비스)에 로그인 요청  
  2. 서비스 B는 사용자에게 로그인 화면 제공  
  3. 로그인 후 사용자는 서비스 A가 특정 자원에 접근하도록 **허가**  
  4. 서비스 B는 액세스 토큰을 서비스 A에 전달  
  5. 서비스 A는 이 토큰으로 서비스 B의 API에 접근


#### ✅ 관련 인증 방식 정리
- **계정 정보를 요청 헤더에 넣는 방식**: Basic 인증 등  
- **Cookie/Session 방식**: 서버에 세션 저장, 클라이언트는 쿠키로 세션 ID 보관  
- **JWT (JSON Web Token)**: 토큰 기반 인증, 클라이언트가 자체적으로 인증 정보 보관  
- **OAuth**: **제한된 자원 접근 권한 위임**, 토큰 기반  
- **SSO (Single Sign-On)**: 한 번의 인증으로 여러 시스템 접근 가능  
- **Kerberos**: 네트워크 상에서 안전하게 인증을 제공하는 프로토콜  
- **아이핀(i-PIN)**: **주민등록번호 대체** 인증 수단


#### ✅ AAA (Authentication, Authorization, Accounting)
- **Authentication (인증)**: 사용자가 누구인지 확인  
- **Authorization (권한 부여)**: 사용자에게 어떤 서비스를 사용할 권한이 있는지 확인  
- **Accounting (계정 관리)**: 사용자의 자원 사용 기록 수집 및 분석


------------------------------------------------------------------------


\## 문제 2


리눅스에서 사용자에게 \*\*읽기/쓰기/실행 권한\*\*을 부여하고,  
그룹에는 \*\*읽기/실행 권한\*\*을 부여하고,  
그 외(기타 사용자)에는 \*\*실행 권한만\*\*을 `text.txt` 파일에 부여하고자 한다.  

명령어를 포함해서 알맞은 답안을 작성하시오.


\### 답:
\*\*chmod 751 text.txt\*\*

---

### 📌 chmod 명령어 핵심 정리

- `chmod`는 파일이나 폴더에 **읽기, 쓰기, 실행 권한**을 숫자로 설정하는 명령어다.  
- 권한 숫자: 읽기(r) = 4, 쓰기(w) = 2, 실행(x) = 1  
- 3자리 숫자는 **소유자**, **그룹**, **기타 사용자** 순서로 권한 합을 나타낸다.

---

### 예시: `chmod 751 파일명`

| 사용자 | 권한           | 숫자 계산  | 설명                          |
|--------|----------------|------------|-------------------------------|
| 소유자 | 읽기+쓰기+실행 | 4 + 2 + 1 = 7 | 파일 주인 마음대로 다 가능        |
| 그룹   | 읽기 + 실행    | 4 + 0 + 1 = 5 | 읽고 실행은 가능, 수정은 불가     |
| 기타   | 실행만         | 0 + 0 + 1 = 1 | 실행만 가능, 읽기/쓰기 불가       |

---

### 핵심!  
`chmod 751 파일명` 한 줄로  
- 소유자는 다 하고  
- 그룹은 읽고 실행만 하고  
- 기타는 실행만 할 수 있게 권한 설정 완료!

---------------------------------------------------------

\## 문제 3

두 테이블을 이용하여 `UNION` 연산을 수행하였다.  
결과값을 **표 형태**로 작성하시오.  
(*타이틀은 포함하지 않아도 된다*)

SELECT A FROM T1
UNION
SELECT B FROM T2
ORDER BY A DESC;


<T1>

| A |
|---|
| 4 |
| 1 |
| 3 |

<T2>

| B |
|---|
| 4 |
| 2 |
| 3 |


답:
4
3
2
1



📌 관련 개념 설명

✅ UNION  
- 두 개의 SELECT 결과를 합쳐서 중복을 제거한 후 반환  
- 기본적으로 중복된 값은 하나만 표시  
- 각 SELECT 문의 열 개수와 타입이 동일해야 함  

✅ 실행 과정 분석  
- `SELECT A FROM T1`  
  → 결과: 4, 1, 3  

- `SELECT B FROM T2`  
  → 결과: 4, 2, 3  

- UNION 수행  
  → 중복 제거 후 합친 결과: 1, 2, 3, 4  

- `ORDER BY A DESC` 적용  
  → 내림차순 정렬: 4, 3, 2, 1  

결과:  
4  
3  
2  
1  

------------------------------------------------------------------


\## 문제 4

다음은 접근 통제 유형에 대한 설명이다. 괄호에 들어갈 **영문 약어**를 쓰시오.


1. **(  )** :  
리소스마다 분류 레이블(예: 기밀, 비밀)이 지정되고 사용자마다 보안 등급이 주어진다.  
사용자의 보안 등급이 리소스의 분류 레이블을 만족할 때만 접근이 허용된다.  
이 모델은 주로 **국방이나 정부 기관**에서 중요한 데이터를 보호하기 위해 사용된다.

2. **(  )** :  
데이터 **소유자**가 자신의 자원에 대한 **접근 권한을 직접 관리**할 수 있는 모델이다.  
소유자는 다른 사용자나 그룹에게 자원을 사용할 권한을 **부여하거나 취소**할 수 있다.

3. **(  )** :  
**사용자의 역할**에 따라 접근 권한을 부여하는 모델이다.  
각 사용자는 하나 이상의 역할을 부여받으며, 해당 역할은 특정 권한과 연결된다.  
이 모델은 조직 내에서 역할에 따라 자원 접근을 효율적으로 관리하고자 할 때 유용하다.

### 답:

1) **MAC** (Mandatory Access Control, 강제적 접근 통제)  
2) **DAC** (Discretionary Access Control, 임의적 접근 통제)  
3) **RBAC** (Role-Based Access Control, 역할 기반 접근 통제)


### 📌 관련 개념 설명

#### ✅ MAC (Mandatory Access Control, 강제적 접근 통제)
- 시스템이 리소스와 사용자 모두에 등급(Label)을 부여함  
- 사용자가 권한을 직접 못 줌 → 시스템이 통제  
- 주로 군사, 정부 등 기밀성 보안 모델에 쓰임  
- 대표 모델: 벨-라파둘라 모델 (BLP)  
  - No Read Up: 상위 등급 읽기 금지  
  - No Write Down: 하위 등급 쓰기 금지  
- **예시**: 군대에서 '기밀', '비밀', '일반' 등급별 문서 접근 제한  

#### ✅ DAC (Discretionary Access Control, 임의적 접근 통제)
- 소유자가 직접 자원 접근 권한 관리  
- 유연하지만 보안은 상대적으로 약함  
- 윈도우, 리눅스 같은 일반 시스템에서 사용  
- **예시**: 내 컴퓨터에서 파일 공유 설정해서 특정 사용자만 접근 허용  

#### ✅ RBAC (Role-Based Access Control, 역할 기반 접근 통제)
- 사용자에게 직접 권한을 안 줌, 역할(Role)을 줌  
- 역할에 여러 권한이 포함됨  
- 역할 기반 업무 분장이 명확한 조직에서 효과적  
- 관리 효율성과 보안 둘 다 챙김  
- **예시**: 회사에서 '관리자', '팀원', '인사' 역할별로 시스템 접근 권한 다르게 부여  

---

### 🔎 관련 접근 통제 모델 요약

| 모델            | 주요 특징               | 중점     | 예시                              |
|-----------------|------------------------|----------|---------------------------------|
| 벨-라파둘라 (BLP) | MAC 기반, 기밀성 중시   | 기밀성   | 군사 기밀문서 등급별 접근 제한      |
| 비바 모델 (Biba)  | MAC 기반, 무결성 중시   | 무결성   | 금융 거래 기록 무결성 보장         |
| 클락-윌슨 모델    | 트랜잭션 무결성 보장    | 무결성   | 은행 시스템의 안전한 거래 처리     |
| 만리장성 모델      | 이해 충돌 방지          | 격리/보안 | 대기업 내부 부서별 업무 충돌 방지  |


------------------------------------------------------------------

\## 문제 5


다음에서 설명하는 용어를 영어 약자로 작성하시오.

> 광대역 멀티미디어 통신을 지원하기 위해 고안된 네트워크 기술이다.  
> 이 기술은 특히 고속 네트워크 환경에서 다양한 종류의 트래픽을 효과적으로 처리할 수 있도록 설계되었으며,  
> 주로 전화망 및 인터넷 백본에서 사용되었다.  
> 데이터를 \*\*53바이트 크기의 고정 길이 셀\*\*로 전송한다.  
> 이 중 \*\*5바이트는 헤더\*\*, \*\*48바이트는 페이로드(실제 데이터)\*\* 로 사용된다.  
> \*\*고정 길이 셀 사용은 셀 스위칭을 단순하고 빠르게\*\* 만든다.  
> 데이터 전송을 시작하기 전에 \*\*논리적 연결이 먼저 설정\*\*되어야 한다.


\### 답:

\*\*ATM\*\* (Asynchronous Transfer Mode)



### 📌 관련 개념 설명

#### ✅ ATM (Asynchronous Transfer Mode)
- 53바이트 셀 단위로 데이터를 빠르게 전송하는 기술  
  - 5바이트: 헤더(Header)  
  - 48바이트: 페이로드(Payload)  
- 셀 기반 전송으로 지연 최소화, QoS 보장  
- 음성, 영상, 데이터 같은 멀티미디어 트래픽 처리에 좋음  
- 연결지향 방식: 전송 전에 경로를 미리 설정해야 함  
- 예전에는 인터넷 백본, 전화망, 기업 통신망에 많이 쓰였으나 지금은 IP 기술로 대체됨  



### 🔎 관련 개념: 다중화기 종류

| 구분                        | 설명                                      |
|-----------------------------|-----------------------------------------|
| **FDM** (Frequency Division Multiplexing) | 주파수 대역을 나눠서 여러 신호를 동시에 보냄        |
| **TDM** (Time Division Multiplexing)      | 시간 슬롯을 나눠서 여러 신호가 순서대로 전송됨      |
| **CDM** (Code Division Multiplexing)      | 각 채널에 고유 코드를 줘서 동시에 보내지만 구분 가능 |
| **WDM** (Wavelength Division Multiplexing) | 광섬유에서 다른 파장의 빛으로 여러 신호 동시 전송    |
| **SDM** (Space Division Multiplexing)     | 물리적 공간(경로)를 나눠서 여러 신호 전송            |



### 예시  
- ATM: 전화 통화, 영상 통화 같은 실시간 데이터 빠르게 보내는 데 최적  
- FDM: 라디오 방송에서 여러 주파수를 동시에 사용  
- TDM: 전화 교환기에서 여러 전화 신호가 시간대별로 나눠서 전송  
- CDM: 휴대폰 4G/5G에서 여러 사용자가 동시에 신호 보내기  
- WDM: 인터넷 광케이블에서 여러 파장으로 데이터 전송  
- SDM: 다중 이더넷 포트 같은 물리적으로 선 여러 개 나눠서 쓰기  

---------------------------------------------------------------



\## 문제 6


\### 문제  

괄호에 들어갈 용어를 \*\*영어 약자\*\*로 작성하시오.


> (  )은 주로 \*\*사설 네트워크와 공인 네트워크 간의 IP 주소를 매핑하고 변환\*\*하는 데 사용되며,  
> 여러 대의 컴퓨터가 \*\*하나의 공인 IP 주소를 공유\*\*하여 인터넷에 접속할 수 있도록 한다.  
> (  )은 주로 \*\*라우터나 방화벽\*\* 같은 네트워크 장치에서 구현된다.  
> 네트워크 내부의 장치(사설 IP 주소를 가진)가 인터넷(공인 IP 주소를 사용하는)으로 데이터를 전송할 때,  
> (  ) 장치는 내부 IP 주소를 공인 IP 주소로 \*\*변환\*\*한다.  
> (  )은 \*\*IP 주소의 부족 문제를 완화\*\*하고, \*\*네트워크 보안\*\*을 강화하는 데 중요한 기술이다.



\### 답:

\*\*NAT\*\* (Network Address Translation)

---

### 📌 관련 개념 설명

#### ✅ NAT (Network Address Translation)
- 사설 IP 주소와 공인 IP 주소를 서로 변환해 주는 기술  
- 인터넷과 내부 네트워크 사이에서 주소를 바꿔 주는 경계 역할  
- 주로 라우터나 방화벽에서 사용  
- 하나의 공인 IP로 여러 사설 IP가 인터넷에 동시에 접속 가능  
- 외부에서 내부 네트워크가 직접 보이지 않아 보안 강화 효과  



### 🔸 NAT 주요 유형

| 유형                  | 설명                                    |
|-----------------------|---------------------------------------|
| **Static NAT**        | 사설 IP 1개와 공인 IP 1개를 1:1로 매핑        |
| **Dynamic NAT**       | 공인 IP 풀에서 사설 IP에 동적으로 할당           |
| **PAT (포트 주소 변환)** | 여러 사설 IP가 하나 공인 IP를 포트 번호로 나눠 공유 (NAT Overload) |



### 🔎 IP 관련 기타 기술

| 기술                   | 설명                                   |
|------------------------|--------------------------------------|
| **DNS**                | 도메인 이름 ↔ IP 주소 변환             |
| **QoS**                | 특정 트래픽에 대역폭, 우선순위 보장       |
| **VPN**                | 공용 네트워크에서 사설망처럼 안전하게 통신  |
| **DHCP**               | 장치에 자동으로 IP 주소 할당              |



### 예시  
- NAT: 집에서 여러 기기가 하나의 공인 IP로 인터넷 사용  
- Static NAT: 특정 서버가 항상 같은 공인 IP를 가질 때  
- Dynamic NAT: 회사 내 여러 PC가 공인 IP를 공유할 때 동적으로 할당  
- PAT: 집 공유기에서 여러 기기가 하나 공인 IP로 동시에 인터넷 접속  
- DNS: www.google.com → 172.217.0.0 같은 IP로 변환  
- QoS: 영상통화에 인터넷 속도 우선 보장  
- VPN: 카페에서 회사 내부망 안전하게 접속  
- DHCP: 스마트폰, 노트북 자동으로 IP 받음  

---


\## 문제 7


UML을 이용한 다이어그램 중 \*\*아래 그림\*\*에 해당하는 다이어그램을 쓰시오.


인터넷 서점

결제 장바구니

^ ↖

|

|

카드 계좌이체



\### 답:  

\*\*패키지 다이어그램\*\* (Package Diagram)





### 📌 관련 개념 설명

#### ✅ 패키지 다이어그램 (Package Diagram)
- 시스템을 **모듈 단위로 나눠 구조를 표현**하는 UML 다이어그램
- 클래스, 유스케이스, 컴포넌트 등을 **논리적으로 그룹화**할 때 사용
- **의존(Dependency)**, **포함(Containment)** 관계를 화살표와 중첩으로 표현

---

### 🔸 패키지 다이어그램 특징
- **패키지 = 관련 요소들의 논리적 묶음**
- 패키지 간 관계는 **화살표(의존성)**로 표현
- 하나의 큰 시스템을 여러 하위 패키지로 분리하여 관리 용이
- 중복되는 요소를 분리해서 재사용 구조 만들기 좋음

---

### 🔍 예시 구조

#### 예: 인터넷 서점 UML 패키지 다이어그램 구조

[인터넷서점]
├── [결제] ──▶ [카드]
│ └──▶ [계좌이체]
└── [장바구니]

- `[인터넷서점]`: 최상위 패키지
- `[결제]`: 카드와 계좌이체 패키지에 **의존**
- `[장바구니]`: 독립적인 하위 패키지
- **실제 클래스는 각 패키지 안에 존재함 (예: 카드결제클래스 등)**


### 🔎 UML 주요 다이어그램 요약

| 다이어그램           | 설명                                 |
|----------------------|--------------------------------------|
| **클래스 다이어그램**    | 클래스 간의 구조와 관계 표현              |
| **유스케이스 다이어그램** | 사용자와 시스템 기능의 상호작용 표현       |
| **시퀀스 다이어그램**    | 객체 간 메시지 흐름 (시간 순서대로 표현)   |
| **패키지 다이어그램**    | 시스템을 논리적 단위(패키지)로 나눠 표현  |
| **컴포넌트 다이어그램**  | 물리적 컴포넌트 구성 및 관계 표현         |
| **배치 다이어그램**      | 하드웨어와 소프트웨어의 배치 구조 표현    |

---



\## 문제 8



다음에서 설명하는 테스트 기법을 보기에서 골라 작성하시오.



> 이 기법은 입력 데이터를 \*\*효율적으로 테스트\*\*하기 위해 사용되며,  
> 특히 입력 데이터의 \*\*범위나 조건에 따라 테스트를 최소화\*\*하면서도  
> \*\*최대의 효과\*\*를 달성하는 데 도움을 준다.  

> 전체 입력 데이터를 여러 개의 '\*\*등가 클래스\*\*'로 나눈다.  
> 각 등가 클래스는 해당 클래스의 모든 값이 \*\*기대되는 동일한 행동\*\*을 보여야 한다고 가정한다.  
> 즉, 한 클래스의 하나의 값을 테스트하면, 해당 클래스의 다른 모든 값도  
> 동일한 결과를 보일 것이라고 예상한다.  

> 이러한 방식으로 \*\*테스트 케이스의 수를 줄일 수 있으며\*\*,  
> 테스트의 \*\*범위와 효율성\*\*을 높일 수 있다.


\### 답:

\*\*동등분할 기법 (Equivalence Partitioning)\*\*



### 📌 관련 개념 설명

#### ✅ 동등분할 기법 (Equivalence Partitioning)

- **블랙박스 테스트 기법** 중 하나
- 전체 입력값을 **유사한 특성의 그룹(=등가 클래스)** 으로 나눔
- 각 그룹에서 **대표값 1개만 테스트** → **테스트 수 줄이면서 커버리지는 확보**
- **유효한 값**과 **무효한 값** 둘 다 고려 가능


### 🔸 핵심 포인트
- 테스트 대상이 많을 때 **입력 범위 줄이기** 좋음
- 하나의 등가 클래스 내부는 **동일하게 처리된다고 가정**
- 각 클래스를 대표하는 **샘플 값 하나만 테스트**하면 됨

---

### ✅ 예시

#### 조건: 입력값은 1~100 사이의 정수여야 함

| 구분         | 클래스           | 대표 테스트 값 |
|--------------|------------------|----------------|
| 유효 클래스   | 1~100            | `50`           |
| 무효 클래스① | 0 이하           | `-1`           |
| 무효 클래스② | 101 이상         | `150`          |

→ 이 3개 값만으로도 전체 테스트 범위를 커버 가능


### 🔍 블랙박스 테스트 대표 기법 요약

| 기법               | 설명                                                             |
|--------------------|------------------------------------------------------------------|
| **동등분할 기법**     | 입력값을 등가 클래스(유사 동작 그룹)로 나눠 **대표값만 테스트**             |
| **경계값 분석**       | 입력 범위의 **경계값 전후 중심**으로 테스트 (예: 0, 1, 100, 101)         |
| **원인-효과 그래프**  | 입력 조건과 출력의 **논리 관계를 그래프로 모델링**, 복잡한 조건 처리 시 유용 |
| **오류 예측 검사**    | **경험/직관**에 기반해 오류 가능성이 높은 부분 위주로 테스트             |
| **비교 검사 (병행)** | 동일 입력을 **2개 시스템에 동시에 넣고 결과 비교**                        |




---

\## 문제 9



\### 문제  

다음은 클라우드에 대한 설명이다. 괄호 안에 알맞은 답을 보기에서 골라 작성하시오.

\#### (1)  

가상화된 \*\*컴퓨팅 자원\*\*을 인터넷을 통해 제공한다.  
사용자는 \*\*서버, 스토리지, 네트워킹과 같은 기본 인프라\*\*를 임대하여 사용한다.  
\*\*운영체제 및 응용프로그램 설치, 데이터 관리 등을 스스로 관리\*\*한다.  
\*\*확장성\*\*이 뛰어나고, \*\*사용한 만큼 비용을 지불\*\*하는 구조이다.  


→ \*\*답: IaaS (Infrastructure as a Service)\*\*


\#### (2)  

\*\*애플리케이션 개발과 배포\*\*를 위한 플랫폼 및 환경을 인터넷을 통해 제공한다.  
사용자는 \*\*개발 환경\*\*을 제공받으며, \*\*하드웨어 및 운영 체제 관리는 서비스 제공자\*\*가 담당한다.  
\*\*개발, 테스트, 배포, 호스팅 및 유지보수\*\*의 단순화된 프로세스를 제공한다.  

→ \*\*답: PaaS (Platform as a Service)\*\*


\#### (3)  

인터넷을 통해 \*\*소프트웨어 애플리케이션\*\*을 제공한다.  
사용자는 소프트웨어를 \*\*설치하거나 관리할 필요 없이 웹브라우저\*\*를 통해 사용 가능하다.  
\*\*업데이트 및 유지관리\*\*는 모두 \*\*서비스 제공자\*\*가 담당한다.  
사용자는 \*\*정기 구독료\*\*를 지불하며, \*\*다수의 사용자가 쉽게 접근\*\*할 수 있다.  


→ \*\*답: SaaS (Software as a Service)\*\*



\### ✅ 최종 답:

1\) \*\*IaaS\*\*  
2\) \*\*PaaS\*\*  
3\) \*\*SaaS\*\*



\### 📌 관련 개념 정리


| 구분    | 설명                                                              | 예시 (갓반인 기준)                                                                 |
|---------|-------------------------------------------------------------------|-------------------------------------------------------------------------------------|
| **IaaS** | Infrastructure as a Service<br>가상 서버, 스토리지, 네트워크 같은 **인프라를 빌려 씀** | 💡 컴퓨터를 통째로 빌려 쓰는 느낌<br>예: 게임 서버 만들려고 EC2로 리눅스 머신 띄움          |
| **PaaS** | Platform as a Service<br>**앱 만들 수 있는 개발 플랫폼을 빌려 씀**           | 💡 코드는 내가 짜고, 서버 운영은 안 해도 되는 느낌<br>예: Heroku에 코드만 올리면 배포됨     |
| **SaaS** | Software as a Service<br>**그냥 서비스 쓰는 것**                            | 💡 설치 없이 바로 웹에서 사용<br>예: Gmail로 메일 보내기, Google Docs로 문서 작성 등        |

---



\## 문제 10



\### 문제  

다음에서 설명하는 프로토콜을 \*\*영어 약어\*\*로 작성하시오.


> 내부 라우팅 프로토콜 중 하나로, 네트워크 내 라우터들 사이에서 정보를  
> 교환하여 \*\*최적의 경로\*\*를 결정하는 데 사용된다.  
> \*\*거리 벡터 라우팅 프로토콜\*\*의 일종으로, 목적지까지의 거리를 기반으로 라우팅 결정을 한다.  
> \*\*경로의 길이를 홉 카운트(hop count)\*\*로 측정하며, \*\*최대 15홉\*\*까지만 허용한다.  
> 일반적으로 \*\*30초마다 전체 라우팅 테이블을 브로드캐스트\*\*하거나 멀티캐스트한다.

\### ✅ 답: \*\*RIP\*\* (Routing Information Protocol)



### 📌 관련 개념 설명

#### ✅ RIP (Routing Information Protocol)

- **IGP (Interior Gateway Protocol)**의 대표적인 거리 벡터 기반 프로토콜
- 라우터끼리 **라우팅 정보를 주고받으며** 최단 경로를 계산함
- **경로 길이 = 홉 수(Hop Count)** 로 판단함  
  → 한 라우터를 지나칠 때마다 홉 수 +1  
  → **최대 15홉까지만 가능**, 16 이상은 도달 불가로 간주
- **30초마다** 라우팅 테이블 전체를 이웃 라우터에게 보냄  
  → **브로드캐스트** 또는 **멀티캐스트**로 전달


### 🧠 갓반인 예시

💬 “서울에서 부산까지 가는 길을 알려줘!”

- 서울 라우터는 옆에 있는 수원 라우터에게 “나는 서울까지 1홉 거리야”라고 알려줌
- 수원은 그걸 듣고 “아하, 내가 서울까지 1홉이구나”라고 기억함
- 수원은 다시 대전에게 “나는 서울까지 2홉이야”라고 전달함
- 이런 식으로 각 라우터가 몇 홉 걸리는지 계산하고 기억함

📌 홉 수가 16이 넘으면?
- 너무 멀어서 “그건 못 가요~”라고 생각함 → 도달 불가 판정


### ✅ 비교용 한 줄 요약

| 프로토콜 | 기준            | 설명                           |
|----------|-----------------|--------------------------------|
| **RIP**  | 홉 수           | 단순하지만 멀리 못 감 (최대 15) |
| **OSPF** | 링크 상태 기반  | 더 똑똑하고, 큰 네트워크에 적합 |


---


\## 문제 11


\### 문제  

다음은 관계 대수 기호이다. 보기에서 알맞은 \*\*기호\*\*로 작성하시오.



| 연산 종류  | 기호 |
|------------|------|
| (1) JOIN   | ?    |
| (2) PROJECT| ?    |
| (3) SELECT | ?    |
| (4) DIVISION| ?   |



### ✅ 답:

1) **JOIN** → ⨝  
2) **PROJECT** → **π**  
3) **SELECT** → **σ**  
4) **DIVISION** → **÷**



### 📌 관련 개념 설명

| 연산자     | 기호 | 설명                                       | 갓반인 예시                                 |
|------------|------|--------------------------------------------|---------------------------------------------|
| **JOIN**   | ⨝    | 두 테이블을 조건에 맞게 붙이는 연산       | 학생 테이블 ⨝ 수강 테이블 = 학생이 수강한 강의 |
| **PROJECT**| π    | 원하는 열만 추출하는 연산 (세로 추출)      | 학생 테이블에서 이름만 뽑기 → π 이름(학생)     |
| **SELECT** | σ    | 조건에 맞는 행만 추출하는 연산 (가로 필터) | 수강 테이블에서 점수 ≥ 90 → σ 점수≥90(수강)   |
| **DIVISION**| ÷   | A에서 B의 모든 값을 만족하는 행 추출      | 모든 과목 수강한 학생 찾기 등 (복잡하지만 강력) |


### 🔎 관계 대수 연산 요약

#### 🔹 순수 관계 연산자

- **SELECT (σ)**: 행 필터링 → 조건 만족하는 데이터만 골라냄  
- **PROJECT (π)**: 열 필터링 → 필요한 속성만 뽑아냄  
- **JOIN (⨝)**: 두 릴레이션을 조인 조건에 따라 연결  
- **DIVISION (÷)**: 어떤 조건을 **전부** 만족하는 튜플만 추출  

#### 🔹 일반 집합 연산자

- **합집합 (∪)**: A 또는 B에 있는 것 전부  
- **교집합 (∩)**: A와 B 둘 다 있는 것만  
- **차집합 (−)**: A에만 있고 B에는 없는 것  
- **카티션 프로덕트 (×)**: 모든 조합 생성 (JOIN 전 단계)


### 🧠 갓반인 요약 한 줄 정리

- SELECT는 행 고르기 (가로)
- PROJECT는 열 고르기 (세로)
- JOIN은 테이블 붙이기
- DIVISION은 **전부 만족하는 것만 골라내기** (시험 자주 나옴!)

---



\## 문제 12

다음에서 설명하는 제약 조건에 대해서 쓰시오.


> 데이터베이스의 (  ) 무결성 제약 조건은 데이터베이스 내에서 데이터의  
> 정확성과 일관성을 유지하는 데 중요한 역할을 한다.  
> 이 제약조건은 특히 관계형 데이터베이스에서 \*\*외래키 관계\*\*를 통해 구현되며,  
> 연관된 테이블 간의 적절한 데이터 관계가 유지되도록 보장한다.  
> 한 테이블의 필드(외래키)가 다른 테이블의 기본키를 참고할 때,  
> 외래키 값은 참조하는 테이블의 기본키에 존재하는 값이어야 한다.  
> 즉, 참조하는 데이터가 실제로 존재해야 한다.


\### 답:  

\*\*참조 무결성\*\* (Referential Integrity)


### 📌 관련 개념 설명

#### ✅ 참조 무결성 (Referential Integrity)
- **외래키(Foreign Key)** 제약조건으로 구현
- 외래키 값은 반드시 참조 대상 테이블의 **기본키** 중 하나여야 함
- 데이터의 **일관성과 정확성 유지**를 위해 필수

#### 🔸 동작 옵션
| 옵션 | 설명 |
|------|------|
| **CASCADE** | 참조 대상이 삭제/수정되면 같이 삭제/수정됨 |
| **SET NULL** | 참조 대상이 삭제/수정되면 외래키 값을 NULL로 설정 |
| **NO ACTION / RESTRICT** | 참조 대상이 삭제/수정되지 않도록 제한 |


### 🔎 무결성 제약 조건 종류

| 무결성 종류       | 설명 |
|------------------|------|
| **도메인 무결성** | 각 컬럼의 값이 정해진 범위(타입) 안에 있어야 함 |
| **개체 무결성**   | 기본키는 **중복 불가 + NULL 불가** |
| **참조 무결성**   | 외래키는 참조 대상 테이블의 기본키를 **반드시 참조**해야 함 |
| **사용자 정의 무결성** | 업무 규칙에 따른 조건 직접 설정 (예: 급여 > 0) |

---

### 🧠 갓반인용 예시

#### 예시 테이블

**부서 테이블 (Department)**  
| dept_id (PK) | dept_name  |
|--------------|------------|
| 10           | 개발팀     |
| 20           | 마케팅팀   |


**직원 테이블 (Employee)**  
| emp_id | emp_name | dept_id (FK) |
|--------|----------|--------------|
| 101    | 철수     | 10           |
| 102    | 영희     | 20           |
| 103    | 민수     | 30 ❌ (존재하지 않음) |

✅ 103번 직원처럼 **없는 부서 번호(30)** 를 참조하면 **참조 무결성 위반**!


### 📌 핵심 요약

- **외래키는 반드시 기본키를 참조해야 함**
- 참조 대상이 사라질 때, 어떻게 처리할지 옵션 선택 필수
- 데이터 간 연결의 신뢰성을 지켜주는 핵심 규칙!

---

\## 문제 13

class A {

    public void paint() {
        System.out.print("A");
        draw();
    }

    public void draw() {
        System.out.print("B");
        draw();
    }
}
class B extends A {

    public void paint() {
        super.draw();
        System.out.print("C");
        this.draw();
    }

    public void draw() {
        System.out.print("D");
    }
}
class EraonEdu {

    public static void main(String[] args) {
        A b = new B();
        b.paint();
        b.draw();
    }
}


### 코드 분석: 상속, 오버라이딩, 다형성


#### 1. 클래스 구조

- **class A (부모 클래스)**
  - `paint()` 메서드: "A" 찍고 `draw()` 호출
  - `draw()` 메서드: "B" 찍고 다시 `draw()` 호출 (오버라이딩된 자식 메서드가 실행됨)

- **class B extends A (자식 클래스)**
  - `paint()` 메서드: `super.draw()` 호출(부모 A의 draw()), "C" 찍고 `this.draw()` 호출(자기 자신 B의 draw())
  - `draw()` 메서드: "D" 찍음 (부모 A의 draw()를 오버라이딩)

#### 2. main() 실행 분석
A b = new B();
b.paint();
b.draw();
다형성 발생: 변수 b는 A 타입이지만 실제 객체는 B이다.

3. b.paint() 호출 흐름
실제 호출: B.paint()
super.draw(); → 부모 A의 draw() 호출
System.out.print("B"); → 출력: B
draw(); 호출 → 오버라이딩된 B의 draw() 호출
System.out.print("D"); → 출력: D
System.out.print("C"); → 출력: C
this.draw(); → B의 draw() 호출
System.out.print("D"); → 출력: D

이 시점까지 출력: BDCD

4. b.draw() 호출 흐름
실제 호출: B.draw()
System.out.print("D"); → 출력: D

5. 최종 출력
BDCDD

핵심 정리
| 개념            | 설명                                            |
|-----------------|-------------------------------------------------|
| 상속(Inheritance) | B가 A를 상속받음                                  |
| 오버라이딩       | B가 A의 draw()를 재정의                           |
| 다형성(Polymorphism) | A 타입 변수로 B 객체를 다루며, 실제 메서드 실행은 B 기준 |
| 동적 바인딩      | 런타임에 객체 타입(B)의 메서드가 호출됨             |
| super.draw()    | 부모 클래스 A의 draw() 직접 호출                   |
| this.draw()     | 현재 객체 B의 draw() 호출                          |

---

\## 문제 14


다음 C언어 코드의 출력 결과를 쓰시오.


#include <stdio.h>

int main(){
    char *p = "KOREA";
    printf("%s \n", p);
    printf("%s \n", p+1);
    printf("%c \n", *p);
    printf("%c \n", *(p+3));
    printf("%c", *p+4);
}

답: 
KOREA
OREA
K
E
O




### 코드 분석

이 코드는 C언어의 **포인터(Pointer)**와 문자열을 다루는 문제다.

```c
char *p = "KOREA";
p라는 문자 포인터를 선언하고, "KOREA"라는 문자열의 첫 글자 주소를 가리킨다.

문자열 "KOREA"는 메모리에 'K', 'O', 'R', 'E', 'A', \0 (널 문자, 문자열 끝 표시) 순서로 저장된다.


printf("%s \n", p);
%s는 문자열 전체 출력.

p가 "KOREA"의 시작 주소이므로 "KOREA" 전체가 출력된다.

출력: KOREA


printf("%s \n", p+1);
p+1은 p가 가리키는 주소에서 한 칸 뒤 이동.

"KOREA"에서 'K' 다음인 'O'의 주소.

%s로 출력하면 'O'부터 문자열 끝까지 출력.

출력: OREA


printf("%c \n", *p);
%c는 문자 하나 출력.
*p는 p가 가리키는 주소의 문자.
p는 'K' 주소를 가리키므로 'K' 출력.

출력: K

printf("%c \n", *(p+3));
p+3은 p가 가리키는 주소에서 세 칸 뒤 이동.

인덱스: 0→'K', 1→'O', 2→'R', 3→'E'
'E' 주소를 가리키므로 'E' 출력.

출력: E

printf("%c", *p+4);
*p+4는 p가 가리키는 문자 'K'의 ASCII 코드에 4를 더함.
'K' ASCII 코드 75 + 4 = 79 → ASCII 79는 'O'

%c로 'O' 출력.

출력: O
---


\## 문제 15

\### 문제  

C언어 코드에서 구조체의 멤버에 접근하기 위한 괄호 내의 공통된 접근자를 쓰시오.


#include <stdio.h>

struct User {
    char* name;
    int age;
};

int main() {
    struct User d1;
    struct User *d2;
    d2->name = "Lee";
    d2->age = 45;
    printf("%s, %d", d2->name, d2->age);
}


### ✅ 정답  
**`->`**


### 📌 핵심 개념 정리

| 구분              | 설명                                                  | 예시        |
|-------------------|-------------------------------------------------------|-------------|
| `.` (점 연산자)   | 일반 구조체 변수로 멤버에 접근할 때 사용             | `d1.name`   |
| `->` (화살표 연산자) | **구조체 포인터로** 멤버에 접근할 때 사용 (**포인터가 핵심**) | `d2->name`  |


### ✅ 정답  
**`->`**




---



\## 문제 16

다음 C언어 코드의 출력 결과를 쓰시오.


#include <stdio.h>

int func(int n){
    int i, sum = 0;
    for (i = 1; i <= n / 2; i++) {
        if (n % i == 0)
            sum += i;
    }

    if (n == sum)
        return 1;

    return 0;
}

int main(){
    int i, sum = 0;
    for (i = 2; i <= 100; i++) {
        if (func(i))
            sum += i;
    }

    printf("%d", sum);
    return 0;
}


답:
34



### ✅ 코드 분석: 완전수 판별 프로그램

이 코드는 **완전수(Perfect Number)**를 찾는 C언어 프로그램이다.  
완전수란 자기 자신을 제외한 약수들의 합이 자기 자신과 같은 수이다.

예)  
- `6`의 약수: 1, 2, 3, 6 → `1 + 2 + 3 = 6` ✅ 완전수  
- `28`의 약수: 1, 2, 4, 7, 14, 28 → `1 + 2 + 4 + 7 + 14 = 28` ✅ 완전수  

---


### 🔍 1. `func(int n)` 함수: 완전수 판별기


int func(int n){
    int i, sum = 0;
    for (i = 1; i <= n / 2; i++) {
        if (n % i == 0)
            sum += i;
    }
    if (n == sum)
        return 1;
    return 0;
}

sum = 0; → 약수의 합 저장

i <= n/2 → 약수는 자기 수의 절반 이하

n % i == 0 → 약수인지 확인

sum += i; → 약수 더하기

n == sum → 완전수 여부 판단 → return 1

아니면 return 0

🔍 2. main() 함수: 2부터 100까지 완전수의 합 구하기

int main(){
    int i, sum = 0;
    for (i = 2; i <= 100; i++) {
        if (func(i))
            sum += i;
    }
    printf("%d", sum);
    return 0;
}

i = 2 ~ 100 범위의 모든 수에 대해 완전수인지 검사

func(i)가 1 반환 → 완전수

sum += i; → 누적합 계산

최종적으로 완전수의 총합 출력

🧠 실행 흐름 요약
수	약수	약수의 합	완전수 여부
6	1, 2, 3	6	✅ 완전수
28	1, 2, 4, 7, 14	28	✅ 완전수
그 외	-	-	❌ 전부 탈락

✅ 최종 출력 결과
34
---



\## 문제 17



다음 자바 코드는 오류가 발생한다. 오류가 발생하는 명령을 쓰시오.



```java

class Person {

&nbsp;   private String name;

&nbsp;   public Person(String val){

&nbsp;       name = val;

&nbsp;   }

&nbsp;   public static String get(){

&nbsp;       return name;

&nbsp;   }

&nbsp;   public void print(){

&nbsp;       System.out.println(name);

&nbsp;   }

}



public class Main {

&nbsp;   public static void main(String \[] args){

&nbsp;       Person obj = new Person "Lee");

&nbsp;       obj.print();

&nbsp;   }

}



답:

return name;



설명

get() 메서드는 static으로 선언되어 있는데, name 변수는 인스턴스 변수(non-static)이다.



static 메서드에서 인스턴스 변수 name에 접근할 수 없어 컴파일 오류 발생



따라서 return name; 부분에서 오류가 발생함



또한, new Person "Lee") 부분에도 괄호 오류가 있으나, 문제에서 묻는 오류는 return name;으로 보임.

**-----------------------------------------------------------------------------------**

**## 문제 18**



**### 문제**  

**다음 자바 코드의 결과를 쓰시오.**



**```java**

**class Parent {**

    **int com(int n){**

        **if (n <= 1)**

            **return n;**

        **return com(n-1) + com(n-2);**

    **}**

**}**



**class Child extends Parent {**

    **int com(int n){**

        **if(n <= 1)**

            **return n;**

        **return com(n-1) + com(n-3);**

    **}**

**}**



**Parent obj = new Child();**

**System.out.print(obj.com(7));**

**답:**

**2**



**설명**

**obj는 Parent 타입 변수지만, 실제로는 Child 클래스의 인스턴스를 참조함 → 오버라이딩된 Child의 com()가 호출됨**



**Child 클래스의 com(n) 재귀 호출은 다음과 같음:**



**복사**

**편집**

**com(n) = com(n-1) + com(n-3) (단, n <= 1일 경우 n 반환)**

**이를 계산해 보면 com(7)의 결과는 2가 됨 (자세한 계산 과정은 재귀 트리로 분석 가능)**



**따라서 출력값은 2**

**-----------------------------------------------------------------------------------**



**## 문제 19**



**### 문제**  

**다음 C코드의 결과를 쓰시오.**



**```c**

**#include <stdio.h>**

**int f(int n){**

    **if(n <=1) return 1;**

    **else return n \* f(n-1);**

**}**

**int main(){**

    **printf("%d", f(7));**

**}**

**답:**

**5040**



**설명**

**함수 f는 팩토리얼을 계산하는 재귀함수이다.**



**f(7)은 7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040 이다.**



**따라서 출력 결과는 5040이 된다.**

**-----------------------------------------------------------------------------------**



**## 문제 20**



**### 문제**  

**다음 파이썬 코드 중 괄호에 들어갈 알맞은 함수를 작성하시오.**  

**(단 입력된 값은 `2 3` 이고, 출력은 `2 3`으로 출력된다.)**



**```python**

**num1, num2 = input().\_\_\_()**

**num1 = int(num1)**

**num2 = int(num2)**

**print(num1, num2)**

**답:**

**split**



**설명**

**input() 함수로 입력받은 문자열 "2 3"을 split() 함수로 공백 기준 분리하여 리스트로 반환한다.**



**이렇게 분리된 문자열 "2"와 "3"이 각각 num1, num2에 할당된다.**



**이후 int()로 정수 변환 후 출력한다.**



**따라서 출력은 2 3이 된다.**

