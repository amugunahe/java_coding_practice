\## 문제 1


\### 문제

아래에서 설명하는 용어를 보기에서 골라 답안을 작성하시오.


> 인터넷 사용자가 웹사이트나 애플리케이션에 비밀번호를 공개하지 않고도 정보를 다른 웹사이트에서 안전하게 접근할 수 있도록 허용하는 개방형 표준이다.  
> 예를 들어 한 웹사이트에서 다른 서비스에 로그인할 때 사용자의 비밀번호를 직접 입력하지 않고도 서비스 간에 안전하게 권한을 부여할 수 있다.
> 서드파티 애플리케이션이 사용자의 비밀번호에 접근하지 않고도 서비스 간에 데이터를 안전하게 공유할 수 있도록 한다.  
> 소셜 미디어 로그인, 데이터 공유 API, 클라우드 서비스 등 다양한 분야에서 널리 사용되고 있다.



\### 답:

\*\*OAuth\*\*


### 📌 관련 개념 설명 (쉽고 직관적으로 정리함)

---

#### ✅ OAuth (Open Authorization)

> 🔐 **비밀번호 안 알려줘도** 다른 앱이 **내 정보 일부에 접근**할 수 있게 해주는 기술

- **서드파티 앱**이 내 계정에 **제한된 접근 권한만** 갖도록 허용함  
- **비밀번호 노출 없음**, 대신 **토큰**을 주고 사용하게 함  
- 현실 예시:  
  - **갓반인**이 과제 제출 도우미 앱을 만들었어.  
    - 사용자한테 "구글 계정으로 로그인해!" 하게 하고  
    - 사용자가 동의하면, 앱은 구글에서 받은 **토큰**으로 과제 제출함  
    - 이때 구글 비밀번호는 갓반인 앱이 **몰라**도 됨

✅ **동작 흐름 (5단계 요약)**

1. 사용자가 **앱(갓반인 과제 도우미)**에서 **구글 로그인** 누름  
2. 구글이 **로그인 창** 띄움  
3. 로그인 성공 후, 사용자에게 **정보 접근 허용**할지 물어봄  
4. 사용자가 허용 → 구글이 **토큰(access token)** 발급  
5. 갓반인 앱이 이 토큰으로 구글 API에 요청함  
   → 예: 사용자의 이름, 이메일 등 필요한 정보만 가져옴

---

#### ✅ 관련 인증 방식 총정리

| 인증 방식 | 설명 |
|-----------|------|
| **Basic 인증** | 아이디/비밀번호를 HTTP 요청 헤더에 담아서 보냄 (안전하지 않음, HTTPS 필요) |
| **Cookie/Session** | 서버가 로그인 상태를 세션에 저장하고, 클라이언트는 세션 ID를 쿠키에 보관 |
| **JWT (JSON Web Token)** | 로그인 정보 자체를 클라이언트가 토큰 형태로 들고 있음 (서버는 상태 안 가짐) |
| **OAuth** | 비밀번호를 안 알려주고도 **제한된 자원** 접근 권한을 위임받는 **토큰 기반 인증** |
| **SSO (Single Sign-On)** | **한 번 로그인**으로 여러 시스템에 자동 로그인 (예: 구글 계정으로 유튜브+Gmail) |
| **Kerberos** | 안전한 네트워크 인증을 위한 복잡한 프로토콜 (기업/대학에서 많이 사용) |
| **i-PIN (아이핀)** | 주민등록번호 대신 쓰는 개인정보 인증 방식 (한국 특화) |

---

#### ✅ AAA 모델: 인증 관련 개념 3종 세트

| 구성 요소 | 의미 | 한 줄 설명 |
|-----------|------|------------|
| **Authentication** | 인증 | 너 누구냐? 신원 확인 |
| **Authorization** | 권한 부여 | 너 이 기능 써도 되냐? |
| **Accounting** | 계정 관리 | 너 뭐 썼는지 기록 남김 |

> ✅ 예: 갓반인 로그 시스템  
> - 로그인할 때 `Authentication`  
> - "성적 확인" 버튼 누를 때 권한 체크 → `Authorization`  
> - 과제 제출 로그 남기기 → `Accounting`

---



------------------------------------------------------------------------


\## 문제 2


리눅스에서 사용자에게 \*\*읽기/쓰기/실행 권한\*\*을 부여하고,  
그룹에는 \*\*읽기/실행 권한\*\*을 부여하고,  
그 외(기타 사용자)에는 \*\*실행 권한만\*\*을 `text.txt` 파일에 부여하고자 한다.  

명령어를 포함해서 알맞은 답안을 작성하시오.


\### 답:
\*\*chmod 751 text.txt\*\*

---

### 📌 chmod 명령어 핵심 정리 (갓반인도 1초 컷 가능)

---

#### ✅ `chmod`란?

- 리눅스에서 파일/폴더의 **접근 권한을 설정**하는 명령어야.
- 형식은 `chmod [권한숫자] 파일명`
- 여기서 권한 숫자는 **읽기(r)=4, 쓰기(w)=2, 실행(x)=1**로 구성돼.
- 보통 **세 자리 숫자**로 입력하는데, 순서는 아래처럼 돼:

| 자리 | 의미 |
|------|------|
| 첫 번째 숫자 | 소유자(owner)의 권한 |
| 두 번째 숫자 | 그룹(group)의 권한 |
| 세 번째 숫자 | 기타 사용자(others)의 권한 |

---

#### ✅ 예제: `chmod 751 파일명`

> 갓반인이 제출한 과제를 친구랑 공유할 수 있게 설정하고 싶다.  
> 단, **나는 마음대로 수정 가능하고**,  
> **친구(같은 그룹)는 실행과 보기만 가능**,  
> **기타 사람은 그냥 실행만 가능**하게 하고 싶을 때?

그럴 때 딱 맞는 명령어가 `chmod 751 파일명`임!

| 대상     | 권한 부여         | 계산식       | 의미 |
|----------|-------------------|--------------|------|
| 소유자   | 읽기 + 쓰기 + 실행 | 4 + 2 + 1 = 7 | 갓반인 마음대로 다 가능 |
| 그룹     | 읽기 + 실행        | 4 + 0 + 1 = 5 | 같이 공부하는 친구들은 보기 + 실행만 가능 |
| 기타 사용자 | 실행만 가능       | 0 + 0 + 1 = 1 | 나머지는 그냥 실행만 가능 (내용 볼 수 없음) |

---

#### ✅ 직관 요약

> `chmod 751 파일명`  
> 👉 **내 맘대로**  
> 👉 **친구는 실행하고 보기만 가능**  
> 👉 **모르는 애들은 실행만 가능 (내용은 못 봄)**

---

#### 🔁 추가 팁: 자주 쓰는 chmod 조합

| 명령어         | 의미 |
|----------------|------|
| `chmod 777`    | **누구나 읽기/쓰기/실행 다 가능** (주의: 위험함!) |
| `chmod 755`    | 나만 쓰기 가능, 나머지는 읽기/실행만 가능 |
| `chmod 644`    | 나만 쓰기 가능, 나머지는 읽기만 가능 (웹 서버 파일에 자주 사용) |
| `chmod 700`    | 나만 읽기/쓰기/실행 가능, 나머지는 아무것도 못 함 (비밀 파일용) |

---

📌 갓반인 요약:
> `chmod 751` = 주인은 풀옵션, 친구는 읽기+실행, 나머지는 실행만  
> 아주 깔끔한 권한 설정임. **권한 숫자 외우면 실전에서 꿀임!**


---------------------------------------------------------

\## 문제 3

두 테이블을 이용하여 `UNION` 연산을 수행하였다.  
결과값을 **표 형태**로 작성하시오.  
(*타이틀은 포함하지 않아도 된다*)

SELECT A FROM T1
UNION
SELECT B FROM T2
ORDER BY A DESC;


<T1>

| A |
|---|
| 4 |
| 1 |
| 3 |

<T2>

| B |
|---|
| 4 |
| 2 |
| 3 |


답:
4
3
2
1



📌 관련 개념 설명

### 📌 관련 개념 설명: UNION 완전 정복 (갓반인 기준)

---

#### ✅ UNION 이란?

- `UNION`은 **두 개 이상의 SELECT 결과를 하나로 합치는** SQL 연산자야.
- 단, **중복된 값은 자동으로 제거**돼.  
- 각 SELECT문의 **열 개수와 데이터 타입이 같아야 함**.
- 중복도 허용하고 싶으면 `UNION ALL` 사용하면 돼.

---

#### ✅ 갓반인 예제로 UNION 흐름 이해하기

```sql
-- 테이블 T1에 A 컬럼이 있고
SELECT A FROM T1
-- 결과: 4, 1, 3

-- 테이블 T2에 B 컬럼이 있고
SELECT B FROM T2
-- 결과: 4, 2, 3

-- 이 둘을 UNION 하면?
SELECT A FROM T1
UNION
SELECT B FROM T2;

SELECT A FROM T1
UNION
SELECT B FROM T2
ORDER BY A DESC;

### ✅ 핵심 요약

| 키워드       | 의미                                     |
|--------------|------------------------------------------|
| `UNION`      | 중복 제거하고 SELECT 결과 합침             |
| `UNION ALL`  | 중복 제거 없이 모든 결과 합침              |
| `ORDER BY`   | 전체 UNION 결과에 정렬 적용                |
| **주의사항** | SELECT 문들의 **컬럼 개수, 타입이 같아야 함** |

---

### 👊 갓반인 요약

- SELECT 결과 **합치고 싶으면** → `UNION`  
- **중복까지 다 보고 싶으면** → `UNION ALL`  
- **정렬하고 싶으면** → `ORDER BY`는 무조건 **맨 끝**에 써야 함!


------------------------------------------------------------------


\## 문제 4

다음은 접근 통제 유형에 대한 설명이다. 괄호에 들어갈 **영문 약어**를 쓰시오.


1. **(  )** :  
리소스마다 분류 레이블(예: 기밀, 비밀)이 지정되고 사용자마다 보안 등급이 주어진다.  
사용자의 보안 등급이 리소스의 분류 레이블을 만족할 때만 접근이 허용된다.  
이 모델은 주로 **국방이나 정부 기관**에서 중요한 데이터를 보호하기 위해 사용된다.

2. **(  )** :  
데이터 **소유자**가 자신의 자원에 대한 **접근 권한을 직접 관리**할 수 있는 모델이다.  
소유자는 다른 사용자나 그룹에게 자원을 사용할 권한을 **부여하거나 취소**할 수 있다.

3. **(  )** :  
**사용자의 역할**에 따라 접근 권한을 부여하는 모델이다.  
각 사용자는 하나 이상의 역할을 부여받으며, 해당 역할은 특정 권한과 연결된다.  
이 모델은 조직 내에서 역할에 따라 자원 접근을 효율적으로 관리하고자 할 때 유용하다.

### 답:

1) **MAC** (Mandatory Access Control, 강제적 접근 통제)  
2) **DAC** (Discretionary Access Control, 임의적 접근 통제)  
3) **RBAC** (Role-Based Access Control, 역할 기반 접근 통제)


### 📌 관련 개념 설명

---

#### ✅ MAC (Mandatory Access Control, 강제적 접근 통제)
- 시스템이 **사용자와 리소스에 보안 등급(Label)**을 지정함
- 사용자가 직접 권한을 설정할 수 없고, **시스템이 강제로 통제**
- 주로 **군사/정부 조직**에서 사용됨
- 대표 모델: **벨-라파둘라 (Bell-LaPadula, BLP)**  
  - 📌 **No Read Up**: 낮은 등급 사용자는 상위 등급 데이터 읽기 ❌  
  - 📌 **No Write Down**: 높은 등급 사용자는 하위 등급에 쓰기 ❌  
- ✅ **갓반인 예시**: 군대에서 '기밀' 등급 병사는 '일반' 문서는 볼 수 있지만, '1급 비밀'은 못 봄  

---

#### ✅ DAC (Discretionary Access Control, 임의적 접근 통제)
- 자원의 **소유자(사용자)**가 직접 **권한을 부여하거나 제거**
- 권한 설정이 자유롭지만, **보안에 취약할 수 있음**
- 일반적인 운영체제(Windows, Linux 등)에서 사용
- ✅ **갓반인 예시**: 내가 만든 파일을 친구에게 읽기 전용으로 공유하는 것  

---

#### ✅ RBAC (Role-Based Access Control, 역할 기반 접근 통제)
- 사용자에게 직접 권한을 주지 않고, **'역할(Role)'을 할당**
- 역할에 따라 여러 자원에 대한 권한이 자동으로 부여됨
- **업무 분장이 명확한 조직**에서 매우 효율적
- ✅ **갓반인 예시**: 회사에서 '관리자'는 전체 조회/수정, '팀원'은 본인 작업만 접근 가능  

---

### 🔎 접근 통제 모델 요약

| 모델              | 주요 특징                   | 중점     | ✅ 갓반인 예시                                  |
|-------------------|----------------------------|----------|------------------------------------------------|
| 벨-라파둘라 (BLP) | MAC 기반, **기밀성 중심**     | 기밀성   | 군사 기밀문서 – 등급 낮으면 상위 문서 못 읽음       |
| 비바 (Biba)       | MAC 기반, **무결성 중심**     | 무결성   | 회계 부서에서 데이터는 바꾸되, 무단 수정은 막음     |
| 클락-윌슨         | **트랜잭션 단위 무결성 보장** | 무결성   | 은행 – 이중 승인 시스템 통한 안전한 송금 처리       |
| 만리장성 모델     | **이해 충돌 방지**            | 격리     | 컨설팅 회사 – 경쟁사 간 자료 열람 못 하도록 차단   |

------------------------------------------------------------------

\## 문제 5


다음에서 설명하는 용어를 영어 약자로 작성하시오.

> 광대역 멀티미디어 통신을 지원하기 위해 고안된 네트워크 기술이다.  
> 이 기술은 특히 고속 네트워크 환경에서 다양한 종류의 트래픽을 효과적으로 처리할 수 있도록 설계되었으며,  
> 주로 전화망 및 인터넷 백본에서 사용되었다.  
> 데이터를 \*\*53바이트 크기의 고정 길이 셀\*\*로 전송한다.  
> 이 중 \*\*5바이트는 헤더\*\*, \*\*48바이트는 페이로드(실제 데이터)\*\* 로 사용된다.  
> \*\*고정 길이 셀 사용은 셀 스위칭을 단순하고 빠르게\*\* 만든다.  
> 데이터 전송을 시작하기 전에 \*\*논리적 연결이 먼저 설정\*\*되어야 한다.


\### 답:

\*\*ATM\*\* (Asynchronous Transfer Mode)



### 📌 관련 개념 설명

---

#### ✅ ATM (Asynchronous Transfer Mode)

- 데이터를 **53바이트 셀 단위**로 빠르게 전송하는 통신 기술  
  - 앞 5바이트: **헤더** (주소나 제어 정보)  
  - 뒤 48바이트: **페이로드** (실제 데이터)  
- 📦 셀 기반 전송이라 지연이 적고, **QoS** 보장 (품질 유지 잘됨)
- **연결지향 방식** → 데이터를 보내기 전에 통신 경로부터 설정함
- **멀티미디어 트래픽 (음성, 영상 등)** 전송에 최적화  
- ✅ **갓반인 예시**: 90년대에 영상통화할 때 ATM 기술 덕분에 소리랑 영상이 끊기지 않고 갔던 거  

---

### 🔎 관련 개념: 다중화기 종류

| 구분      | 설명 | ✅ 갓반인 예시 |
|-----------|------|----------------|
| **FDM** (주파수 분할 다중화) | 하나의 회선에 여러 **주파수 대역**을 나눠서 동시에 전송 | 라디오 방송국: 89.1MHz, 91.9MHz 동시에 송출 가능 |
| **TDM** (시간 분할 다중화) | 하나의 회선에 **시간을 나눠서** 신호를 순서대로 전송 | 전화 교환기: 여러 사람 통화 신호를 시간별로 나눠 전송 |
| **CDM** (코드 분할 다중화) | 각 사용자에게 고유 **코드**를 부여해 동시에 보내고 나중에 구분 | 4G/5G 휴대폰: 여러 사람이 동시에 데이터 써도 구분됨 |
| **WDM** (파장 분할 다중화) | 광섬유에서 **파장(색깔)**을 다르게 해서 여러 신호를 전송 | 인터넷 광케이블에서 보라색/파란색 빛으로 동시에 데이터 전송 |
| **SDM** (공간 분할 다중화) | **물리적 경로**를 여러 개로 나눠서 신호를 동시에 전송 | 하나의 스위치에서 여러 랜선 포트로 각각 따로 데이터 전송 |

---

### 🧠 핵심 요약 (진짜 쉽게)

- ATM: 예전 통신 고속도로. 정해진 크기의 박스(셀)에 담아서 **빠르고 깔끔하게 전송**
- FDM: **주파수** 나눠서 동시에 전송 (라디오 느낌)
- TDM: **시간** 나눠서 하나씩 보내기 (순서지킴이)
- CDM: **암호(코드)** 써서 동시에 보내도 나중에 누가 보낸 건지 구분
- WDM: **빛 색깔** 다르게 해서 광케이블로 여러 개 동시 전송
- SDM: **물리적인 선로**를 여러 개 깔아서 동시 송신


---------------------------------------------------------------



\## 문제 6


\### 문제  

괄호에 들어갈 용어를 \*\*영어 약자\*\*로 작성하시오.


> (  )은 주로 \*\*사설 네트워크와 공인 네트워크 간의 IP 주소를 매핑하고 변환\*\*하는 데 사용되며,  
> 여러 대의 컴퓨터가 \*\*하나의 공인 IP 주소를 공유\*\*하여 인터넷에 접속할 수 있도록 한다.  
> (  )은 주로 \*\*라우터나 방화벽\*\* 같은 네트워크 장치에서 구현된다.  
> 네트워크 내부의 장치(사설 IP 주소를 가진)가 인터넷(공인 IP 주소를 사용하는)으로 데이터를 전송할 때,  
> (  ) 장치는 내부 IP 주소를 공인 IP 주소로 \*\*변환\*\*한다.  
> (  )은 \*\*IP 주소의 부족 문제를 완화\*\*하고, \*\*네트워크 보안\*\*을 강화하는 데 중요한 기술이다.



\### 답:

\*\*NAT\*\* (Network Address Translation)

---

### 📌 관련 개념 설명

---

#### ✅ NAT (Network Address Translation)

- 사설 IP와 공인 IP를 **서로 변환**해 주는 기술  
- 인터넷과 내부 네트워크 사이에서 **주소를 바꿔 주는 경계 역할**  
- 주로 라우터나 방화벽에서 사용됨  
- 하나의 공인 IP로 여러 사설 IP가 인터넷에 **동시에 접속 가능**  
- 내부 네트워크가 외부에 직접 보이지 않아 **보안 강화 효과**  

---

### 🔸 NAT 주요 유형

| 유형                  | 설명                                     | ✅ 갓반인 예시                             |
|-----------------------|----------------------------------------|-----------------------------------------|
| **Static NAT**        | 사설 IP 1개 ↔ 공인 IP 1개를 1:1 매핑    | 회사 서버가 항상 같은 공인 IP를 쓸 때      |
| **Dynamic NAT**       | 공인 IP 풀에서 사설 IP에 동적으로 할당    | 여러 PC가 공인 IP 풀에서 IP를 임시로 받음  |
| **PAT (포트 주소 변환)** | 여러 사설 IP가 하나 공인 IP를 포트로 나눠 공유 (NAT Overload) | 집 공유기에서 여러 기기가 하나 공인 IP로 인터넷 사용 |

---

### 🔎 IP 관련 기타 기술

| 기술                   | 설명                                   | ✅ 갓반인 예시                                  |
|------------------------|--------------------------------------|----------------------------------------------|
| **DNS**                | 도메인 이름 ↔ IP 주소 변환             | www.google.com → 172.217.0.0 같은 IP 주소로 변환 |
| **QoS**                | 특정 트래픽에 대역폭, 우선순위 보장       | 영상통화 중 인터넷 속도 우선 보장                |
| **VPN**                | 공용 네트워크에서 사설망처럼 안전하게 통신  | 카페에서 회사 내부망 안전하게 접속               |
| **DHCP**               | 장치에 자동으로 IP 주소 할당              | 스마트폰, 노트북이 자동으로 IP를 받음            |

---

### 🧠 핵심 정리 (진짜 쉽게!)

- NAT: 집 공유기처럼, 여러 내부 기기가 하나의 공인 IP로 인터넷 나갈 수 있게 변환해 줌  
- Static NAT: 특정 서버에 딱 한 개의 공인 IP 고정 배정  
- Dynamic NAT: 여러 PC가 공인 IP 풀에서 필요할 때마다 IP 임시 대여  
- PAT: 포트 번호를 쪼개 여러 기기가 하나 IP를 공유 (집 공유기의 핵심!)  
- DNS: www 주소 → IP 주소 변환기  
- QoS: 중요한 통신에 인터넷 속도 우선권 주기  
- VPN: 공용 와이파이에서 회사 네트워크 안전하게 쓰기  
- DHCP: 새로 연결된 기기에 자동으로 IP 줌  



---


\## 문제 7


UML을 이용한 다이어그램 중 \*\*아래 그림\*\*에 해당하는 다이어그램을 쓰시오.


인터넷 서점

결제 장바구니

^ ↖

|

|

카드 계좌이체



\### 답:  

\*\*패키지 다이어그램\*\* (Package Diagram)





### 📌 관련 개념 설명

---

#### ✅ 패키지 다이어그램 (Package Diagram)
- 시스템을 **모듈 단위로 나눠 구조를 표현**하는 UML 다이어그램  
- 클래스, 유스케이스, 컴포넌트 등을 **논리적으로 그룹화**할 때 사용  
- **의존(Dependency)**, **포함(Containment)** 관계를 화살표와 중첩으로 표현  

---

### 🔸 패키지 다이어그램 특징
- **패키지 = 관련 요소들의 논리적 묶음**  
- 패키지 간 관계는 **화살표(의존성)**로 표현  
- 하나의 큰 시스템을 여러 하위 패키지로 분리하여 관리 용이  
- 중복되는 요소를 분리해서 재사용 구조 만들기 좋음  

---

### 🔍 예시 구조

#### 예: 인터넷 서점 UML 패키지 다이어그램 구조

[인터넷서점]
├── [결제] ──▶ [카드]
│ └──▶ [계좌이체]
└── [장바구니]


- `[인터넷서점]`: 최상위 패키지  
- `[결제]`: 카드와 계좌이체 패키지에 **의존**  
- `[장바구니]`: 독립적인 하위 패키지  
- 실제 클래스는 각 패키지 안에 존재함 (예: 카드결제클래스 등)  

---

### 🔎 UML 주요 다이어그램 요약

| 다이어그램           | 설명                                |
|----------------------|------------------------------------|
| **클래스 다이어그램**    | 클래스 간의 구조와 관계 표현           |
| **유스케이스 다이어그램** | 사용자와 시스템 기능의 상호작용 표현    |
| **시퀀스 다이어그램**    | 객체 간 메시지 흐름 (시간 순서대로 표현) |
| **패키지 다이어그램**    | 시스템을 논리적 단위(패키지)로 나눠 표현 |
| **컴포넌트 다이어그램**  | 물리적 컴포넌트 구성 및 관계 표현      |
| **배치 다이어그램**      | 하드웨어와 소프트웨어의 배치 구조 표현  |

---



\## 문제 8



다음에서 설명하는 테스트 기법을 보기에서 골라 작성하시오.



> 이 기법은 입력 데이터를 \*\*효율적으로 테스트\*\*하기 위해 사용되며,  
> 특히 입력 데이터의 \*\*범위나 조건에 따라 테스트를 최소화\*\*하면서도  
> \*\*최대의 효과\*\*를 달성하는 데 도움을 준다.  

> 전체 입력 데이터를 여러 개의 '\*\*등가 클래스\*\*'로 나눈다.  
> 각 등가 클래스는 해당 클래스의 모든 값이 \*\*기대되는 동일한 행동\*\*을 보여야 한다고 가정한다.  
> 즉, 한 클래스의 하나의 값을 테스트하면, 해당 클래스의 다른 모든 값도  
> 동일한 결과를 보일 것이라고 예상한다.  

> 이러한 방식으로 \*\*테스트 케이스의 수를 줄일 수 있으며\*\*,  
> 테스트의 \*\*범위와 효율성\*\*을 높일 수 있다.


\### 답:

\*\*동등분할 기법 (Equivalence Partitioning)\*\*



### 📌 관련 개념 설명

---

#### ✅ 동등분할 기법 (Equivalence Partitioning)

- **블랙박스 테스트 기법** 중 하나  
- 전체 입력값을 **유사한 특성의 그룹(=등가 클래스)** 으로 나눔  
- 각 그룹에서 **대표값 1개만 테스트** → **테스트 수 줄이면서 커버리지는 확보**  
- **유효한 값**과 **무효한 값** 둘 다 고려 가능  

---

### 🔸 핵심 포인트
- 테스트 대상이 많을 때 **입력 범위 줄이기** 좋음  
- 하나의 등가 클래스 내부는 **동일하게 처리된다고 가정**  
- 각 클래스를 대표하는 **샘플 값 하나만 테스트**하면 됨  

---

### ✅ 예시

#### 조건: 입력값은 1~100 사이의 정수여야 함

| 구분         | 클래스           | 대표 테스트 값 |
|--------------|------------------|----------------|
| 유효 클래스   | 1~100            | `50`           |
| 무효 클래스① | 0 이하           | `-1`           |
| 무효 클래스② | 101 이상         | `150`          |

→ 이 3개 값만으로도 전체 테스트 범위를 커버 가능  

---

### 🔍 블랙박스 테스트 대표 기법 요약

| 기법               | 설명                                                             |
|--------------------|------------------------------------------------------------------|
| **동등분할 기법**     | 입력값을 등가 클래스(유사 동작 그룹)로 나눠 **대표값만 테스트**             |
| **경계값 분석**       | 입력 범위의 **경계값 전후 중심**으로 테스트 (예: 0, 1, 100, 101)         |
| **원인-효과 그래프**  | 입력 조건과 출력의 **논리 관계를 그래프로 모델링**, 복잡한 조건 처리 시 유용 |
| **오류 예측 검사**    | **경험/직관**에 기반해 오류 가능성이 높은 부분 위주로 테스트             |
| **비교 검사 (병행)** | 동일 입력을 **2개 시스템에 동시에 넣고 결과 비교**                        |

---

\## 문제 9



\### 문제  

다음은 클라우드에 대한 설명이다. 괄호 안에 알맞은 답을 보기에서 골라 작성하시오.

\#### (1)  

가상화된 \*\*컴퓨팅 자원\*\*을 인터넷을 통해 제공한다.  
사용자는 \*\*서버, 스토리지, 네트워킹과 같은 기본 인프라\*\*를 임대하여 사용한다.  
\*\*운영체제 및 응용프로그램 설치, 데이터 관리 등을 스스로 관리\*\*한다.  
\*\*확장성\*\*이 뛰어나고, \*\*사용한 만큼 비용을 지불\*\*하는 구조이다.  


→ \*\*답: IaaS (Infrastructure as a Service)\*\*


\#### (2)  

\*\*애플리케이션 개발과 배포\*\*를 위한 플랫폼 및 환경을 인터넷을 통해 제공한다.  
사용자는 \*\*개발 환경\*\*을 제공받으며, \*\*하드웨어 및 운영 체제 관리는 서비스 제공자\*\*가 담당한다.  
\*\*개발, 테스트, 배포, 호스팅 및 유지보수\*\*의 단순화된 프로세스를 제공한다.  

→ \*\*답: PaaS (Platform as a Service)\*\*


\#### (3)  

인터넷을 통해 \*\*소프트웨어 애플리케이션\*\*을 제공한다.  
사용자는 소프트웨어를 \*\*설치하거나 관리할 필요 없이 웹브라우저\*\*를 통해 사용 가능하다.  
\*\*업데이트 및 유지관리\*\*는 모두 \*\*서비스 제공자\*\*가 담당한다.  
사용자는 \*\*정기 구독료\*\*를 지불하며, \*\*다수의 사용자가 쉽게 접근\*\*할 수 있다.  


→ \*\*답: SaaS (Software as a Service)\*\*



\### ✅ 최종 답:

1\) \*\*IaaS\*\*  
2\) \*\*PaaS\*\*  
3\) \*\*SaaS\*\*



\### 📌 관련 개념 정리


| 구분    | 설명                                                              | 예시 (갓반인 기준)                                                                 |
|---------|-------------------------------------------------------------------|-------------------------------------------------------------------------------------|
| **IaaS** | Infrastructure as a Service<br>가상 서버, 스토리지, 네트워크 같은 **인프라를 빌려 씀** | 💡 컴퓨터를 통째로 빌려 쓰는 느낌<br>예: 게임 서버 만들려고 EC2로 리눅스 머신 띄움          |
| **PaaS** | Platform as a Service<br>**앱 만들 수 있는 개발 플랫폼을 빌려 씀**           | 💡 코드는 내가 짜고, 서버 운영은 안 해도 되는 느낌<br>예: Heroku에 코드만 올리면 배포됨     |
| **SaaS** | Software as a Service<br>**그냥 서비스 쓰는 것**                            | 💡 설치 없이 바로 웹에서 사용<br>예: Gmail로 메일 보내기, Google Docs로 문서 작성 등        |

---



\## 문제 10



\### 문제  

다음에서 설명하는 프로토콜을 \*\*영어 약어\*\*로 작성하시오.


> 내부 라우팅 프로토콜 중 하나로, 네트워크 내 라우터들 사이에서 정보를  
> 교환하여 \*\*최적의 경로\*\*를 결정하는 데 사용된다.  
> \*\*거리 벡터 라우팅 프로토콜\*\*의 일종으로, 목적지까지의 거리를 기반으로 라우팅 결정을 한다.  
> \*\*경로의 길이를 홉 카운트(hop count)\*\*로 측정하며, \*\*최대 15홉\*\*까지만 허용한다.  
> 일반적으로 \*\*30초마다 전체 라우팅 테이블을 브로드캐스트\*\*하거나 멀티캐스트한다.

\### ✅ 답: \*\*RIP\*\* (Routing Information Protocol)



### 📌 관련 개념 설명

#### ✅ RIP (Routing Information Protocol)

- **IGP (Interior Gateway Protocol)**의 대표적인 거리 벡터 기반 프로토콜
- 라우터끼리 **라우팅 정보를 주고받으며** 최단 경로를 계산함
- **경로 길이 = 홉 수(Hop Count)** 로 판단함  
  → 한 라우터를 지나칠 때마다 홉 수 +1  
  → **최대 15홉까지만 가능**, 16 이상은 도달 불가로 간주
- **30초마다** 라우팅 테이블 전체를 이웃 라우터에게 보냄  
  → **브로드캐스트** 또는 **멀티캐스트**로 전달


### 🧠 갓반인 예시

💬 “서울에서 부산까지 가는 길을 알려줘!”

- 서울 라우터는 옆에 있는 수원 라우터에게 “나는 서울까지 1홉 거리야”라고 알려줌
- 수원은 그걸 듣고 “아하, 내가 서울까지 1홉이구나”라고 기억함
- 수원은 다시 대전에게 “나는 서울까지 2홉이야”라고 전달함
- 이런 식으로 각 라우터가 몇 홉 걸리는지 계산하고 기억함

📌 홉 수가 16이 넘으면?
- 너무 멀어서 “그건 못 가요~”라고 생각함 → 도달 불가 판정


### ✅ 비교용 한 줄 요약

| 프로토콜 | 기준            | 설명                           |
|----------|-----------------|--------------------------------|
| **RIP**  | 홉 수           | 단순하지만 멀리 못 감 (최대 15) |
| **OSPF** | 링크 상태 기반  | 더 똑똑하고, 큰 네트워크에 적합 |


---


\## 문제 11


\### 문제  

다음은 관계 대수 기호이다. 보기에서 알맞은 \*\*기호\*\*로 작성하시오.



| 연산 종류  | 기호 |
|------------|------|
| (1) JOIN   | ?    |
| (2) PROJECT| ?    |
| (3) SELECT | ?    |
| (4) DIVISION| ?   |



### ✅ 답:

1) **JOIN** → ⨝  
2) **PROJECT** → **π**  
3) **SELECT** → **σ**  
4) **DIVISION** → **÷**



### 📌 관련 개념 설명

| 연산자     | 기호 | 설명                                       | 갓반인 예시                                 |
|------------|------|--------------------------------------------|---------------------------------------------|
| **JOIN**   | ⨝    | 두 테이블을 조건에 맞게 붙이는 연산       | 학생 테이블 ⨝ 수강 테이블 = 학생이 수강한 강의 |
| **PROJECT**| π    | 원하는 열만 추출하는 연산 (세로 추출)      | 학생 테이블에서 이름만 뽑기 → π 이름(학생)     |
| **SELECT** | σ    | 조건에 맞는 행만 추출하는 연산 (가로 필터) | 수강 테이블에서 점수 ≥ 90 → σ 점수≥90(수강)   |
| **DIVISION**| ÷   | A에서 B의 모든 값을 만족하는 행 추출      | 모든 과목 수강한 학생 찾기 등 (복잡하지만 강력) |


### 🔎 관계 대수 연산 요약

#### 🔹 순수 관계 연산자

- **SELECT (σ)**: 행 필터링 → 조건 만족하는 데이터만 골라냄  
- **PROJECT (π)**: 열 필터링 → 필요한 속성만 뽑아냄  
- **JOIN (⨝)**: 두 릴레이션을 조인 조건에 따라 연결  
- **DIVISION (÷)**: 어떤 조건을 **전부** 만족하는 튜플만 추출  

#### 🔹 일반 집합 연산자

- **합집합 (∪)**: A 또는 B에 있는 것 전부  
- **교집합 (∩)**: A와 B 둘 다 있는 것만  
- **차집합 (−)**: A에만 있고 B에는 없는 것  
- **카티션 프로덕트 (×)**: 모든 조합 생성 (JOIN 전 단계)


### 🧠 갓반인 요약 한 줄 정리

- SELECT는 행 고르기 (가로)
- PROJECT는 열 고르기 (세로)
- JOIN은 테이블 붙이기
- DIVISION은 **전부 만족하는 것만 골라내기** (시험 자주 나옴!)

---



\## 문제 12

다음에서 설명하는 제약 조건에 대해서 쓰시오.


> 데이터베이스의 (  ) 무결성 제약 조건은 데이터베이스 내에서 데이터의  
> 정확성과 일관성을 유지하는 데 중요한 역할을 한다.  
> 이 제약조건은 특히 관계형 데이터베이스에서 \*\*외래키 관계\*\*를 통해 구현되며,  
> 연관된 테이블 간의 적절한 데이터 관계가 유지되도록 보장한다.  
> 한 테이블의 필드(외래키)가 다른 테이블의 기본키를 참고할 때,  
> 외래키 값은 참조하는 테이블의 기본키에 존재하는 값이어야 한다.  
> 즉, 참조하는 데이터가 실제로 존재해야 한다.


\### 답:  

\*\*참조 무결성\*\* (Referential Integrity)


### 📌 관련 개념 설명

#### ✅ 참조 무결성 (Referential Integrity)
- **외래키(Foreign Key)** 제약조건으로 구현
- 외래키 값은 반드시 참조 대상 테이블의 **기본키** 중 하나여야 함
- 데이터의 **일관성과 정확성 유지**를 위해 필수

#### 🔸 동작 옵션
| 옵션 | 설명 |
|------|------|
| **CASCADE** | 참조 대상이 삭제/수정되면 같이 삭제/수정됨 |
| **SET NULL** | 참조 대상이 삭제/수정되면 외래키 값을 NULL로 설정 |
| **NO ACTION / RESTRICT** | 참조 대상이 삭제/수정되지 않도록 제한 |


### 🔎 무결성 제약 조건 종류

| 무결성 종류       | 설명 |
|------------------|------|
| **도메인 무결성** | 각 컬럼의 값이 정해진 범위(타입) 안에 있어야 함 |
| **개체 무결성**   | 기본키는 **중복 불가 + NULL 불가** |
| **참조 무결성**   | 외래키는 참조 대상 테이블의 기본키를 **반드시 참조**해야 함 |
| **사용자 정의 무결성** | 업무 규칙에 따른 조건 직접 설정 (예: 급여 > 0) |

---

### 🧠 갓반인용 예시

#### 예시 테이블

**부서 테이블 (Department)**  
| dept_id (PK) | dept_name  |
|--------------|------------|
| 10           | 개발팀     |
| 20           | 마케팅팀   |


**직원 테이블 (Employee)**  
| emp_id | emp_name | dept_id (FK) |
|--------|----------|--------------|
| 101    | 철수     | 10           |
| 102    | 영희     | 20           |
| 103    | 민수     | 30 ❌ (존재하지 않음) |

✅ 103번 직원처럼 **없는 부서 번호(30)** 를 참조하면 **참조 무결성 위반**!


### 📌 핵심 요약

- **외래키는 반드시 기본키를 참조해야 함**
- 참조 대상이 사라질 때, 어떻게 처리할지 옵션 선택 필수
- 데이터 간 연결의 신뢰성을 지켜주는 핵심 규칙!

---
문제 13)

  
                                    // class A: 부모 클래스다.
class A {
                                                  // public void paint(): A 클래스의 paint 메서드다.
    public void paint() {
        System.out.print("A");                                         // "A"를 출력한다.
        draw();                                   // draw() 메서드를 호출한다. (이 시점에는 아직 B 객체를 만들기 전이니, A의 draw()를 호출하려는 시도)
    }

    // public void draw(): A 클래스의 draw 메서드다.
    public void draw() {
        System.out.print("B");                                           // "B"를 출력한다.
                                                                  // 💡 재귀 호출! 자기 자신(A의 draw())을 다시 호출한다.
                                                                  // 이 A 클래스만 단독으로 실행된다면 "BBBBBB..." 하면서 무한 루프에 빠질 거다.
                                                                  // 하지만 자식 클래스 B가 이 메서드를 '오버라이딩'했기 때문에, 실제 동작은 달라진다.
        draw();
    }
}

                                                                        // class B extends A: 자식 클래스 B는 부모 클래스 A를 상속받는다.
class B extends A {
                                                                      // @Override: 이 어노테이션은 이 메서드가 부모 클래스 A의 paint() 메서드를 '오버라이딩'했음을 명시한다.
                                                                      // 오버라이딩은 부모의 메서드를 자식이 자기 방식대로 '재정의'하는 걸 말한다.
    @Override
    public void paint() {
                                                                      // super.draw(): 💡 개중요! 'super' 키워드는 '부모 클래스(A)의 멤버'를 가리킬 때 쓴다.
                                                                      // 따라서 'super.draw()'는 '부모 A 클래스의 draw() 메서드'를 호출한다.
                                                                      // A의 draw()가 실행되면 "B"를 출력하고 다시 draw()를 호출하는데,
                                                                      // 이때 A의 draw() 안에서 호출되는 'draw()'는 실제 객체(B)의 오버라이딩된 draw() (즉, B의 draw())가 호출된다.
                                                                      // 결과적으로 여기서 "B" -> "D" 순으로 출력된다.
        super.draw();
        System.out.print("C"); // "C"를 출력한다.
                                                                          // this.draw(): 💡 중요! 'this' 키워드는 '현재 객체(B)의 멤버'를 가리킬 때 쓴다.
                                                                          // 따라서 'this.draw()'는 '현재 B 클래스 객체의 오버라이딩된 draw() 메서드'를 호출한다.
                                                                          // B의 draw()가 실행되면 "D"를 출력한다.
        this.draw();
    }

                                                                                // @Override: 이 어노테이션은 이 메서드가 부모 클래스 A의 draw() 메서드를 '오버라이딩'했음을 명시한다.
    @Override
    public void draw() {
   System.out.print("D");                                               // "D"를 출력한다.
                                                                      // B의 draw() 메서드는 부모 A의 draw()처럼 재귀 호출이 없다.
                                                                      // 단순히 "D"만 출력하고 종료된다.
                                                                      // 이 덕분에 A의 draw()에서 재귀 호출하는 부분이 실제 B 객체에서 실행될 때 무한 루프에 빠지지 않는 거다.
    }
}

                                                                                            // class EraonEdu: 프로그램을 실행하는 메인 클래스다.
class EraonEdu {
                                                                      // public static void main(String[] args): 자바 프로그램의 시작점이다.
    public static void main(String[] args) {
                                                                            // A b = new B();: 💡 다형성(Polymorphism)의 핵심!
                                                                            // 'A' 타입의 참조 변수 'b'가 'B' 타입의 객체를 참조한다.
                                                                            // 컴파일 시점에는 'b'가 'A' 타입으로 보이지만,
                                                                            // 런타임 시점에는 'b'가 실제로 'B' 객체를 가리키고 있기 때문에 'B' 객체의 오버라이딩된 메서드가 호출된다.
        A b = new B();

                                                                                    // b.paint(): 'b' 변수가 가리키는 객체(B 객체)의 'paint()' 메서드를 호출한다.
                                                                                    // 런타임에 'B' 객체의 오버라이딩된 paint()가 실행된다.
                                                                                    // 실행 흐름:
                                                                                    // 1. B의 paint() 시작
                                                                                    // 2. super.draw() 호출 -> A의 draw() 실행 -> "B" 출력
                                                                                    // 3. A의 draw() 안에서 'draw()' 호출 (이때는 B 객체이므로 B의 draw()가 실행) -> "D" 출력
                                                                                    //    (여기까지 총 "BD" 출력됨)
                                                                                    // 4. System.out.print("C"); 실행 -> "C" 출력
                                                                                    //    (여기까지 총 "BDC" 출력됨)
                                                                                    // 5. this.draw() 호출 -> B의 draw() 실행 -> "D" 출력
                                                                                    //    (여기까지 총 "BDCD" 출력됨)
        b.paint();

                                                                                  // b.draw(): 'b' 변수가 가리키는 객체(B 객체)의 'draw()' 메서드를 호출한다.
                                                                                  // 런타임에 'B' 객체의 오버라이딩된 draw()가 실행된다.
                                                                                  // 실행 흐름:
                                                                                  // 1. B의 draw() 시작
                                                                                  // 2. System.out.print("D"); 실행 -> "D" 출력
                                                                                  //    (최종적으로 "BDCDD" 출력됨)
        b.draw();
    }
}


🚀 최종 출력 결과
BDCDD

### 📌 핵심 개념 정리: 상속과 다형성

| 개념               | 설명                                                                                      | 갓반인 예시                                              |
|--------------------|-----------------------------------------------------------------------------------------|---------------------------------------------------------|
| **상속 (Inheritance)**   | 클래스 B가 클래스 A의 속성과 기능을 물려받음                                             | 자동차(A) 클래스를 상속받아 전기자동차(B)를 만듦           |
| **오버라이딩 (Overriding)** | 클래스 B가 부모 A의 메서드(draw 등)를 자신에 맞게 재정의함                                | 부모 클래스의 draw() 대신 자식 클래스에서 새로 그리기 구현    |
| **다형성 (Polymorphism)**  | 부모 클래스 타입(A) 변수로 자식 객체(B)를 다루지만, 실제 실행은 자식 클래스 메서드 기준       | A타입 변수에 B 객체를 담아도 B의 draw()가 실행됨            |
| **동적 바인딩 (Dynamic Binding)** | 실행 시점(런타임)에 실제 객체(B)의 메서드를 호출하는 것                                  | 실행할 때 B 객체인지 판단해 B의 메서드를 실행함             |
| **super.draw()**         | 부모 클래스 A의 draw() 메서드를 직접 호출함                                               | B 클래스에서 부모 A의 원래 draw() 기능을 쓸 때 사용           |
| **this.draw()**          | 현재 객체(B)의 draw() 메서드를 호출함                                                    | B 클래스 내에서 자신의 오버라이딩된 draw()를 호출할 때 사용     |

---

💡 쉽게 말하면,  
상속은 부모 속성/기능을 물려받는 것,  
오버라이딩은 부모 기능을 자식 방식으로 바꾸는 것,  
다형성은 부모 타입 변수로 자식을 다뤄도 자식 메서드가 실행되는 거야!  
동적 바인딩 덕분에 가능하며, `super`와 `this`로 부모/자신 메서드 구분할 수 있어.


---

\## 문제 14


다음 C언어 코드의 출력 결과를 쓰시오.


#include <stdio.h>                     // 표준 입출력 함수 (printf)를 사용하기 위해 필요한 헤더 파일이다.

int main(){                       // C 프로그램이 시작될 때 가장 먼저 실행되는 함수다.
                                                    // char *p = "KOREA"; // 💡 중요! 'p'라는 char 포인터 변수를 선언하고,
                                                                         // "KOREA"라는 문자열 리터럴의 시작 주소를 'p'에 할당한다.
                                                                         // 문자열 리터럴은 읽기 전용 메모리 영역에 저장된다.
                                                                         // 즉, 'p'는 이제 메모리 어딘가에 있는 'K', 'O', 'R', 'E', 'A', '\0'(널 종료 문자)
                                                                         // 순으로 저장된 공간의 'K'의 주소를 가리킨다.
    char *p = "KOREA";
printf("%s \n", p);                                                           // 1. '%s'는 문자열(string)을 출력하라는 서식 지정자다.
                                                                  //    'p'는 문자열 "KOREA"의 시작 주소를 가리키므로,
                                                                  //    널 문자('\0')를 만날 때까지 "KOREA" 전체를 출력한다.
                                                                  //    '\n'은 줄 바꿈.  
                                                                  //    출력: KOREA
    printf("%s \n", p);

    printf("%s \n", p+1);                   // 2. 'p+1'은 'p'가 가리키는 주소에서 1바이트(char 크기)만큼 뒤로 이동한 주소다.
                                                            //    원래 'K'의 주소였는데, 이제 'O'의 주소를 가리키게 된다.
                                                            //    '%s'로 출력하므로, 'O'부터 널 문자까지 "OREA"를 출력한다.
                                                            //    출력: OREA
    printf("%s \n", p+1);

    printf("%c \n", *p);                                  // 3. '%c'는 단일 문자(character)를 출력하라는 서식 지정자다.
                                                      //    '*p'는 'p'가 가리키는 주소에 있는 '값'을 의미한다.
                                                      //    'p'는 여전히 "KOREA"의 시작 주소(K)를 가리키므로, 'K' 문자가 출력된다.
                                                      //    출력: K
    printf("%c \n", *p);

    printf("%c \n", *(p+3));                       // 4. '*(p+3)'는 'p'가 가리키는 주소에서 3칸 뒤로 이동한 후, 그 위치의 '값'을 의미한다.
                                                               //    p -> K, p+1 -> O, p+2 -> R, p+3 -> E
                                                               //    따라서 'E' 문자가 출력된다.
                                                               //    출력: E
    printf("%c \n", *(p+3));

    printf("%c", *p+4);                     // 5. 💡 개중요! '*p+4'는 'p'가 가리키는 값(문자 'K')에 정수 4를 더한 결과다.
                                                                //    문자 'K'는 아스키(ASCII) 코드 값으로 75다.
                                                                //    75 + 4 = 79.
                                                                //    아스키 코드 79는 대문자 'O'를 의미한다.
                                                                //    '%c'로 출력하므로, 'O' 문자가 출력된다.
                                                                //    출력: O
                                                                //    (이 마지막 printf는 '\n'이 없으므로 다음에 출력되는 게 있다면 바로 옆에 붙는다.)
    printf("%c", *p+4);
}


답: 
KOREA
OREA
K
E
O




### 코드 분석
### 🔍 각 printf 라인별 상세 설명

```c
printf("%s \n", p);
p는 문자열 "KOREA"의 시작 주소를 가리킴

%s는 해당 주소부터 널 문자(\0)까지 문자열 출력

출력: KOREA

printf("%s \n", p+1);
p+1은 "KOREA"에서 한 칸 뒤, 즉 'O'의 주소

%s는 'O'부터 널 문자까지 출력

출력: OREA

printf("%c \n", *p);
*p는 p가 가리키는 값, 즉 'K' 문자 자체

%c는 단일 문자 출력

출력: K

printf("%c \n", *(p+3));
p+3은 "KOREA"에서 세 칸 뒤, 즉 'E' 문자 주소

*(p+3)은 그 주소의 값, 즉 'E' 문자

%c는 단일 문자 출력

출력: E

printf("%c", *p+4);
*p는 'K' 문자 (아스키 코드 75)

*p + 4는 75 + 4 = 79

아스키 79는 문자 'O'

%c는 단일 문자 출력

출력: O

---


\## 문제 15

                                                    // #include: 헤더 파일을 포함하는 전처리기 지시문인데, 이 코드에서는 파일 이름이 빠져 있다.
                                                    // 🚨 컴파일 에러 발생 지점! -> `#include <stdio.h>` 처럼 정확한 헤더 파일 이름을 써야 한다.
 #include
                                                             // struct User: 'User'라는 이름의 구조체(Structure)를 정의한다.
                                                             // 구조체는 여러 다른 타입의 데이터를 하나로 묶어 관리할 때 사용한다.
 struct User{
                                                                 // char* name;: 'name'이라는 멤버 변수다. 문자열(char*)을 저장할 포인터다.
                                                                 // 이 포인터는 문자열의 첫 글자가 저장된 메모리 주소를 가리킨다.
 char*name;
                                               // int age;: 'age'라는 멤버 변수다. 나이를 저장할 정수형 변수다.
 int age;
 };
                                               // int main(): C 프로그램의 시작점이다. 이 함수부터 코드가 실행된다.
 intmain() {
                                                   // struct User d1;: 'd1'이라는 이름의 User 구조체 '변수'를 선언한다.
                                                   // 이 변수는 스택(Stack) 메모리 영역에 'name' 포인터와 'age' 정수를 위한 공간을 바로 확보한다.
 structUser d1;
                                                     // struct User *d2;: 💡 개중요! 'd2'라는 이름의 User 구조체 '포인터' 변수를 선언한다.
                                                     // 이 'd2'는 'User 구조체 타입의 데이터가 저장된 메모리 주소'를 저장할 포인터다.
                                                     // 🚨 중요! 이 시점에는 'd2' 포인터 변수 자체만 선언된 거고,
                                                     // 'd2'가 실제로 가리킬 'User' 구조체 데이터 공간은 아직 '어디에도 할당되지 않았다'.
                                                     // 즉, 'd2'는 쓰레기 값(아무 의미 없는 주소)을 가지고 있거나, NULL 상태다.
                                                     // 비어있는 주소록에 그냥 이름표만 붙여놓은 격이다.
 structUser *d2;
                                                   // 🚨 치명적인 컴파일 에러 발생 지점!
                                                   // d2( )name = “Lee”;
                                                   // d2( )age = 45;
                                                   // 💡 문법 오류! C 언어에서 '구조체 포인터'가 가리키는 멤버에 접근할 때는 반드시
                                                        '->'(화살표) 연산자를 사용해야 한다.
                                                   // 'd2( )name'은 'd2'를 함수처럼 호출하려는 문법으로 인식되는데, 'd2'는 함수가 아니므로 컴파일러가 오류를 낸다.
                                                   // 올바른 문법은 'd2->name'과 'd2->age'다.
 d2( )name= “Lee”;                                 // 여기서 컴파일 에러가 발생한다.
 d2( )age=45;                                   // 여기서도 컴파일 에러가 발생한다.
                                                       // printf(“%s,%d”, d2( )name, d2( )age);
                                                       // 위에 문법 오류 때문에 이 printf 문은 컴파일조차 되지 않으므로, 실행될 수 없다.
 printf(“%s,%d”, d2( )name, d2( )age);
}


### ✅ 정답  
**`->`**


## 💥 최종 결론: 컴파일 에러 (Syntax Error)
이 코드는 **다음과 같은 문법 오류** 때문에 **컴파일 자체가 실패**하고, 실행 결과는 **아예 없음**.

---

### 🚨 오류 1: `#include` 뒤에 헤더 파일 누락
#include
<stdio.h>와 같은 헤더 파일 이름이 빠짐

→ 컴파일러가 printf() 등 함수 정의를 찾지 못해 오류 발생

🚨 오류 2: 구조체 포인터 멤버 접근 문법 오류
d2( )name
이건 함수를 호출하려는 문법처럼 보이는데, d2는 함수가 아님

구조체 포인터로 멤버에 접근할 땐 → 연산자를 사용해야 함

올바른 문법: d2->name

❌ 실행 결과는 없음
문법 오류 때문에 컴파일 단계에서 실패

즉, 실행 자체가 되지 않음 → 출력도 없음

💡 정보처리 시험이라면 이렇게 생각하자!
포인트	설명
✅ 기본 문법 지식	구조체 포인터는 ->로 멤버 접근
✅ 에러 식별 능력	문법상 오류로 인해 컴파일 실패 여부를 파악할 수 있어야 함

📌 정답 고르라면?
→ "컴파일 오류" 또는 "문법 에러" 선택!
---

\## 문제 16

다음 C언어 코드의 출력 결과를 쓰시오.
#include <stdio.h>                           // 표준 입출력 함수 (printf)를 사용하기 위해 필요하다.

                                              // func 함수: 정수 n을 입력받아 n이 완전수인지 아닌지 판별한다.
                                              // 완전수: 자기 자신을 제외한 약수(나누어 떨어지는 수)들의 합이 자기 자신과 같은 수.
                                              // 예: 6의 약수 = 1, 2, 3, 6. 자기 자신(6)을 제외한 약수 1+2+3 = 6. 따라서 6은 완전수다.
int func(int n){
    int i, sum = 0;                     // 약수들의 합을 저장할 'sum' 변수를 0으로 초기화한다.
    
                                                            // for 반복문: 1부터 n의 절반(n/2)까지 순회하며 약수를 찾는다.
                                                            // n의 약수는 n/2를 넘을 수 없으므로, 이 범위까지만 확인하면 된다. (자기 자신은 제외)
    for (i = 1; i <= n / 2; i++) {
                                                                      // if 조건문: 'n'을 'i'로 나눈 나머지가 0인지 확인한다.
                                                                      // 나머지가 0이면 'i'는 'n'의 약수라는 뜻이다.
        if (n % i == 0)
            sum += i;                               // 'i'가 약수라면 'sum'에 더한다.
    }

    // if 조건문: 계산된 약수들의 합 'sum'이 원래 숫자 'n'과 같은지 확인한다.
    if (n == sum)
        return 1; // 같으면 'n'은 완전수이므로 1(참)을 반환한다.

    return 0; // 다르면 'n'은 완전수가 아니므로 0(거짓)을 반환한다.
}


답:
34


#include <stdio.h>

                                                            // ✅ func: n이 완전수인지 판단하는 함수
int func(int n) {
    int i, sum = 0;

                                                            // 1부터 n-1까지의 약수를 찾고 합산
    for (i = 1; i < n; i++) {
        if (n % i == 0)                                                  // i가 n의 약수라면
            sum += i;
    }

                                                                  // 완전수이면 1, 아니면 0 반환
    return sum == n;
}

int main() {
    int i, sum = 0;

                                                                  // 2부터 100까지 완전수 탐색
    for (i = 2; i <= 100; i++) {
        if (func(i))                                                      // i가 완전수면
            sum += i;                                                               // 합산
    }

    printf("%d", sum);                                                // 출력: 완전수들의 합
    return 0;
}

🎯 최종 출력 결과
34

func(n)은 n이 완전수인지 확인한다.
n의 약수(자기 자신 제외)들을 찾아 sum에 더한다.
sum이 n과 같으면 1(완전수)을 반환하고, 다르면 0(완전수 아님)을 반환한다.

✅ 핵심 요약 (갓반인 스타일)
포인트	설명
func(n)	약수 다 더해서 n이랑 같으면 완전수 (1 반환)
main()	2부터 100까지 돌면서 완전수면 sum에 더함
완전수	자기 자신을 제외한 약수의 합 = 자기 자신
100 이하 완전수	6, 28
최종 출력	6 + 28 = 34

🔍 예시 흐름 (갓반인 시점)
i = 6:
1 + 2 + 3 = 6 → ✅ 완전수! → sum = 6

i = 28:
1 + 2 + 4 + 7 + 14 = 28 → ✅ 완전수! → sum = 6 + 28 = 34

i = 496:
✅ 완전수지만 ❌ 100 초과라서 패스


---

\## 문제 17

다음 자바 코드는 오류가 발생한다. 오류가 발생하는 명령을 쓰시오.

class Person {
    private String name; // 🚩 인스턴스 변수: 객체(인스턴스)가 생성될 때마다 개별적으로 만들어진다.

    public Person(String val){ // 생성자: 객체 생성 시 'name'을 초기화한다.
        name = val;
    }

    public static String get(){ // 🚩 static 메서드: 객체 생성 없이 '클래스명.메서드명()'으로 호출 가능하다.
        return name; // 💥 첫 번째 오류 발생 지점!
                     // static 메서드 안에서는 '인스턴스 변수(name)'에 직접 접근할 수 없다.
                     // 인스턴스 변수는 특정 '객체'에 속하는데, static 메서드는 '객체'가 없어도 존재하기 때문이다.
                     // (컴파일 에러: Non-static field 'name' cannot be referenced from a static context)
    }

    public void print(){ // 인스턴스 메서드: 객체를 통해서만 호출 가능하며, 인스턴스 변수에 접근할 수 있다.
        System.out.println(name);
    }
}

public class Main {
    public static void main(String [] args){
        // 💥 두 번째 오류 발생 지점!
        // Person obj = new Person "Lee"); // 문법 오류: 생성자 호출 시 괄호가 빠졌다.
        //                                // 올바른 문법은 'new Person("Lee");'이다.
        Person obj = new Person "Lee");

        obj.print(); // 위에서 컴파일 오류가 발생했으므로 이 라인은 실행되지 않는다.
; // 불필요한 세미콜론. 문법 오류는 아니지만 코드 스타일을 해친다.
    }
}

답:

return name;



🚨 오류가 발생하는 명령은?
✅ 핵심 오류: return name;
이 코드는 static 메서드 get() 안에서 인스턴스 변수 name에 접근하려고 하기 때문에 컴파일 오류가 발생함.

static 메서드는 클래스 소속이고, 인스턴스 변수는 객체 소속이기 때문에, 직접 접근 불가능함.

✨ 요약
항목	설명
⚠️ 오류 위치	return name;
❌ 이유	static 메서드에서 인스턴스 변수에 직접 접근
📌 원칙	static은 객체 없이 호출되므로, 인스턴스 변수에 접근하려면 객체 참조를 통해야 함
💥 결과	컴파일 에러 발생 (non-static variable name cannot be referenced from a static context)

💡 추가 오류: 생성자 괄호 누락
new Person "Lee";  // ❌ 오류 발생
new Person("Lee");처럼 괄호를 반드시 써야 한다.

위 문법 오류는 문자열을 생성자 인자로 넘기지 못하게 됨 → 문법상 잘못된 생성자 호출

🎯 정보처리 시험 포인트
static 메서드 내부에서 인스턴스 멤버 접근 시도 → 시험 단골 문제

컴파일 타임 오류로, 코드 실행 전에 바로 막힘

출제자는 이를 통해 static과 인스턴스 멤버 구분을 할 수 있는지를 파악하려는 것

🧨 결론
static 메서드에서 인스턴스 변수에 직접 접근하면 컴파일 오류 난다!
객체 없이 존재하는 애한테, 객체가 있어야만 존재하는 걸 찾으려 하니까 당연히 못 찾는다.


**-----------------------------------------------------------------------------------**

**## 문제 18**



**### 문제**  

**다음 자바 코드의 결과를 쓰시오.**

                                    // class Parent: 부모 클래스다.
class Parent {
                                // int com(int n): 'com' 메서드다. 재귀적으로 호출되는 함수다.
                                // 이 메서드는 n이 1 이하일 때 n을 반환하고, 그 외에는 com(n-1)과 com(n-2)를 더하는 방식으로 작동한다.
                                // 이는 전형적인 '피보나치 수열'과 같은 형태다.
    int com(int n){
        if (n <= 1)                       // 💡 재귀 호출의 종료 조건이다. n이 0이거나 1이면 더 이상 재귀 호출을 하지 않고 n 값을 바로 반환한다.
            return n;                         // com(0)은 0, com(1)은 1을 반환하게 된다.
                                                    // 💡 중요! 자기 자신을 n-1과 n-2 값으로 다시 호출한다.
                                                    // 예를 들어, com(2)는 com(1) + com(0)이 되고, com(3)은 com(2) + com(1)이 된다.
        return com(n-1) + com(n-2);
    }
}

                                                // class Child extends Parent: 자식 클래스 Child는 부모 클래스 Parent를 상속받는다.
class Child extends Parent {
                  // @Override: 이 어노테이션은 이 메서드가 부모 클래스 Parent의 com(int n) 메서드를 '오버라이딩'했음을 명시한다.
                  // 오버라이딩은 부모 클래스가 가진 메서드와 '이름, 매개변수, 반환 타입'이 모두 같게 자식 클래스에서 '재정의'하는 것을 말한다.
    @Override
    int com(int n){                             // 부모 Parent의 com(int n) 메서드를 오버라이딩했다.
        if(n <= 1)                                 // 💡 재귀 호출의 종료 조건이다. 부모 클래스와 동일하게 n이 0이거나 1이면 n 값을 바로 반환한다.
            return n;
                                              // 💡 개중요! 부모 클래스와 다르게 com(n-1)과 com(n-3)을 더한다.
                                              // 이 부분 때문에 최종 결과가 부모의 피보나치 수열과 다르게 나온다.
                                              // 런타임 시에 'Child' 객체의 메서드가 호출될 때, 항상 이 오버라이딩된 'Child'의 com() 메서드가 사용된다.
        return com(n-1) + com(n-3);
    }
}

                                      // public class Main: 프로그램을 실행하는 메인 클래스다.
public class Main {
                                // public static void main(String[] args): 자바 프로그램의 시작점이다.
    public static void main(String [] args){
                                            // Parent obj = new Child();: 💡 다형성(Polymorphism)의 핵심!
                                          // 'Parent' 타입의 참조 변수 'obj'가 'Child' 타입의 객체를 참조한다.
                                          // 컴파일 시점에는 'obj'가 'Parent' 타입으로 보이지만,
                                          // 런타임 시점에는 실제 객체인 'Child'의 오버라이딩된 메서드가 호출된다. 이것을 '동적 바인딩(Dynamic Binding)'이라고 한다.
        Parent obj = new Child();

                                        // System.out.print(obj.com(7));: 'obj' 변수가 가리키는 객체(Child 객체)의 'com(7)' 메서드를 호출한다.
                                        // 'obj'는 Child 객체를 참조하고 있으므로, Child 클래스의 오버라이딩된 'com(7)' 메서드가 실행된다.
                                        // 이 메서드는 com(n-1) + com(n-3) 로직을 따른다.
        System.out.print(obj.com(7));
    }
}

답:2



🔍 obj.com(7) 실행 흐름 (Child 클래스 기준)
Child 클래스에서는 com(n)이 다음 로직으로 구성돼 있어:

int com(int n){
    if(n <= 1) return n;
    return com(n-1) + com(n-3);
}

✅ 재귀 호출 종료 조건
입력값	반환값	이유
com(0)	0	n <= 1 이므로 그대로 반환
com(1)	1	n <= 1 이므로 그대로 반환
com(-1)	-1	n <= 1 이므로 그대로 반환 (비정상 입력이지만 조건엔 맞음)

🧮 계산 과정 (Top-down 방식)
text
복사
편집
com(7)
= com(6) + com(4)
= (com(5) + com(3)) + (com(3) + com(1))
= ((com(4) + com(2)) + (com(2) + com(0))) + ((com(2) + com(0)) + 1)
= (((com(3) + com(1)) + (com(1) + com(-1))) + ((com(1) + com(-1)) + 0)) + ((com(1) + com(-1)) + 1)
= ...
너무 깊게 가면 복잡하니까 최종 계산 결과만 정리하면 다음과 같아:

호출	계산식	결과
com(-1)	종료 조건 → -1 반환	-1
com(0)	종료 조건 → 0 반환	0
com(1)	종료 조건 → 1 반환	1
com(2)	com(1) + com(-1) = 1 + (-1)	0
com(3)	com(2) + com(0) = 0 + 0	0
com(4)	com(3) + com(1) = 0 + 1	1
com(5)	com(4) + com(2) = 1 + 0	1
com(6)	com(5) + com(3) = 1 + 0	1
com(7)	com(6) + com(4) = 1 + 1	2

🚀 최종 출력 결과
System.out.print(obj.com(7));


🔽 출력 결과:
2

**-----------------------------------------------------------------------------------**



**## 문제 19**



#include <stdio.h> // 표준 입출력 함수 (printf)를 사용하기 위해 이 헤더 파일을 포함해야 한다.

                                // int f(int n): 'f'라는 이름의 함수다. 정수 'n'을 입력받아 팩토리얼을 계산한다.
                                // 팩토리얼(Factorial): 1부터 n까지의 모든 양의 정수를 곱한 값. 기호는 'n!'
                                // 예: 5! = 5 × 4 × 3 × 2 × 1 = 120
int f(int n){
    if(n <= 1)                     // 💡 재귀 호출의 종료 조건이다. n이 1 이하면 재귀 호출을 멈추고 1을 반환한다.
                                           // 0!도 1, 1!도 1이기 때문에 이렇게 설정한다.
        return 1;
    else // n이 1보다 크면 다음 계산을 수행한다.
        // 💡 중요! 'n'에 'n-1'의 팩토리얼 값 (f(n-1)의 결과)을 곱하는 방식으로 재귀 호출한다.
        // 예를 들어, f(3)은 3 * f(2)가 되고, f(2)는 2 * f(1)이 된다.
        return n * f(n-1);
}

🔍 f(n) 함수 설명 (재귀 팩토리얼 함수)
f(n) 함수는 재귀 함수다.
→ 자기 자신을 계속 호출하면서 값을 계산한다.

✅ 재귀 종료 조건
if(n <= 1) return 1;
이 부분이 재귀 호출의 종료 조건이다.

이 조건이 없으면 함수가 끝없이 호출되다 스택 오버플로우가 발생한다.

✅ 팩토리얼 계산 핵심
=
else return n * f(n-1);
n과 f(n-1)의 결과를 곱하는 방식으로 팩토리얼을 계산한다.

🧠 예시: f(4)

f(4) → 4 * f(3)
     → 4 * 3 * f(2)
     → 4 * 3 * 2 * f(1)
     → 4 * 3 * 2 * 1 = 24

답:5040


**-----------------------------------------------------------------------------------**

**## 문제 20**


**다음 파이썬 코드 중 괄호에 들어갈 알맞은 함수를 작성하시오.**  

**(단 입력된 값은 `2 3` 이고, 출력은 `2 3`으로 출력된다.)**



                              # num1, num2 = input().___()
                              # input(): 사용자로부터 한 줄을 입력받아서 문자열(string) 형태로 반환한다.
                              #           예시: 사용자가 "10 20"이라고 입력하면, 이 시점에서 "10 20"이라는 문자열이 반환된다.
                              # ___(): 이 부분에 들어갈 메소드는 문자열을 특정 기준으로 '분리'하는 역할을 한다.
                              #        별도의 기준을 주지 않으면 공백(space)을 기준으로 문자열을 여러 개의 부분 문자열로 분리하여 '리스트(list)' 형태로 반환한다.
num1, num2 = input().split()           # 💡 핵심! 'split()' 메소드는 문자열을 공백 기준으로 나눠서 리스트로 반환한다.
                                       #        그리고 그 리스트의 요소들을 각각 num1, num2에 할당한다.
                                       #        예시: input()이 "10 20"을 반환하면, split()은 ['10', '20'] 리스트를 반환하고,
                                       #        '10'은 num1에, '20'은 num2에 각각 문자열 형태로 들어간다.

num1 = int(num1) # num1은 현재 문자열 "10"이므로, int() 함수를 사용하여 정수 10으로 변환한다.
num2 = int(num2) # num2는 현재 문자열 "20"이므로, int() 함수를 사용하여 정수 20으로 변환한다.

print(num1, num2) # num1과 num2의 값을 출력한다.



🔍 실행 과정 예시

만약 사용자가 50 70이라고 입력한다면:

input()이 "50 70"이라는 문자열을 반환한다.
이 문자열에 split() 메소드를 적용하면 ['50', '70']이라는 리스트가 생성된다.
num1, num2 = ['50', '70']에 의해 num1에는 "50" (문자열), num2에는 "70" (문자열)이 할당된다.
num1 = int(num1)은 "50"을 정수 50으로 변환하여 num1에 저장한다.
num2 = int(num2)는 "70"을 정수 70으로 변환하여 num2에 저장한다.
print(num1, num2)는 50과 70을 출력한다.

🚀 최종 결론

input()으로 받은 문자열을 공백 기준으로 여러 개의 문자열로 나누어 리스트로 만들고 싶을 때 사용하는 메소드는 바로 **split()**이다.

num1, num2 = input().split()

