\## 문제 1



\### 문제

아래에서 설명하는 용어를 보기에서 골라 답안을 작성하시오.



> 인터넷 사용자가 웹사이트나 애플리케이션에 비밀번호를 공개하지 않고도 정보를 다른 웹사이트에서 안전하게 접근할 수 있도록 허용하는 개방형 표준이다.  

> 예를 들어 한 웹사이트에서 다른 서비스에 로그인할 때 사용자의 비밀번호를 직접 입력하지 않고도 서비스 간에 안전하게 권한을 부여할 수 있다.

>

> 서드파티 애플리케이션이 사용자의 비밀번호에 접근하지 않고도 서비스 간에 데이터를 안전하게 공유할 수 있도록 한다.  

> 소셜 미디어 로그인, 데이터 공유 API, 클라우드 서비스 등 다양한 분야에서 널리 사용되고 있다.



\### 답:

\*\*OAuth\*\*



---



\### 📌 관련 개념 설명



\#### ✅ OAuth (Open Authorization)

\- \*\*개방형 표준\*\*으로, 제3자(서드파티) 애플리케이션이 \*\*사용자의 비밀번호를 직접 알지 않고도\*\* 자원에 제한된 접근 권한을 부여받을 수 있도록 한다.

\- 대표적인 예: \*\*페이스북/구글 로그인\*\*, \*\*카카오/네이버 로그인\*\*

\- \*\*토큰 기반 인증\*\* 방식으로, 액세스 토큰(access token)을 이용해 사용자의 자원에 접근한다.

\- 보통 다음의 흐름으로 동작:

&nbsp; 1. 사용자가 서비스 A(서드파티 애플리케이션)에서 서비스 B(자원 소유 서비스)에 로그인 요청

&nbsp; 2. 서비스 B는 사용자에게 로그인 화면 제공

&nbsp; 3. 로그인 후 사용자는 서비스 A가 특정 자원에 접근하도록 \*\*허가\*\*

&nbsp; 4. 서비스 B는 액세스 토큰을 서비스 A에 전달

&nbsp; 5. 서비스 A는 이 토큰으로 서비스 B의 API에 접근



\#### ✅ 관련 인증 방식 정리

\- \*\*계정 정보를 요청 헤더에 넣는 방식\*\*: Basic 인증 등

\- \*\*Cookie/Session 방식\*\*: 서버에 세션 저장, 클라이언트는 쿠키로 세션 ID 보관

\- \*\*JWT (JSON Web Token)\*\*: 토큰 기반 인증, 클라이언트가 자체적으로 인증 정보를 보관

\- \*\*OAuth\*\*: \*\*제한된 자원 접근 권한 위임\*\*, 토큰 기반

\- \*\*SSO (Single Sign-On)\*\*: 한 번의 인증으로 여러 시스템 접근 가능

\- \*\*Kerberos\*\*: 네트워크 상에서 안전하게 인증을 제공하는 프로토콜

\- \*\*아이핀(i-PIN)\*\*: \*\*주민등록번호 대체\*\* 인증 수단



\#### ✅ AAA (Authentication, Authorization, Accounting)

\- \*\*Authentication (인증)\*\*: 사용자가 누구인지 확인

\- \*\*Authorization (권한 부여)\*\*: 사용자에게 어떤 서비스를 사용할 권한이 있는지 확인

\- \*\*Accounting (계정 관리)\*\*: 사용자의 자원 사용 기록 수집 및 분석

------------------------------------------------------------------------



\## 문제 2



리눅스에서 사용자에게 \*\*읽기/쓰기/실행 권한\*\*을 부여하고,  

그룹에는 \*\*읽기/실행 권한\*\*을 부여하고,  

그 외(기타 사용자)에는 \*\*실행 권한만\*\*을 `text.txt` 파일에 부여하고자 한다.  



명령어를 포함해서 알맞은 답안을 작성하시오.



\### 답:

\*\*chmod 751 text.txt\*\*



---



\### 📌 관련 개념 설명



\#### ✅ chmod 명령어

\- `chmod`는 \*\*파일 또는 디렉토리의 권한(permission)\*\* 을 설정할 때 사용하는 리눅스 명령어이다.



\#### ✅ 숫자 권한 체계 (rwx)

| 권한 | 기호 | 값 |

|------|------|----|

| 읽기 | r    | 4  |

| 쓰기 | w    | 2  |

| 실행 | x    | 1  |



\- 각 사용자 범주에 따라 3자리 숫자로 표현됨:  

&nbsp; \*\*\[소유자]\[그룹]\[기타 사용자]\*\*



\#### ✅ 문제에서 요구하는 권한

\- 사용자(User) → \*\*읽기(r) + 쓰기(w) + 실행(x)\*\* → `4+2+1 = 7`

\- 그룹(Group) → \*\*읽기(r) + 실행(x)\*\* → `4+1 = 5`

\- 기타(Others) → \*\*실행(x)\*\* → `1`



따라서 `chmod 751 text.txt` 명령어를 사용하면 다음과 같은 권한이 부여됨:



```bash

$ chmod 751 text.txt



---------------------------------------------------------



\## 문제 3



두 테이블을 이용하여 `UNION` 연산을 수행하였다.  

결과값을 \*\*표 형태\*\*로 작성하시오.  

(\*타이틀은 포함하지 않아도 된다\*)



```sql

SELECT A FROM T1

UNION

SELECT B FROM T2

ORDER BY A DESC;

<T1>

A

4

1

3



<T2>

B

4

2

3



답:

4

3

2

1



📌 관련 개념 설명

✅ UNION

UNION은 두 개의 SELECT 결과를 합쳐서 중복을 제거한 후 반환함.



기본적으로 중복된 값은 하나만 표시됨.



각 SELECT 문의 열 개수와 타입이 동일해야 함.



✅ 실행 과정 분석

SELECT A FROM T1

-- 결과: 4, 1, 3



SELECT B FROM T2

-- 결과: 4, 2, 3



UNION

-- 중복 제거 후 합친 결과: 1, 2, 3, 4



ORDER BY A DESC

-- 내림차순 정렬: 4, 3, 2, 1

결과적으로 다음과 같은 값이 출력됨:



4

3

2

1



------------------------------------------------------------------



\## 문제 4



다음은 접근 통제 유형에 대한 설명이다. 괄호에 들어갈 \*\*영문 약어\*\*를 쓰시오.



---



1\. \*\*(  )\*\* :  

&nbsp;  리소스마다 분류 레이블(예: 기밀, 비밀)이 지정되고 사용자마다 보안 등급이 주어진다.  

&nbsp;  사용자의 보안 등급이 리소스의 분류 레이블을 만족할 때만 접근이 허용된다.  

&nbsp;  이 모델은 주로 \*\*국방이나 정부 기관\*\*에서 중요한 데이터를 보호하기 위해 사용된다.



2\. \*\*(  )\*\* :  

&nbsp;  데이터 \*\*소유자\*\*가 자신의 자원에 대한 \*\*접근 권한을 직접 관리\*\*할 수 있는 모델이다.  

&nbsp;  소유자는 다른 사용자나 그룹에게 자원을 사용할 권한을 \*\*부여하거나 취소\*\*할 수 있다.



3\. \*\*(  )\*\* :  

&nbsp;  \*\*사용자의 역할\*\*에 따라 접근 권한을 부여하는 모델이다.  

&nbsp;  각 사용자는 하나 이상의 역할을 부여받으며, 해당 역할은 특정 권한과 연결된다.  

&nbsp;  이 모델은 조직 내에서 역할에 따라 자원 접근을 효율적으로 관리하고자 할 때 유용하다.



---



\### 답:

1\) \*\*MAC\*\* (Mandatory Access Control, 강제적 접근 통제)  

2\) \*\*DAC\*\* (Discretionary Access Control, 임의적 접근 통제)  

3\) \*\*RBAC\*\* (Role-Based Access Control, 역할 기반 접근 통제)



---



\### 📌 관련 개념 설명



\#### ✅ MAC (Mandatory Access Control, 강제적 접근 통제)

\- 시스템에서 \*\*리소스와 사용자 모두에 등급(Label)\*\* 을 부여

\- 사용자가 직접 권한을 부여할 수 없음 → 시스템이 통제

\- \*\*기밀성 보안 모델\*\*에 자주 사용 (예: 군사, 정부)

\- 대표 모델: \*\*벨-라파둘라 모델 (BLP)\*\*  

&nbsp; - \*\*No Read Up\*\* (상위 등급 읽기 금지)  

&nbsp; - \*\*No Write Down\*\* (하위 등급 쓰기 금지)



\#### ✅ DAC (Discretionary Access Control, 임의적 접근 통제)

\- \*\*소유자가 직접\*\* 리소스 접근 권한을 제어

\- 유연하나, \*\*보안 측면에서 상대적으로 취약\*\*

\- 일반적인 상용 시스템에서 많이 사용 (예: 윈도우, 리눅스)



\#### ✅ RBAC (Role-Based Access Control, 역할 기반 접근 통제)

\- 사용자에게 직접 권한을 부여하지 않고, \*\*역할(Role)\*\* 을 부여

\- 역할은 여러 권한을 포함

\- \*\*역할 기반 업무 분장\*\*이 명확한 조직에서 사용 효율적

\- 관리 효율성과 보안성을 모두 고려한 방식



---



\### 🔎 관련 접근 통제 모델 요약



| 모델 | 주요 특징 | 중점 |

|------|-----------|------|

| 벨-라파둘라 (BLP) | MAC 기반, 기밀성 중시 | 기밀성 |

| 비바 모델 (Biba) | MAC 기반, 무결성 중시 | 무결성 |

| 클락-윌슨 모델 | 트랜잭션 무결성 보장 | 무결성 |

| 만리장성 모델 | 이해 충돌 방지 | 격리/보안 |

------------------------------------------------------------------



\## 문제 5





다음에서 설명하는 용어를 영어 약자로 작성하시오.



> 광대역 멀티미디어 통신을 지원하기 위해 고안된 네트워크 기술이다.  

> 이 기술은 특히 고속 네트워크 환경에서 다양한 종류의 트래픽을 효과적으로 처리할 수 있도록 설계되었으며,  

> 주로 전화망 및 인터넷 백본에서 사용되었다.  

> 데이터를 \*\*53바이트 크기의 고정 길이 셀\*\*로 전송한다.  

> 이 중 \*\*5바이트는 헤더\*\*, \*\*48바이트는 페이로드(실제 데이터)\*\* 로 사용된다.  

> \*\*고정 길이 셀 사용은 셀 스위칭을 단순하고 빠르게\*\* 만든다.  

> 데이터 전송을 시작하기 전에 \*\*논리적 연결이 먼저 설정\*\*되어야 한다.





\### 답:

\*\*ATM\*\* (Asynchronous Transfer Mode)



---



\### 📌 관련 개념 설명



\#### ✅ ATM (Asynchronous Transfer Mode)

\- 고정된 \*\*53바이트 셀 단위\*\*로 데이터를 전송하는 고속 네트워크 전송 기술

&nbsp; - \*\*5바이트: 헤더(Header)\*\*  

&nbsp; - \*\*48바이트: 페이로드(Payload)\*\*  

\- \*\*셀 기반(cell switching)\*\* 방식으로, 전송 지연을 최소화하고 QoS(서비스 품질)를 보장

\- \*\*멀티미디어 트래픽 처리\*\*에 유리 (음성, 영상, 데이터 동시 전송)

\- \*\*연결지향(Connection-oriented)\*\*: 데이터 전송 전 논리적 경로 설정 필요

\- 한때 \*\*인터넷 백본\*\*, \*\*전화망\*\*, \*\*기업 통신망\*\* 등에 널리 사용되었으나 현재는 IP 기반 기술로 대부분 대체됨



---



\### 🔎 관련 개념: 다중화기 종류



| 구분 | 설명 |

|------|------|

| \*\*FDM\*\* (Frequency Division Multiplexing) | 주파수 대역을 나누어 다중화 |

| \*\*TDM\*\* (Time Division Multiplexing) | 시간 슬롯으로 나누어 다중화 <br> - 동기식 TDM / 비동기식(통계적) TDM |

| \*\*CDM\*\* (Code Division Multiplexing) | 각 채널에 고유 코드 부여 (무선 통신 등에서 사용) |

| \*\*WDM\*\* (Wavelength Division Multiplexing) | 광섬유에서 서로 다른 파장의 빛을 사용 |

| \*\*SDM\*\* (Space Division Multiplexing) | 물리적 경로(공간)를 나누어 사용 |



---------------------------------------------------------------



\## 문제 6



\### 문제  

괄호에 들어갈 용어를 \*\*영어 약자\*\*로 작성하시오.



> (  )은 주로 \*\*사설 네트워크와 공인 네트워크 간의 IP 주소를 매핑하고 변환\*\*하는 데 사용되며,  

> 여러 대의 컴퓨터가 \*\*하나의 공인 IP 주소를 공유\*\*하여 인터넷에 접속할 수 있도록 한다.  

> (  )은 주로 \*\*라우터나 방화벽\*\* 같은 네트워크 장치에서 구현된다.  

> 네트워크 내부의 장치(사설 IP 주소를 가진)가 인터넷(공인 IP 주소를 사용하는)으로 데이터를 전송할 때,  

> (  ) 장치는 내부 IP 주소를 공인 IP 주소로 \*\*변환\*\*한다.  

> (  )은 \*\*IP 주소의 부족 문제를 완화\*\*하고, \*\*네트워크 보안\*\*을 강화하는 데 중요한 기술이다.



---



\### 답:

\*\*NAT\*\* (Network Address Translation)



---



\### 📌 관련 개념 설명



\#### ✅ NAT (Network Address Translation)

\- \*\*사설 IP ↔ 공인 IP 변환\*\*을 수행하는 기술

\- \*\*인터넷과 내부 네트워크 사이의 경계 역할\*\*을 수행

\- 일반적으로 \*\*라우터\*\*나 \*\*방화벽\*\*에서 사용됨

\- NAT는 하나의 공인 IP 주소를 이용해 여러 사설 IP 장치가 동시에 인터넷에 접근 가능하도록 함

\- 보안 측면에서 외부로부터 내부 네트워크의 직접 노출을 줄여줌



\#### 🔸 NAT의 주요 유형

| 유형 | 설명 |

|------|------|

| \*\*Static NAT\*\* | 하나의 사설 IP ↔ 하나의 공인 IP를 1:1 매핑 |

| \*\*Dynamic NAT\*\* | 공인 IP 풀(pool)에서 동적으로 사설 IP에 매핑 |

| \*\*PAT (Port Address Translation)\*\* | 다수의 사설 IP가 하나의 공인 IP 주소를 \*\*포트 번호를 기준으로 공유\*\*  

(또는 "NAT Overload"라고도 불림) |



---



\### 🔎 IP 관련 기타 기술 요약



| 기술 | 설명 |

|------|------|

| \*\*DNS\*\* (Domain Name System) | 도메인 이름과 IP 주소 간의 변환 |

| \*\*QOS\*\* (Quality of Service) | 특정 트래픽에 대역폭, 우선순위 등을 보장하여 품질 유지 |

| \*\*VPN\*\* (Virtual Private Network) | 공용망에서 사설 네트워크처럼 안전하게 통신할 수 있게 함 |

| \*\*DHCP\*\* (Dynamic Host Configuration Protocol) | 장치에 \*\*자동으로 IP 주소\*\*를 할당 |



---



\## 문제 7



UML을 이용한 다이어그램 중 \*\*아래 그림\*\*에 해당하는 다이어그램을 쓰시오.



인터넷 서점

결제 장바구니

^ ↖

|

|

카드 계좌이체



---



\### 답:  

\*\*패키지 다이어그램\*\* (Package Diagram)



---



\### 📌 관련 개념 설명



\#### ✅ 패키지 다이어그램 (Package Diagram)

\- \*\*시스템을 모듈화하여 구조를 표현\*\*할 때 사용되는 UML 다이어그램

\- 클래스, 유스케이스, 컴포넌트 등을 \*\*논리적으로 그룹화\*\*하는 데 사용됨

\- \*\*의존성(Dependency)\*\* 관계, \*\*포함(Containment)\*\* 관계를 시각적으로 표현 가능



\#### 🔸 특징

\- \*\*패키지\*\*는 시스템의 관련 요소들을 묶는 논리적 단위

\- 패키지 간 \*\*의존성\*\*은 화살표로 나타냄 (예: 결제가 카드에 의존)

\- 예시 구조:

\[인터넷서점]

├── \[결제] ─→ \[카드]

├── \[결제] ─→ \[계좌이체]

└── \[장바구니]



\#### 🔸 해당 예시 해석

\- `인터넷 서점`이 상위 패키지

\- `결제`, `장바구니`는 하위 패키지

\- `카드`, `계좌이체`는 `결제` 패키지의 하위 구성 요소이며, `결제`는 이 두 요소에 의존함



---



\### 🔎 UML의 주요 다이어그램 분류



| 유형 | 설명 |

|------|------|

| \*\*클래스 다이어그램\*\* | 클래스 간 구조와 관계 표현 |

| \*\*유스케이스 다이어그램\*\* | 사용자와 시스템 기능 간 상호작용 |

| \*\*시퀀스 다이어그램\*\* | 객체 간 메시지 흐름 |

| \*\*패키지 다이어그램\*\* | 시스템을 논리적 단위로 묶어 구조 표현 |

| \*\*컴포넌트 다이어그램\*\* | 시스템의 물리적 컴포넌트 간 관계 표현 |

| \*\*배치 다이어그램\*\* | 하드웨어와 소프트웨어 배치 구조 표현 |---

---



\## 문제 8



다음에서 설명하는 테스트 기법을 보기에서 골라 작성하시오.



> 이 기법은 입력 데이터를 \*\*효율적으로 테스트\*\*하기 위해 사용되며,  

> 특히 입력 데이터의 \*\*범위나 조건에 따라 테스트를 최소화\*\*하면서도  

> \*\*최대의 효과\*\*를 달성하는 데 도움을 준다.  

>

> 전체 입력 데이터를 여러 개의 '\*\*등가 클래스\*\*'로 나눈다.  

> 각 등가 클래스는 해당 클래스의 모든 값이 \*\*기대되는 동일한 행동\*\*을 보여야 한다고 가정한다.  

> 즉, 한 클래스의 하나의 값을 테스트하면, 해당 클래스의 다른 모든 값도  

> 동일한 결과를 보일 것이라고 예상한다.  

>

> 이러한 방식으로 \*\*테스트 케이스의 수를 줄일 수 있으며\*\*,  

> 테스트의 \*\*범위와 효율성\*\*을 높일 수 있다.



---



\### 답:

\*\*동등분할 기법 (Equivalence Partitioning)\*\*



---



\### 📌 관련 개념 설명



\#### ✅ 동등분할 기법 (Equivalence Partitioning)

\- \*\*블랙박스 테스트 기법\*\* 중 하나

\- 전체 입력 데이터를 기능적으로 유사한 \*\*등가 클래스(equivalence class)\*\* 로 나눔

\- 각 클래스에서 \*\*대표 값 하나만 선택\*\*해 테스트함으로써 테스트 \*\*범위를 최소화\*\*하면서 \*\*효율성\*\*은 극대화

\- 정상 입력뿐 아니라 \*\*유효하지 않은 입력\*\*도 포함하여 테스트할 수 있음



\#### 예시:

```text

입력값이 1~100인 경우:

\- 유효한 등가 클래스: 1~100 → 대표값: 50

\- 무효한 등가 클래스:

&nbsp;  - 0 이하 (예: -1)

&nbsp;  - 101 이상 (예: 150)



🔎 블랙박스 테스트의 대표 기법

기법	설명

동등분할 기법	입력값을 등가 클래스(동등한 동작 예상 그룹)로 나눠 대표값만 테스트

경계값 분석	입력값의 경계 지점을 중심으로 테스트 (최소값, 최대값 등)

원인-효과 그래프	입력 조건 간의 논리적 관계를 그래프로 나타내어 효율적 테스트 도출

오류 예측 검사	과거 경험이나 직관을 바탕으로 오류 발생 가능 영역을 예측하여 테스트

비교 검사	동일한 입력값을 여러 시스템에 적용하여 결과를 비교 (ex. 병행 테스트)



---

\## 문제 9



\### 문제  

다음은 클라우드에 대한 설명이다. 괄호 안에 알맞은 답을 보기에서 골라 작성하시오.



---



\#### (1)  

가상화된 \*\*컴퓨팅 자원\*\*을 인터넷을 통해 제공한다.  

사용자는 \*\*서버, 스토리지, 네트워킹과 같은 기본 인프라\*\*를 임대하여 사용한다.  

\*\*운영체제 및 응용프로그램 설치, 데이터 관리 등을 스스로 관리\*\*한다.  

\*\*확장성\*\*이 뛰어나고, \*\*사용한 만큼 비용을 지불\*\*하는 구조이다.  



→ \*\*답: IaaS (Infrastructure as a Service)\*\*



---



\#### (2)  

\*\*애플리케이션 개발과 배포\*\*를 위한 플랫폼 및 환경을 인터넷을 통해 제공한다.  

사용자는 \*\*개발 환경\*\*을 제공받으며, \*\*하드웨어 및 운영 체제 관리는 서비스 제공자\*\*가 담당한다.  

\*\*개발, 테스트, 배포, 호스팅 및 유지보수\*\*의 단순화된 프로세스를 제공한다.  



→ \*\*답: PaaS (Platform as a Service)\*\*



---



\#### (3)  

인터넷을 통해 \*\*소프트웨어 애플리케이션\*\*을 제공한다.  

사용자는 소프트웨어를 \*\*설치하거나 관리할 필요 없이 웹브라우저\*\*를 통해 사용 가능하다.  

\*\*업데이트 및 유지관리\*\*는 모두 \*\*서비스 제공자\*\*가 담당한다.  

사용자는 \*\*정기 구독료\*\*를 지불하며, \*\*다수의 사용자가 쉽게 접근\*\*할 수 있다.  



→ \*\*답: SaaS (Software as a Service)\*\*



---



\### ✅ 최종 답:

1\) \*\*IaaS\*\*  

2\) \*\*PaaS\*\*  

3\) \*\*SaaS\*\*



---



\### 📌 관련 개념 정리



| 구분 | 설명 | 예시 |

|------|------|------|

| \*\*IaaS\*\* | Infrastructure as a Service<br>가상 서버, 스토리지, 네트워크 등 인프라 제공 | AWS EC2, Microsoft Azure VM |

| \*\*PaaS\*\* | Platform as a Service<br>애플리케이션 개발/배포를 위한 플랫폼 제공 | Google App Engine, Heroku |

| \*\*SaaS\*\* | Software as a Service<br>웹 기반 소프트웨어를 사용자에게 제공 | Gmail, Microsoft 365, Dropbox |

---



\## 문제 10



\### 문제  

다음에서 설명하는 프로토콜을 \*\*영어 약어\*\*로 작성하시오.



> 내부 라우팅 프로토콜 중 하나로, 네트워크 내 라우터들 사이에서 정보를  

> 교환하여 \*\*최적의 경로\*\*를 결정하는 데 사용된다.  

> \*\*거리 벡터 라우팅 프로토콜\*\*의 일종으로, 목적지까지의 거리를 기반으로 라우팅 결정을 한다.  

> \*\*경로의 길이를 홉 카운트(hop count)\*\*로 측정하며, \*\*최대 15홉\*\*까지만 허용한다.  

> 일반적으로 \*\*30초마다 전체 라우팅 테이블을 브로드캐스트\*\*하거나 멀티캐스트한다.



\### ✅ 답: \*\*RIP\*\* (Routing Information Protocol)



---



\### 📌 관련 개념 설명



\#### ✅ RIP (Routing Information Protocol)

\- \*\*IGP(Interior Gateway Protocol)\*\*의 대표적인 거리 벡터 기반 프로토콜

\- 라우터 간에 \*\*라우팅 정보를 교환\*\*하여 최단 경로를 계산

\- \*\*홉 수(Hop Count)\*\* 기준 (최대 15홉)

\- \*\*30초마다 라우팅 테이블 전체를 전송\*\* (브로드캐스트 또는 멀티캐스트)



---



\## 문제 11



\### 문제  

다음은 관계 대수 기호이다. 보기에서 알맞은 \*\*기호\*\*로 작성하시오.



| 연산 종류  | 기호 |

|------------|------|

| (1) JOIN   | ?    |

| (2) PROJECT| ?    |

| (3) SELECT | ?    |

| (4) DIVISION| ?   |



---



\### ✅ 답:

1\) \*\*JOIN\*\* → ⨝  

2\) \*\*PROJECT\*\* → \*\*π\*\*  

3\) \*\*SELECT\*\* → \*\*σ\*\*  

4\) \*\*DIVISION\*\* → \*\*÷\*\*



---



\### 📌 관련 개념 설명



| 연산자 | 기호 | 설명 |

|--------|------|------|

| \*\*JOIN\*\* | ⨝ | 두 릴레이션을 조인 조건에 따라 연결 |

| \*\*PROJECT\*\* | π | 원하는 속성(열)만 추출하는 수직 연산 |

| \*\*SELECT\*\* | σ | 조건에 맞는 튜플(행)을 선택하는 수평 연산 |

| \*\*DIVISION\*\* | ÷ | A 릴레이션에서 B의 모든 값을 만족하는 튜플 추출 |



---



\### 🔎 관계 대수 연산 정리



\#### 🔹 순수 관계 연산자

\- \*\*SELECT (σ)\*\*: 조건에 맞는 행을 선택

\- \*\*PROJECT (π)\*\*: 원하는 열을 추출

\- \*\*JOIN (⨝)\*\*: 두 릴레이션을 연결

\- \*\*DIVISION (÷)\*\*: 포함관계 기반 필터링



\#### 🔹 일반 집합 연산자

\- \*\*합집합 (∪)\*\*

\- \*\*교집합 (∩)\*\*

\- \*\*차집합 (−)\*\*

\- \*\*카티션 프로덕트 (×)\*\*

---



\## 문제 12



다음에서 설명하는 제약 조건에 대해서 쓰시오.



> 데이터베이스의 (  ) 무결성 제약 조건은 데이터베이스 내에서 데이터의  

> 정확성과 일관성을 유지하는 데 중요한 역할을 한다.  

> 이 제약조건은 특히 관계형 데이터베이스에서 \*\*외래키 관계\*\*를 통해 구현되며,  

> 연관된 테이블 간의 적절한 데이터 관계가 유지되도록 보장한다.  

> 한 테이블의 필드(외래키)가 다른 테이블의 기본키를 참고할 때,  

> 외래키 값은 참조하는 테이블의 기본키에 존재하는 값이어야 한다.  

> 즉, 참조하는 데이터가 실제로 존재해야 한다.



---



\### 답:  

\*\*참조 무결성\*\* (Referential Integrity)



---



\### 📌 관련 개념 설명



\#### ✅ 참조 무결성 (Referential Integrity)

\- 관계형 데이터베이스에서 \*\*외래키(Foreign Key) 제약조건\*\*을 통해 구현

\- 한 테이블의 외래키 값은 반드시 참조 대상 테이블의 기본키 값 중 하나여야 함

\- 데이터의 \*\*일관성 및 정확성 유지\*\*에 필수적

\- 참조 대상 데이터가 삭제되거나 변경될 때, 외래키가 가리키는 값과의 관계를 유지하도록 조치 필요  

&nbsp; (예: CASCADE, SET NULL, NO ACTION 등 옵션)



---



\### 🔎 무결성 제약 조건 종류



| 무결성 종류 | 설명 |

|-------------|------|

| \*\*도메인 무결성\*\* | 각 컬럼의 값이 정의된 도메인 범위 내에 있어야 함 |

| \*\*개체 무결성\*\* | 기본키 값은 반드시 유일하고 NULL이 될 수 없음 |

| \*\*참조 무결성\*\* | 외래키 값은 참조되는 기본키에 반드시 존재해야 함 |

| \*\*사용자 정의 무결성\*\* | 사용자 요구사항에 따른 추가 제약 조건 |



---



\## 문제 13

&nbsp; 

다음 JAVA 코드의 출력 결과를 쓰시오.



```java

class A {

&nbsp;   public void paint(){

&nbsp;       System.out.print("A");

&nbsp;       draw();

&nbsp;   }

&nbsp;   public void draw(){

&nbsp;       System.out.print("B");

&nbsp;       draw();

&nbsp;   }

}



class B extends A {

&nbsp;   public void paint(){

&nbsp;       super.draw();

&nbsp;       System.out.print("C");

&nbsp;       this.draw();

&nbsp;   }

&nbsp;   public void draw(){

&nbsp;       System.out.print("D");

&nbsp;   }

}



class EraonEdu {

&nbsp;   public static void main(String\[] args){

&nbsp;       A b = new B();

&nbsp;       b.paint();

&nbsp;       b.draw();

&nbsp;   }

}



답:

BDCDD



출력 과정 상세 설명

A b = new B();



참조 변수는 A 타입, 실제 인스턴스는 B 객체.



b.paint(); 호출



paint() 메서드는 실제 객체 타입 B의 메서드가 호출됨 (오버라이딩된 메서드)



B.paint() 내부:



super.draw(); → A.draw() 호출



A.draw()는



System.out.print("B");  

draw();   // 이때 호출은 오버라이딩된 B.draw() 호출

따라서 출력 "B"



draw() 호출 시, 실제 객체의 B.draw() 실행 → "D" 출력



A.draw() 종료



이어서 "C" 출력



this.draw(); → B.draw() 호출 → "D" 출력



결과: "B" + "D" + "C" + "D" = "BDCD"



b.draw(); 호출



b의 실제 타입이 B이므로 B.draw() 호출 → "D" 출력



최종 출력:

BDCDD

---



\## 문제 14



&nbsp;

다음 C언어 코드의 출력 결과를 쓰시오.



```c

\#include <stdio.h>

int main(){

&nbsp;   char \*p = "KOREA";

&nbsp;   printf("%s \\n", p);

&nbsp;   printf("%s \\n", p+1);

&nbsp;   printf("%c \\n", \*p);

&nbsp;   printf("%c \\n", \*(p+3));

&nbsp;   printf("%c", \*p+4);

}

답:

KOREA

OREA

K

E

O

출력 과정 설명

printf("%s \\n", p);



p는 문자열 "KOREA"의 시작 주소



출력: KOREA



printf("%s \\n", p+1);



p+1은 문자열의 두 번째 문자 주소 ('O')



출력: OREA



printf("%c \\n", \*p);



\*p는 p가 가리키는 문자, 즉 'K'



출력: K



printf("%c \\n", \*(p+3));



\*(p+3)는 문자열 네 번째 문자, 'E'



출력: E



printf("%c", \*p+4);



\*p는 'K'의 ASCII 코드(75)



75 + 4 = 79 → ASCII 코드 79는 'O'



출력: O---

---



\## 문제 15



\### 문제  

C언어 코드에서 구조체의 멤버에 접근하기 위한 괄호 내의 공통된 접근자를 쓰시오.



```c

\#include <stdio.h>

struct User {

&nbsp;   char\* name;

&nbsp;   int age;

};

int main() {

&nbsp;   struct User d1;

&nbsp;   struct User \*d2;

&nbsp;   d2()name = "Lee";

&nbsp;   d2()age = 45;

&nbsp;   printf("%s, %d", d2()name, d2()age);

}

답:

->



설명

포인터(d2)가 가리키는 구조체 멤버에 접근할 때 사용하는 연산자



d2->name 은 (\*d2).name 과 동일한 의미



따라서, 빈칸에 들어갈 접근자는 -> 입니다.



---



\## 문제 16



다음 C언어 코드의 출력 결과를 쓰시오.



```c

int func(int n){

&nbsp;   int i, sum = 0;

&nbsp;   for (i = 1; i <= n / 2; i++) {

&nbsp;       if (n % i == 0)

&nbsp;           sum += i;

&nbsp;   }

&nbsp;   if (n == sum)

&nbsp;       return 1;



&nbsp;   return 0;

}



int main(){

&nbsp;   int i, sum = 0;

&nbsp;   for (i = 2; i <= 100; i++) {

&nbsp;       if (func(i))

&nbsp;           sum += i;

&nbsp;   }

&nbsp;   printf("%d", sum);

&nbsp;   return 0;

}



답:

34



설명

함수 func(int n)는 완전수(perfect number) 판별 함수임



완전수: 자기 자신을 제외한 약수의 합이 자기 자신과 같은 수



2부터 100까지 완전수를 검사하고 완전수인 경우 sum에 더함



2~100 사이의 완전수는 6과 28뿐임



따라서 출력값은 6 + 28 = 34

---



\## 문제 17



다음 자바 코드는 오류가 발생한다. 오류가 발생하는 명령을 쓰시오.



```java

class Person {

&nbsp;   private String name;

&nbsp;   public Person(String val){

&nbsp;       name = val;

&nbsp;   }

&nbsp;   public static String get(){

&nbsp;       return name;

&nbsp;   }

&nbsp;   public void print(){

&nbsp;       System.out.println(name);

&nbsp;   }

}



public class Main {

&nbsp;   public static void main(String \[] args){

&nbsp;       Person obj = new Person "Lee");

&nbsp;       obj.print();

&nbsp;   }

}



답:

return name;



설명

get() 메서드는 static으로 선언되어 있는데, name 변수는 인스턴스 변수(non-static)이다.



static 메서드에서 인스턴스 변수 name에 접근할 수 없어 컴파일 오류 발생



따라서 return name; 부분에서 오류가 발생함



또한, new Person "Lee") 부분에도 괄호 오류가 있으나, 문제에서 묻는 오류는 return name;으로 보임.

**-----------------------------------------------------------------------------------**

**## 문제 18**



**### 문제**  

**다음 자바 코드의 결과를 쓰시오.**



**```java**

**class Parent {**

    **int com(int n){**

        **if (n <= 1)**

            **return n;**

        **return com(n-1) + com(n-2);**

    **}**

**}**



**class Child extends Parent {**

    **int com(int n){**

        **if(n <= 1)**

            **return n;**

        **return com(n-1) + com(n-3);**

    **}**

**}**



**Parent obj = new Child();**

**System.out.print(obj.com(7));**

**답:**

**2**



**설명**

**obj는 Parent 타입 변수지만, 실제로는 Child 클래스의 인스턴스를 참조함 → 오버라이딩된 Child의 com()가 호출됨**



**Child 클래스의 com(n) 재귀 호출은 다음과 같음:**



**복사**

**편집**

**com(n) = com(n-1) + com(n-3) (단, n <= 1일 경우 n 반환)**

**이를 계산해 보면 com(7)의 결과는 2가 됨 (자세한 계산 과정은 재귀 트리로 분석 가능)**



**따라서 출력값은 2**

**-----------------------------------------------------------------------------------**



**## 문제 19**



**### 문제**  

**다음 C코드의 결과를 쓰시오.**



**```c**

**#include <stdio.h>**

**int f(int n){**

    **if(n <=1) return 1;**

    **else return n \* f(n-1);**

**}**

**int main(){**

    **printf("%d", f(7));**

**}**

**답:**

**5040**



**설명**

**함수 f는 팩토리얼을 계산하는 재귀함수이다.**



**f(7)은 7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040 이다.**



**따라서 출력 결과는 5040이 된다.**

**-----------------------------------------------------------------------------------**



**## 문제 20**



**### 문제**  

**다음 파이썬 코드 중 괄호에 들어갈 알맞은 함수를 작성하시오.**  

**(단 입력된 값은 `2 3` 이고, 출력은 `2 3`으로 출력된다.)**



**```python**

**num1, num2 = input().\_\_\_()**

**num1 = int(num1)**

**num2 = int(num2)**

**print(num1, num2)**

**답:**

**split**



**설명**

**input() 함수로 입력받은 문자열 "2 3"을 split() 함수로 공백 기준 분리하여 리스트로 반환한다.**



**이렇게 분리된 문자열 "2"와 "3"이 각각 num1, num2에 할당된다.**



**이후 int()로 정수 변환 후 출력한다.**



**따라서 출력은 2 3이 된다.**

