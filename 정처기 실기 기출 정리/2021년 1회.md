## 문제 1) 물리주소(MAC)을 IP주소로 변화하는 프로토콜을 작성하시오

**답:** RARP

---

📌 **해설:**

- RARP (Reverse Address Resolution Protocol):  
  MAC 주소(물리 주소)를 이용하여 IP 주소(논리 주소)를 알아내는 프로토콜.
  주로 디스크 없는 컴퓨터가 부팅 시 자신의 IP 주소를 모르고 MAC 주소만 알고 있을 때, 네트워크 상의 RARP 서버에 요청하여 IP를 할당받을 때 사용됨.

- 반대 개념: ARP (Address Resolution Protocol)  
  IP 주소를 이용하여 MAC 주소를 알아냄.

---

## 📚 네트워크 프로토콜 계층별 정리 (존나 쉽고 직관적인 예시)

| OSI 7계층         | TCP/IP 4계층          | 주요 프로토콜 및 포트                              |
|------------------|----------------------|--------------------------------------------------|
| **응용계층**       |                      | 웹사이트 보는 HTTP(80), 파일 전송하는 FTP(20, 21)         |
| **표현계층**       | **응용 계층**         | 이메일 보내는 SMTP(25), 원격 접속하는 TELNET(23), SSH(22)  |
| **세션계층**       |                      | SSH(22), 인터넷 주소 찾는 DNS(UDP 53), 네트워크 관리 SNMP(161,162), 자동 IP 할당 DHCP(67) |
| **전송계층**       | **전송 계층**         | TCP(신뢰성 보장, 순서대로 전송), UDP(빠르지만 신뢰성 낮음) |
| **네트워크 계층**   | **인터넷 계층**       | IP(주소 지정), ICMP(네트워크 상태 체크), ARP(주소 변환)        |
| **데이터링크 계층** | **네트워크 액세스 계층** | 이더넷 케이블, X.25(옛날 통신망), RS-232C(직렬통신 규격)      |
| **물리계층**       |                      | 실제 전기 신호, 빛, 무선 신호 등 물리적 매체                |

---

### 쉽게 이해하는 설명

- **HTTP(80번 포트)**는 웹 브라우저가 서버에 요청 보내고 페이지를 받을 때 쓰는 규칙  
- **FTP(20,21번 포트)**는 컴퓨터 간에 파일을 주고받을 때 쓰는 규칙  
- **SMTP(25번 포트)**는 이메일을 보내는 규칙  
- **TELNET(23번 포트)**과 **SSH(22번 포트)**는 원격으로 다른 컴퓨터에 접속하는 방법  
- **DHCP**는 컴퓨터가 켜질 때 자동으로 IP 주소를 받아오는 시스템  
- **TCP**는 편지를 보낼 때 확인하고 순서대로 잘 받았는지 확인하는 방식  
- **UDP**는 빠르게 보내지만 확인은 안 하는, 예를 들어 실시간 게임이나 영상 스트리밍에 적합한 방식  
- **IP**는 집 주소처럼 컴퓨터마다 고유한 주소를 지정하는 역할  
- **ICMP**는 네트워크 문제 있을 때 알려주는 신호  
- **이더넷**은 우리가 흔히 쓰는 랜선 기술

---

이런 식으로, 인터넷이 돌아가려면 여러 층위에서 역할을 나누고 서로 협력해서 데이터를 정확하고 빠르게 주고받는 거야.  
쉽게 말해, **편지(데이터)를 정확한 주소(IP)로 보내고, 편지 봉투(패킷)를 잘 포장(전송계층)해서, 우체국(네트워크 계층)과 배달부(데이터링크/물리계층)가 힘을 합쳐 전달하는 과정**이라고 보면 된다!


---------------------------------------------------------------------------------------------------
## 문제 2) 빈칸 1~3에 해당하는 용어를 쓰시오

> (1) 현실 세계에 있는 그대로 사람이 이해할 수 있는 형태의 정보 구조를 만들어가는 과정을  
> 의미하기 때문에 **정보 모델**이라고 한다.  
>
> (2) 추출된 엔티티와 속성들의 관계를 구조적으로 정의하는 단계로, (1)에서 만들어진 구조를  
> 컴퓨터가 이해하고 처리할 수 있도록 변환하는 과정  
>
> (3) 실제 저장장치에 어떻게 저장할지 설계하는 단계

---

**답:**  
- (1) 개념적 설계  
- (2) 논리적 설계  
- (3) 물리적 설계

---

📌 **해설 (존나 쉽고 직관적인 예시)**

데이터베이스 설계를 집 짓는 과정으로 생각해보자!

### 1. 개념적 설계 (Conceptual Design)  
- **땅을 고르고 집의 구조를 설계하는 단계**야.  
- "방은 몇 개 만들고, 거실은 어디에 둘까?" 같은 큰 그림을 그리는 거지.  
- ER 다이어그램은 집 구조를 그리는 설계도 같은 거야.  
- 예) “학생(Student)”이라는 방과 “수업(Course)”이라는 방이 어떻게 연결될지 결정하는 것.

### 2. 논리적 설계 (Logical Design)  
- 이제 설계도를 바탕으로 집을 짓기 위한 구체적인 도면과 재료 목록을 만드는 단계야.  
- 방을 실제 벽으로 만들고, 문과 창문 위치를 정하는 것처럼,  
- ER 모델을 데이터베이스가 이해할 수 있는 테이블과 컬럼, 키 등으로 변환하는 거야.

### 3. 물리적 설계 (Physical Design)  
- 집을 실제로 짓고, 편리하게 살 수 있도록 내부 배선이나 배관, 가구 배치 등을 정하는 단계야.  
- 데이터베이스에서는 인덱스나 저장 방식, 파일 배치 등을 결정해서 빠르고 효율적으로 데이터를 저장하고 꺼내게 해.

---

| 단계       | 비유                         | 산출물                      | 목적                  |
|------------|------------------------------|-----------------------------|-----------------------|
| 개념적 설계 | 집 구조 설계도 그리기          | ER 다이어그램               | 큰 그림(요구사항) 파악  |
| 논리적 설계 | 구체적인 도면과 재료 목록 만들기 | 릴레이션 스키마(테이블 구조) | DB가 이해할 수 있게 변환 |
| 물리적 설계 | 실제 집 짓기, 배관/가구 배치    | 인덱스, 저장 구조           | 성능 최적화, 효율적 저장 |

---

이렇게 3단계를 거쳐서,  
**“요구사항 → 구체 설계 → 효율적 구현”**이 차근차근 완성돼서 데이터가 안전하고 빠르게 관리될 수 있는 거야!


---------------------------------------------------------------------------------------------------
## 문제 3) 다음 테이블의 카디널리티와 차수를 구하시오

| 학번     | 이름 | 학년 | 학과         |
|----------|------|------|--------------|
| 181101   | KKK  | 1    | 컴퓨터공학과 |
| 171201   | HHH  | 2    | 전자공학과   |
| 171302   | XXX  | 3    | 컴퓨터공학과 |
| 161107   | YYY  | 3    | 건축공학과   |
| 151403   | QQQ  | 4    | 전자공학과   |

---

**답:**  
- **카디널리티(Cardinality): 5**  
- **차수(Degree): 4**

---

📌 **해설 (존나 쉽고 직관적인 예시)**

### 🔹 카디널리티 (Cardinality)
- **테이블에 몇 줄(행)이 있느냐**를 뜻해.  
- 예를 들어, 학생 명단에 학생 5명이 있으면 카디널리티는 5야.  
- 쉽게 말해 "몇 명이 있냐" 정도로 생각하면 돼.

### 🔹 차수 (Degree)
- **테이블에 몇 개의 정보 항목(열)이 있느냐**를 뜻해.  
- 예를 들어, 학생 한 명에 대해 학번, 이름, 학년, 학과 이렇게 4가지 정보가 있으면 차수는 4야.  
- 쉽게 말해 "한 명에 대해 몇 가지 정보를 기록하냐" 정도로 보면 돼.

---

| 용어          | 쉽게 말하면                      | 예시 (학생 테이블 기준)       |
|---------------|---------------------------------|------------------------------|
| **카디널리티** | 몇 명(몇 줄)이 있냐?              | 5명 학생(5개의 행)             |
| **차수**       | 한 명당 몇 가지 정보가 있냐?       | 4개 정보(학번, 이름, 학년, 학과) |
| **레코드**     | 테이블의 한 줄                   | `181101 KKK 1 컴퓨터공학과`     |
| **속성**       | 테이블의 한 열(정보 종류)          | `학번`, `이름`, `학년`, `학과`    |

---

이렇게 카디널리티와 차수를 생각하면,  
테이블이 얼마나 크고 어떤 정보를 담고 있는지 쉽게 이해할 수 있어!


---------------------------------------------------------------------------------------------------

## 문제 4) 

기업 내부에서 운영되는 각종 플랫폼 및 애플리케이션 간의 정보 전달, 연계, 통합을  
가능하게 하는 솔루션이다. Point-to-Point, Hub & Spoke, Message Bus, Hybrid 형태로 구성된다.

---

**답:** EAI

---

📌 **해설 (존나 쉽고 직관적인 예시)**

### 🔹 EAI (Enterprise Application Integration)

- **무슨 뜻이냐면?**  
  회사 안에 서로 다른 프로그램들(예: 판매 관리, 고객 관리, 재고 관리)이 있는데,  
  이걸 서로 **“대화하게 만들고, 데이터도 잘 공유하게”** 해주는 기술이야.

- **왜 하냐면?**  
  - 서로 따로따로 돌아가면 데이터가 엉망이 되고  
  - 중복으로 일해야 해서 일이 두 배로 늘어나거든.  
  - 그래서 EAI로 연결하면 효율도 올라가고 실수도 줄어들어.

---

📌 **EAI 연결 방식 쉽게 이해하기**

| 방법 이름        | 쉽게 설명                                                  |
|-----------------|----------------------------------------------------------|
| **Point-to-Point** | 프로그램 A랑 B가 1대1로 직접 연결하는 방식<br>처음엔 간단하지만 프로그램이 많아지면 헬게이트 오픈 |
| **Hub & Spoke**   | 중앙 ‘허브’라는 통제탑을 두고 모든 프로그램이 여기 연결됨<br>관리 쉽지만 허브가 뻗으면 전부 멈춤 |
| **Message Bus**   | ‘버스’처럼 중앙 허브 없이도 여기저기 메시지가 자유롭게 왔다 갔다 하는 방식<br>유연하고 확장 쉬움 |
| **Hybrid**        | 위 방식을 상황에 맞게 섞어서 쓰는 혼합형 |

---

📌 **관련 용어 한눈에 정리**

| 용어  | 쉬운 설명                                      |
|-------|----------------------------------------------|
| **EAI** | 회사 내부 프로그램들끼리 데이터랑 기능 연결하는 것 |
| **ESB** | EAI를 더 진화시킨 버스형 통합 플랫폼 (소프트웨어 허브) |
| **EDI** | 회사끼리 문서(주문서, 송장 등) 전자적으로 주고받기 |
| **API** | 프로그램 기능을 외부에서 부를 수 있게 만든 인터페이스 |

---

📌 **EAI를 도입하면 좋은 점**

- 사람이 일일이 안 해도 자동으로 일 처리해줌  
- 같은 데이터 중복 저장 줄어서 정확도 쩜  
- 여러 시스템이 유기적으로 붙어서 업무가 쭉쭉 잘 돌아감  

---

이렇게 EAI는 회사 안에 여러 프로그램들이 **끈끈하게 손발 맞춰서 일하게 해주는 마법 같은 기술**이라고 생각하면 딱이다!

---------------------------------------------------------------------------------------------------

## 문제 5) 

다음 <보기>에 해당하는 데이터 모델 구성 3요소 중 ①, ②에 알맞은 데이터 모델 구성 요소를 쓰시오.

<보기>

(1): 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로, 데이터베이스를 조작하는 도구이다.  
(2): 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현한다.  
제약조건: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

---

**답:**
- (1) 연산  
- (2) 구조

---
📌 **해설:**

### 🔹 데이터 모델의 구성 3요소

데이터 모델은 크게 세 가지로 나눌 수 있어요.  
쉽게 말하면, 데이터와 그 데이터를 다루는 법, 그리고 데이터에 붙이는 규칙이라고 생각하면 됩니다.

| 구성 요소     | 쉽게 설명                              | 예시                             |
|--------------|-------------------------------------|---------------------------------|
| **구조 (Structure)**   | 데이터가 어떻게 생겼고, 어떻게 연결되어 있는지 | 테이블(릴레이션), 컬럼(속성), 키(기본키, 외래키) |
| **연산 (Operation)**   | 데이터를 넣고, 빼고, 고치고, 찾는 방법          | SELECT(찾기), INSERT(넣기), DELETE(삭제) 등      |
| **제약조건 (Constraint)** | 데이터가 이상하게 저장되는 걸 막는 규칙          | 기본키 중복 방지, 외래키 연결 유지, 데이터 형식 제한 |

---

### 🔹 쉽게 정리하자면

- **연산**은 데이터를 ‘어떻게 조작할까?’ 하는 행동들 (예: 검색, 추가, 삭제)
- **구조**는 데이터를 ‘어떻게 저장하고 연결할까?’ 하는 틀 (예: 표 형태, 컬럼 이름)
- **제약조건**은 ‘데이터가 이상해지지 않게 하려면 뭘 지켜야 하지?’ 하는 약속 (예: 학번은 중복 안 됨)

---

📌 **추가 용어 정리**

- **데이터 모델(Data Model)**  
  → 데이터를 체계적으로 정리하고, 다루고, 지키는 규칙과 틀을 모두 포함하는 개념.

- **관계형 데이터 모델(Relational Data Model)**  
  → 데이터가 테이블(릴레이션) 형태로 저장되고, SQL 같은 언어로 조작되며,  
  → 기본키나 외래키 같은 제약조건으로 데이터 무결성을 지키는 모델.

---

### 💡 쉽게 예시로 이해하기

- 구조: 학생 테이블에는 `학번`, `이름`, `학년` 같은 칸(컬럼)이 있고,  
- 연산: 학생 정보를 추가하거나 검색하거나 삭제하는 행위,  
- 제약조건: `학번`은 중복되면 안 되고, 존재하지 않는 과목 번호는 입력 못 하도록 막는 규칙

이게 다 데이터 모델에서 말하는 ‘구조, 연산, 제약조건’이에요!

데이터베이스가 멋지게 돌아가려면 이 3가지를 다 잘 설계하는 게 핵심입니다.

---------------------------------------------------------------------------------------------------
## 문제 6)

다음은 블랙박스 테스트의 예시이다. 1, 2에 알맞은 테스트를 작성하시오.

1. 0 <= X <= 10일 때, 1, 0, 10, 11인 경우 사용하는 테스트  
2. 유효값과 그렇지 않은 범위를 나눠야 할 경우 사용하는 테스트

---

**답:**  
(1) 경계값 분석 (Boundary Value Analysis)  
(2) 동등분할 테스트 (Equivalence Partitioning)

---

📌 **해설:**

### 🔹 블랙박스 테스트 (Black Box Testing)

- 내부 구조를 몰라도 OK!  
- ‘입력 → 출력’만 보고 제대로 동작하는지 확인하는 테스트 방법이에요.  
- 사용자가 기대하는 기능이 제대로 구현됐는지 확인하는 데 집중합니다.

---

### 🔹 주요 기법 쉽게 이해하기

| 기법             | 쉽게 설명                                                   |
|------------------|------------------------------------------------------------|
| **동등분할 테스트** | 입력값을 ‘같은 종류’끼리 묶어서 대표값 하나만 쏙쏙 골라서 테스트하기 (예: 1~10은 정상, 11 이상은 오류) |
| **경계값 분석**    | 경계선 주변 숫자들을 집중 공략! (예: 0, 1, 10, 11 같은 ‘경계값’과 그 바로 위아래 값)        |
| **원인-효과 그래프 검사** | 입력 조건들이 어떻게 연결되는지 그려서 효율적으로 테스트 케이스 뽑기                     |
| **오류 예측 검사**  | ‘여기서 틀릴 가능성 크겠다!’ 싶을 때 집중 점검하기 (경험에서 나오는 감각)                   |
| **비교 검사**     | 이전 버전과 새 버전 프로그램에 같은 입력 넣고 결과가 똑같은지 비교하기                       |

---

### 🔹 문제 속 답변 쉽게 풀이

- (1) **경계값 분석**:  
  경계값(최솟값, 최댓값) 주변 숫자들을 집중 테스트해 오류를 찾는 방법이에요.  
  예를 들어 0, 1, 10, 11 같은 숫자들로 테스트해서 ‘경계에서 틀릴 수 있는 오류’를 잡아내는 거죠.

- (2) **동등분할 테스트**:  
  입력 범위를 ‘정상 범위’와 ‘오류 범위’처럼 동등한 그룹으로 나누고, 각 그룹에서 대표값 하나만 테스트해 효율적으로 검증하는 방법이에요.

---

✅ **요약:**  
- **경계값 분석:** 경계 근처 숫자 집중 점검  
- **동등분할 테스트:** 입력 범위를 그룹으로 묶고 대표값만 테스트  
둘 다 블랙박스 테스트에서 ‘효과적으로 입력값 검증하는 기법’으로 아주 자주 쓰여요!


---------------------------------------------------------------------------------------------------
## 문제 7)

괄호 안에 공통적으로 들어갈 공격 기법을 쓰시오.

- () 은 시스템 간 연결이 활성화된 상태, 즉 로그인된 상태를 가로채는 것을 뜻한다.  
- ()은 TCP의 고유한 취약점을 이용해 정상적인 접속을 빼앗는 방법이다.  
  서버와 클라이언트 통신 시 TCP의 시퀀스 번호를 제어하는 데 발생하는 문제를 공격한다.  
- TCP는 클라이언트와 서버 간 통신을 할 때 패킷의 연속성을 보장하기 위해 각각 시퀀스 번호를 사용한다.  
- 이 시퀀스 번호가 잘못되면 이를 바로잡기 위한 작업을 하는데 ()은 서버와 클라이언트에 각각 잘못된  
  시퀀스 번호를 위조해서 연결된 세션에 잠시 혼란을 준 뒤 자신이 끼어들어가는 방식이다.

---

**답:** 세션 하이재킹 (Session Hijacking)

---

📌 **해설:**

### 🔹 세션 하이재킹(Session Hijacking)이 뭐야?

- 쉽게 말하면, 네가 인터넷에 로그인해서 사용하는 ‘임시 열쇠’ 같은 세션 정보를 누군가 훔쳐서  
  너인 척 인터넷을 사용하는 거야.  

- 예를 들어, 너가 카페에서 주문할 때 주문표를 들고 있는데, 누군가 그 주문표를 몰래 빼앗아서  
  대신 주문하고 돈까지 쓰는 상황과 비슷해.  

- 해커는 네가 로그인해서 서버와 주고받는 통신 속 ‘순서 번호(TCP 시퀀스 번호)’를 몰래 훔치거나  
  조작해서 세션을 탈취해버리는 거야.

---

### 🔹 왜 위험해?

- 한번 세션이 탈취되면, 해커가 네 계정으로 로그인한 것처럼 마음대로 사용할 수 있어!  
- 은행, 쇼핑몰, 이메일 등 중요한 사이트에서 매우 치명적이지.

---

### 🔹 쉽게 생각하는 공격 방법

- 네가 친구랑 주고받는 편지를 가로채서, 친구가 보낸 것처럼 위조하는 거랑 비슷해.  
- 그래서 ‘내가 보낸 메시지야!’라고 속이고 네 권한을 빼앗아버리는 거야.

---

### 🔹 기타 비슷한 공격 예시

| 공격명           | 쉽게 설명하자면                     |
|------------------|-----------------------------------|
| SMURF 공격       | 누군가에게 “야, 이거 퍼뜨려!”라고 큰 소리로 외쳐서, 너무 많은 응답이 몰려와서  
컴퓨터가 버티기 힘든 상황 만들기 |
| SYN 플러딩       | “안녕하세요” 인사만 계속 보내서 컴퓨터가 정신 못 차리게 만들기 |
| UDP 플러딩       | “나 여기 있어요!”라고 계속 떠들어댐 (트래픽 폭주)  |
| PING 플러딩      | ‘삐빅삐빅’ 소리 무한 반복해서 귀찮게 하기   |
| PING OF DEATH    | 너무 큰 메세지 보내서 컴퓨터 멈추게 만들기  |
| TEARDROP 공격    | 퍼즐 조각 잘못 보내서 컴퓨터가 헷갈리게 하기  |
| LAND 공격        | 네가 네 자신한테 계속 전화 거는 상황 만들기    |

---

✅ **정리:**  
- 세션 하이재킹은 로그인 상태의 ‘임시 열쇠’를 훔쳐서 내 계정을 도용하는 공격!  
- 네트워크 속 ‘통신 순서 번호’를 훔치거나 조작해서 이루어진다!  
- 그래서 인터넷 쓸 때는 항상 보안에 신경 써야 한다는 뜻이지!


 ---------------------------------------------------------------------------------------------------
## 문제 8)

다음 (1), (2)에 알맞은 답안을 작성하시오.

- IPv6 는 (1) 비트의 길이를 가진다.  
- IPv4의 길이는 32비트이며, (2) 비트씩 4분할 한다.

---

**답:**  
(1) 128  
(2) 8

---

📌 **해설:**

### 1) IPv6

- IPv6 주소 길이: **128비트**  
- IPv4(32비트)보다 훨씬 길어서 엄청나게 많은 주소를 만들 수 있어  
- 주소는 16비트씩 8개 블록으로 나누고, 콜론(:)으로 구분  
- 예: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`

- 쉽게 말하면, IPv6는 우주에서 모래알 수 만큼 많은 인터넷 주소를 만들 수 있는 초거대 주소 체계!

---

### 2) IPv4

- IPv4 주소 길이: **32비트**  
- 8비트씩 4개(옥텟)로 나누어 점(.)으로 구분  
- 예: `192.168.0.1`

- IPv4는 인터넷 초창기부터 쓰던 주소 체계인데, 주소가 43억 개 정도라  
  요즘처럼 인터넷이 많아지면서 주소 부족 문제가 생김.

---

✅ **쉽고 직관적 요약:**  
- IPv4는 4자리 숫자 4개 묶음 (예: 집 주소 아파트 동, 층, 호수 느낌)  
- IPv6는 16자리 8개 묶음 (우주만큼 넓은 주소지도를 상상해봐!)  
- 그래서 IPv6는 인터넷이 엄청 커져도 문제없도록 만든 차세대 주소 체계야.



---------------------------------------------------------------------------------------------------

## 문제 9)

다음 1~3에서 설명하는 결합도를 작성하시오.

1. 두 모듈이 동일한 자료구조를 조회하는 경우  
2. 가장 강한 결합도를 가지고 있으며, 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 조회하도록 설계되었을 경우  
3. 여러 모듈이 공통 자료 영역을 사용하는 경우

---

**정답:**  
(1) 스탬프 결합도 (Stamp Coupling)  
(2) 내용 결합도 (Content Coupling)  
(3) 공통 결합도 (Common Coupling)

---

📌 **해설:**

### 🔹 결합도 (Coupling)

- 모듈들이 서로 얼마나 서로에게 의존하는지를 나타내는 척도야.  
- 결합도가 낮으면 각 모듈이 독립적이라 수정, 유지보수가 쉽고 좋아.

---

### 🔹 결합도 종류

| 종류                  | 설명                                                        | 특징 및 예시                         |
|-----------------------|-------------------------------------------------------------|------------------------------------|
| **내용 결합도 (Content Coupling)** | 한 모듈이 다른 모듈 내부를 들여다보거나 직접 변경할 때 발생          | 가장 강한 결합도, 유지보수 최악 사례 |
| **공통 결합도 (Common Coupling)**   | 여러 모듈이 전역 변수 같은 공통 데이터를 같이 쓸 때                 | 전역 변수를 여러 군데서 공유하는 경우 |
| **스탬프 결합도 (Stamp Coupling)**  | 모듈 간에 구조체나 레코드 같은 복잡한 데이터 덩어리를 통째로 전달할 때 | 필요한 일부만 써도 전체 구조체를 넘김 |

---

✅ **쉽고 직관적 요약:**  
- (1) 구조체 같은 큰 자료 덩어리를 건네주는 건 → 스탬프 결합도  
- (2) 상대방 내부를 쓱 들여다보고 직접 손대는 건 → 내용 결합도 (최악)  
- (3) 여러 모듈이 똑같은 전역 변수를 공유하는 건 → 공통 결합도  

결합도가 낮을수록 '모듈끼리 너무 엮이지 않아 자유롭게 고치고 관리할 수 있다'는 뜻이야!

---------------------------------------------------------------------------------------------------
## 문제 10)

<보기>에 해당하는 용어를 쓰시오.

- (1) 요구사항은 제품을 구현하기 위해 소프트웨어가 가져야 할 기능적 속성  
- (2) 요구사항은 제품 품질 기준 등의 만족을 위해 소프트웨어가 가져야 할 특성

---

**답:**  
(1) 기능적 요구사항 (Functional Requirements)  
(2) 비기능적 요구사항 (Non-Functional Requirements)

---

📌 **해설:**

### 1) 기능적 요구사항 (Functional Requirements)

- **정의:**  
  소프트웨어가 ‘무엇을 해야 하는지’, 즉 구체적인 기능이나 동작을 명확히 적어놓은 것  
- **예시:**  
  - 사용자가 로그인할 수 있어야 한다  
  - 상품 검색, 수정 기능 제공  
  - 보고서를 출력하는 기능  

### 2) 비기능적 요구사항 (Non-Functional Requirements)

- **정의:**  
  소프트웨어가 ‘어떻게 해야 하는지’, 즉 성능, 보안, 사용성 같은 품질 특성이나 제약 조건  
- **예시:**  
  - 사용자 요청에 2초 이내 응답해야 한다 (성능)  
  - 데이터는 암호화되어야 한다 (보안)  
  - 쉽게 유지보수할 수 있어야 한다  
  - 다양한 OS에서 동작해야 한다 (호환성)  

---

📌 **쉽고 직관적 정리**

| 구분       | 의미                              | 예시                        |
|------------|---------------------------------|-----------------------------|
| 기능적     | 시스템이 ‘무엇을 할 것인가’      | 로그인, 주문 처리, 알림 기능 |
| 비기능적   | 시스템이 ‘어떻게 할 것인가’ 또는 ‘얼마나 잘 할 것인가’ | 속도, 보안, 신뢰성 등         |

---

✅ 핵심:  
- **기능적 요구사항 = ‘무엇을 할 것인가’**  
- **비기능적 요구사항 = ‘어떻게 할 것인가’, ‘얼마나 잘 할 것인가’**

---------------------------------------------------------------------------------------------------

## 문제 11)

시스템 객체의 접근을 개인 또는 그룹의 식별자에 기반한 방법으로  
어떤 종류의 접근 권한을 가진 사용자가 다른 사용자에게 자신의 판단에 따라 권한을 허용하는 접근 제어 방식은?

---

**답:** DAC (임의적 접근 통제, Discretionary Access Control)

---

📌 **해설:**


### 🔹 DAC (임의적 접근 통제)

- **쉽게 말하면:**  
  내 물건(파일, 데이터 등)은 내가 권한을 줘서 친구(다른 사용자)가 쓸 수 있게 하거나 못 쓰게 할 수 있는 방식.  
- **특징:**  
  - 권한 주는 사람은 ‘물건 주인’인 사용자  
  - 마음대로 권한을 주거나 뺄 수 있어서 편하지만, 잘못하면 권한 남용 위험 있음  
  - 구현도 쉽고 유연함

---

### 🔹 접근 통제 방식 비교

| 구분         | MAC (강제 접근 통제)           | DAC (임의적 접근 통제)         | RBAC (역할 기반 접근 통제)    |
|--------------|-------------------------------|-------------------------------|------------------------------|
| 권한 부여자  | 시스템 관리자(중앙 통제)        | 사용자(소유자)                 | 관리자(역할에 따라 권한 부여) |
| 접근 결정 기준 | 보안 등급, 레이블로 엄격 통제    | 소유자가 신분에 따라 임의 조절  | 맡은 역할에 따라 접근 허용    |
| 정책 변경    | 어렵고 엄격함                  | 자유롭고 유연함                | 역할 바꾸면 권한도 자동 변경  |
| 장점         | 안정적, 강력한 보안             | 유연하고 간단                  | 관리 편리, 조직에 적합        |

---

### 🔹 관련 보안 모델 예시

- **벨-라파둘라 모델:** 기밀성(비밀 지키기) 중심  
- **비바 모델:** 무결성(데이터 정확성) 중심  
- **클락-윌슨 모델:** 상업적 업무 무결성 강조  
- **만리장성 모델:** 이해 충돌 방지, 주로 금융 분야

---

✅ **요약:**  
- DAC는 ‘내가 주인’인 데이터에 대해 권한을 자유롭게 주고 빼는 방식이다.  
- 편하지만 권한 관리 소홀 시 보안 위험이 있을 수 있음.



---------------------------------------------------------------------------------------------------
## 문제 12)

웹서비스의 구체적 내용이 기술되어 있어 서비스 제공 장소,  
서비스 메시지 포맷, 프로토콜 등이 기술되어 있는 언어는?

---

**답:** WSDL

---

📌 **해설:**

### 🔹 WSDL (웹서비스 설명 언어)

- **쉽게 말하면:**  
  ‘웹서비스의 사용 설명서’ 같은 거야.  
  어떤 기능을 제공하는지, 어디서 서비스를 받는지(URL), 어떤 방식으로 메시지를 주고받는지 등을 XML로 자세히 적어놓은 문서야.

- **주요 역할:**  
  - 서비스 제공자가 ‘이 서비스는 이렇게 쓸 수 있어요’라고 알려주는 것  
  - 서비스 이용자가 ‘어떻게 호출해야 하는지’ 정보를 얻는 데 도움  
  - 주로 SOAP 방식 웹서비스에서 쓰임

- **WSDL 문서의 주요 구성:**  
  - **Types:** 메시지에 들어가는 데이터 타입 정의  
  - **Message:** 주고받는 메시지 형태 설명  
  - **PortType:** 서비스가 제공하는 기능(인터페이스) 정의  
  - **Binding:** 어떤 프로토콜(HTTP, SMTP 등)과 데이터 포맷(XML 등)을 쓸지 명시  
  - **Service:** 실제 서비스 위치(URL) 알려줌

---

### 🔹 관련 용어 쉽게 이해하기

| 용어  | 쉽게 설명하기                          |
|-------|-------------------------------------|
| SOAP  | XML로 메시지를 주고받는 통신 규칙     |
| UDDI  | 서비스 등록하고 찾을 수 있는 ‘서비스 전화번호부’ |
| REST  | 웹에서 많이 쓰는 간단한 통신 방식 (HTTP 기반)  |

---

✅ **요약:**  
WSDL은 ‘웹서비스 사용 설명서’라고 생각하면 쉽다.  
서비스가 뭘 하고, 어떻게 호출하고, 어디서 쓰는지 구체적으로 적혀 있어서, 개발자가 서비스와 쉽게 연결할 수 있게 해준다.

---------------------------------------------------------------------------------------------------
## 문제 13)

<보기>에 해당하는 용어를 쓰시오.

1. 개발자가 원시 코드를 대상으로 다른 부분과 연계되는 부분은 고려하지 않고, 각각의 단위 자체에만 집중하여 테스트 한다.  
2. 인터페이스 간 시스템이 정상적으로 실행되는지 확인하는 테스트이다.

---

**정답:**  
1) 단위 테스트 (Unit Testing)  
2) 통합 테스트 (Integration Testing)

---

📌 **해설:**

### 1) 단위 테스트 (Unit Testing)

- **쉽게 말하면:**  
  소프트웨어의 ‘가장 작은 부품’(예: 함수나 메서드)을 따로 떼어내서 잘 작동하는지 혼자만 테스트하는 거야.  
- **특징:**  
  - 다른 부분과 섞지 않고 독립적으로 검증  
  - 개발자가 주로 직접 함  
  - 문제 있으면 바로바로 고치기 좋음

### 2) 통합 테스트 (Integration Testing)

- **쉽게 말하면:**  
  여러 부품(모듈)을 다 합쳐서 서로 잘 연결되고 의사소통이 제대로 되는지 확인하는 과정.  
- **특징:**  
  - 부품끼리 충돌 없이 잘 붙는지 확인  
  - 데이터가 잘 전달되는지 체크  
  - 시스템 테스트 전에 꼭 거치는 단계

---

📌 **테스트 단계 쉽게 정리**

| 테스트 종류    | 쉽게 이해하기                        | 누가 하나?        | 목적                          |
|----------------|-----------------------------------|-------------------|-------------------------------|
| 단위 테스트    | 부품 하나하나 따로따로 점검        | 개발자            | 기능이 제대로 동작하는지 확인  |
| 통합 테스트    | 여러 부품 합쳐서 연결 상태 점검     | 개발자나 테스터   | 부품들이 서로 잘 이어졌는지 확인 |
| 시스템 테스트  | 전체 프로그램을 완성품처럼 테스트   | 테스터            | 요구사항에 맞게 작동하는지 점검 |
| 인수 테스트    | 실제 사용자 입장에서 최종 확인     | 사용자와 테스터   | 사용자 요구 충족하는지 최종 승인 |

---

✅ **요약:**  
- 단위 테스트는 ‘부품 하나만’ 확인하는 것  
- 통합 테스트는 ‘부품들이 잘 연결되어 작동하는지’ 확인하는 것  
둘 다 소프트웨어가 제대로 작동하는지 확인하는 필수 단계야.


---------------------------------------------------------------------------------------------------

## 문제 14)

시스템의 성능 향상, 개발 과정의 편의성 등을 위해 정규화된 데이터 모델을  
분할, 통합, 추가하는 과정으로, 의도적으로 정규화에 위배되는 행위이다.  
무엇을 설명하는 것인지 쓰시오.

---

**답:** 반정규화 (역정규화, 비정규화)

---

## 📦 반정규화(Denormalization) 예시 – 갓반도 3초 컷

### 🎯 목표
온라인 쇼핑몰 주문 정보를 저장하는 DB 설계를 반정규화 예제로 알아보자.

---

### ✅ 정규화된 구조 (정석대로 설계함)

#### 📄 [고객 테이블]
| 고객 ID | 이름     | 전화번호    |
|---------|----------|-------------|
| C001    | 홍길동   | 010-1234-5678 |

#### 📄 [주문 테이블]
| 주문 ID | 고객 ID | 상품명  | 주문일       |
|---------|----------|---------|--------------|
| O001    | C001     | 키보드 | 2025-07-17   |

> 👉 장점: 데이터 중복 없음, 변경 시 한 군데만 수정하면 됨  
> 👉 단점: 고객 이름이나 전화번호 보려면 **JOIN 해야 함**

---

### 🔁 반정규화된 구조 (조회 성능↑)

#### 📄 [주문 테이블 - 반정규화]
| 주문 ID | 고객 ID | 고객이름 | 전화번호    | 상품명  | 주문일       |
|---------|----------|-----------|-------------|---------|--------------|
| O001    | C001     | 홍길동    | 010-1234-5678 | 키보드 | 2025-07-17   |

> 👉 장점: 고객 정보 바로 조회 가능, JOIN 필요 없음, 속도 빠름  
> 👉 단점: 고객 전화번호 바꾸면 **여러 군데 다 수정해야 함** (데이터 중복)

---

### 🧠 정리
- **정규화**: 데이터 중복 줄이고 무결성 유지 (근데 느릴 수 있음)
- **반정규화**: 성능 ↑, 편의성 ↑, 대신 데이터 중복 생김
- 즉, **읽는 속도 중요할 땐 반정규화도 쓸 수 있음**

---

💡 **갓반 꿀팁**: 정규화는 ‘원칙’, 반정규화는 ‘현실 최적화’.  
실무에선 상황 따라 반정규화가 훨씬 유리할 수도 있음.


---------------------------------------------------------------------------------------------------
## 문제 15)

실행 프로세스 간의 통신을 가능하게 하는 기술로 종류에는 파이프, 메시지 큐,  
공유 메모리, 세마포어, 소켓 등이 있다.

---

**답:** IPC

---

## 🔄 IPC (Inter-Process Communication) – 갓반도 바로 이해하는 예시

---

### 🤔 IPC가 뭔데?

> 서로 다른 프로그램(프로세스)끼리 **데이터를 주고받는 방법**이야.  
예: 엑셀에서 복사한 내용을 한글에서 붙여넣는 것도 일종의 IPC야.  
즉, **"야 이거 좀 줄래?" "ㅇㅋ 여기 받아"** 같은 거.

---

### 🔧 IPC 종류랑 진짜 쉬운 예시

| 종류 | 설명 | 예시 |
|------|------|------|
| **파이프 (Pipe)** | 한 프로그램의 출력을 다른 프로그램 입력으로 넘김 | `ls | grep txt` → ls 결과를 grep한테 넘김 |
| **메시지 큐** | 편지처럼 메시지를 보내놓고 나중에 받음 (비동기) | 알바생이 주방에 주문서(메시지)를 큐에 넣음 |
| **공유 메모리** | 두 프로세스가 같은 메모리를 씀 → **엄청 빠름** | 두 앱이 하나의 문서 버퍼를 같이 편집 |
| **세마포어** | 자물쇠처럼 공유 자원 접근을 제어함 | 화장실(공유 자원)은 한 명만 들어감. 나와야 다른 사람 들어갈 수 있음 |
| **소켓** | 네트워크 통신용. 원격 프로세스랑 대화 가능 | 메신저 앱에서 서버랑 대화할 때 소켓 씀 |

---

### 🧠 정리 요약

- IPC는 **프로세스끼리 대화하거나 자료 주고받는 기술**!
- 파이프는 간단한 전달, 메시지 큐는 알림장, 공유 메모리는 속도빠름, 세마포어는 문지기, 소켓은 네트워크 대화용!
- 실무에선 상황 따라 섞어 씀 (속도, 안정성, 복잡도 등 고려)

---

💬 **갓반 꿀팁:**  
“같이 일하려면 말이 통해야 함 → 프로세스도 마찬가지!”  
그래서 IPC가 있음.

---------------------------------------------------------------------------------------------------

## 문제 16)

다음 SQL 문의 실행 결과를 쓰시오.

```sql
SELECT COUNT(*) FROM TABLE01
WHERE EMPNO > 100
AND SAL >= 3000
OR EMPNO = 200;
EMPNO	SAL
100	1000
200	3000
300	1500

답:
1

📌 해설:

## 📌 SQL WHERE 조건 분석 예제

### 🧾 쿼리
```sql
SELECT COUNT(*) 
FROM EMP 
WHERE EMPNO > 100 
  AND SAL >= 3000 
  OR EMPNO = 200;
```

---

### ✅ 1. 조건 우선순위 해석

- SQL에서 **AND**는 **OR보다 우선순위가 높음**.
- 따라서 아래처럼 괄호를 묶어 해석해야 함:

```text
(EMPNO > 100 AND SAL >= 3000) OR (EMPNO = 200)
```

---

### ✅ 2. 각 행에 대해 조건 검사

| EMPNO | SAL  | 조건 평가                                                                                                                                      | 결과  |
|--------|------|--------------------------------------------------------------------------------------------------------------------------------------------------|--------|
| 100    | 1000 | (100 > 100 AND 1000 >= 3000) → (False AND False) → False<br>OR (100 = 200) → False                           | ❌ False |
| 200    | 3000 | (200 > 100 AND 3000 >= 3000) → (True AND True) → True<br>OR (200 = 200) → True                                | ✅ True  |
| 300    | 1500 | (300 > 100 AND 1500 >= 3000) → (True AND False) → False<br>OR (300 = 200) → False                             | ❌ False |

---

### ✅ 3. 결과

- 조건을 만족하는 행은 **200번 사원 1개**
- 따라서 결과는:

```text
COUNT(*) = 1
```

---

### 💡 정리
- SQL에서 **조건 우선순위** 주의!
- 괄호로 명확하게 표현하는 습관이 중요
- 이 예제에선 **`EMPNO = 200`**이 **OR 조건**이라 **결과에 큰 영향**을 줌


---------------------------------------------------------------------------------------------------

## 문제 17)

다음 파이썬 프로그램의 실행 결과를 쓰시오.

```python
class arr:
    a = ["Seoul", "Kyeonggi", "Incheon", "Daejeon", "Daegu", "Pusan"]

str = ' '
for i in arr.a:
    str = str + i[0]
print(str)

답:
 SKIDDP

※ 공백 포함: 첫 글자가 ' '(빈칸)부터 시작됨

📌 해설:

class arr: # 'arr'이라는 클래스를 정의했다.
    a = ["Seoul", "Kyeonggi", "Incheon", "Daejeon", "Daegu", "Pusan"]
    # 클래스 변수 'a'에 리스트를 저장했지. 이 리스트는 클래스 이름 'arr'로 바로 접근할 수 있다.

str = ' ' # 'str'이라는 변수를 만들고, 맨 처음에 공백 하나를 넣어놨네? 이거 중요함!

for i in arr.a: # arr.a (즉, ["Seoul", "Kyeonggi", ...]) 리스트의 각 요소를 'i'에 넣어서 반복한다.
    # 첫 번째 반복: i는 "Seoul"
    # 두 번째 반복: i는 "Kyeonggi"
    # ... 이런 식이지.

    str = str + i[0] # 여기서 핵심!
                     # 'i[0]'은 현재 'i' 문자열의 **첫 번째 글자**를 의미한다. (인덱스는 0부터 시작하니까)
                     # 그리고 그 첫 글자를 기존 'str' 문자열 뒤에 계속 붙이는 거야.

    # 과정:
    # 1. i = "Seoul"    -> str = ' ' + 'S'  -> str = ' S'
    # 2. i = "Kyeonggi" -> str = ' S' + 'K' -> str = ' SK'
    # 3. i = "Incheon"  -> str = ' SK' + 'I' -> str = ' SKI'
    # 4. i = "Daejeon"  -> str = ' SKI' + 'D' -> str = ' SKID'
    # 5. i = "Daegu"    -> str = ' SKID' + 'D' -> str = ' SKIDD'
    # 6. i = "Pusan"    -> str = ' SKIDD' + 'P' -> str = ' SKIDDP'

print(str) # 최종적으로 만들어진 'str'을 출력한다.



✅ 정답:
 SKIDDP
---------------------------------------------------------------------------------------------------

## 문제 18)

다음 JAVA 프로그램의 실행결과를 쓰시오.

public class SumExample {
    public static void main(String[] args) {             // 메인 메소드
        int i, sum;                           // 'i'는 반복문을 위한 변수, 'sum'은 합계를 저장할 변수.
                                              // 여기서 'sum' 변수가 초기화되지 않은 상태로 선언만 되어 있음에 주의!
                                            // 일반적으로 자바에서는 지역 변수를 초기화하지 않고 사용하면 컴파일 에러가 난다.
                                              // 하지만 문제 풀이에서는 초기값 0으로 가정하고 진행한다.

                                                  // 만약 실제 코드를 돌린다면 sum을 0으로 초기화해야 함: int sum = 0;

        for (i = 0; i <= 5; i++) {                           // 'i'가 0부터 5까지 1씩 증가하면서 반복한다. 총 6번 반복.
            sum += i;                                       // 현재 'i' 값을 'sum'에 더한다.
                                                    // (만약 sum이 초기화 안 되었다면 여기서 런타임 에러 발생 가능성 있음)

            System.out.print(i);                                   // 현재 'i' 값을 출력한다. (줄바꿈 없음)

            if (i == 5) {                                   // 만약 'i'가 5와 같으면 (즉, 마지막 숫자까지 다 더했으면)
                System.out.print("=");                       // '=' 기호를 출력하고
                System.out.print(sum);                       // 최종 합계인 'sum' 값을 출력한다.
            } else {                                         // 'i'가 5가 아니면 (아직 더할 숫자가 남았으면)
                System.out.print("+");                     // '+' 기호를 출력한다.
            }
        }
                                                            // for 루프가 끝나면 프로그램 종료
    }
}

✅ 최종 출력 결과:
0+1+2+3+4+5=15

📌 해설:

### 🔍 반복 흐름 정리

| i 값 | 누적합 sum 값 (`sum += i`) | 출력 내용 (`System.out.print()`) |
|------|-----------------------------|-----------------------------|
| 0    | 0 (0 + 0)                   | `0+`                        |
| 1    | 1 (0 + 1)                   | `1+`                        |
| 2    | 3 (1 + 2)                   | `2+`                        |
| 3    | 6 (3 + 3)                   | `3+`                        |
| 4    | 10 (6 + 4)                  | `4+`                        |
| 5    | 15 (10 + 5)                 | `5=15`                      |

### 💡 포인트
- `if (i < 5)` 조건으로 마지막 `+`를 `=`로 바꿔 출력
- `sum` 변수는 누적합을 계속 업데이트하며 마지막에 사용

---------------------------------------------------------------------------------------------------

## 문제 19)

다음 Java 프로그램의 실행 결과를 쓰시오.

int val[][] = {
    {45, 50, 75},                           // 첫 번째 행 (val[0])은 요소 3개를 가지고 있음.
    {89}                                  // 두 번째 행 (val[1])은 요소 1개를 가지고 있음.
};

System.out.println(val[0].length);                 // val[0]은 첫 번째 행 리스트 {45, 50, 75}를 가리킨다.
                                                       // '.length'는 그 리스트의 길이를 반환하니, 3이 출력됨.
                                                       // 출력: 3

System.out.println(val[1].length);                     // val[1]은 두 번째 행 리스트 {89}를 가리킨다.
                                                       // '.length'는 그 리스트의 길이를 반환하니, 1이 출력됨.
                                                       // 출력: 1

System.out.println(val[0][0]);                           // val[0]은 첫 번째 행 {45, 50, 75}이고,
                                                         // [0]은 그 행의 첫 번째 요소인 45를 가리킨다.
                                                         // 출력: 45

System.out.println(val[0][1]);                           // val[0]은 첫 번째 행 {45, 50, 75}이고,
                                                         // [1]은 그 행의 두 번째 요소인 50을 가리킨다.
                                                         // 출력: 50

System.out.println(val[1][0]);                           // val[1]은 두 번째 행 {89}이고,
                                                         // [0]은 그 행의 첫 번째 요소인 89를 가리킨다.
                                                         // 출력: 89


✅ 결과 요약:
3
1
45
50
89


📌 해설:

최종 요약
2차원 배열의 .length: val.length는 전체 행의 개수를 반환한다 (여기서는 2). 반면에 val[0].length처럼 특정 **행 뒤에 .length를 붙이면, 해당 행의 열 개수(요소 개수)**를 반환한다.

불규칙 배열: 자바에서는 2차원 배열을 선언할 때 각 행마다 열의 개수를 다르게 할 수 있어. 이걸 **불규칙 배열(Ragged Array)**이라고 부르지. 이 문제의 val 배열이 딱 그런 경우다.


📌 추가 설명: 가변 배열(Jagged Array)

Java에서는 2차원 배열도 사실상 1차원 배열의 배열이다.

각 행의 길이가 달라도 되며, 이를 가변 배열이라고 부른다.

예:
int[][] a = new int[2][];
a[0] = new int[3];  // 길이 3
a[1] = new int[1];  // 길이 1

---------------------------------------------------------------------------------------------------

## 문제 20)

다음 C 프로그램의 실행 결과를 쓰시오.

int main() {
                                        // 'insa'라는 구조체를 정의했다. 이름(char 배열)과 나이(int)를 가짐.
    struct insa {
        char name[10];                         // 이름을 저장할 문자 배열 (최대 9글자 + 널 문자)
        int age;                                     // 나이를 저장할 정수
    } a[] = {                                     // 'insa' 구조체 타입의 배열 'a'를 선언하고 바로 초기화했다.
                                                        // 배열이라서 여러 개의 'insa' 구조체 데이터를 저장할 수 있지.
        "Kim", 28,                                        // a[0] = {"Kim", 28}
        "Lee", 38,                                        // a[1] = {"Lee", 38}
        "Park", 41,                                         // a[2] = {"Park", 41}
        "Choi", 30                                          // a[3] = {"Choi", 30}
    };

    struct insa *p;                                         // 'insa' 구조체를 가리키는 포인터 'p'를 선언했다.

    p = a;                                                 // 포인터 'p'에 배열 'a'의 첫 번째 요소 주소를 저장한다.
                                                             // 즉, 'p'는 지금 a[0]인 {"Kim", 28}을 가리키고 있어.

    p++;                                                   // 여기서 핵심! 포인터 'p'를 1 증가시킨다.
                                                             // 일반 정수 포인터처럼 1바이트씩 움직이는 게 아니라,
                                                             // 'p'가 'insa' 구조체를 가리키는 포인터이기 때문에,
                                                             // 'insa' 구조체의 크기만큼 메모리 주소가 점프한다.
                                                             // 결과적으로 'p'는 이제 a[1]인 {"Lee", 38}을 가리키게 된다.

    print("%s", p->name);                                     // 'p'가 가리키는 구조체의 'name' 멤버를 문자열로 출력한다.
                                                              // 'p'는 {"Lee", 38}을 가리키고 있으니 "Lee"가 출력되지.

    print("%d", p->age);                                       // 'p'가 가리키는 구조체의 'age' 멤버를 정수로 출력한다.
                                                           // 'p'는 {"Lee", 38}을 가리키고 있으니 38이 출력된다.
}

✅ 최종 출력 결과

Lee38

📌 해설:

최종 요약
구조체 배열: 여러 개의 구조체 데이터를 한 번에 묶어서 다룰 수 있다.

구조체 포인터: 구조체 데이터를 가리키는 포인터로, -> 연산자를 써서 구조체 멤버에 접근한다.

포인터 연산: 구조체 포인터를 ++ 하면, 해당 구조체의 크기만큼 다음 구조체로 이동한다는 게 중요함! 일반 변수 포인터랑 다르다는 걸 기억해야 한다.


