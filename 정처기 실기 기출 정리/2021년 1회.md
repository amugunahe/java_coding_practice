## 문제 1) 물리주소(MAC)을 IP주소로 변화하는 프로토콜을 작성하시오

**답:** RARP

---

📌 **해설:**

- RARP (Reverse Address Resolution Protocol):  
  MAC 주소(물리 주소)를 이용하여 IP 주소(논리 주소)를 알아내는 프로토콜.
  주로 디스크 없는 컴퓨터가 부팅 시 자신의 IP 주소를 모르고 MAC 주소만 알고 있을 때, 네트워크 상의 RARP 서버에 요청하여 IP를 할당받을 때 사용됨.

- 반대 개념: ARP (Address Resolution Protocol)  
  IP 주소를 이용하여 MAC 주소를 알아냄.

---

## 📚 네트워크 프로토콜 계층별 정리

| OSI 7계층         | TCP/IP 4계층          | 주요 프로토콜 및 포트 |
|------------------|----------------------|----------------------|
| **응용계층**       |                      | HTTP (80), FTP (20, 21) |
| **표현계층**       | **응용 계층**         | SMTP (25), TELNET (23), SSH (22) |
| **세션계층**       |                      | SSH (22), UDP-DNS (53), SNMP (161,162), DHCP (67) |
| **전송계층**       | **전송 계층**         | TCP, UDP |
| **네트워크 계층**   | **인터넷 계층**       | IP, ICMP, IGMP, ARP, RARP |
| **데이터링크 계층** | **네트워크 액세스 계층** | Ethernet, X.25, RS-232C |
| **물리계층**       |                      | - |

---

📌 **참고 용어 정리**

- **TCP (Transmission Control Protocol)**: 연결 지향형, 신뢰성 보장, 순서 보장.
- **UDP (User Datagram Protocol)**: 비연결형, 빠르지만 신뢰성 없음.
- **DHCP (Dynamic Host Configuration Protocol)**: 동적으로 IP 주소를 할당해주는 프로토콜.
- **SNMP (Simple Network Management Protocol)**: 네트워크 장비를 관리하기 위한 프로토콜.
- **ICMP (Internet Control Message Protocol)**: 네트워크 진단 및 오류 보고.
- **IGMP (Internet Group Management Protocol)**: 멀티캐스트 그룹 관리.
- **X.25**: 패킷 교환 방식의 WAN 프로토콜.
- **RS-232C**: 직렬 통신 규격.

---------------------------------------------------------------------------------------------------
## 문제 2) 빈칸 1~3에 해당하는 용어를 쓰시오

> (1) 현실 세계에 있는 그대로 사람이 이해할 수 있는 형태의 정보 구조를 만들어가는 과정을  
> 의미하기 때문에 **정보 모델**이라고 한다.  
>
> (2) 추출된 엔티티와 속성들의 관계를 구조적으로 정의하는 단계로, (1)에서 만들어진 구조를  
> 컴퓨터가 이해하고 처리할 수 있도록 변환하는 과정  
>
> (3) 실제 저장장치에 어떻게 저장할지 설계하는 단계

---

**답:**  
- (1) 개념적 설계  
- (2) 논리적 설계  
- (3) 물리적 설계

---

📌 **해설:**

데이터베이스 설계는 일반적으로 다음과 같은 3단계로 나뉩니다:

### 1. **개념적 설계 (Conceptual Design)**
- 사용자의 요구사항을 분석하고, 현실 세계의 정보를 추상화하여 사람이 이해할 수 있는 **개념적 데이터 모델**로 표현.
- ER 다이어그램(ERD, Entity-Relationship Diagram)으로 작성됨.
- 예: "학생(Student)이 수업(Course)을 듣는다"는 관계를 시각적으로 모델링.

### 2. **논리적 설계 (Logical Design)**
- 개념적 설계에서 작성된 ER 모델을 바탕으로 컴퓨터가 이해할 수 있는 형태로 변환하는 과정.
- 관계형 모델(RDBMS) 기준으로 **릴레이션 스키마**로 변환함.
- 예: 엔터티 → 테이블, 속성 → 컬럼, 관계 → 외래 키 등.

### 3. **물리적 설계 (Physical Design)**
- 논리적으로 설계된 데이터를 실제 데이터베이스 시스템에 어떻게 효율적으로 저장하고 접근할 것인지 결정.
- 인덱스, 파티션, 클러스터링, 저장소 구조 등의 **구현 세부 사항** 포함.

---

📌 **추가 개념 정리**

| 단계 | 주요 산출물 | 목적 |
|------|-------------|------|
| 개념적 설계 | ER 모델 | 사용자 요구사항 반영 |
| 논리적 설계 | 릴레이션 스키마 | DBMS에 맞게 변환 |
| 물리적 설계 | 스토리지 구조, 인덱스 등 | 성능 최적화, 저장 효율 |

이러한 설계 과정을 통해 데이터의 일관성과 효율성을 높일 수 있으며, 요구사항 변화에 유연하게 대응할 수 있습니다.

---------------------------------------------------------------------------------------------------
## 문제 3) 다음 테이블의 카디널리티와 차수를 구하시오

| 학번     | 이름 | 학년 | 학과         |
|----------|------|------|--------------|
| 181101   | KKK  | 1    | 컴퓨터공학과 |
| 171201   | HHH  | 2    | 전자공학과   |
| 171302   | XXX  | 3    | 컴퓨터공학과 |
| 161107   | YYY  | 3    | 건축공학과   |
| 151403   | QQQ  | 4    | 전자공학과   |

---

**답:**  
- **카디널리티(Cardinality): 5**  
- **차수(Degree): 4**

---

📌 **해설:**

### 🔹 카디널리티 (Cardinality)
- **행(row, 튜플)의 수**를 의미함.
- 이 테이블에는 총 **5개의 행**이 있으므로 카디널리티는 **5**.

### 🔹 차수 (Degree)
- **속성(attribute, 열/column)의 수**를 의미함.
- 이 테이블에는 `학번`, `이름`, `학년`, `학과`의 **4개의 열**이 있으므로 차수는 **4**.

---

📌 **추가 개념 요약**

| 용어          | 의미                          | 예시 (위 테이블 기준) |
|---------------|-------------------------------|------------------------|
| **카디널리티** | 튜플(행, Row)의 수              | 5                     |
| **차수**       | 속성(열, Column)의 수           | 4                     |
| **레코드**     | 테이블의 한 행                  | `181101 KKK 1 컴퓨터공학과` |
| **속성**       | 테이블의 한 열(컬럼) 이름       | `학번`, `이름`, `학년`, `학과` |

테이블이 커지더라도 이 원칙은 동일하게 적용됩니다.

---------------------------------------------------------------------------------------------------

## 문제 4) 

기업 내부에서 운영되는 각종 플랫폼 및 애플리케이션 간의 정보 전달, 연계, 통합을  
가능하게 하는 솔루션이다. Point-to-Point, Hub & Spoke, Message Bus, Hybrid 형태로 구성된다.

---

**답:** EAI

---

📌 **해설:**

### 🔹 EAI (Enterprise Application Integration)

- **정의:**  
  기업 내부의 서로 다른 애플리케이션(ERP, CRM, SCM 등) 간의 **정보 연계 및 통합**을 위한 솔루션.  
  다양한 운영 환경(OS, DBMS, 언어 등)의 시스템 간에 실시간으로 데이터를 주고받을 수 있게 해준다.

- **주요 목적:**  
  - 정보의 **일관성 유지**
  - 업무 **효율성 증대**
  - **중복 개발 및 비용 감소**

---

📌 **EAI 구성 형태**

| 구성 형태       | 설명 |
|----------------|------|
| **Point-to-Point** | 애플리케이션 간 1:1 직접 연결 방식<br>구현이 간단하지만 시스템이 많아질수록 복잡성 증가 |
| **Hub & Spoke**   | 중앙 허브(Hub)를 통해 연결<br>중앙 집중식 관리 가능하지만 허브 장애 시 전체 영향 |
| **Message Bus**   | 메시지 버스를 통해 분산 환경에서 통합<br>확장성과 유연성 우수 |
| **Hybrid**        | 위의 여러 구조를 혼합한 형태로, 상황에 맞게 유연하게 구성 |

---

📌 **관련 용어 비교**

| 용어 | 설명 |
|------|------|
| **EAI** | 내부 애플리케이션 간 통합 (Enterprise Application Integration) |
| **ESB** | EAI의 확장된 개념으로, SOA 기반 통합 플랫폼 (Enterprise Service Bus) |
| **EDI** | 기업 간 문서 전송을 위한 전자적 방식 (Electronic Data Interchange) |
| **API** | 애플리케이션 기능을 외부에서 호출할 수 있도록 하는 인터페이스 (Application Programming Interface) |

---

📌 **EAI 도입의 효과**

- 업무 자동화 및 간소화
- 데이터 중복 제거 및 정확성 향상
- 유기적인 프로세스 연계 가능



---------------------------------------------------------------------------------------------------

## 문제 5) 

다음 <보기>에 해당하는 데이터 모델 구성 3요소 중 ①, ②에 알맞은 데이터 모델 구성 요소를 쓰시오.

<보기>

(1): 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로, 데이터베이스를 조작하는 도구이다.  
(2): 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현한다.  
제약조건: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

---

**답:**
- (1) 연산  
- (2) 구조

---

📌 **해설:**

### 🔹 데이터 모델의 구성 3요소

데이터 모델은 다음의 3가지 요소로 구성됩니다:

| 구성 요소 | 설명 | 예시 |
|------------|------------------------------|-----------------------------|
| **구조 (Structure)** | 데이터 간의 논리적 관계를 표현하며, 데이터 모델의 정적 측면을 정의 | 릴레이션, 속성, 키 등 |
| **연산 (Operation)** | 데이터를 **조작**하기 위한 연산의 집합 | SELECT, INSERT, DELETE 등 |
| **제약조건 (Constraint)** | 데이터의 **무결성**을 보장하기 위한 논리적 제약 | 기본키, 외래키, 도메인 제약 등 |

---

📌 **정리된 설명**

- **(1) 연산:**  
  데이터를 삽입, 삭제, 갱신, 검색하는 등의 동작.  
  → DBMS의 DML (데이터 조작어)이 여기에 포함됨.

- **(2) 구조:**  
  테이블(릴레이션), 속성, 키 등의 데이터 구성 요소와 그들 간의 관계를 정의.

- **제약조건:**  
  잘못된 데이터 저장을 막기 위해 논리적으로 설정한 규칙.  
  → 엔터티 무결성, 참조 무결성, 도메인 제약 등

---

📌 **추가 용어 정리**

- **데이터 모델(Data Model):**  
  데이터의 구조, 연산, 제약조건을 명확히 정의하여 시스템에서 데이터를 관리하고 다루기 쉽게 만드는 논리적 틀

- **관계형 데이터 모델(Relational Data Model):**  
  구조: 릴레이션(테이블)  
  연산: 관계 대수, 관계 해석, SQL  
  제약조건: 기본키, 외래키, NULL 제한 등

---------------------------------------------------------------------------------------------------
## 문제 6)

다음은 블랙박스 테스트의 예시이다. 1, 2에 알맞은 테스트를 작성하시오.

1. 0 <= X <= 10일 때, 1, 0, 10, 11인 경우 사용하는 테스트  
2. 유효값과 그렇지 않은 범위를 나눠야 할 경우 사용하는 테스트

---

**답:**  
(1) 경계값 분석 (Boundary Value Analysis)  
(2) 동등분할 테스트 (Equivalence Partitioning)

---

📌 **해설:**

### 🔹 블랙박스 테스트 (Black Box Testing)

- 내부 구조를 고려하지 않고, 입력과 출력에만 집중하여 테스트하는 기법  
- 기능 요구사항 기반 테스트

---

### 🔹 주요 기법

| 기법            | 설명                                                                                     |
|-----------------|------------------------------------------------------------------------------------------|
| 동등분할 테스트 | 입력 자료를 유효/무효 또는 여러 동등한 클래스로 나누고 각 클래스에서 대표 값을 테스트하는 방법 |
| 경계값 분석     | 입력값의 경계(최솟값, 최댓값 등)를 중심으로 테스트 케이스를 선정하는 방법                      |
| 원인-효과 그래프 검사 | 입력 조건 간 관계를 분석하여 효율적인 테스트 케이스를 도출하는 기법                               |
| 오류 예측 검사  | 과거 경험이나 감각을 기반으로 오류가 발생하기 쉬운 부분을 중심으로 테스트하는 기법                  |
| 비교 검사      | 여러 버전 프로그램에 동일 입력을 제공해 결과 일치 여부를 확인하는 기법                            |

---

### 🔹 문제 설명과 답변 연결

- (1) 경계값 분석:  
  0, 1, 10, 11과 같이 입력값의 경계와 경계 바로 바깥 값을 테스트함으로써 경계 관련 오류 탐지에 효과적임

- (2) 동등분할 테스트:  
  유효한 값과 유효하지 않은 값 범위를 나누어 각 구간을 대표하는 값을 테스트하여 입력 범위를 효율적으로 검증

---

✅ **요약:**  
- 경계값 분석은 입력의 경계에 집중한 테스트  
- 동등분할 테스트는 입력 범위를 동등한 클래스로 나누어 대표 값을 테스트하는 방법

---------------------------------------------------------------------------------------------------
## 문제 7)

괄호 안에 공통적으로 들어갈 공격 기법을 쓰시오.

- () 은 시스템 간 연결이 활성화된 상태, 즉 로그인된 상태를 가로채는 것을 뜻한다.  
- ()은 TCP의 고유한 취약점을 이용해 정상적인 접속을 빼앗는 방법이다.  
  서버와 클라이언트 통신 시 TCP의 시퀀스 번호를 제어하는 데 발생하는 문제를 공격한다.  
- TCP는 클라이언트와 서버 간 통신을 할 때 패킷의 연속성을 보장하기 위해 각각 시퀀스 번호를 사용한다.  
- 이 시퀀스 번호가 잘못되면 이를 바로잡기 위한 작업을 하는데 ()은 서버와 클라이언트에 각각 잘못된  
  시퀀스 번호를 위조해서 연결된 세션에 잠시 혼란을 준 뒤 자신이 끼어들어가는 방식이다.

---

**답:** 세션 하이재킹 (Session Hijacking)

---

📌 **해설:**

### 🔹 세션 하이재킹(Session Hijacking)

- **정의:**  
  사용자가 로그인하여 활성화된 세션(연결 상태)을 공격자가 가로채거나 탈취하여,  
  해당 사용자인 것처럼 행세하는 공격 기법.

- **공격 방식:**  
  - 활성화된 TCP 세션의 시퀀스 번호를 위조하거나 탈취  
  - 클라이언트와 서버 간의 정상적인 통신을 방해하고 자신의 패킷을 삽입  
  - 세션 도용 및 권한 탈취 가능

- **특징:**  
  - TCP 시퀀스 번호 취약점을 악용  
  - 네트워크 트래픽을 감청하거나 조작할 수 있는 환경에서 효과적  
  - 로그인 상태 세션 탈취에 초점

---

### 🔹 관련 서비스 공격 유형 (DoS 및 기타)

| 공격명           | 설명                                            |
|------------------|-------------------------------------------------|
| SMURF ATTACK     | ICMP Echo 요청을 이용한 대규모 반사 공격          |
| SYN FLOODING     | SYN 패킷을 대량 전송하여 서버 자원 고갈 유발       |
| UDP 플러딩       | UDP 패킷을 다량 전송하여 네트워크 과부하 유발      |
| PING 플러딩      | ICMP 패킷 과다 전송                              |
| PING OF DEATH    | 비정상적으로 큰 ICMP 패킷 전송으로 시스템 다운 유발 |
| TEARDROP ATTACK  | 조작된 IP 조각 패킷으로 시스템 충돌 유발           |
| LAND ATTACK      | 출발지와 목적지가 동일한 IP 패킷을 전송하여 장애 유발 |

---

✅ **요약:**  
- ()에 들어갈 공격 기법은 **세션 하이재킹**  
- 활성화된 세션을 탈취하여 권한을 빼앗고, TCP 시퀀스 번호 조작을 통한 공격이다.


 ---------------------------------------------------------------------------------------------------
## 문제 8)

다음 (1), (2)에 알맞은 답안을 작성하시오.

- IPv6 는 (1) 비트의 길이를 가진다.  
- IPv4의 길이는 32비트이며, (2) 비트씩 4분할 한다.

---

**답:**  
(1) 128  
(2) 8

---

📌 **해설:**

### 1) IPv6

- IPv6 주소 길이: **128비트**  
- 기존 IPv4 주소의 32비트보다 훨씬 길어, 훨씬 더 많은 주소를 할당할 수 있음  
- 주소 표현 예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334 (8개의 16비트 블록)

### 2) IPv4

- IPv4 주소 길이: **32비트**  
- 주소는 8비트씩 4부분으로 나누어짐 (총 4옥텟)  
- 주소 표현 예: 192.168.0.1 (4개의 8비트 숫자)

---

✅ **요약:**  
- IPv6는 128비트 길이의 주소 체계  
- IPv4는 32비트 길이, 8비트씩 4분할하여 표현


---------------------------------------------------------------------------------------------------

## 문제 9)

다음 1~3에서 설명하는 결합도를 작성하시오.

1. 두 모듈이 동일한 자료구조를 조회하는 경우  
2. 가장 강한 결합도를 가지고 있으며, 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 조회하도록 설계되었을 경우  
3. 여러 모듈이 공통 자료 영역을 사용하는 경우

---

**정답:**  
(1) 스탬프 결합도 (Stamp Coupling)  
(2) 내용 결합도 (Content Coupling)  
(3) 공통 결합도 (Common Coupling)

---

📌 **해설:**

### 🔹 결합도 (Coupling)

- 모듈 간 상호 의존성 정도를 나타내는 척도  
- 결합도가 낮을수록 모듈 간 독립성이 높고 유지보수에 유리함

---

### 🔹 결합도 종류

| 종류          | 설명                                                              | 특징 및 예시                                   |
|---------------|-------------------------------------------------------------------|-----------------------------------------------|
| 내용 결합도 (Content Coupling) | 한 모듈이 다른 모듈의 내부 자료나 기능을 직접 참조하거나 변경하는 경우 | 가장 강한 결합도, 매우 바람직하지 않음       |
| 공통 결합도 (Common Coupling) | 여러 모듈이 공통된 전역 데이터를 공유하는 경우                      | 전역 변수를 통한 데이터 공유                   |
| 스탬프 결합도 (Stamp Coupling) | 모듈 간에 구조화된 데이터(예: 레코드, 구조체)를 전달하는 경우          | 필요한 데이터 구조 일부만 사용하더라도 전체 구조 전달 |

---

✅ **요약:**  
- (1) 구조체 등 자료구조를 조회하는 경우 → 스탬프 결합도  
- (2) 내부 구현까지 직접 접근하는 경우 → 내용 결합도  
- (3) 전역 데이터 영역을 공유하는 경우 → 공통 결합도

---------------------------------------------------------------------------------------------------
## 문제 10)

<보기>에 해당하는 용어를 쓰시오.

- (1) 요구사항은 제품을 구현하기 위해 소프트웨어가 가져야 할 기능적 속성  
- (2) 요구사항은 제품 품질 기준 등의 만족을 위해 소프트웨어가 가져야 할 특성

---

**답:**  
(1) 기능적 요구사항 (Functional Requirements)  
(2) 비기능적 요구사항 (Non-Functional Requirements)

---

📌 **해설:**

### 1) 기능적 요구사항 (Functional Requirements)

- **정의:**  
  소프트웨어가 수행해야 할 구체적인 기능이나 동작을 명세한 요구사항  
- **예시:**  
  - 사용자 로그인 기능  
  - 데이터 검색 및 수정  
  - 보고서 출력

### 2) 비기능적 요구사항 (Non-Functional Requirements)

- **정의:**  
  시스템의 품질, 성능, 신뢰성, 사용성 등 기능 외적 속성이나 제약 조건  
- **예시:**  
  - 응답 시간(성능)  
  - 보안 요구사항  
  - 유지보수성  
  - 호환성

---

📌 **요구사항 구분 요약**

| 구분       | 내용                                   | 예시                           |
|------------|--------------------------------------|--------------------------------|
| 기능적     | 시스템이 반드시 수행해야 하는 기능      | 회원 가입, 주문 처리, 알림 기능 |
| 비기능적   | 시스템이 만족해야 하는 품질 속성 및 제약 | 처리 속도, 보안, 신뢰성          |

---

✅ **정리:**  
- 기능적 요구사항은 '무엇을 할 것인가'를 정의  
- 비기능적 요구사항은 '어떻게 할 것인가' 또는 '얼마나 잘 할 것인가'를 정의


---------------------------------------------------------------------------------------------------

## 문제 11)

시스템 객체의 접근을 개인 또는 그룹의 식별자에 기반한 방법으로  
어떤 종류의 접근 권한을 가진 사용자가 다른 사용자에게 자신의 판단에 따라 권한을 허용하는 접근 제어 방식은?

---

**답:** DAC (임의적 접근 통제, Discretionary Access Control)

---

📌 **해설:**

### 🔹 DAC (Discretionary Access Control, 임의적 접근 통제)

- **정의:**  
  데이터 소유자(사용자)가 자신이 소유한 객체(파일, 프로세스 등)에 대해  
  다른 사용자에게 접근 권한을 부여하거나 해제할 수 있는 접근 통제 방식.

- **특징:**  
  - 권한 부여자가 객체 소유자임  
  - 권한을 다른 사용자에게 임의로 위임 가능  
  - 유연하고 구현이 비교적 쉬움  
  - 보안상 권한 남용 위험 가능

---

### 🔹 접근 통제 정책 비교

| 정책    | MAC (Mandatory Access Control)   | DAC (Discretionary Access Control) | RBAC (Role-Based Access Control) |
|---------|---------------------------------|------------------------------------|----------------------------------|
| 권한 부여 | 시스템(중앙 관리자)              | 데이터 소유자                      | 중앙 관리자                      |
| 접근 결정 | 보안 등급 (LABEL)                | 신분 (IDENTITY)                   | 역할 (ROLE)                     |
| 정책 변경 | 고정적 (변경 어려움)             | 변경 용이                        | 변경 용이                      |
| 장점    | 안정적, 중앙 집중적              | 구현 용이, 유연함                 | 관리 용이                      |

---

### 🔹 관련 보안 모델

1. **벨-라파둘라 모델 (Bell-LaPadula, BLP)**  
   - 기밀성(Confidentiality) 강조  
   - 규칙: NO READ UP, NO WRITE DOWN

2. **비바 모델 (Biba Model)**  
   - 무결성(Integrity) 강조  
   - 규칙: NO READ DOWN, NO WRITE UP

3. **클락-윌슨 모델 (Clark-Wilson Model)**  
   - 무결성 중점의 상업용 모델  
   - 업무 처리 과정의 무결성 유지에 초점

4. **만리장성 모델 (Chinese Wall Model)**  
   - 이해 충돌 방지 목적  
   - 주로 금융 및 컨설팅 분야에서 사용

---

✅ **요약:**  
- DAC는 사용자가 소유한 객체에 대해 권한을 임의로 부여하거나 해제할 수 있는 접근 통제 방식이다.  
- 중앙 관리자나 시스템이 아닌, 데이터 소유자가 권한 부여를 담당한다.



---------------------------------------------------------------------------------------------------
## 문제 12)

웹서비스의 구체적 내용이 기술되어 있어 서비스 제공 장소,  
서비스 메시지 포맷, 프로토콜 등이 기술되어 있는 언어는?

---

**답:** WSDL

---

📌 **해설:**

### 🔹 WSDL (Web Services Description Language)

- **정의:**  
  웹서비스의 기능, 위치, 메시지 형식, 통신 프로토콜 등  
  서비스에 관한 상세한 정보를 기술하는 XML 기반 언어.

- **역할:**  
  - 서비스 제공자가 제공하는 서비스의 상세 설명을 명시  
  - 서비스 소비자가 서비스 호출에 필요한 정보를 획득 가능  
  - SOAP 기반 웹서비스에서 주로 사용됨

- **구성요소:**  
  - **Types:** 메시지에서 사용하는 데이터 타입 정의  
  - **Message:** 교환되는 메시지의 추상적 정의  
  - **PortType:** 제공하는 서비스의 인터페이스 (작업과 메시지 연결)  
  - **Binding:** 프로토콜과 데이터 형식에 대한 구체적 설명  
  - **Service:** 실제 서비스 위치(URL) 정보

---

📌 **관련 용어**

| 용어   | 설명                       |
|--------|----------------------------|
| SOAP   | XML 기반 메시지 프로토콜    |
| UDDI   | 서비스 등록 및 검색을 위한 레지스트리 |
| REST   | HTTP 프로토콜 기반 아키텍처 스타일 |

---

✅ **요약:**  
WSDL은 웹서비스가 어떻게 동작하는지, 어디서 사용할 수 있는지, 어떤 메시지 포맷과 프로토콜을 사용하는지 등 구체적인 내용을 기술하는 언어이다.

---------------------------------------------------------------------------------------------------
## 문제 13)

<보기>에 해당하는 용어를 쓰시오.

1. 개발자가 원시 코드를 대상으로 다른 부분과 연계되는 부분은 고려하지 않고, 각각의 단위 자체에만 집중하여 테스트 한다.  
2. 인터페이스 간 시스템이 정상적으로 실행되는지 확인하는 테스트이다.

---

**정답:**  
1) 단위 테스트 (Unit Testing)  
2) 통합 테스트 (Integration Testing)

---

📌 **해설:**

### 1) 단위 테스트 (Unit Testing)

- **정의:**  
  소프트웨어 개발 과정에서 가장 작은 단위(함수, 메서드, 클래스 등)를 독립적으로 테스트하는 과정.  
- **특징:**  
  - 외부 의존성 배제  
  - 코드의 정확성 및 기능 확인  
  - 주로 개발자가 수행

### 2) 통합 테스트 (Integration Testing)

- **정의:**  
  여러 모듈 또는 컴포넌트를 통합하여 인터페이스 및 상호작용이 올바르게 작동하는지 검증하는 테스트.  
- **특징:**  
  - 모듈 간 연결 상태 점검  
  - 데이터 흐름 및 상호 작용 확인  
  - 시스템 테스트 전 단계

---

📌 **테스트 단계 요약**

| 테스트 종류    | 설명                             | 주체            | 목적                   |
|----------------|----------------------------------|-----------------|------------------------|
| 단위 테스트    | 개별 모듈/함수 단위 테스트        | 개발자          | 기능 단위 정확성 검증  |
| 통합 테스트    | 모듈 간 연동 및 인터페이스 테스트 | 개발자/테스터   | 시스템 통합 상태 점검  |
| 시스템 테스트  | 전체 시스템 테스트                | 테스터          | 요구사항 만족 여부 확인 |
| 인수 테스트    | 사용자 요구사항에 맞는지 확인      | 사용자/테스터   | 최종 승인               |

---

✅ **정리:**  
- **단위 테스트:** 개별 단위 기능 검증  
- **통합 테스트:** 여러 단위가 잘 연동되는지 검증


---------------------------------------------------------------------------------------------------

## 문제 14)

시스템의 성능 향상, 개발 과정의 편의성 등을 위해 정규화된 데이터 모델을  
분할, 통합, 추가하는 과정으로, 의도적으로 정규화에 위배되는 행위이다.  
무엇을 설명하는 것인지 쓰시오.

---

**답:** 반정규화 (역정규화, 비정규화)

---

📌 **해설:**

### 🔹 반정규화 (Denormalization)

- **정의:**  
  정규화된 데이터베이스 구조를 일부러 정규화 원칙에 반하여 테이블을 합치거나 데이터를 중복 저장하는 행위.

- **목적:**  
  - 시스템 성능 향상 (특히 조회 성능 개선)  
  - 개발 및 유지보수 편의성 증대  
  - 복잡한 JOIN 연산 감소

- **단점:**  
  - 데이터 중복으로 인한 저장 공간 증가  
  - 데이터 무결성 유지가 어려워질 수 있음

---

📌 **관련 개념**

| 용어         | 설명                                   |
|--------------|----------------------------------------|
| **정규화 (Normalization)**   | 데이터 중복 최소화와 무결성 유지를 위해 데이터 구조를 체계적으로 분해하는 과정 |
| **반정규화 (Denormalization)** | 정규화된 구조를 성능과 편의성을 위해 일부러 비정규화 하는 과정 |
| **무결성 (Integrity)**       | 데이터의 정확성과 일관성을 보장하는 상태 |

---

✅ **요약:**  
반정규화는 성능 향상과 개발 편의성을 위해 의도적으로 정규화 원칙을 깨는 설계 기법이다.

---------------------------------------------------------------------------------------------------
## 문제 15)

실행 프로세스 간의 통신을 가능하게 하는 기술로 종류에는 파이프, 메시지 큐,  
공유 메모리, 세마포어, 소켓 등이 있다.

---

**답:** IPC

---

📌 **해설:**

### 🔹 IPC (Inter-Process Communication)

- **정의:**  
  서로 다른 프로세스 간에 데이터를 교환하거나 정보를 주고받을 수 있게 하는 메커니즘.

- **목적:**  
  독립적으로 실행되는 프로세스들이 협력하여 작업을 수행할 수 있도록 지원.

---

### 🔹 IPC의 주요 종류

| 종류          | 설명                                      |
|---------------|-------------------------------------------|
| **파이프 (Pipe)**          | 한 프로세스의 출력이 다른 프로세스의 입력으로 전달되는 통신 방식. 주로 부모-자식 프로세스 간에 사용됨. |
| **메시지 큐 (Message Queue)** | 메시지를 큐 형태로 저장하여 비동기적으로 프로세스 간 메시지를 전달하는 방식. |
| **공유 메모리 (Shared Memory)** | 여러 프로세스가 동시에 접근 가능한 메모리 공간을 공유하여 데이터를 교환하는 방식. 속도가 빠름. |
| **세마포어 (Semaphore)**     | 공유 자원에 대한 접근을 제어하기 위한 동기화 기법. 주로 공유 메모리와 함께 사용됨. |
| **소켓 (Socket)**           | 네트워크를 통한 프로세스 간 통신을 위한 인터페이스. 로컬 또는 원격 통신 모두 가능. |

---

📌 **요약**

- IPC는 프로세스 간의 데이터 교환과 동기화를 위한 다양한 기법들의 총칭이다.
- 종류별 특성과 목적에 따라 적절한 IPC 방식을 선택하여 사용한다.

---

✅ **정리:**  
프로세스 간 통신(IPC)은 현대 운영체제에서 필수적인 기능이며,  
파이프, 메시지 큐, 공유 메모리, 세마포어, 소켓 등이 대표적인 IPC 기술이다.


---------------------------------------------------------------------------------------------------

## 문제 16)

다음 SQL 문의 실행 결과를 쓰시오.

```sql
SELECT COUNT(*) FROM TABLE01
WHERE EMPNO > 100
AND SAL >= 3000
OR EMPNO = 200;
EMPNO	SAL
100	1000
200	3000
300	1500

답:
1

📌 해설:

1. WHERE 조건 분석

WHERE EMPNO > 100
AND SAL >= 3000
OR EMPNO = 200
SQL에서 AND가 OR보다 우선순위가 높음 → AND 먼저 계산

즉, 조건은 다음과 같이 해석됨:

(EMPNO > 100 AND SAL >= 3000) OR (EMPNO = 200)
2. 각 행에 대해 조건 검사
EMPNO	SAL	조건 평가	결과
100	1000	(100 > 100) AND (1000 >= 3000) = (False AND False) = False
OR (100 = 200) = False	False
200	3000	(200 > 100) AND (3000 >= 3000) = (True AND True) = True
OR (200 = 200) = True	True
300	1500	(300 > 100) AND (1500 >= 3000) = (True AND False) = False
OR (300 = 200) = False	False

200번 행만 조건을 만족

3. COUNT(*) 결과
조건을 만족하는 행은 1개이므로 결과는 1
---------------------------------------------------------------------------------------------------

## 문제 17)

다음 파이썬 프로그램의 실행 결과를 쓰시오.

```python
class arr:
    a = ["Seoul", "Kyeonggi", "Incheon", "Daejeon", "Daegu", "Pusan"]

str = ' '
for i in arr.a:
    str = str + i[0]
print(str)

답:
 SKIDDP

※ 공백 포함: 첫 글자가 ' '(빈칸)부터 시작됨

📌 해설:

🔹 클래스 선언

class arr:
    a = ["Seoul", "Kyeonggi", "Incheon", "Daejeon", "Daegu", "Pusan"]
클래스 arr는 클래스 변수 a를 가지고 있으며, 이는 도시 이름이 들어 있는 리스트임.

arr.a

클래스 이름으로 직접 리스트 접근 가능 (클래스 변수)

🔹 문자열 누적
str = ' '
for i in arr.a:
    str = str + i[0]
str은 ' '로 시작함 (공백 한 칸)

i[0]는 각 도시 이름의 첫 글자를 의미

순서대로 추가되는 문자:

도시명	i[0]	누적 결과
Seoul	S	' ' + S → ' S'
Kyeonggi	K	' S' + K → ' SK'
Incheon	I	' SK' + I → ' SKI'
Daejeon	D	' SKI' + D → ' SKID'
Daegu	D	' SKID' + D → ' SKIDD'
Pusan	P	' SKIDD' + P → ' SKIDDP'

🔹 최종 출력

print(str)  # 출력: ' SKIDDP'
문자열 앞에 공백 한 칸이 포함됨


✅ 정답:
 SKIDDP
---------------------------------------------------------------------------------------------------

## 문제 18)

다음 JAVA 프로그램의 실행결과를 쓰시오.

```java
int i, sum;

for (i = 0; i <= 5; i++) {
    sum += i;
    System.out.print(i);
    if (i == 5) {
        System.out.print("=");
        System.out.print(sum);
    } else {
        System.out.print("+");
    }
}

답:

0+1+2+3+4+5=15

📌 해설:

🔹 변수 선언
int i, sum;
→ 하지만 sum이 초기화되지 않았음
→ Java에서는 지역 변수는 명시적으로 초기화하지 않으면 컴파일 오류 발생

→ 따라서 실제로 실행 가능한 코드로 바꾸려면 sum = 0; 으로 초기화해야 함.

수정된 코드 (실행 가능한 형태):

int i, sum = 0;

for (i = 0; i <= 5; i++) {
    sum += i;
    System.out.print(i);
    if (i == 5) {
        System.out.print("=");
        System.out.print(sum);
    } else {
        System.out.print("+");
    }
}

🔹 반복문 동작 흐름
i = 0 → 5까지 반복

각 단계마다 i를 출력하고 + 또는 = 출력

마지막 i == 5일 때는 =와 sum을 출력

출력 흐름:
i	출력 내용	누적 합 sum
0	0+	0
1	1+	1
2	2+	3
3	3+	6
4	4+	10
5	5=15	15


✅ 최종 출력 결과:
0+1+2+3+4+5=15
---------------------------------------------------------------------------------------------------

## 문제 19)

다음 Java 프로그램의 실행 결과를 쓰시오.

```java
int val[][] = {
    {45, 50, 75},
    {89}
};

System.out.println(val[0].length);
System.out.println(val[1].length);
System.out.println(val[0][0]);
System.out.println(val[0][1]);
System.out.println(val[1][0]);

답:

3
1
45
50
89

📌 해설:

🔹 2차원 배열 선언
java
복사
편집
int val[][] = {
    {45, 50, 75},   // val[0]
    {89}            // val[1]
};
이 배열은 가변 배열 (jagged array) 형태로 선언되어 있음.

val[0]은 길이가 3인 배열이고, val[1]은 길이가 1인 배열.

🔹 각 출력문의 의미
val[0].length
→ val[0]의 길이 = 3
→ 출력: 3

val[1].length
→ val[1]의 길이 = 1
→ 출력: 1

val[0][0]
→ val[0]의 첫 번째 요소 = 45
→ 출력: 45

val[0][1]
→ val[0]의 두 번째 요소 = 50
→ 출력: 50

val[1][0]
→ val[1]의 첫 번째 요소 = 89
→ 출력: 89

📌 추가 설명: 가변 배열(Jagged Array)

Java에서는 2차원 배열도 사실상 1차원 배열의 배열이다.

각 행의 길이가 달라도 되며, 이를 가변 배열이라고 부른다.

예:
int[][] a = new int[2][];
a[0] = new int[3];  // 길이 3
a[1] = new int[1];  // 길이 1

✅ 결과 요약:
3
1
45
50
89

---------------------------------------------------------------------------------------------------

## 문제 20)

다음 C 프로그램의 실행 결과를 쓰시오.

```c
int main() {
    struct insa {
        char name[10];
        int age; 
    } a[] = {
        "Kim", 28,
        "Lee", 38,
        "Park", 41,
        "Choi", 30
    };

    struct insa *p;
    p = a;
    p++;
    print("%s", p->name);
    print("%d", p->age);
}

답:
Lee38

📌 해설:

🔹 구조체 정의 및 배열 초기화

struct insa {
    char name[10];
    int age;
};
구조체 insa는 두 멤버:

name[10] (char 배열)

age (정수형)

a[] = {
    "Kim", 28,
    "Lee", 38,
    "Park", 41,
    "Choi", 30
};
구조체 배열 a의 초기화 결과는 다음과 같음:

인덱스	name	age
a[0]	"Kim"	28
a[1]	"Lee"	38
a[2]	"Park"	41
a[3]	"Choi"	30

※ 문자열은 char[10] 크기 배열에 들어가므로 "Lee"는 {'L', 'e', 'e', '\0', ..., ...} 형태로 저장됨.

🔹 포인터 연산 해석
p = a;     // p가 a[0]을 가리킴
p++;       // p가 a[1]을 가리킴
p가 가리키는 구조체는 a[1], 즉 두 번째 구조체

🔹 출력문 해석
print("%s", p->name);   // "Lee" 출력
print("%d", p->age);    // 38 출력
주의: print는 오타로 보이며, 실제 C에서는 printf가 정식 함수입니다.
시험에서는 printf로 간주하고 문제 풀이함.

✅ 최종 출력 결과

Lee38

